[
    {
        "py": "def Conversion ( centi ) : NEW_LINE INDENT pixels = ( 96 * centi ) / 2.54 NEW_LINE print ( round ( pixels , 2 ) ) NEW_LINE DEDENT",
        "explain": "Function to convert centimeters to pixels"
    },
    {
        "py": "centi = 15 NEW_LINE Conversion ( centi ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def xor_operations ( N , arr , M , K ) : NEW_LINE",
        "explain": "Method that returns the corresponding output by taking the given inputs ."
    },
    {
        "py": "if M < 0 or M >= N : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "If this condition is satisfied , value of M is invalid"
    },
    {
        "py": "if K < 0 or K >= N - M : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Check if index K is valid"
    },
    {
        "py": "for _ in range ( M ) : NEW_LINE",
        "explain": "Loop to perform M operations"
    },
    {
        "py": "temp = [ ] NEW_LINE",
        "explain": "Creating a temporary list"
    },
    {
        "py": "for i in range ( len ( arr ) - 1 ) : NEW_LINE",
        "explain": "Traversing the array"
    },
    {
        "py": "value = arr [ i ] ^ arr [ i + 1 ] NEW_LINE",
        "explain": "Calculate XOR values of adjacent elements"
    },
    {
        "py": "temp . append ( value ) NEW_LINE",
        "explain": "Adding this value to the temporary list"
    },
    {
        "py": "arr = temp [ : ] NEW_LINE",
        "explain": "Update the original array"
    },
    {
        "py": "ans = arr [ K ] NEW_LINE return ans NEW_LINE",
        "explain": "Getting value at index K"
    },
    {
        "py": "N = 5 NEW_LINE",
        "explain": "Number of elements"
    },
    {
        "py": "arr = [ 1 , 4 , 5 , 6 , 7 ] NEW_LINE M = 1 NEW_LINE K = 2 NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "print ( xor_operations ( N , arr , M , K ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def canBreakN ( n ) : NEW_LINE",
        "explain": "Function to find the K consecutive elements with a sum equal to N"
    },
    {
        "py": "for i in range ( 2 , n ) : NEW_LINE",
        "explain": "Iterate over [ 2 , INF ]"
    },
    {
        "py": "m = i * ( i + 1 ) // 2 NEW_LINE",
        "explain": "Store the sum"
    },
    {
        "py": "if ( m > n ) : NEW_LINE INDENT break NEW_LINE DEDENT k = n - m NEW_LINE",
        "explain": "If the sum exceeds N then break the loop"
    },
    {
        "py": "if ( k % i ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Common difference should be divisible by number of terms"
    },
    {
        "py": "print ( i ) NEW_LINE return NEW_LINE",
        "explain": "Print value of i & return"
    },
    {
        "py": "print ( \" - 1\" ) NEW_LINE",
        "explain": "Print \" - 1\" if not possible to break N"
    },
    {
        "py": "N = 12 NEW_LINE",
        "explain": "Given N"
    },
    {
        "py": "canBreakN ( N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find two coprime divisors of a given number such that both are greater than 1"
    },
    {
        "py": "def findCoprimePair ( N ) : NEW_LINE",
        "explain": "Function which finds the required pair of divisors of N"
    },
    {
        "py": "for x in range ( 2 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % x == 0 ) : NEW_LINE DEDENT",
        "explain": "We iterate upto sqrt ( N ) as we can find all the divisors of N in this time"
    },
    {
        "py": "while ( N % x == 0 ) : NEW_LINE INDENT N //= x NEW_LINE DEDENT if ( N > 1 ) : NEW_LINE",
        "explain": "If x is a divisor of N keep dividing as long as possible"
    },
    {
        "py": "print ( x , N ) NEW_LINE return ; NEW_LINE",
        "explain": "We have found a required pair"
    },
    {
        "py": "print ( \" - 1\" ) NEW_LINE",
        "explain": "No such pair of divisors of N was found , hence print - 1"
    },
    {
        "py": "N = 45 NEW_LINE findCoprimePair ( N ) NEW_LINE",
        "explain": "Sample example 1"
    },
    {
        "py": "N = 25 NEW_LINE findCoprimePair ( N ) NEW_LINE",
        "explain": "Sample example 2"
    },
    {
        "py": "import math NEW_LINE MAX = 10000 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "primes = [ ] NEW_LINE",
        "explain": "Array to store all prime less than and equal to MAX ."
    },
    {
        "py": "def sieveSundaram ( ) : NEW_LINE",
        "explain": "Function for Sieve of Sundaram"
    },
    {
        "py": "marked = [ False ] * ( ( MAX // 2 ) + 1 ) NEW_LINE",
        "explain": "Boolean Array"
    },
    {
        "py": "for i in range ( 1 , ( ( int ( math . sqrt ( MAX ) ) - 1 ) // 2 ) + 1 ) : NEW_LINE INDENT j = ( i * ( i + 1 ) ) << 1 NEW_LINE while j <= ( MAX // 2 ) : NEW_LINE INDENT marked [ j ] = True NEW_LINE j = j + 2 * i + 1 NEW_LINE DEDENT DEDENT",
        "explain": "Mark all numbers which do not generate prime number by 2 * i + 1"
    },
    {
        "py": "primes . append ( 2 ) NEW_LINE",
        "explain": "Since 2 is a prime number"
    },
    {
        "py": "for i in range ( 1 , ( MAX // 2 ) + 1 ) : NEW_LINE INDENT if marked [ i ] == False : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT DEDENT",
        "explain": "Print remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."
    },
    {
        "py": "def isWasteful ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function that returns true if n is a Wasteful number"
    },
    {
        "py": "original_no = n NEW_LINE sumDigits = 0 NEW_LINE while ( original_no > 0 ) : NEW_LINE INDENT sumDigits += 1 NEW_LINE original_no = original_no // 10 NEW_LINE DEDENT pDigit , count_exp , p = 0 , 0 , 0 NEW_LINE",
        "explain": "Count digits in original number"
    },
    {
        "py": "i = 0 NEW_LINE while ( primes [ i ] <= ( n // 2 ) ) : NEW_LINE",
        "explain": "Count all digits in prime factors of N pDigit is going to hold this value ."
    },
    {
        "py": "while ( n % primes [ i ] == 0 ) : NEW_LINE",
        "explain": "Count powers of p in n"
    },
    {
        "py": "p = primes [ i ] NEW_LINE n = n // p NEW_LINE",
        "explain": "If primes [ i ] is a prime factor ,"
    },
    {
        "py": "count_exp += 1 NEW_LINE",
        "explain": "Count the power of prime factors"
    },
    {
        "py": "while ( p > 0 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE p = p // 10 NEW_LINE DEDENT",
        "explain": "Add its digits to pDigit"
    },
    {
        "py": "while ( count_exp > 1 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE count_exp = count_exp // 10 NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "Add digits of power of prime factors to pDigit ."
    },
    {
        "py": "if ( n != 1 ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT pDigit += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT DEDENT",
        "explain": "If n != 1 then one prime factor still to be summed up"
    },
    {
        "py": "return bool ( pDigit > sumDigits ) NEW_LINE",
        "explain": "If digits in prime factors is more than digits in original number then return true . Else return false ."
    },
    {
        "py": "def Solve ( N ) : NEW_LINE",
        "explain": "Function to print Wasteful Number before N"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT if ( isWasteful ( i ) ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Iterate till N and check if i is wastefull or not"
    },
    {
        "py": "sieveSundaram ( ) NEW_LINE N = 10 NEW_LINE",
        "explain": "Precompute prime numbers upto 10 ^ 6"
    },
    {
        "py": "Solve ( N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def printhexaRec ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 or \\ n == 2 or n == 3 or \\ n == 4 or n == 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( printhexaRec ( n - 1 ) + printhexaRec ( n - 2 ) + printhexaRec ( n - 3 ) + printhexaRec ( n - 4 ) + printhexaRec ( n - 5 ) + printhexaRec ( n - 6 ) ) NEW_LINE DEDENT DEDENT def printhexa ( n ) : NEW_LINE INDENT print ( printhexaRec ( n ) ) NEW_LINE DEDENT",
        "explain": "Function to print the Nth Hexanacci number"
    },
    {
        "py": "n = 11 NEW_LINE printhexa ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printhexa ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the Nth term of the Hexanacci number"
    },
    {
        "py": "first = 0 NEW_LINE second = 0 NEW_LINE third = 0 NEW_LINE fourth = 0 NEW_LINE fifth = 0 NEW_LINE sixth = 1 NEW_LINE",
        "explain": "Initialize first five numbers to base cases"
    },
    {
        "py": "curr = 0 NEW_LINE if ( n < 6 ) : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif ( n == 6 ) : NEW_LINE INDENT print ( sixth ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "declare a current variable"
    },
    {
        "py": "for i in range ( 6 , n ) : NEW_LINE INDENT curr = first + second + third + fourth + fifth + sixth NEW_LINE first = second NEW_LINE second = third NEW_LINE third = fourth NEW_LINE fourth = fifth NEW_LINE fifth = sixth NEW_LINE sixth = curr NEW_LINE DEDENT print ( curr ) NEW_LINE",
        "explain": "Loop to add previous five numbers for each number starting from 5 and then assign first , second , third , fourth fifth to second , third , fourth , fifth and curr to sixth respectively"
    },
    {
        "py": "n = 11 NEW_LINE printhexa ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def smallestNumber ( N ) : NEW_LINE INDENT print ( ( N % 9 + 1 ) * pow ( 10 , ( N // 9 ) ) - 1 ) NEW_LINE DEDENT",
        "explain": "Function to find the smallest number whose sum of digits is also N"
    },
    {
        "py": "N = 10 NEW_LINE smallestNumber ( N ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isComposite ( n ) : NEW_LINE",
        "explain": "Function to check if a number is composite ."
    },
    {
        "py": "if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE",
        "explain": "This is checked so that we can skip the middle five numbers in the below loop"
    },
    {
        "py": "def Compositorial_list ( n ) : NEW_LINE INDENT l = 0 NEW_LINE for i in range ( 4 , 10 ** 6 ) : NEW_LINE INDENT if l < n : NEW_LINE INDENT if isComposite ( i ) : NEW_LINE INDENT compo . append ( i ) NEW_LINE l += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT",
        "explain": "This function stores all Composite numbers less than N"
    },
    {
        "py": "def calculateCompositorial ( n ) : NEW_LINE",
        "explain": "Function to calculate the Compositorial of n"
    },
    {
        "py": "result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * compo [ i ] NEW_LINE DEDENT return result NEW_LINE",
        "explain": "Multiply first n composite number"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "compo = [ ] NEW_LINE Compositorial_list ( n ) NEW_LINE print ( calculateCompositorial ( n ) ) NEW_LINE",
        "explain": "Vector to store all the composite less than N"
    },
    {
        "py": "b = [ 0 for i in range ( 50 ) ] NEW_LINE",
        "explain": "Initializing the PowerArray with all 0 's"
    },
    {
        "py": "def PowerArray ( n , k ) : NEW_LINE",
        "explain": "Function to find the powers of N that add up to K"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Initializing the counter"
    },
    {
        "py": "while ( k ) : NEW_LINE INDENT if ( k % n == 0 ) : NEW_LINE INDENT k //= n NEW_LINE count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Executing the while loop until K is greater than 0"
    },
    {
        "py": "elif ( k % n == 1 ) : NEW_LINE INDENT k -= 1 NEW_LINE b [ count ] += 1 NEW_LINE DEDENT",
        "explain": "If K % N == 1 , then the power array is incremented by 1"
    },
    {
        "py": "if ( b [ count ] > 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT",
        "explain": "Checking if any power is occurred more than once"
    },
    {
        "py": "else : NEW_LINE INDENT print ( - 1 ) NEW_LINE return 0 NEW_LINE DEDENT",
        "explain": "For any other value , the sum of powers cannot be added up to K"
    },
    {
        "py": "for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = \" , \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Printing the powers of N that sum up to K"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 40 NEW_LINE PowerArray ( N , K ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import pow NEW_LINE",
        "explain": "Python 3 Program to find the value 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K"
    },
    {
        "py": "def findSum ( N , k ) : NEW_LINE",
        "explain": "Function to find value of 1 ^ K + 2 ^ K + 3 ^ K + . . + N ^ K"
    },
    {
        "py": "sum = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE",
        "explain": "Initialise sum to 0"
    },
    {
        "py": "sum += pow ( i , k ) NEW_LINE",
        "explain": "Find the value of pow ( i , 4 ) and then add it to the sum"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "Return the sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE k = 4 NEW_LINE DEDENT",
        "explain": "Drives Code"
    },
    {
        "py": "print ( int ( findSum ( N , k ) ) ) NEW_LINE",
        "explain": "Function call to find the sum"
    },
    {
        "py": "def countIndices ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count of indices that satisfy the given condition"
    },
    {
        "py": "cnt = 0 ; NEW_LINE",
        "explain": "To store the result"
    },
    {
        "py": "max = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store the current maximum Initialized to 0 since there are only positive elements in the array"
    },
    {
        "py": "if ( max < arr [ i ] ) : NEW_LINE",
        "explain": "i is a valid index"
    },
    {
        "py": "max = arr [ i ] ; NEW_LINE",
        "explain": "Update the maximum so far"
    },
    {
        "py": "cnt += 1 ; NEW_LINE return cnt ; NEW_LINE",
        "explain": "Increment the counter"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countIndices ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "bin = [ \"000\" , \"001\" , \"010\" , \"011\" , \"100\" , \"101\" , \"110\" , \"111\" ] ; NEW_LINE",
        "explain": "Binary representation of the digits"
    },
    {
        "py": "def maxFreq ( s ) : NEW_LINE",
        "explain": "Function to return the maximum frequency of s modulo with a power of 2"
    },
    {
        "py": "binary = \" \" ; NEW_LINE",
        "explain": "Store the binary representation"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT",
        "explain": "Convert the octal to binary"
    },
    {
        "py": "binary = binary [ 0 : len ( binary ) - 1 ] ; NEW_LINE count = 1 ; prev = - 1 ; j = 0 ; NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Remove the LSB"
    },
    {
        "py": "if ( binary [ i ] == '1' ) : NEW_LINE",
        "explain": "If there is 1 in the binary representation"
    },
    {
        "py": "count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE j += 1 ; NEW_LINE return count ; NEW_LINE",
        "explain": "Find the number of zeroes in between two 1 's in the binary representation"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT octal = \"13\" ; NEW_LINE print ( maxFreq ( octal ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt , pow NEW_LINE sz = 100005 NEW_LINE isPrime = [ True for i in range ( sz + 1 ) ] NEW_LINE",
        "explain": "Python 3 implementation of the approach"
    },
    {
        "py": "def sieve ( ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , int ( sqrt ( sz ) ) + 1 , 1 ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , sz , i ) : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT",
        "explain": "Function for Sieve of Eratosthenes"
    },
    {
        "py": "def findPrimesD ( d ) : NEW_LINE",
        "explain": "Function to print all the prime numbers with d digits"
    },
    {
        "py": "left = int ( pow ( 10 , d - 1 ) ) NEW_LINE right = int ( pow ( 10 , d ) - 1 ) NEW_LINE",
        "explain": "Range to check integers"
    },
    {
        "py": "for i in range ( left , right + 1 , 1 ) : NEW_LINE",
        "explain": "For every integer in the range"
    },
    {
        "py": "if ( isPrime [ i ] ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If the current integer is prime"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "sieve ( ) NEW_LINE d = 1 NEW_LINE findPrimesD ( d ) NEW_LINE",
        "explain": "Generate primes"
    },
    {
        "py": "def Cells ( n , x ) : NEW_LINE INDENT if ( n <= 0 or x <= 0 or x > n * n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( i * i < x ) : NEW_LINE INDENT if ( x % i == 0 and x <= n * i ) : NEW_LINE INDENT count += 2 ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( i * i == x ) : NEW_LINE INDENT return count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return count NEW_LINE DEDENT DEDENT",
        "explain": "Function to find number of cells in the table contains X"
    },
    {
        "py": "n = 6 NEW_LINE x = 12 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( Cells ( n , x ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def maxOfMin ( a , n , S ) : NEW_LINE",
        "explain": "Function to find the maximum possible value of the minimum value of the modified array"
    },
    {
        "py": "mi = 10 ** 9 NEW_LINE",
        "explain": "To store minimum value of array"
    },
    {
        "py": "s1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s1 += a [ i ] NEW_LINE mi = min ( a [ i ] , mi ) NEW_LINE DEDENT",
        "explain": "To store sum of elements of array"
    },
    {
        "py": "if ( s1 < S ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Solution is not possible"
    },
    {
        "py": "if ( s1 == S ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "zero is the possible value"
    },
    {
        "py": "low = 0 NEW_LINE",
        "explain": "minimum possible value"
    },
    {
        "py": "high = mi NEW_LINE",
        "explain": "maximum possible value"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "to store a required answer"
    },
    {
        "py": "while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT",
        "explain": "Binary Search"
    },
    {
        "py": "if ( s1 - ( mid * n ) >= S ) : NEW_LINE INDENT ans = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT",
        "explain": "If mid is possible then try to increase required answer"
    },
    {
        "py": "else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT",
        "explain": "If mid is not possible then decrease required answer"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return required answer"
    },
    {
        "py": "a = [ 10 , 10 , 10 , 10 , 10 ] NEW_LINE S = 10 NEW_LINE n = len ( a ) NEW_LINE print ( maxOfMin ( a , n , S ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def Alphabet_N_Pattern ( N ) : NEW_LINE",
        "explain": "Function to print the desired Alphabet N Pattern"
    },
    {
        "py": "Right = 1 NEW_LINE Left = 1 NEW_LINE Diagonal = 2 NEW_LINE",
        "explain": "Declaring the values of Right , Left and Diagonal values"
    },
    {
        "py": "for index in range ( N ) : NEW_LINE",
        "explain": "Main Loop for the rows"
    },
    {
        "py": "print ( Left , end = \" \" ) NEW_LINE Left += 1 NEW_LINE",
        "explain": "For the left Values"
    },
    {
        "py": "for side_index in range ( 0 , 2 * ( index ) , 1 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Spaces for the diagonals"
    },
    {
        "py": "if ( index != 0 and index != N - 1 ) : NEW_LINE INDENT print ( Diagonal , end = \" \" ) NEW_LINE Diagonal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Condition for the diagonals"
    },
    {
        "py": "for side_index in range ( 0 , 2 * ( N - index - 1 ) , 1 ) : NEW_LINE INDENT print ( \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Spaces for the Right Values"
    },
    {
        "py": "print ( Right , end = \" \" ) NEW_LINE Right += 1 NEW_LINE print ( \" \" , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE",
        "explain": "For the right values"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "Size = 6 NEW_LINE",
        "explain": "Size of the Pattern"
    },
    {
        "py": "Alphabet_N_Pattern ( Size ) NEW_LINE",
        "explain": "Calling the function to print the desired Pattern"
    },
    {
        "py": "def isSumDivides ( N ) : NEW_LINE INDENT temp = N NEW_LINE sum = 0 NEW_LINE DEDENT",
        "explain": "Function to check if sum of digits of a number divides it"
    },
    {
        "py": "while ( temp ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT if ( N % sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Calculate sum of all of digits of N"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE if ( isSumDivides ( N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def sum ( N ) : NEW_LINE INDENT global S1 , S2 , S3 NEW_LINE S1 = ( ( ( N // 3 ) ) * ( 2 * 3 + ( N // 3 - 1 ) * 3 ) // 2 ) NEW_LINE S2 = ( ( ( N // 4 ) ) * ( 2 * 4 + ( N // 4 - 1 ) * 4 ) // 2 ) NEW_LINE S3 = ( ( ( N // 12 ) ) * ( 2 * 12 + ( N // 12 - 1 ) * 12 ) // 2 ) NEW_LINE return int ( S1 + S2 - S3 ) NEW_LINE DEDENT",
        "explain": "Function to calculate the sum of numbers divisible by 3 or 4"
    },
    {
        "py": "def nextGreater ( N ) : NEW_LINE INDENT power_of_2 = 1 ; NEW_LINE shift_count = 0 ; NEW_LINE DEDENT",
        "explain": "Function to find next greater number than N with exactly one bit different in binary representation of N"
    },
    {
        "py": "while ( True ) : NEW_LINE",
        "explain": "It is guaranteed that there is a bit zero in the number"
    },
    {
        "py": "if ( ( ( N >> shift_count ) & 1 ) % 2 == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT",
        "explain": "If the shifted bit is zero then break"
    },
    {
        "py": "shift_count += 1 ; NEW_LINE",
        "explain": "increase the bit shift"
    },
    {
        "py": "power_of_2 = power_of_2 * 2 ; NEW_LINE",
        "explain": "increase the power of 2"
    },
    {
        "py": "return ( N + power_of_2 ) ; NEW_LINE",
        "explain": "set the lowest bit of the number"
    },
    {
        "py": "N = 11 ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( \" The \u2581 next \u2581 number \u2581 is \u2581 = \" , nextGreater ( N ) ) ; NEW_LINE",
        "explain": "display the next number"
    },
    {
        "py": "def countWays ( n ) : NEW_LINE",
        "explain": "Function to return the count of the total number of ways to cover the distance with 1 , 2 and 3 steps"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT",
        "explain": "Base conditions"
    },
    {
        "py": "f0 = 1 NEW_LINE f1 = 1 NEW_LINE f2 = 2 NEW_LINE ans = 0 NEW_LINE",
        "explain": "To store the last three stages"
    },
    {
        "py": "for i in range ( 3 , n + 1 ) : NEW_LINE INDENT ans = f0 + f1 + f2 NEW_LINE f0 = f1 NEW_LINE f1 = f2 NEW_LINE f2 = ans NEW_LINE DEDENT",
        "explain": "Find the numbers of steps required to reach the distance i"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import numpy as np NEW_LINE n = 6 ; m = 6 ; NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def maxSum ( arr ) : NEW_LINE",
        "explain": "Function to find the maximum value"
    },
    {
        "py": "dp = np . zeros ( ( n + 1 , 3 ) ) ; NEW_LINE",
        "explain": "Dp table"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Fill the dp in bottom up manner"
    },
    {
        "py": "m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE",
        "explain": "Maximum of the three sections"
    },
    {
        "py": "if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT",
        "explain": "Maximum of the first section"
    },
    {
        "py": "elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT",
        "explain": "Maximum of the second section"
    },
    {
        "py": "elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT",
        "explain": "Maximum of the third section"
    },
    {
        "py": "dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE",
        "explain": "If we choose element from section 1 , we cannot have selection from same section in adjacent rows"
    },
    {
        "py": "print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; NEW_LINE",
        "explain": "Print the maximum sum"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def solve ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to find the total palindromic odd Length sub - sequences"
    },
    {
        "py": "dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE",
        "explain": "dp array to store the number of palindromic subsequences for 0 to i - 1 and j + 1 to n - 1"
    },
    {
        "py": "for Len in range ( n - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "We will start with the largest distance between i and j"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if i + Len >= n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "For each Len , we fix our i"
    },
    {
        "py": "j = i + Len NEW_LINE",
        "explain": "For this i we will find our j"
    },
    {
        "py": "if ( i == 0 and j == n - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( s [ i ] != s [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "if ( i - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j + 1 ] NEW_LINE DEDENT if ( i - 1 < 0 or j + 1 >= n ) : NEW_LINE",
        "explain": "If the characters are equal then look for out of bound index"
    },
    {
        "py": "dp [ i ] [ j ] += 1 NEW_LINE elif ( s [ i ] != s [ j ] ) : NEW_LINE",
        "explain": "We have only 1 way that is to just pick these characters"
    },
    {
        "py": "if ( i - 1 >= 0 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i - 1 ] [ j ] NEW_LINE DEDENT if ( j + 1 <= n - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] += dp [ i ] [ j + 1 ] NEW_LINE DEDENT if ( i - 1 >= 0 and j + 1 <= n - 1 ) : NEW_LINE",
        "explain": "If the characters are not equal"
    },
    {
        "py": "dp [ i ] [ j ] -= dp [ i - 1 ] [ j + 1 ] NEW_LINE ways = [ ] NEW_LINE for i in range ( n ) : NEW_LINE if ( i == 0 or i == n - 1 ) : NEW_LINE",
        "explain": "Subtract it as we have counted it twice"
    },
    {
        "py": "ways . append ( 1 ) NEW_LINE else : NEW_LINE",
        "explain": "We have just 1 palindrome sequence of Length 1"
    },
    {
        "py": "total = dp [ i - 1 ] [ i + 1 ] NEW_LINE ways . append ( total ) NEW_LINE for i in ways : NEW_LINE print ( i , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Else total ways would be sum of dp [ i - 1 ] [ i + 1 ] , that is number of palindrome sub - sequences from 1 to i - 1 + number of palindrome sub - sequences from i + 1 to n - 1"
    },
    {
        "py": "s = \" xyxyx \" NEW_LINE solve ( s ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getChicks ( n ) : NEW_LINE",
        "explain": "Function to return the number of chicks on the nth day"
    },
    {
        "py": "size = max ( n , 7 ) ; NEW_LINE dp = [ 0 ] * size ; NEW_LINE dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE",
        "explain": "Size of dp [ ] has to be at least 6 ( 1 - based indexing )"
    },
    {
        "py": "for i in range ( 2 , 7 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] * 3 ; NEW_LINE DEDENT",
        "explain": "Every day current population will be three times of the previous day"
    },
    {
        "py": "dp [ 6 ] = 726 ; NEW_LINE",
        "explain": "Manually calculated value"
    },
    {
        "py": "for i in range ( 8 , n + 1 ) : NEW_LINE",
        "explain": "From 8 th day onwards"
    },
    {
        "py": "dp [ i ] = ( dp [ i - 1 ] - ( 2 * dp [ i - 6 ] // 3 ) ) * 3 ; NEW_LINE return dp [ n ] ; NEW_LINE",
        "explain": "Chick population decreases by 2 / 3 everyday . For 8 th day on [ i - 6 ] i . e 2 nd day population was 3 and so 2 new born die on the 6 th day and so on for the upcoming days"
    },
    {
        "py": "n = 3 ; NEW_LINE print ( getChicks ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getChicks ( n ) : NEW_LINE INDENT chicks = pow ( 3 , n - 1 ) NEW_LINE return chicks NEW_LINE DEDENT",
        "explain": "Function to return the number of chicks on the nth day"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( getChicks ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import numpy as np NEW_LINE n = 3 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "dp = np . zeros ( ( n , n ) ) NEW_LINE",
        "explain": "2d array to store states of dp"
    },
    {
        "py": "v = np . zeros ( ( n , n ) ) ; NEW_LINE",
        "explain": "Array to determine whether a state has been solved before"
    },
    {
        "py": "def minSteps ( i , j , arr ) : NEW_LINE",
        "explain": "Function to return the minimum steps required"
    },
    {
        "py": "if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE dp [ i ] [ j ] = 9999999 ; NEW_LINE",
        "explain": "If a state has been solved before it won 't be evaluated again"
    },
    {
        "py": "for k in range ( max ( 0 , arr [ i ] [ j ] + j - n + 1 ) , min ( n - i - 1 , arr [ i ] [ j ] ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , minSteps ( i + k , j + arr [ i ] [ j ] - k , arr ) ) ; NEW_LINE DEDENT dp [ i ] [ j ] += 1 ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE",
        "explain": "Recurrence relation"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 4 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 2 , 1 , 1 ] ] ; NEW_LINE ans = minSteps ( 0 , 0 , arr ) ; NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import numpy as np ; NEW_LINE n = 3 NEW_LINE",
        "explain": "Python3 program to implement above approach"
    },
    {
        "py": "dp = np . zeros ( ( n , n ) ) ; NEW_LINE",
        "explain": "2d array to store states of dp"
    },
    {
        "py": "v = np . zeros ( ( n , n ) ) ; NEW_LINE",
        "explain": "array to determine whether a state has been solved before"
    },
    {
        "py": "def minSteps ( i , j , arr ) : NEW_LINE",
        "explain": "Function to find the minimum number of steps to reach the end of matrix"
    },
    {
        "py": "if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i > n - 1 or j > n - 1 ) : NEW_LINE INDENT return 9999999 ; NEW_LINE DEDENT",
        "explain": "base cases"
    },
    {
        "py": "if ( v [ i ] [ j ] ) : NEW_LINE INDENT return dp [ i ] [ j ] ; NEW_LINE DEDENT v [ i ] [ j ] = 1 ; NEW_LINE",
        "explain": "if a state has been solved before it won 't be evaluated again."
    },
    {
        "py": "dp [ i ] [ j ] = 1 + min ( minSteps ( i + arr [ i ] [ j ] , j , arr ) , minSteps ( i , j + arr [ i ] [ j ] , arr ) ) ; NEW_LINE return dp [ i ] [ j ] ; NEW_LINE",
        "explain": "recurrence relation"
    },
    {
        "py": "arr = [ [ 2 , 1 , 2 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; NEW_LINE ans = minSteps ( 0 , 0 , arr ) ; NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 1001 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE",
        "explain": "A memoization based program to find maximum treasure that can be collected ."
    },
    {
        "py": "def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT if ( k == n ) : NEW_LINE DEDENT",
        "explain": "k is current index and col is previous color ."
    },
    {
        "py": "dp [ k ] [ col ] = 0 NEW_LINE return dp [ k ] [ col ] NEW_LINE if ( dp [ k ] [ col ] != - 1 ) : NEW_LINE return dp [ k ] [ col ] NEW_LINE summ = 0 NEW_LINE",
        "explain": "base case"
    },
    {
        "py": "if ( col == color [ k ] ) : NEW_LINE",
        "explain": "we have two options either visit current city or skip that"
    },
    {
        "py": "summ += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE else : NEW_LINE summ += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE dp [ k ] [ col ] = summ NEW_LINE",
        "explain": "check if color of this city is equal to prev visited city"
    },
    {
        "py": "return dp [ k ] [ col ] NEW_LINE",
        "explain": "return max of both options"
    },
    {
        "py": "A = - 5 NEW_LINE B = 7 NEW_LINE treasure = [ 4 , 8 , 2 , 9 ] NEW_LINE color = [ 2 , 2 , 6 , 2 ] NEW_LINE n = len ( color ) NEW_LINE print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printTetra ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 5 ) ; NEW_LINE DEDENT",
        "explain": "Function to print the N - th tetranacci number"
    },
    {
        "py": "dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = 1 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE dp [ 3 ] = 2 ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] + dp [ i - 4 ] ) ; NEW_LINE DEDENT print ( dp [ n ] ) ; NEW_LINE",
        "explain": "base cases"
    },
    {
        "py": "n = 10 ; NEW_LINE printTetra ( n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def maxSum1 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE DEDENT",
        "explain": "Function to calculate the sum from 0 th position to ( n - 2 ) th position"
    },
    {
        "py": "dp [ i ] = arr [ i ] NEW_LINE",
        "explain": "copy the element of original array to dp [ ]"
    },
    {
        "py": "if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT",
        "explain": "find the maximum element in the array"
    },
    {
        "py": "for i in range ( 2 , n - 1 ) : NEW_LINE",
        "explain": "start from 2 nd to n - 1 th pos"
    },
    {
        "py": "for j in range ( i - 1 ) : NEW_LINE",
        "explain": "traverse for all pairs bottom - up approach"
    },
    {
        "py": "if ( dp [ i ] < dp [ j ] + arr [ i ] ) : NEW_LINE INDENT dp [ i ] = dp [ j ] + arr [ i ] NEW_LINE DEDENT",
        "explain": "dp - condition"
    },
    {
        "py": "if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT",
        "explain": "find maximum sum"
    },
    {
        "py": "return maxi NEW_LINE",
        "explain": "return the maximum"
    },
    {
        "py": "def maxSum2 ( arr , n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE maxi = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE if ( maxi < arr [ i ] ) : NEW_LINE INDENT maxi = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to find the maximum sum from 1 st position to n - 1 - th position"
    },
    {
        "py": "for i in range ( 3 , n ) : NEW_LINE",
        "explain": "Traverse from third to n - th pos"
    },
    {
        "py": "for j in range ( 1 , i - 1 ) : NEW_LINE",
        "explain": "bootom - up approach"
    },
    {
        "py": "if ( dp [ i ] < arr [ i ] + dp [ j ] ) : NEW_LINE INDENT dp [ i ] = arr [ i ] + dp [ j ] NEW_LINE DEDENT",
        "explain": "dp condition"
    },
    {
        "py": "if ( maxi < dp [ i ] ) : NEW_LINE INDENT maxi = dp [ i ] NEW_LINE DEDENT",
        "explain": "find max sum"
    },
    {
        "py": "return maxi NEW_LINE def findMaxSum ( arr , n ) : NEW_LINE return max ( maxSum1 ( arr , n ) , maxSum2 ( arr , n ) ) NEW_LINE",
        "explain": "return max"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def permutationCoeff ( n , k ) : NEW_LINE INDENT P = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE DEDENT",
        "explain": "Returns value of Permutation Coefficient P ( n , k )"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE DEDENT",
        "explain": "Calculate value of Permutation Coefficient in bottom up manner"
    },
    {
        "py": "if ( j == 0 ) : NEW_LINE INDENT P [ i ] [ j ] = 1 NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "else : NEW_LINE INDENT P [ i ] [ j ] = P [ i - 1 ] [ j ] + ( j * P [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT",
        "explain": "Calculate value using previously stored values"
    },
    {
        "py": "if ( j < k ) : NEW_LINE INDENT P [ i ] [ j + 1 ] = 0 NEW_LINE DEDENT return P [ n ] [ k ] NEW_LINE",
        "explain": "This step is important as P ( i , j ) = 0 for j > i"
    },
    {
        "py": "n = 10 NEW_LINE k = 2 NEW_LINE print ( \" Value \u2581 fo \u2581 P ( \" , n , \" , \u2581 \" , k , \" ) \u2581 is \u2581 \" , permutationCoeff ( n , k ) , sep = \" \" ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def permutationCoeff ( n , k ) : NEW_LINE INDENT fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE DEDENT",
        "explain": "Returns value of Permutation Coefficient P ( n , k )"
    },
    {
        "py": "fact [ 0 ] = 1 NEW_LINE",
        "explain": "base case"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Calculate value factorials up to n"
    },
    {
        "py": "return int ( fact [ n ] / fact [ n - k ] ) NEW_LINE",
        "explain": "P ( n , k ) = n ! / ( n - k ) !"
    },
    {
        "py": "n = 10 NEW_LINE k = 2 NEW_LINE print ( \" Value \u2581 of \u2581 P ( \" , n , \" , \u2581 \" , k , \" ) \u2581 is \u2581 \" , permutationCoeff ( n , k ) , sep = \" \" ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isSubsetSum ( set , n , sum ) : NEW_LINE",
        "explain": "Returns true if there is a subset of set [ ] with sun equal to given sum"
    },
    {
        "py": "if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Base Cases"
    },
    {
        "py": "if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT",
        "explain": "If last element is greater than sum , then ignore it"
    },
    {
        "py": "return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE",
        "explain": "else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element"
    },
    {
        "py": "set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def compute_z ( s , z ) : NEW_LINE INDENT l = 0 NEW_LINE r = 0 NEW_LINE n = len ( s ) NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( i > r ) : NEW_LINE INDENT l = i NEW_LINE r = i NEW_LINE while ( r < n and s [ r - l ] == s [ r ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ i ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = i - l NEW_LINE if ( z [ k ] < r - i + 1 ) : NEW_LINE INDENT z [ i ] = z [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT l = i NEW_LINE while ( r < n and s [ r - l ] == s [ r ] ) : NEW_LINE INDENT r += 1 NEW_LINE DEDENT z [ i ] = r - l NEW_LINE r -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT",
        "explain": "Implementation of Z - algorithm for linear time pattern searching"
    },
    {
        "py": "def countPermutation ( a , b ) : NEW_LINE",
        "explain": "Function to get the count of the cyclic permutations of b that given 0 when XORed with a"
    },
    {
        "py": "b = b + b NEW_LINE",
        "explain": "concatenate b with b"
    },
    {
        "py": "b = b [ 0 : len ( b ) - 1 ] NEW_LINE",
        "explain": "new b now contains all the cyclic permutations of old b as it 's sub-strings"
    },
    {
        "py": "ans = 0 NEW_LINE s = a + \" $ \" + b NEW_LINE n = len ( s ) NEW_LINE",
        "explain": "concatenate pattern with text"
    },
    {
        "py": "z = [ 0 for i in range ( n ) ] NEW_LINE compute_z ( s , z ) NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE",
        "explain": "Fill z array used in Z algorithm"
    },
    {
        "py": "if ( z [ i ] == len ( a ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "pattern occurs at index i since z value of i equals pattern length"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = \"101\" NEW_LINE b = \"101\" NEW_LINE print ( countPermutation ( a , b ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def smallestSubsequence ( S , K ) : NEW_LINE",
        "explain": "Function to find lexicographically smallest subsequence of size K"
    },
    {
        "py": "N = len ( S ) NEW_LINE",
        "explain": "Length of string"
    },
    {
        "py": "answer = [ ] NEW_LINE",
        "explain": "Stores the minimum subsequence"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the string S"
    },
    {
        "py": "if ( len ( answer ) == 0 ) : NEW_LINE INDENT answer . append ( S [ i ] ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If the stack is empty"
    },
    {
        "py": "while ( len ( answer ) > 0 and ( S [ i ] < answer [ len ( answer ) - 1 ] ) and ( len ( answer ) - 1 + N - i >= K ) ) : NEW_LINE INDENT answer = answer [ : - 1 ] NEW_LINE DEDENT",
        "explain": "Iterate till the current character is less than the the character at the top of stack"
    },
    {
        "py": "if ( len ( answer ) == 0 or len ( answer ) < K ) : NEW_LINE",
        "explain": "If stack size is < K"
    },
    {
        "py": "answer . append ( S [ i ] ) NEW_LINE",
        "explain": "Push the current character into it"
    },
    {
        "py": "ret = [ ] NEW_LINE",
        "explain": "Stores the resultant string"
    },
    {
        "py": "while ( len ( answer ) > 0 ) : NEW_LINE INDENT ret . append ( answer [ len ( answer ) - 1 ] ) NEW_LINE answer = answer [ : - 1 ] NEW_LINE DEDENT",
        "explain": "Iterate until stack is empty"
    },
    {
        "py": "ret = ret [ : : - 1 ] NEW_LINE ret = ' ' . join ( ret ) NEW_LINE",
        "explain": "Reverse the string"
    },
    {
        "py": "print ( ret ) NEW_LINE",
        "explain": "Print the string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabdaabc \" NEW_LINE K = 3 NEW_LINE smallestSubsequence ( S , K ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import sqrt , floor , ceil NEW_LINE",
        "explain": "Python3 program to Check if the given is right to left diagonal or not"
    },
    {
        "py": "def is_rtol ( s ) : NEW_LINE INDENT tmp = floor ( sqrt ( len ( s ) ) ) - 1 NEW_LINE first = s [ tmp ] NEW_LINE DEDENT",
        "explain": "Function to check if the given is right to left diagonal or not"
    },
    {
        "py": "for pos in range ( tmp , len ( s ) - 1 , tmp ) : NEW_LINE",
        "explain": "Iterate over string"
    },
    {
        "py": "if ( s [ pos ] != first ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "If character is not same as the first character then return false"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "str = \" abcxabxcaxbcxabc \" NEW_LINE",
        "explain": "Given String str"
    },
    {
        "py": "if ( is_rtol ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "def check ( str , K ) : NEW_LINE",
        "explain": "Function for checking string"
    },
    {
        "py": "if ( len ( str ) % K == 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT",
        "explain": "Check if the string can be split into substrings of K length only"
    },
    {
        "py": "for i in range ( K ) : NEW_LINE INDENT sum += ord ( str [ i ] ) ; NEW_LINE DEDENT",
        "explain": "Compute the sum of first substring of length K"
    },
    {
        "py": "for j in range ( K , len ( str ) , K ) : NEW_LINE INDENT s_comp = 0 ; NEW_LINE for p in range ( j , j + K ) : NEW_LINE INDENT s_comp += ord ( str [ p ] ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Compute the sum of remaining substrings"
    },
    {
        "py": "if ( s_comp != sum ) : NEW_LINE",
        "explain": "Check if sum is equal to that of the first substring"
    },
    {
        "py": "return False ; NEW_LINE",
        "explain": "Since all sums are not equal , return False"
    },
    {
        "py": "return True ; NEW_LINE",
        "explain": "All sums are equal , Return true"
    },
    {
        "py": "return False ; NEW_LINE",
        "explain": "All substrings cannot be of size K"
    },
    {
        "py": "K = 3 ; NEW_LINE str = \" abdcbbdba \" ; NEW_LINE if ( check ( str , K ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxSum ( str ) : NEW_LINE INDENT maximumSum = 0 NEW_LINE DEDENT",
        "explain": "Function to maximize the sum of the count of zeros and ones in the left and right substring"
    },
    {
        "py": "totalOnes = 0 NEW_LINE for i in str : NEW_LINE INDENT if i == '1' : NEW_LINE INDENT totalOnes += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count the total numbers of ones in str"
    },
    {
        "py": "zero = 0 NEW_LINE ones = 0 NEW_LINE",
        "explain": "To store the count of zeros and ones while traversing string"
    },
    {
        "py": "i = 0 NEW_LINE while i < len ( str ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Iterate the given and update the maximum sum"
    },
    {
        "py": "maximumSum = max ( maximumSum , zero + ( totalOnes - ones ) ) NEW_LINE i += 1 NEW_LINE return maximumSum NEW_LINE",
        "explain": "Update the maximum Sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "str = \"011101\" NEW_LINE",
        "explain": "Given binary string"
    },
    {
        "py": "print ( maxSum ( str ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def maxLenSubStr ( s ) : NEW_LINE",
        "explain": "Function to return the length of the longest substring such that no three consecutive characters are same"
    },
    {
        "py": "if ( len ( s ) < 3 ) : NEW_LINE INDENT return len ( s ) NEW_LINE DEDENT",
        "explain": "If the length of the given string is less than 3"
    },
    {
        "py": "temp = 2 NEW_LINE ans = 2 NEW_LINE",
        "explain": "Initialize temporary and final ans to 2 as this is the minimum length of substring when length of the given string is greater than 2"
    },
    {
        "py": "for i in range ( 2 , len ( s ) ) : NEW_LINE",
        "explain": "Traverse the string from the third character to the last"
    },
    {
        "py": "if ( s [ i ] != s [ i - 1 ] or s [ i ] != s [ i - 2 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT",
        "explain": "If no three consecutive characters are same then increment temporary count"
    },
    {
        "py": "else : NEW_LINE INDENT ans = max ( temp , ans ) NEW_LINE temp = 2 NEW_LINE DEDENT ans = max ( temp , ans ) NEW_LINE return ans NEW_LINE",
        "explain": "Else update the final ans and reset the temporary count"
    },
    {
        "py": "s = \" baaabbabbb \" NEW_LINE print ( maxLenSubStr ( s ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def no_of_ways ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to return the number of ways of removing a sub - string from s such that all the remaining characters are same"
    },
    {
        "py": "count_left = 0 NEW_LINE count_right = 0 NEW_LINE",
        "explain": "To store the count of prefix and suffix"
    },
    {
        "py": "for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ 0 ] ) : NEW_LINE INDENT count_left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "Loop to count prefix"
    },
    {
        "py": "i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == s [ n - 1 ] ) : NEW_LINE INDENT count_right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT",
        "explain": "Loop to count suffix"
    },
    {
        "py": "if ( s [ 0 ] == s [ n - 1 ] ) : NEW_LINE INDENT return ( ( count_left + 1 ) * ( count_right + 1 ) ) NEW_LINE DEDENT",
        "explain": "First and last characters of the string are same"
    },
    {
        "py": "else : NEW_LINE INDENT return ( count_left + count_right + 1 ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE print ( no_of_ways ( s ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def preCompute ( n , s , pref ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] NEW_LINE if s [ i - 1 ] == s [ i ] : NEW_LINE INDENT pref [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to create prefix array"
    },
    {
        "py": "def query ( pref , l , r ) : NEW_LINE INDENT return pref [ r ] - pref [ l ] NEW_LINE DEDENT",
        "explain": "Function to return the result of the query"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" ggggggg \" NEW_LINE n = len ( s ) NEW_LINE pref = [ 0 ] * n NEW_LINE preCompute ( n , s , pref ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "l = 1 NEW_LINE r = 2 NEW_LINE print ( query ( pref , l , r ) ) NEW_LINE",
        "explain": "Query 1"
    },
    {
        "py": "l = 1 NEW_LINE r = 5 NEW_LINE print ( query ( pref , l , r ) ) NEW_LINE",
        "explain": "Query 2"
    },
    {
        "py": "def findDirection ( s ) : NEW_LINE INDENT count = 0 NEW_LINE d = \" \" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' L ' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( s [ i ] == ' R ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT",
        "explain": "Function to find the final direction"
    },
    {
        "py": "if ( count > 0 ) : NEW_LINE INDENT if ( count % 4 == 0 ) : NEW_LINE INDENT d = \" N \" NEW_LINE DEDENT elif ( count % 4 == 10 ) : NEW_LINE INDENT d = \" E \" NEW_LINE DEDENT elif ( count % 4 == 2 ) : NEW_LINE INDENT d = \" S \" NEW_LINE DEDENT elif ( count % 4 == 3 ) : NEW_LINE INDENT d = \" W \" NEW_LINE DEDENT DEDENT",
        "explain": "if count is positive that implies resultant is clockwise direction"
    },
    {
        "py": "if ( count < 0 ) : NEW_LINE INDENT count *= - 1 NEW_LINE if ( count % 4 == 0 ) : NEW_LINE INDENT d = \" N \" NEW_LINE DEDENT elif ( count % 4 == 1 ) : NEW_LINE INDENT d = \" W \" NEW_LINE DEDENT elif ( count % 4 == 2 ) : NEW_LINE INDENT d = \" S \" NEW_LINE DEDENT elif ( count % 4 == 3 ) : NEW_LINE INDENT d = \" E \" NEW_LINE DEDENT DEDENT return d NEW_LINE",
        "explain": "if count is negative that implies resultant is anti - clockwise direction"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" LLRLRRL \" NEW_LINE print ( findDirection ( s ) ) NEW_LINE s = \" LL \" NEW_LINE print ( findDirection ( s ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isCheck ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE lowerStr , upperStr = \" \" , \" \" NEW_LINE DEDENT",
        "explain": "Function to check if both the case follow the same order"
    },
    {
        "py": "for i in range ( length ) : NEW_LINE",
        "explain": "Traverse the string"
    },
    {
        "py": "if ( ord ( str [ i ] ) >= 65 and ord ( str [ i ] ) <= 91 ) : NEW_LINE INDENT upperStr = upperStr + str [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT lowerStr = lowerStr + str [ i ] NEW_LINE DEDENT",
        "explain": "Store both lowercase and uppercase in two different strings"
    },
    {
        "py": "transformStr = lowerStr . upper ( ) NEW_LINE return transformStr == upperStr NEW_LINE",
        "explain": "transfor lowerStr to uppercase"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeGkEEsKS \" NEW_LINE if isCheck ( str ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def encode ( s , k ) : NEW_LINE",
        "explain": "Function to move string character"
    },
    {
        "py": "newS = \" \" NEW_LINE",
        "explain": "changed string"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "iterate for every characters"
    },
    {
        "py": "val = ord ( s [ i ] ) NEW_LINE",
        "explain": "ASCII value"
    },
    {
        "py": "dup = k NEW_LINE",
        "explain": "store the duplicate"
    },
    {
        "py": "' NEW_LINE INDENT if val + k > 122 : NEW_LINE INDENT k -= ( 122 - val ) NEW_LINE k = k % 26 NEW_LINE newS += chr ( 96 + k ) NEW_LINE DEDENT else : NEW_LINE INDENT newS += chr ( val + k ) NEW_LINE DEDENT k = dup NEW_LINE DEDENT",
        "explain": "if k - th ahead character exceed 'z"
    },
    {
        "py": "print ( newS ) NEW_LINE",
        "explain": "print the new string"
    },
    {
        "py": "str = \" abc \" NEW_LINE k = 28 NEW_LINE",
        "explain": "driver code"
    },
    {
        "py": "encode ( str , k ) NEW_LINE",
        "explain": "'' function call"
    },
    {
        "py": "def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if the character x is a vowel or not"
    },
    {
        "py": "def updateSandwichedVowels ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE DEDENT",
        "explain": "Returns the updated string formed after removing all the Sandwiched Vowels from the given string"
    },
    {
        "py": "updatedString = \" \" NEW_LINE",
        "explain": "string to store the Updated String after removing the Sandwiched Vowels"
    },
    {
        "py": "for i in range ( 0 , n , 1 ) : NEW_LINE",
        "explain": "traverse the string from left to right"
    },
    {
        "py": "' NEW_LINE INDENT if ( i == 0 or i == n - 1 ) : NEW_LINE INDENT updatedString += a [ i ] NEW_LINE continue NEW_LINE DEDENT DEDENT",
        "explain": "if the current character is the first or the last character of the string then , this needs to be appended to the updatedString , since the corner alphabet irrespective of it being a vowel or a consonant , is never 'Sandwiched"
    },
    {
        "py": "if ( isVowel ( a [ i ] ) == True and isVowel ( a [ i - 1 ] ) == False and isVowel ( a [ i + 1 ] ) == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Check if the current character of the string is a vowel and both the previous and the next characters are consonants , if so then this is a sandwiched vowel , thus is ignored and not appended to the updated string"
    },
    {
        "py": "updatedString += a [ i ] NEW_LINE return updatedString NEW_LINE",
        "explain": "if this character is not a sandwiched Vowel append it to the updated String"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "updatedString = updateSandwichedVowels ( str ) NEW_LINE print ( updatedString ) NEW_LINE",
        "explain": "Remove all the Sandwitched Vowels"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT",
        "explain": "A Binary Tree node"
    },
    {
        "py": "def findPathUtil ( root : Node , k : int , path : list , flag : int ) : NEW_LINE INDENT global ans NEW_LINE if root is None : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT",
        "explain": "A recursive function to print the paths whose maximum element is greater than or equal to K ."
    },
    {
        "py": "if root . data >= k : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "If the current node value is greater than or equal to k , then all the subtrees following that node will get printed , flag = 1 indicates to print the required path"
    },
    {
        "py": "if root . left is None and root . right is None : NEW_LINE INDENT if flag : NEW_LINE INDENT ans = 1 NEW_LINE print ( \" ( \" , end = \" \" ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT print ( path [ i ] , end = \" , \u2581 \" ) NEW_LINE DEDENT print ( root . data , end = \" ) , \u2581 \" ) NEW_LINE DEDENT return NEW_LINE DEDENT",
        "explain": "If the leaf node is encountered , then the path is printed if the size of the path vector is greater than 0"
    },
    {
        "py": "path . append ( root . data ) NEW_LINE",
        "explain": "Append the node to the path vector"
    },
    {
        "py": "findPathUtil ( root . left , k , path , flag ) NEW_LINE findPathUtil ( root . right , k , path , flag ) NEW_LINE",
        "explain": "Recur left and right subtrees"
    },
    {
        "py": "path . pop ( ) NEW_LINE",
        "explain": "Backtracking to return the vector and print the path if the flag is 1"
    },
    {
        "py": "def findPath ( root : Node , k : int ) : NEW_LINE INDENT global ans NEW_LINE DEDENT",
        "explain": "Function to initialize the variables and call the utility function to print the paths with maximum values greater than or equal to K"
    },
    {
        "py": "flag = 0 NEW_LINE",
        "explain": "Initialize flag"
    },
    {
        "py": "ans = 0 NEW_LINE v = [ ] NEW_LINE",
        "explain": "ans is used to check empty condition"
    },
    {
        "py": "findPathUtil ( root , k , v , flag ) NEW_LINE",
        "explain": "Call function that print path"
    },
    {
        "py": "if ans == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT",
        "explain": "If the path doesn 't exist"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT ans = 0 NEW_LINE k = 25 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "root = Node ( 10 ) NEW_LINE root . left = Node ( 5 ) NEW_LINE root . right = Node ( 8 ) NEW_LINE root . left . left = Node ( 29 ) NEW_LINE root . left . right = Node ( 2 ) NEW_LINE root . right . right = Node ( 98 ) NEW_LINE root . right . left = Node ( 1 ) NEW_LINE root . right . right . right = Node ( 50 ) NEW_LINE root . left . left . left = Node ( 20 ) NEW_LINE findPath ( root , k ) NEW_LINE",
        "explain": "Constructing the following tree : 10 / \\ 5 8 / \\ / \\ 29 2 1 98 / \\ 20 50"
    },
    {
        "py": "def Tridecagonal_num ( n ) : NEW_LINE",
        "explain": "Function to find N - th tridecagonal number"
    },
    {
        "py": "return ( 11 * n * n - 9 * n ) / 2 NEW_LINE",
        "explain": "Formula to calculate nth tridecagonal number"
    },
    {
        "py": "n = 3 NEW_LINE print ( int ( Tridecagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Tridecagonal_num ( n ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findNumbers ( n , w ) : NEW_LINE INDENT x = 0 ; NEW_LINE sum = 0 ; NEW_LINE DEDENT",
        "explain": "Function to find total possible numbers with n digits and weight w"
    },
    {
        "py": "if ( w >= 0 and w <= 8 ) : NEW_LINE",
        "explain": "When Weight of an integer is Positive"
    },
    {
        "py": "x = 9 - w ; NEW_LINE",
        "explain": "Subtract the weight from 9"
    },
    {
        "py": "elif ( w >= - 9 and w <= - 1 ) : NEW_LINE",
        "explain": "When weight of an integer is negative"
    },
    {
        "py": "x = 10 + w ; NEW_LINE sum = pow ( 10 , n - 2 ) ; NEW_LINE sum = ( x * sum ) ; NEW_LINE return sum ; NEW_LINE",
        "explain": "add the weight to 10 to make it positive"
    },
    {
        "py": "n = 3 ; NEW_LINE w = 4 ; NEW_LINE",
        "explain": "number of digits in an integer and w as weight"
    },
    {
        "py": "print ( findNumbers ( n , w ) ) ; NEW_LINE",
        "explain": "print the total possible numbers with n digits and weight w"
    },
    {
        "py": "def MaximumHeight ( a , n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE DEDENT",
        "explain": "Python program to find the maximum height of Pyramidal Arrangement of array values"
    },
    {
        "py": "y = ( i * ( i + 1 ) ) / 2 NEW_LINE",
        "explain": "Just checking whether ith level is possible or not if possible then we must have atleast ( i * ( i + 1 ) ) / 2 elements in the array"
    },
    {
        "py": "if ( y < n ) : NEW_LINE INDENT result = i NEW_LINE DEDENT",
        "explain": "updating the result value each time"
    },
    {
        "py": "else : NEW_LINE INDENT break NEW_LINE DEDENT return result NEW_LINE",
        "explain": "otherwise we have exceeded n value"
    },
    {
        "py": "arr = [ 40 , 100 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MaximumHeight ( arr , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findK ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE DEDENT",
        "explain": "Python3 code to find k - th element in the Odd - Even sequence ."
    },
    {
        "py": "i = 1 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT",
        "explain": "insert all the odd numbers from 1 to n ."
    },
    {
        "py": "i = 2 NEW_LINE while i < n : NEW_LINE INDENT a . append ( i ) NEW_LINE i = i + 2 NEW_LINE DEDENT return ( a [ k - 1 ] ) NEW_LINE",
        "explain": "insert all the even numbers from 1 to n ."
    },
    {
        "py": "n = 10 NEW_LINE k = 3 NEW_LINE print ( findK ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def factorial ( n ) : NEW_LINE",
        "explain": "Python3 program to find factorial of given number"
    },
    {
        "py": "return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) ; NEW_LINE",
        "explain": "single line to find factorial"
    },
    {
        "py": "num = 5 ; NEW_LINE print ( \" Factorial \u2581 of \" , num , \" is \" , factorial ( num ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = 2 * b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT",
        "explain": "calculate nth pell number"
    },
    {
        "py": "n = 4 NEW_LINE print ( pell ( n ) ) NEW_LINE",
        "explain": "driver function"
    },
    {
        "py": "def isMultipleOf10 ( n ) : NEW_LINE INDENT return ( n % 15 == 0 ) NEW_LINE DEDENT",
        "explain": "Returns true if n - th Fibonacci number is multiple of 10."
    },
    {
        "py": "n = 30 NEW_LINE if ( isMultipleOf10 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countOddPrimeFactors ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE DEDENT",
        "explain": "A function to count all odd prime factors of a given number n"
    },
    {
        "py": "while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE DEDENT",
        "explain": "Eliminate all even prime factor of number of n"
    },
    {
        "py": "i = 3 NEW_LINE while i * i <= n : NEW_LINE INDENT divCount = 0 NEW_LINE DEDENT",
        "explain": "n must be odd at this point , so iterate for only odd numbers till sqrt ( n )"
    },
    {
        "py": "while ( n % i == 0 ) : NEW_LINE INDENT n /= i NEW_LINE divCount = divCount + 1 NEW_LINE DEDENT result = result * divCount + 1 NEW_LINE i = i + 2 NEW_LINE",
        "explain": "if i divides n , then start counting of Odd divisors"
    },
    {
        "py": "if ( n > 2 ) : NEW_LINE INDENT result = result * 2 NEW_LINE DEDENT return result NEW_LINE def politness ( n ) : NEW_LINE return countOddPrimeFactors ( n ) - 1 ; NEW_LINE",
        "explain": "If n odd prime still remains then count it"
    },
    {
        "py": "n = 90 NEW_LINE print \" Politness \u2581 of \u2581 \" , n , \" \u2581 = \u2581 \" , politness ( n ) NEW_LINE n = 15 NEW_LINE print \" Politness \u2581 of \u2581 \" , n , \" \u2581 = \u2581 \" , politness ( n ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "import math NEW_LINE MAX = 10000 ; NEW_LINE",
        "explain": "Python3 program to find the nearest prime to n ."
    },
    {
        "py": "primes = [ ] ; NEW_LINE",
        "explain": "array to store all primes less than 10 ^ 6"
    },
    {
        "py": "def Sieve ( ) : NEW_LINE INDENT n = MAX ; NEW_LINE DEDENT",
        "explain": "Utility function of Sieve of Sundaram"
    },
    {
        "py": "nNew = int ( math . sqrt ( n ) ) ; NEW_LINE",
        "explain": "In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x"
    },
    {
        "py": "marked = [ 0 ] * ( int ( n / 2 + 500 ) ) ; NEW_LINE",
        "explain": "This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j"
    },
    {
        "py": "for i in range ( 1 , int ( ( nNew - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , ( int ( n / 2 ) + 1 ) , ( 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "eliminate indexes which does not produce primes"
    },
    {
        "py": "primes . append ( 2 ) ; NEW_LINE",
        "explain": "Since 2 is a prime number"
    },
    {
        "py": "for i in range ( 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."
    },
    {
        "py": "def binarySearch ( left , right , n ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = int ( ( left + right ) / 2 ) ; NEW_LINE DEDENT DEDENT",
        "explain": "modified binary search to find nearest prime less than N"
    },
    {
        "py": "if ( mid == 0 or mid == len ( primes ) - 1 ) : NEW_LINE INDENT return primes [ mid ] ; NEW_LINE DEDENT",
        "explain": "base condition is , if we are reaching at left corner or right corner of primes [ ] array then return that corner element because before or after that we don 't have any prime number in  primes array"
    },
    {
        "py": "if ( primes [ mid ] == n ) : NEW_LINE INDENT return primes [ mid - 1 ] ; NEW_LINE DEDENT",
        "explain": "now if n is itself a prime so it will be present in primes array and here we have to find nearest prime less than n so we will return primes [ mid - 1 ]"
    },
    {
        "py": "if ( primes [ mid ] < n and primes [ mid + 1 ] > n ) : NEW_LINE INDENT return primes [ mid ] ; NEW_LINE DEDENT if ( n < primes [ mid ] ) : NEW_LINE INDENT return binarySearch ( left , mid - 1 , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( mid + 1 , right , n ) ; NEW_LINE DEDENT return 0 ; NEW_LINE",
        "explain": "now if primes [ mid ] < n and primes [ mid + 1 ] > n that means we reached at nearest prime"
    },
    {
        "py": "Sieve ( ) ; NEW_LINE n = 17 ; NEW_LINE print ( binarySearch ( 0 , len ( primes ) - 1 , n ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def factorial ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT",
        "explain": "Function to find factorial of given number"
    },
    {
        "py": "num = 5 ; NEW_LINE print ( \" Factorial \u2581 of \" , num , \" is \" , factorial ( num ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def FlipBits ( n ) : NEW_LINE INDENT n -= ( n & ( - n ) ) ; NEW_LINE return n ; NEW_LINE DEDENT",
        "explain": "Unsets the rightmost set bit of n and returns the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 ; NEW_LINE print ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \" , end = \" \" ) ; NEW_LINE print ( \" \u2581 rightmost \u2581 set \u2581 bit : \u2581 \" , FlipBits ( N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def Maximum_xor_Triplet ( n , a ) : NEW_LINE",
        "explain": "function to count maximum XOR value for a triplet"
    },
    {
        "py": "s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE DEDENT",
        "explain": "set is used to avoid repetitions"
    },
    {
        "py": "s . add ( a [ i ] ^ a [ j ] ) NEW_LINE ans = 0 NEW_LINE for i in s : NEW_LINE for j in range ( 0 , n ) : NEW_LINE",
        "explain": "store all possible unique XOR value of pairs"
    },
    {
        "py": "ans = max ( ans , i ^ a [ j ] ) NEW_LINE print ( ans ) NEW_LINE",
        "explain": "store maximum value"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 8 , 15 ] NEW_LINE n = len ( a ) NEW_LINE Maximum_xor_Triplet ( n , a ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from bisect import bisect_left NEW_LINE",
        "explain": "Python library for binary search"
    },
    {
        "py": "def printMissing ( arr , n , low , high ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE DEDENT",
        "explain": "Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]"
    },
    {
        "py": "ptr = bisect_left ( arr , low ) NEW_LINE index = ptr NEW_LINE",
        "explain": "Do binary search for ' low ' in sorted array and find index of first element which either equal to or greater than low ."
    },
    {
        "py": "i = index NEW_LINE x = low NEW_LINE while ( i < n and x <= high ) : NEW_LINE",
        "explain": "Start from the found index and linearly search every range element x after this index in arr [ ]"
    },
    {
        "py": "if ( arr [ i ] != x ) : NEW_LINE INDENT print ( x , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If x doesn 't math with current element  print it"
    },
    {
        "py": "else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT",
        "explain": "If x matches , move to next element in arr [ ]"
    },
    {
        "py": "x = x + 1 NEW_LINE",
        "explain": "Move to next element in range [ low , high ]"
    },
    {
        "py": "while ( x <= high ) : NEW_LINE INDENT print ( x , end = \" \u2581 \" ) NEW_LINE x = x + 1 NEW_LINE DEDENT",
        "explain": "Print range elements thar are greater than the last element of sorted array ."
    },
    {
        "py": "arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low = 1 NEW_LINE high = 10 NEW_LINE printMissing ( arr , n , low , high ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printMissing ( arr , n , low , high ) : NEW_LINE",
        "explain": "Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]"
    },
    {
        "py": "points_of_range = [ False ] * ( high - low + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Create boolean list of size high - low + 1 , each index i representing wether ( i + low ) th element found or not ."
    },
    {
        "py": "if ( low <= arr [ i ] and arr [ i ] <= high ) : NEW_LINE INDENT points_of_range [ arr [ i ] - low ] = True NEW_LINE DEDENT",
        "explain": "if ith element of arr is in range low to high then mark corresponding index as true in array"
    },
    {
        "py": "for x in range ( high - low + 1 ) : NEW_LINE INDENT if ( points_of_range [ x ] == False ) : NEW_LINE INDENT print ( low + x , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Traverse through the range and print all elements whose value is false"
    },
    {
        "py": "arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low , high = 1 , 10 NEW_LINE printMissing ( arr , n , low , high ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printMissing ( arr , n , low , high ) : NEW_LINE",
        "explain": "Print all elements of range [ low , high ] that are not present in arr [ 0. . n - 1 ]"
    },
    {
        "py": "s = set ( arr ) NEW_LINE",
        "explain": "Insert all elements of arr [ ] in set"
    },
    {
        "py": "for x in range ( low , high + 1 ) : NEW_LINE INDENT if x not in s : NEW_LINE INDENT print ( x , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT",
        "explain": "Traverse through the range and print all missing elements"
    },
    {
        "py": "arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low , high = 1 , 10 NEW_LINE printMissing ( arr , n , low , high ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def find ( a , b , k , n1 , n2 ) : NEW_LINE",
        "explain": "Returns k - th missing element . It returns - 1 if no k is more than number of missing elements ."
    },
    {
        "py": "s = set ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT s . add ( b [ i ] ) NEW_LINE DEDENT",
        "explain": "insert all elements of given sequence b [ ] ."
    },
    {
        "py": "missing = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT if a [ i ] not in s : NEW_LINE INDENT missing += 1 NEW_LINE DEDENT if missing == k : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE",
        "explain": "Traverse through increasing sequence and keep track of count of missing numbers ."
    },
    {
        "py": "a = [ 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 ] NEW_LINE b = [ 4 , 10 , 6 , 8 , 12 ] NEW_LINE n1 = len ( a ) NEW_LINE n2 = len ( b ) NEW_LINE k = 3 NEW_LINE print ( find ( a , b , k , n1 , n2 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findString ( S , N ) : NEW_LINE",
        "explain": "''Function to find the minimum number of string required to generate the original string"
    },
    {
        "py": "amounts = [ 0 ] * 26 NEW_LINE",
        "explain": "'' Stores the frequency of each  character of String S"
    },
    {
        "py": "for i in range ( len ( S ) ) : NEW_LINE INDENT amounts [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE",
        "explain": "'' Stores the frequency of each  character of String S"
    },
    {
        "py": "for i in range ( 26 ) : NEW_LINE INDENT if amounts [ i ] > 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "'' Count unique characters in S"
    },
    {
        "py": "if count > N : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "'' If unique characters is greater  then N, then return -1"
    },
    {
        "py": "else : NEW_LINE INDENT ans = \" \" NEW_LINE high = 100001 NEW_LINE low = 0 NEW_LINE DEDENT",
        "explain": "'' Otherwise"
    },
    {
        "py": "while ( high - low ) > 1 : NEW_LINE INDENT total = 0 NEW_LINE DEDENT",
        "explain": "'' Perform Binary Search"
    },
    {
        "py": "mid = ( high + low ) // 2 NEW_LINE",
        "explain": "'' Find the value of mid"
    },
    {
        "py": "for i in range ( 26 ) : NEW_LINE",
        "explain": "'' Iterate over the range  [0, 26]"
    },
    {
        "py": "if amounts [ i ] > 0 : NEW_LINE INDENT total += ( amounts [ i ] - 1 ) // mid + 1 NEW_LINE DEDENT",
        "explain": "'' If the amount[i] is  greater than 0"
    },
    {
        "py": "if total <= N : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid NEW_LINE DEDENT print ( high , end = \" \u2581 \" ) NEW_LINE total = 0 NEW_LINE",
        "explain": "'' Update the ranges"
    },
    {
        "py": "for i in range ( 26 ) : NEW_LINE INDENT if amounts [ i ] > 0 : NEW_LINE INDENT total += ( amounts [ i ] - 1 ) // high + 1 NEW_LINE for j in range ( ( amounts [ i ] - 1 ) // high + 1 ) : NEW_LINE DEDENT DEDENT",
        "explain": "'' Find the resultant string"
    },
    {
        "py": "ans += chr ( i + 97 ) NEW_LINE",
        "explain": "Generate the subsequence"
    },
    {
        "py": "for i in range ( total , N ) : NEW_LINE INDENT ans += ' a ' NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE",
        "explain": "' ' \u2581 If \u2581 the \u2581 length \u2581 of \u2581 resultant \u2581 \u2581 string \u2581 is \u2581 less \u2581 than \u2581 N \u2581 than \u2581 \u2581 add \u2581 a \u2581 character \u2581 ' a '"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "'' Print the string"
    },
    {
        "py": "S = \" toffee \" NEW_LINE K = 4 NEW_LINE findString ( S , K ) NEW_LINE",
        "explain": "''Driver code"
    },
    {
        "py": "def printFirstRepeating ( arr , n ) : NEW_LINE",
        "explain": "This function prints the first repeating element in arr [ ]"
    },
    {
        "py": "Min = - 1 NEW_LINE",
        "explain": "Initialize index of first repeating element"
    },
    {
        "py": "myset = dict ( ) NEW_LINE",
        "explain": "Creates an empty hashset"
    },
    {
        "py": "for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Traverse the input array from right to left"
    },
    {
        "py": "if arr [ i ] in myset . keys ( ) : NEW_LINE INDENT Min = i NEW_LINE DEDENT",
        "explain": "If element is already in hash set , update Min"
    },
    {
        "py": "else : NEW_LINE INDENT myset [ arr [ i ] ] = 1 NEW_LINE DEDENT",
        "explain": "Else add element to hash set"
    },
    {
        "py": "if ( Min != - 1 ) : NEW_LINE INDENT print ( \" The \u2581 first \u2581 repeating \u2581 element \u2581 is \" , arr [ Min ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" There \u2581 are \u2581 no \u2581 repeating \u2581 elements \" ) NEW_LINE DEDENT",
        "explain": "Print the result"
    },
    {
        "py": "arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printFirstRepeating ( arr , n ) : NEW_LINE",
        "explain": "This function prints the first repeating element in arr [ ]"
    },
    {
        "py": "k = 0 NEW_LINE",
        "explain": "This will set k = 1 , if any repeating element found"
    },
    {
        "py": "max = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max < arr [ i ] ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "max = maximum from ( all elements & n )"
    },
    {
        "py": "a = [ 0 for i in range ( max + 1 ) ] NEW_LINE",
        "explain": "Array a is for storing 1 st time occurence of element initialized by 0"
    },
    {
        "py": "b = [ 0 for i in range ( max + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Store 1 in array b if element is duplicate initialized by 0"
    },
    {
        "py": "if ( a [ arr [ i ] ] ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 NEW_LINE k = 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Duplicate element found"
    },
    {
        "py": "a [ arr [ i ] ] = i NEW_LINE if ( k == 0 ) : NEW_LINE print ( \" No \u2581 repeating \u2581 element \u2581 found \" ) NEW_LINE else : NEW_LINE min = max + 1 NEW_LINE for i in range ( max + 1 ) : NEW_LINE",
        "explain": "Storing 1 st occurence of arr [ i ]"
    },
    {
        "py": "if ( a [ i ] and ( min > ( a [ i ] ) ) and b [ i ] ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT print ( arr [ min ] ) NEW_LINE",
        "explain": "Trace array a & find repeating element with min index"
    },
    {
        "py": "arr = [ 10 , 5 , 3 , 4 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printFirstRepeating ( arr , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printKDistinct ( arr , n , k ) : NEW_LINE INDENT dist_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "Returns k - th distinct element in arr ."
    },
    {
        "py": "j = 0 NEW_LINE while j < n : NEW_LINE INDENT if ( i != j and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT",
        "explain": "Check if current element is present somewhere else ."
    },
    {
        "py": "if ( j == n ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT if ( dist_count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE",
        "explain": "If element is unique"
    },
    {
        "py": "ar = [ 1 , 2 , 1 , 3 , 4 , 2 ] NEW_LINE n = len ( ar ) NEW_LINE k = 2 NEW_LINE print ( printKDistinct ( ar , n , k ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def countSubarrays ( A ) : NEW_LINE",
        "explain": "''Function to count subarrays having equal count of 0s and 1s with all 0s and all 1s grouped together"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "'' Stores the count"
    },
    {
        "py": "curr , cnt = A [ 0 ] , [ 1 ] NEW_LINE for c in A [ 1 : ] : NEW_LINE",
        "explain": "'' Initialize cur with first element"
    },
    {
        "py": "if c == curr : NEW_LINE",
        "explain": "'' If the next element is same  as the current element"
    },
    {
        "py": "cnt [ - 1 ] += 1 NEW_LINE else : NEW_LINE",
        "explain": "'' Increment count"
    },
    {
        "py": "curr = c NEW_LINE cnt . append ( 1 ) NEW_LINE",
        "explain": "'' Update curr"
    },
    {
        "py": "for i in range ( 1 , len ( cnt ) ) : NEW_LINE",
        "explain": "'' Iterate over the array count"
    },
    {
        "py": "res += min ( cnt [ i - 1 ] , cnt [ i ] ) NEW_LINE print ( res - 1 ) NEW_LINE",
        "explain": "'' Consider the minimum"
    },
    {
        "py": "A = [ 1 , 1 , 0 , 0 , 1 , 0 ] NEW_LINE",
        "explain": "''Given arr[]"
    },
    {
        "py": "countSubarrays ( A ) NEW_LINE",
        "explain": "''Function Call"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . left = None NEW_LINE self . right = None NEW_LINE self . val = data NEW_LINE DEDENT DEDENT",
        "explain": "''Tree node"
    },
    {
        "py": "def newNode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE return temp NEW_LINE DEDENT",
        "explain": "''Function to return new tree node"
    },
    {
        "py": "def isEvenOddBinaryTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE DEDENT",
        "explain": "''Function to check if the tree is even-odd tree"
    },
    {
        "py": "q . append ( root ) NEW_LINE",
        "explain": "'' Stores nodes of each level"
    },
    {
        "py": "level = 0 NEW_LINE",
        "explain": "'' Store the current level  of the binary tree"
    },
    {
        "py": "while ( len ( q ) != 0 ) : NEW_LINE",
        "explain": "'' Traverse until the  queue is empty"
    },
    {
        "py": "size = len ( q ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE DEDENT",
        "explain": "'' Stores the number of nodes  present in the current level"
    },
    {
        "py": "if ( level % 2 == 0 ) : NEW_LINE INDENT if ( node . val % 2 == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( level % 2 == 1 ) : NEW_LINE INDENT if ( node . val % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "'' Check if the level  is even or odd"
    },
    {
        "py": "if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT",
        "explain": "'' Add the nodes of the next  level into the queue"
    },
    {
        "py": "level += 1 NEW_LINE return True NEW_LINE",
        "explain": "'' Increment the level count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "''Driver code"
    },
    {
        "py": "root = None NEW_LINE root = newNode ( 2 ) NEW_LINE root . left = newNode ( 3 ) NEW_LINE root . right = newNode ( 9 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 10 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE",
        "explain": "'' Construct a Binary Tree"
    },
    {
        "py": "if ( isEvenOddBinaryTree ( root ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "'' Check if the binary tree  is even-odd tree or not"
    },
    {
        "py": "import sys NEW_LINE def findMaxLen ( a ) : NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "n = len ( a ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "freq = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT maxFreqElement = - sys . maxsize - 1 NEW_LINE maxFreqCount = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Stores the frequency of array elements"
    },
    {
        "py": "if ( freq [ i ] > maxFreqElement ) : NEW_LINE INDENT maxFreqElement = freq [ i ] NEW_LINE maxFreqCount = 1 NEW_LINE DEDENT",
        "explain": "Find the highest frequency in the array"
    },
    {
        "py": "elif ( freq [ i ] == maxFreqElement ) : NEW_LINE INDENT maxFreqCount += 1 NEW_LINE DEDENT",
        "explain": "Increase count of max frequent element"
    },
    {
        "py": "if ( maxFreqElement == 1 ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If no repetition is present"
    },
    {
        "py": "ans = ( ( n - maxFreqCount ) // ( maxFreqElement - 1 ) ) NEW_LINE",
        "explain": "Find the maximum distance"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the max distance"
    },
    {
        "py": "a = [ 1 , 2 , 1 , 2 ] NEW_LINE print ( findMaxLen ( a ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def getMid ( s , e ) : NEW_LINE INDENT return ( s + ( e - s ) // 2 ) NEW_LINE DEDENT",
        "explain": "Function to obtain the middle index of the range"
    },
    {
        "py": "def MaxUtil ( st , ss , se , l , r , node ) : NEW_LINE",
        "explain": "Recursive function to get the sum of values in the given range from the array . The following are parameters for this function . st . Pointer to segment tree node . Index of current node in the segment tree ss & se . Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r . Starting and ending indexes of range query"
    },
    {
        "py": "if ( l <= ss and r >= se ) : NEW_LINE",
        "explain": "If the segment of this node lies completely within the given range"
    },
    {
        "py": "return st [ node ] NEW_LINE",
        "explain": "Return maximum in the segment"
    },
    {
        "py": "if ( se < l or ss > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "If the segment of this node lies outside the given range"
    },
    {
        "py": "mid = getMid ( ss , se ) NEW_LINE return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) NEW_LINE",
        "explain": "If segment of this node lies partially in the given range"
    },
    {
        "py": "def getMax ( st , n , l , r ) : NEW_LINE",
        "explain": "Function to return the maximum in the range from [ l , r ]"
    },
    {
        "py": "if ( l < 0 or r > n - 1 or l > r ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) NEW_LINE",
        "explain": "Check for erroneous input values"
    },
    {
        "py": "def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE",
        "explain": "Function to conSegment Tree for the subarray [ ss . . se ]"
    },
    {
        "py": "if ( ss == se ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE return arr [ ss ] NEW_LINE DEDENT",
        "explain": "For a single element"
    },
    {
        "py": "mid = getMid ( ss , se ) NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "def constructST ( arr , n ) : NEW_LINE",
        "explain": "Function to conSegment Tree from the given array"
    },
    {
        "py": "x = ( int ) ( math . ceil ( math . log ( n ) ) ) NEW_LINE",
        "explain": "Height of Segment Tree"
    },
    {
        "py": "max_size = 2 * ( int ) ( pow ( 2 , x ) ) - 1 NEW_LINE",
        "explain": "Maximum size of Segment Tree"
    },
    {
        "py": "st = [ 0 ] * max_size NEW_LINE",
        "explain": "Allocate memory"
    },
    {
        "py": "constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE",
        "explain": "Fill the allocated memory"
    },
    {
        "py": "return st NEW_LINE",
        "explain": "Return the constructed Segment Tree"
    },
    {
        "py": "arr = [ 5 , 2 , 3 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "st = constructST ( arr , n ) NEW_LINE Q = [ [ 1 , 3 ] , [ 0 , 2 ] ] NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT Max = getMax ( st , n , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) NEW_LINE ok = 0 NEW_LINE for j in range ( 30 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( Max & ( 1 << j ) ) != 0 ) : NEW_LINE INDENT ok = 1 NEW_LINE DEDENT if ( ok <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max |= ( 1 << j ) NEW_LINE DEDENT print ( Max , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Build the Segment Tree from the given array"
    },
    {
        "py": "def calculate ( a ) : NEW_LINE",
        "explain": "Function to calculate the count"
    },
    {
        "py": "a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE",
        "explain": "Sorting the list using built in function"
    },
    {
        "py": "for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE DEDENT",
        "explain": "Traversing through the elements"
    },
    {
        "py": "count += 1 NEW_LINE else : NEW_LINE",
        "explain": "Counting frequncy of each elements"
    },
    {
        "py": "answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE",
        "explain": "Adding the contribution of the frequency to the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( calculate ( a ) ) NEW_LINE",
        "explain": "Print the count"
    },
    {
        "py": "def calculate ( a ) : NEW_LINE",
        "explain": "Function to calculate the answer"
    },
    {
        "py": "maximum = max ( a ) NEW_LINE",
        "explain": "Finding the maximum of the array"
    },
    {
        "py": "frequency = [ 0 for x in range ( maximum + 1 ) ] NEW_LINE",
        "explain": "Creating frequency array With initial value 0"
    },
    {
        "py": "for i in a : NEW_LINE",
        "explain": "Traversing through the array"
    },
    {
        "py": "frequency [ i ] += 1 NEW_LINE answer = 0 NEW_LINE",
        "explain": "Counting frequency"
    },
    {
        "py": "for i in frequency : NEW_LINE",
        "explain": "Traversing through the frequency array"
    },
    {
        "py": "answer = answer + i * ( i - 1 ) // 2 NEW_LINE return answer NEW_LINE",
        "explain": "Calculating answer"
    },
    {
        "py": "a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( calculate ( a ) ) NEW_LINE",
        "explain": "Function calling"
    },
    {
        "py": "def findSubArray ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxsize = - 1 NEW_LINE DEDENT",
        "explain": "This function Prints the starting and ending indexes of the largest subarray with equal number of 0 s and 1 s . Also returns the size of such subarray ."
    },
    {
        "py": "for i in range ( 0 , n - 1 ) : NEW_LINE INDENT sum = - 1 if ( arr [ i ] == 0 ) else 1 NEW_LINE DEDENT",
        "explain": "Pick a starting point as i"
    },
    {
        "py": "for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = sum + ( - 1 ) if ( arr [ j ] == 0 ) else sum + 1 NEW_LINE DEDENT",
        "explain": "Consider all subarrays starting from i"
    },
    {
        "py": "if ( sum == 0 and maxsize < j - i + 1 ) : NEW_LINE INDENT maxsize = j - i + 1 NEW_LINE startindex = i NEW_LINE DEDENT if ( maxsize == - 1 ) : NEW_LINE print ( \" No \u2581 such \u2581 subarray \" ) ; NEW_LINE else : NEW_LINE print ( startindex , \" to \" , startindex + maxsize - 1 ) ; NEW_LINE return maxsize NEW_LINE",
        "explain": "If this is a 0 sum subarray , then compare it with maximum size subarray calculated so far"
    },
    {
        "py": "arr = [ 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE findSubArray ( arr , size ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "def findMax ( arr , low , high ) : NEW_LINE",
        "explain": "Function to return the maximum element"
    },
    {
        "py": "if ( high == low ) : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT",
        "explain": "If there is only one element left"
    },
    {
        "py": "mid = low + ( high - low ) // 2 NEW_LINE",
        "explain": "Find mid"
    },
    {
        "py": "if ( mid == 0 and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT",
        "explain": "Check if mid reaches 0 , it is greater than next element or not"
    },
    {
        "py": "if ( mid < high and arr [ mid + 1 ] < arr [ mid ] and mid > 0 and arr [ mid ] > arr [ mid - 1 ] ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT",
        "explain": "Check if mid itself is maximum element"
    },
    {
        "py": "if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findMax ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMax ( arr , mid + 1 , high ) NEW_LINE DEDENT",
        "explain": "Decide whether we need to go to the left half or the right half"
    },
    {
        "py": "arr = [ 6 , 5 , 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMax ( arr , 0 , n - 1 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def ternarySearch ( l , r , key , ar ) : NEW_LINE INDENT while r >= l : NEW_LINE DEDENT",
        "explain": "Function to perform Ternary Search"
    },
    {
        "py": "mid1 = l + ( r - l ) // 3 NEW_LINE mid2 = r - ( r - l ) // 3 NEW_LINE",
        "explain": "Find mid1 and mid2"
    },
    {
        "py": "if key == ar [ mid1 ] : NEW_LINE INDENT return mid1 NEW_LINE DEDENT if key == mid2 : NEW_LINE INDENT return mid2 NEW_LINE DEDENT",
        "explain": "Check if key is at any mid"
    },
    {
        "py": "if key < ar [ mid1 ] : NEW_LINE",
        "explain": "Since key is not present at mid , Check in which region it is present Then repeat the search operation in that region"
    },
    {
        "py": "r = mid1 - 1 NEW_LINE elif key > ar [ mid2 ] : NEW_LINE",
        "explain": "key lies between l and mid1"
    },
    {
        "py": "l = mid2 + 1 NEW_LINE else : NEW_LINE",
        "explain": "key lies between mid2 and r"
    },
    {
        "py": "l = mid1 + 1 NEW_LINE r = mid2 - 1 NEW_LINE",
        "explain": "key lies between mid1 and mid2"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "key not found"
    },
    {
        "py": "ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE",
        "explain": "Get the list Sort the list if not sorted"
    },
    {
        "py": "l = 0 NEW_LINE",
        "explain": "Starting index"
    },
    {
        "py": "r = 9 NEW_LINE",
        "explain": "Length of list"
    },
    {
        "py": "key = 5 NEW_LINE",
        "explain": "Key to be searched in the list"
    },
    {
        "py": "p = ternarySearch ( l , r , key , ar ) NEW_LINE",
        "explain": "Search the key using ternary search"
    },
    {
        "py": "print ( \" Index \u2581 of \" , key , \" is \" , p ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "key = 50 NEW_LINE",
        "explain": "Key to be searched in the list"
    },
    {
        "py": "p = ternarySearch ( l , r , key , ar ) NEW_LINE",
        "explain": "Search the key using ternary search"
    },
    {
        "py": "print ( \" Index \u2581 of \" , key , \" is \" , p ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "def majorityNumber ( nums ) : NEW_LINE INDENT num_count = { } NEW_LINE for num in nums : NEW_LINE INDENT if num in num_count : NEW_LINE INDENT num_count [ num ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT num_count [ num ] = 1 NEW_LINE DEDENT DEDENT for num in num_count : NEW_LINE INDENT if num_count [ num ] > len ( nums ) / 2 : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT",
        "explain": "function to print the majorityNumber"
    },
    {
        "py": "a = [ 2 , 2 , 1 , 1 , 1 , 2 , 2 ] NEW_LINE print majorityNumber ( a ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def search ( arr , l , h , key ) : NEW_LINE INDENT if l > h : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( l + h ) // 2 NEW_LINE if arr [ mid ] == key : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT",
        "explain": "Returns index of key in arr [ l . . h ] if key is present , otherwise returns - 1"
    },
    {
        "py": "if arr [ l ] <= arr [ mid ] : NEW_LINE",
        "explain": "If arr [ l ... mid ] is sorted"
    },
    {
        "py": "if key >= arr [ l ] and key <= arr [ mid ] : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) NEW_LINE DEDENT",
        "explain": "As this subarray is sorted , we can quickly check if key lies in half or other half"
    },
    {
        "py": "return search ( arr , mid + 1 , h , key ) NEW_LINE",
        "explain": "If key not lies in first half subarray , Divide other half into two subarrays , such that we can quickly check if key lies in other half"
    },
    {
        "py": "if key >= arr [ mid ] and key <= arr [ h ] : NEW_LINE INDENT return search ( a , mid + 1 , h , key ) NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) NEW_LINE",
        "explain": "If arr [ l . . mid ] is not sorted , then arr [ mid ... r ] must be sorted"
    },
    {
        "py": "arr = [ 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 ] NEW_LINE key = 6 NEW_LINE i = search ( arr , 0 , len ( arr ) - 1 , key ) NEW_LINE if i != - 1 : NEW_LINE INDENT print ( \" Index : \u2581 % \u2581 d \" % i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Key \u2581 not \u2581 found \" ) NEW_LINE DEDENT",
        "explain": "Driver program"
    },
    {
        "py": "def findMin ( arr , low , high ) : NEW_LINE",
        "explain": "Python program to find minimum element in a sorted and rotated array"
    },
    {
        "py": "if high < low : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT",
        "explain": "This condition is needed to handle the case when array is not rotated at all"
    },
    {
        "py": "if high == low : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT",
        "explain": "If there is only one element left"
    },
    {
        "py": "mid = int ( ( low + high ) / 2 ) NEW_LINE",
        "explain": "Find mid"
    },
    {
        "py": "if mid < high and arr [ mid + 1 ] < arr [ mid ] : NEW_LINE INDENT return arr [ mid + 1 ] NEW_LINE DEDENT",
        "explain": "Check if element ( mid + 1 ) is minimum element . Consider the cases like [ 3 , 4 , 5 , 1 , 2 ]"
    },
    {
        "py": "if mid > low and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT",
        "explain": "Check if mid itself is minimum element"
    },
    {
        "py": "if arr [ high ] > arr [ mid ] : NEW_LINE INDENT return findMin ( arr , low , mid - 1 ) NEW_LINE DEDENT return findMin ( arr , mid + 1 , high ) NEW_LINE",
        "explain": "Decide whether we need to go to left half or right half"
    },
    {
        "py": "arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr1 , 0 , n1 - 1 ) ) ) NEW_LINE arr2 = [ 1 , 2 , 3 , 4 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr2 , 0 , n2 - 1 ) ) ) NEW_LINE arr3 = [ 1 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr3 , 0 , n3 - 1 ) ) ) NEW_LINE arr4 = [ 1 , 2 ] NEW_LINE n4 = len ( arr4 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr4 , 0 , n4 - 1 ) ) ) NEW_LINE arr5 = [ 2 , 1 ] NEW_LINE n5 = len ( arr5 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr5 , 0 , n5 - 1 ) ) ) NEW_LINE arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] NEW_LINE n6 = len ( arr6 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr6 , 0 , n6 - 1 ) ) ) NEW_LINE arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n7 = len ( arr7 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr7 , 0 , n7 - 1 ) ) ) NEW_LINE arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] NEW_LINE n8 = len ( arr8 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr8 , 0 , n8 - 1 ) ) ) NEW_LINE arr9 = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n9 = len ( arr9 ) NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" + str ( findMin ( arr9 , 0 , n9 - 1 ) ) ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "def findMin ( arr , low , high ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 ; NEW_LINE if ( arr [ mid ] == arr [ high ] ) : NEW_LINE INDENT high -= 1 ; NEW_LINE DEDENT elif ( arr [ mid ] > arr [ high ] ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return arr [ high ] ; NEW_LINE DEDENT",
        "explain": "Function to find minimum element"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 5 , 6 , 1 , 2 , 3 , 4 ] ; NEW_LINE n1 = len ( arr1 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr1 , 0 , n1 - 1 ) ) ; NEW_LINE arr2 = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n2 = len ( arr2 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr2 , 0 , n2 - 1 ) ) ; NEW_LINE arr3 = [ 1 ] ; NEW_LINE n3 = len ( arr3 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr3 , 0 , n3 - 1 ) ) ; NEW_LINE arr4 = [ 1 , 2 ] ; NEW_LINE n4 = len ( arr4 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr4 , 0 , n4 - 1 ) ) ; NEW_LINE arr5 = [ 2 , 1 ] ; NEW_LINE n5 = len ( arr5 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr5 , 0 , n5 - 1 ) ) ; NEW_LINE arr6 = [ 5 , 6 , 7 , 1 , 2 , 3 , 4 ] ; NEW_LINE n6 = len ( arr6 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr6 , 0 , n6 - 1 ) ) ; NEW_LINE arr7 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; NEW_LINE n7 = len ( arr7 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr7 , 0 , n7 - 1 ) ) ; NEW_LINE arr8 = [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 ] ; NEW_LINE n8 = len ( arr8 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr8 , 0 , n8 - 1 ) ) ; NEW_LINE arr9 = [ 3 , 4 , 5 , 1 , 2 ] ; NEW_LINE n9 = len ( arr9 ) ; NEW_LINE print ( \" The \u2581 minimum \u2581 element \u2581 is \u2581 \" , findMin ( arr9 , 0 , n9 - 1 ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from bisect import bisect as upper_bound NEW_LINE",
        "explain": "Python3 program to find k - th absolute difference between two elements"
    },
    {
        "py": "def countPairs ( a , n , mid ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "returns number of pairs with absolute difference less than or equal to mid ."
    },
    {
        "py": "res += upper_bound ( a , a [ i ] + mid ) NEW_LINE return res NEW_LINE",
        "explain": "Upper bound returns pointer to position of next higher number than a [ i ] + mid in a [ i . . n - 1 ] . We subtract ( a + i + 1 ) from this position to count"
    },
    {
        "py": "def kthDiff ( a , n , k ) : NEW_LINE",
        "explain": "Returns k - th absolute difference"
    },
    {
        "py": "a = sorted ( a ) NEW_LINE",
        "explain": "Sort array"
    },
    {
        "py": "low = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT low = min ( low , a [ i + 1 ] - a [ i ] ) NEW_LINE DEDENT",
        "explain": "Minimum absolute difference"
    },
    {
        "py": "high = a [ n - 1 ] - a [ 0 ] NEW_LINE",
        "explain": "Maximum absolute difference"
    },
    {
        "py": "while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( countPairs ( a , n , mid ) < k ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT return low NEW_LINE",
        "explain": "Do binary search for k - th absolute difference"
    },
    {
        "py": "k = 3 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( kthDiff ( a , n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python program to find smallest and second smallest elements"
    },
    {
        "py": "def print2Smallest ( arr ) : NEW_LINE",
        "explain": "Function to print first smallest and second smallest elements"
    },
    {
        "py": "arr_size = len ( arr ) NEW_LINE if arr_size < 2 : NEW_LINE INDENT print \" Invalid \u2581 Input \" NEW_LINE return NEW_LINE DEDENT first = second = sys . maxint NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE",
        "explain": "There should be atleast two elements"
    },
    {
        "py": "if arr [ i ] < first : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT",
        "explain": "If current element is smaller than first then update both first and second"
    },
    {
        "py": "elif ( arr [ i ] < second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] ; NEW_LINE DEDENT if ( second == sys . maxint ) : NEW_LINE print \" No \u2581 second \u2581 smallest \u2581 element \" NEW_LINE else : NEW_LINE print ' The \u2581 smallest \u2581 element \u2581 is ' , first , ' and ' ' \u2581 second \u2581 smallest \u2581 element \u2581 is ' , second NEW_LINE",
        "explain": "If arr [ i ] is in between first and second then update second"
    },
    {
        "py": "arr = [ 12 , 13 , 1 , 10 , 34 , 1 ] NEW_LINE print2Smallest ( arr ) NEW_LINE",
        "explain": "Driver function to test above function"
    },
    {
        "py": "MAX = 1000 NEW_LINE",
        "explain": "LCM of given range queries using Segment Tree"
    },
    {
        "py": "tree = [ 0 ] * ( 4 * MAX ) NEW_LINE",
        "explain": "allocate space for tree"
    },
    {
        "py": "arr = [ 0 ] * MAX NEW_LINE",
        "explain": "declaring the array globally"
    },
    {
        "py": "def gcd ( a : int , b : int ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT",
        "explain": "Function to return gcd of a and b"
    },
    {
        "py": "def lcm ( a : int , b : int ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT",
        "explain": "utility function to find lcm"
    },
    {
        "py": "def build ( node : int , start : int , end : int ) : NEW_LINE",
        "explain": "Function to build the segment tree Node starts beginning index of current subtree . start and end are indexes in arr [ ] which is global"
    },
    {
        "py": "if start == end : NEW_LINE INDENT tree [ node ] = arr [ start ] NEW_LINE return NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE",
        "explain": "If there is only one element in current subarray"
    },
    {
        "py": "build ( 2 * node , start , mid ) NEW_LINE build ( 2 * node + 1 , mid + 1 , end ) NEW_LINE",
        "explain": "build left and right segments"
    },
    {
        "py": "left_lcm = tree [ 2 * node ] NEW_LINE right_lcm = tree [ 2 * node + 1 ] NEW_LINE tree [ node ] = lcm ( left_lcm , right_lcm ) NEW_LINE",
        "explain": "build the parent"
    },
    {
        "py": "def query ( node : int , start : int , end : int , l : int , r : int ) : NEW_LINE",
        "explain": "Function to make queries for array range ) l , r ) . Node is index of root of current segment in segment tree ( Note that indexes in segment tree begin with 1f or simplicity ) . start and end are indexes of subarray covered by root of current segment ."
    },
    {
        "py": "if end < l or start > r : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Completely outside the segment , returning 1 will not affect the lcm ;"
    },
    {
        "py": "if l <= start and r >= end : NEW_LINE INDENT return tree [ node ] NEW_LINE DEDENT",
        "explain": "completely inside the segment"
    },
    {
        "py": "mid = ( start + end ) // 2 NEW_LINE left_lcm = query ( 2 * node , start , mid , l , r ) NEW_LINE right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) NEW_LINE return lcm ( left_lcm , right_lcm ) NEW_LINE",
        "explain": "partially inside"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr [ 0 ] = 5 NEW_LINE arr [ 1 ] = 7 NEW_LINE arr [ 2 ] = 5 NEW_LINE arr [ 3 ] = 2 NEW_LINE arr [ 4 ] = 10 NEW_LINE arr [ 5 ] = 12 NEW_LINE arr [ 6 ] = 11 NEW_LINE arr [ 7 ] = 17 NEW_LINE arr [ 8 ] = 14 NEW_LINE arr [ 9 ] = 1 NEW_LINE arr [ 10 ] = 44 NEW_LINE",
        "explain": "initialize the array"
    },
    {
        "py": "build ( 1 , 0 , 10 ) NEW_LINE",
        "explain": "build the segment tree"
    },
    {
        "py": "print ( query ( 1 , 0 , 10 , 2 , 5 ) ) NEW_LINE",
        "explain": "Now we can answer each query efficiently Print LCM of ( 2 , 5 )"
    },
    {
        "py": "print ( query ( 1 , 0 , 10 , 5 , 10 ) ) NEW_LINE",
        "explain": "Print LCM of ( 5 , 10 )"
    },
    {
        "py": "print ( query ( 1 , 0 , 10 , 0 , 10 ) ) NEW_LINE",
        "explain": "Print LCM of ( 0 , 10 )"
    },
    {
        "py": "M = 1000000007 NEW_LINE def waysOfDecoding ( s ) : NEW_LINE INDENT dp = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE DEDENT",
        "explain": "Python program for the above approach"
    },
    {
        "py": "if s [ 0 ] == ' * ' : NEW_LINE INDENT dp [ 1 ] = 9 NEW_LINE DEDENT elif s [ 0 ] == '0' : NEW_LINE INDENT dp [ 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] = 1 NEW_LINE DEDENT",
        "explain": "check the first character of the string if it is ' * ' then 9 ways"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "traverse the string"
    },
    {
        "py": "if ( s [ i ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = 9 * dp [ i ] NEW_LINE DEDENT",
        "explain": "If s [ i ] = = ' * ' there can be 9 possible values of *"
    },
    {
        "py": "if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 9 * dp [ i - 1 ] ) % M NEW_LINE DEDENT",
        "explain": "If previous character is 1 then words that can be formed are K ( 11 ) , L ( 12 ) , M ( 13 ) , N ( 14 ) O ( 15 ) , P ( 16 ) , Q ( 17 ) , R ( 18 ) , S ( 19 )"
    },
    {
        "py": "elif ( s [ i - 1 ] == '2' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 6 * dp [ i - 1 ] ) % M NEW_LINE DEDENT",
        "explain": "If previous character is 2 then the words that can be formed are U ( 21 ) , V ( 22 ) , W ( 23 ) , X ( 24 ) Y ( 25 ) , Z ( 26 )"
    },
    {
        "py": "elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + 15 * dp [ i - 1 ] ) % M NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If the previous digit is * then all 15 2 - digit characters can be formed"
    },
    {
        "py": "if s [ i ] != '0' : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = 0 NEW_LINE DEDENT",
        "explain": "taking the value from previous step"
    },
    {
        "py": "if ( s [ i - 1 ] == '1' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT",
        "explain": "If previous character is 1 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] ."
    },
    {
        "py": "elif ( s [ i - 1 ] == '2' and s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i + 1 ] + dp [ i - 1 ] ) % M NEW_LINE DEDENT",
        "explain": "If previous character is 2 and ith character is less than 6 then the i - 1 th character and ith character can be decoded in a single character therefore , adding dp [ i - 1 ] ."
    },
    {
        "py": "elif ( s [ i - 1 ] == ' * ' ) : NEW_LINE INDENT if ( s [ i ] <= '6' ) : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 2 * dp [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i + 1 ] = dp [ i + 1 ] + 1 * dp [ i - 1 ] NEW_LINE DEDENT dp [ i + 1 ] = dp [ i + 1 ] % M NEW_LINE DEDENT return dp [ len ( s ) ] NEW_LINE",
        "explain": "If previous character is * then it will contain the above 2 cases"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"12\" NEW_LINE print ( waysOfDecoding ( s ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countSubset ( arr , n , diff ) : NEW_LINE",
        "explain": "Function to count the number of ways to divide the array into two subsets and such that the difference between their sums is equal to diff"
    },
    {
        "py": "sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT sum += diff NEW_LINE sum = sum // 2 NEW_LINE",
        "explain": "Store the sum of the set S1"
    },
    {
        "py": "t = [ [ 0 for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE",
        "explain": "Initializing the matrix"
    },
    {
        "py": "for j in range ( sum + 1 ) : NEW_LINE INDENT t [ 0 ] [ j ] = 0 NEW_LINE DEDENT",
        "explain": "Number of ways to get sum using 0 elements is 0"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT t [ i ] [ 0 ] = 1 NEW_LINE DEDENT",
        "explain": "Number of ways to get sum 0 using i elements is 1"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE DEDENT",
        "explain": "Traverse the 2D array"
    },
    {
        "py": "if ( arr [ i - 1 ] > j ) : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT t [ i ] [ j ] = t [ i - 1 ] [ j ] + t [ i - 1 ] [ j - arr [ i - 1 ] ] NEW_LINE DEDENT",
        "explain": "If the value is greater than the sum store the value of previous state"
    },
    {
        "py": "return t [ n ] [ sum ] NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "diff , n = 1 , 4 NEW_LINE arr = [ 1 , 1 , 2 , 3 ] NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( countSubset ( arr , n , diff ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "dp = [ [ 0 for i in range ( 605 ) ] for j in range ( 105 ) ] NEW_LINE",
        "explain": "Python3 program for above approach"
    },
    {
        "py": "def find ( N , a , b ) : NEW_LINE INDENT probability = 0.0 NEW_LINE DEDENT",
        "explain": "Function to calculate probability that the sum of numbers on N throws of dice lies between A and B"
    },
    {
        "py": "for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1.0 / 6 NEW_LINE DEDENT for i in range ( 2 , N + 1 ) : NEW_LINE INDENT for j in range ( i , ( 6 * i ) + 1 ) : NEW_LINE INDENT for k in range ( 1 , 7 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j ] + dp [ i - 1 ] [ j - k ] / 6 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Base case"
    },
    {
        "py": "for Sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + dp [ N ] [ Sum ] NEW_LINE DEDENT return probability NEW_LINE",
        "explain": "Add the probability for all the numbers between a and b"
    },
    {
        "py": "N , a , b = 4 , 13 , 17 NEW_LINE probability = find ( N , a , b ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( ' % .6f ' % probability ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "from collections import deque as queue NEW_LINE",
        "explain": "Python3 code for max sum with adjacent levels not allowed"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT",
        "explain": "A BST node"
    },
    {
        "py": "def getSumAlternate ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT sum = root . data NEW_LINE if ( root . left != None ) : NEW_LINE INDENT sum += getSum ( root . left . left ) NEW_LINE sum += getSum ( root . left . right ) NEW_LINE DEDENT if ( root . right != None ) : NEW_LINE INDENT sum += getSum ( root . right . left ) NEW_LINE sum += getSum ( root . right . right ) NEW_LINE DEDENT return sum NEW_LINE DEDENT",
        "explain": "Recursive function to find the maximum sum returned for a root node and its grandchildren"
    },
    {
        "py": "def getSum ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Returns maximum sum with adjacent levels not allowed . This function mainly uses getSumAlternate ( )"
    },
    {
        "py": "return max ( getSumAlternate ( root ) , ( getSumAlternate ( root . left ) + getSumAlternate ( root . right ) ) ) NEW_LINE",
        "explain": "We compute sum of alternate levels starting first level and from second level . And return maximum of two values ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 4 ) NEW_LINE root . right . left . right = Node ( 5 ) NEW_LINE root . right . left . right . left = Node ( 6 ) NEW_LINE print ( getSum ( root ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isSubsetSum ( arr , n , sum ) : NEW_LINE",
        "explain": "Returns true if there exists a subset with given sum in arr [ ]"
    },
    {
        "py": "subset = [ [ False for j in range ( sum + 1 ) ] for i in range ( 3 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE DEDENT",
        "explain": "The value of subset [ i % 2 ] [ j ] will be true if there exists a subset of sum j in arr [ 0 , 1 , ... . , i - 1 ]"
    },
    {
        "py": "if ( j == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = True NEW_LINE DEDENT",
        "explain": "A subset with sum 0 is always possible"
    },
    {
        "py": "elif ( i == 0 ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = False NEW_LINE DEDENT elif ( arr [ i - 1 ] <= j ) : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j - arr [ i - 1 ] ] or subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i % 2 ] [ j ] = subset [ ( i + 1 ) % 2 ] [ j ] NEW_LINE DEDENT return subset [ n % 2 ] [ sum ] NEW_LINE",
        "explain": "If there exists no element no sum is possible"
    },
    {
        "py": "arr = [ 6 , 2 , 5 ] NEW_LINE sum = 7 NEW_LINE n = len ( arr ) NEW_LINE if ( isSubsetSum ( arr , n , sum ) == True ) : NEW_LINE INDENT print ( \" There \u2581 exists \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 subset \u2581 exists \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python 3 program to find maximum equilibrium sum ."
    },
    {
        "py": "def findMaxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum = arr [ i ] NEW_LINE for j in range ( i ) : NEW_LINE INDENT prefix_sum += arr [ j ] NEW_LINE DEDENT suffix_sum = arr [ i ] NEW_LINE j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT suffix_sum += arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( prefix_sum == suffix_sum ) : NEW_LINE INDENT res = max ( res , prefix_sum ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT",
        "explain": "Function to find maximum equilibrium sum ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findMaxSum ( arr , n ) : NEW_LINE",
        "explain": "Function to find maximum equilibrium sum ."
    },
    {
        "py": "preSum = [ 0 for i in range ( n ) ] NEW_LINE",
        "explain": "Array to store prefix sum ."
    },
    {
        "py": "suffSum = [ 0 for i in range ( n ) ] NEW_LINE",
        "explain": "Array to store suffix sum ."
    },
    {
        "py": "ans = - 10000000 NEW_LINE",
        "explain": "Variable to store maximum sum ."
    },
    {
        "py": "preSum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT preSum [ i ] = preSum [ i - 1 ] + arr [ i ] NEW_LINE DEDENT",
        "explain": "Calculate prefix sum ."
    },
    {
        "py": "suffSum [ n - 1 ] = arr [ n - 1 ] NEW_LINE if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ n - 1 ] ) NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] NEW_LINE if ( suffSum [ i ] == preSum [ i ] ) : NEW_LINE INDENT ans = max ( ans , preSum [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE",
        "explain": "Calculate suffix sum and compare it with prefix sum . Update ans accordingly ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program to find maximum equilibrium sum ."
    },
    {
        "py": "def findMaxSum ( arr , n ) : NEW_LINE INDENT ss = sum ( arr ) NEW_LINE prefix_sum = 0 NEW_LINE res = - sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT prefix_sum += arr [ i ] NEW_LINE if prefix_sum == ss : NEW_LINE INDENT res = max ( res , prefix_sum ) ; NEW_LINE DEDENT ss -= arr [ i ] ; NEW_LINE DEDENT return res NEW_LINE DEDENT",
        "explain": "Function to find maximum equilibrium sum ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 2 , 5 , 3 , 1 , 2 , 6 , - 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxSum ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findMajority ( arr , n ) : NEW_LINE INDENT maxCount = 0 NEW_LINE DEDENT",
        "explain": "Function to find Majority element in an array"
    },
    {
        "py": "index = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "sentinels"
    },
    {
        "py": "if ( count > maxCount ) : NEW_LINE INDENT maxCount = count NEW_LINE index = i NEW_LINE DEDENT",
        "explain": "update maxCount if count of current element is greater"
    },
    {
        "py": "if ( maxCount > n // 2 ) : NEW_LINE INDENT print ( arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Majority \u2581 Element \" ) NEW_LINE DEDENT",
        "explain": "if maxCount is greater than n / 2 return the corresponding element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "findMajority ( arr , n ) NEW_LINE",
        "explain": "Function calling"
    },
    {
        "py": "def findCandidate ( A ) : NEW_LINE INDENT maj_index = 0 NEW_LINE count = 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ maj_index ] == A [ i ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT if count == 0 : NEW_LINE INDENT maj_index = i NEW_LINE count = 1 NEW_LINE DEDENT DEDENT return A [ maj_index ] NEW_LINE DEDENT",
        "explain": "Function to find the candidate for Majority"
    },
    {
        "py": "def isMajority ( A , cand ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] == cand : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count > len ( A ) / 2 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if the candidate occurs more than n / 2 times"
    },
    {
        "py": "def printMajority ( A ) : NEW_LINE",
        "explain": "Function to print Majority Element"
    },
    {
        "py": "cand = findCandidate ( A ) NEW_LINE",
        "explain": "Find the candidate for Majority"
    },
    {
        "py": "if isMajority ( A , cand ) == True : NEW_LINE INDENT print ( cand ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Majority \u2581 Element \" ) NEW_LINE DEDENT",
        "explain": "Print the candidate if it is Majority"
    },
    {
        "py": "A = [ 1 , 3 , 3 , 1 , 2 ] NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "printMajority ( A ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def findMajority ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( \" Majority \u2581 found \u2581 : - \" , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( \" No \u2581 Majority \u2581 element \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Python3 program for finding out majority element in an array"
    },
    {
        "py": "arr = [ 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "findMajority ( arr , n ) NEW_LINE",
        "explain": "Function calling"
    },
    {
        "py": "def majorityElement ( arr , n ) : NEW_LINE",
        "explain": "Function to find Majority element in an array it returns - 1 if there is no majority element"
    },
    {
        "py": "arr . sort ( ) NEW_LINE count , max_ele , temp , f = 1 , - 1 , arr [ 0 ] , 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE",
        "explain": "sort the array in O ( nlogn )"
    },
    {
        "py": "if ( temp == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE temp = arr [ i ] NEW_LINE DEDENT",
        "explain": "increases the count if the same element occurs otherwise starts counting new element"
    },
    {
        "py": "if ( max_ele < count ) : NEW_LINE INDENT max_ele = count NEW_LINE ele = arr [ i ] NEW_LINE if ( max_ele > ( n // 2 ) ) : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "sets maximum count and stores maximum occured element so far if maximum count becomes greater than n / 2 it breaks out setting the flag"
    },
    {
        "py": "if f == 1 : NEW_LINE INDENT return ele NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "returns maximum occured element if there is no such element , returns - 1"
    },
    {
        "py": "arr = [ 1 , 1 , 2 , 1 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( majorityElement ( arr , n ) ) NEW_LINE",
        "explain": "Function calling"
    },
    {
        "py": "def isSubsetSum ( set , n , sum ) : NEW_LINE",
        "explain": "Returns true if there is a subset of set [ ] with sum equal to given sum"
    },
    {
        "py": "subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE",
        "explain": "The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT",
        "explain": "If sum is 0 , then answer is true"
    },
    {
        "py": "for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT",
        "explain": "If sum is not 0 and set is empty , then answer is false"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Fill the subset table in bottom up manner"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE for j in range ( sum + 1 ) : NEW_LINE print ( subset [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE print ( ) NEW_LINE return subset [ n ] [ sum ] NEW_LINE",
        "explain": "uncomment this code to print table"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "tab = [ [ - 1 for i in range ( 2000 ) ] for j in range ( 2000 ) ] NEW_LINE",
        "explain": "Taking the matrix as globally"
    },
    {
        "py": "def subsetSum ( a , n , sum ) : NEW_LINE",
        "explain": "Check if possible subset with given sum is possible or not"
    },
    {
        "py": "if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If the sum is zero it means we got our expected sum"
    },
    {
        "py": "if ( tab [ n - 1 ] [ sum ] != - 1 ) : NEW_LINE INDENT return tab [ n - 1 ] [ sum ] NEW_LINE DEDENT",
        "explain": "If the value is not - 1 it means it already call the function with the same value . it will save our from the repetition ."
    },
    {
        "py": "if ( a [ n - 1 ] > sum ) : NEW_LINE INDENT tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) NEW_LINE return tab [ n - 1 ] [ sum ] NEW_LINE DEDENT else : NEW_LINE",
        "explain": "if the value of a [ n - 1 ] is greater than the sum . we call for the next value"
    },
    {
        "py": "tab [ n - 1 ] [ sum ] = subsetSum ( a , n - 1 , sum ) NEW_LINE return tab [ n - 1 ] [ sum ] or subsetSum ( a , n - 1 , sum - a [ n - 1 ] ) NEW_LINE",
        "explain": "Here we do two calls because we don ' t \u2581 know \u2581 which \u2581 value \u2581 is \u2581 \u2581 full - fill \u2581 our \u2581 criteria \u2581 \u2581 that ' s why we doing two calls"
    },
    {
        "py": "n = 5 NEW_LINE a = [ 1 , 5 , 3 , 7 , 4 ] NEW_LINE sum = 12 NEW_LINE if ( subsetSum ( a , n , sum ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import log NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def binpow ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT a = a * a NEW_LINE b //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT",
        "explain": "Function to implement fast exponentiation"
    },
    {
        "py": "def find ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT p = log ( x ) / log ( 2 ) NEW_LINE return binpow ( 2 , p + 1 ) - 1 NEW_LINE DEDENT",
        "explain": "Function to return the value for powers of 2"
    },
    {
        "py": "def getBinary ( n ) : NEW_LINE",
        "explain": "Function to convert N into binary"
    },
    {
        "py": "ans = \" \" NEW_LINE",
        "explain": "To store binary representation"
    },
    {
        "py": "while ( n > 0 ) : NEW_LINE INDENT dig = n % 2 NEW_LINE ans += str ( dig ) NEW_LINE n //= 2 NEW_LINE DEDENT",
        "explain": "Iterate each digit of n"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return binary representation"
    },
    {
        "py": "def totalCountDifference ( n ) : NEW_LINE",
        "explain": "Function to find difference in bits"
    },
    {
        "py": "ans = getBinary ( n ) NEW_LINE",
        "explain": "Get binary representation"
    },
    {
        "py": "req = 0 NEW_LINE",
        "explain": "total number of bit differences from 0 to N"
    },
    {
        "py": "for i in range ( len ( ans ) ) : NEW_LINE",
        "explain": "Iterate over each binary bit"
    },
    {
        "py": "if ( ans [ i ] == '1' ) : NEW_LINE INDENT req += find ( binpow ( 2 , i ) ) NEW_LINE DEDENT return req NEW_LINE",
        "explain": "If current bit is '1' then add the count of current bit"
    },
    {
        "py": "N = 5 NEW_LINE",
        "explain": "Given Number"
    },
    {
        "py": "print ( totalCountDifference ( N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def Maximum_Length ( a ) : NEW_LINE",
        "explain": "Function to return the maximum length of the required prefix"
    },
    {
        "py": "counts = [ 0 ] * 11 NEW_LINE",
        "explain": "Array to store the frequency of each element of the array"
    },
    {
        "py": "for index , v in enumerate ( a ) : NEW_LINE",
        "explain": "Iterating for all the elements"
    },
    {
        "py": "counts [ v ] += 1 NEW_LINE",
        "explain": "Update the frequency of the current element i . e . v"
    },
    {
        "py": "k = sorted ( [ i for i in counts if i ] ) NEW_LINE",
        "explain": "Sorted positive values from counts array"
    },
    {
        "py": "if len ( k ) == 1 or ( k [ 0 ] == k [ - 2 ] and k [ - 1 ] - k [ - 2 ] == 1 ) or ( k [ 0 ] == 1 and k [ 1 ] == k [ - 1 ] ) : NEW_LINE INDENT ans = index NEW_LINE DEDENT",
        "explain": "If current prefix satisfies the given conditions"
    },
    {
        "py": "return ans + 1 NEW_LINE",
        "explain": "Return the maximum length"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Maximum_Length ( a ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT",
        "explain": "Returns the gcd after all updates in the array"
    },
    {
        "py": "def print_gcd_online ( n , m , query , arr ) : NEW_LINE",
        "explain": "Function to calculate gcd of onine queries"
    },
    {
        "py": "max_gcd = 0 NEW_LINE",
        "explain": "Stores the gcd of the initial array elements"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT max_gcd = gcd ( max_gcd , arr [ i ] ) NEW_LINE DEDENT",
        "explain": "calculates the gcd"
    },
    {
        "py": "for i in range ( 0 , m ) : NEW_LINE",
        "explain": "performing online queries"
    },
    {
        "py": "query [ i ] [ 0 ] -= 1 NEW_LINE",
        "explain": "index is 1 based"
    },
    {
        "py": "arr [ query [ i ] [ 0 ] ] //= query [ i ] [ 1 ] NEW_LINE",
        "explain": "divide the array element"
    },
    {
        "py": "max_gcd = gcd ( arr [ query [ i ] [ 0 ] ] , max_gcd ) NEW_LINE",
        "explain": "calculates the current gcd"
    },
    {
        "py": "print ( max_gcd ) NEW_LINE",
        "explain": "Print the gcd after each step"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , m = 3 , 3 NEW_LINE query = [ [ 1 , 3 ] , [ 3 , 12 ] , [ 2 , 4 ] ] NEW_LINE arr = [ 36 , 24 , 72 ] NEW_LINE print_gcd_online ( n , m , query , arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 1000000 NEW_LINE",
        "explain": "Python 3 implementation of the approach"
    },
    {
        "py": "prime = [ True ] * ( MAX + 1 ) NEW_LINE",
        "explain": "stores whether the number is prime or not"
    },
    {
        "py": "sum = [ 0 ] * ( MAX + 1 ) NEW_LINE",
        "explain": "stores the count of prime numbers less than or equal to the index"
    },
    {
        "py": "def SieveOfEratosthenes ( ) : NEW_LINE",
        "explain": "create the sieve"
    },
    {
        "py": "prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all the entries as true . A value in prime [ i ] will finally be false if ' i ' is Not a prime , else true"
    },
    {
        "py": "if ( prime [ p ] ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "' NEW_LINE INDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT sum [ i ] = 1 NEW_LINE DEDENT sum [ i ] += sum [ i - 1 ] NEW_LINE DEDENT DEDENT",
        "explain": "stores the prefix sum of number of primes less than or equal to 'i"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "SieveOfEratosthenes ( ) NEW_LINE",
        "explain": "create the sieve"
    },
    {
        "py": "l = 3 NEW_LINE r = 9 NEW_LINE",
        "explain": "' l ' and ' r ' are the lower and upper bounds of the range"
    },
    {
        "py": "c = ( sum [ r ] - sum [ l - 1 ] ) NEW_LINE",
        "explain": "get the value of count"
    },
    {
        "py": "print ( \" Count : \" , c ) NEW_LINE",
        "explain": "display the count"
    },
    {
        "py": "from math import pow , sqrt NEW_LINE",
        "explain": "Python 3 Program to find the area of the circle inscribed within the rectangle which in turn is inscribed in a semicircle"
    },
    {
        "py": "def area ( r ) : NEW_LINE",
        "explain": "Function to find the area of the circle"
    },
    {
        "py": "if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "radius cannot be negative"
    },
    {
        "py": "area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; NEW_LINE return area ; NEW_LINE",
        "explain": "area of the circle"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( \" { 0 : . 6 } \" . format ( area ( a ) ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import * NEW_LINE N = 100005 NEW_LINE",
        "explain": "Python 3 program to count almost prime numbers from 1 to n"
    },
    {
        "py": "prime = [ True ] * N NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( N ) ) ) : NEW_LINE DEDENT",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."
    },
    {
        "py": "if prime [ p ] == True : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( 2 * p , N , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT",
        "explain": "Update all multiples of p"
    },
    {
        "py": "def almostPrimes ( n ) : NEW_LINE",
        "explain": "Function to count almost prime numbers from 1 to n"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "to store required answer"
    },
    {
        "py": "for i in range ( 6 , n + 1 ) : NEW_LINE",
        "explain": "6 is first almost prime number"
    },
    {
        "py": "c = 0 NEW_LINE for j in range ( 2 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE",
        "explain": "to count prime factors"
    },
    {
        "py": "if i % j == 0 : NEW_LINE INDENT if j * j == i : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if prime [ j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if prime [ i // j ] : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "if it is perfect square"
    },
    {
        "py": "if c == 2 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "if I is almost prime number"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 21 NEW_LINE print ( almostPrimes ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def sumOfDigitsSingle ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while x : NEW_LINE INDENT ans += x % 10 NEW_LINE x //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT",
        "explain": "Returns sum of digits of x"
    },
    {
        "py": "def closest ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( ans * 10 + 9 <= x ) : NEW_LINE INDENT ans = ans * 10 + 9 NEW_LINE DEDENT return ans NEW_LINE DEDENT def sumOfDigitsTwoParts ( N ) : NEW_LINE INDENT A = closest ( N ) NEW_LINE return sumOfDigitsSingle ( A ) + sumOfDigitsSingle ( N - A ) NEW_LINE DEDENT",
        "explain": "Returns closest number to x in terms of 9 's"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 35 NEW_LINE print ( sumOfDigitsTwoParts ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def isPrime ( p ) : NEW_LINE",
        "explain": "Function to check whether ( 2 ^ p - 1 ) is prime or not ."
    },
    {
        "py": "checkNumber = 2 ** p - 1 NEW_LINE",
        "explain": "generate the number"
    },
    {
        "py": "nextval = 4 % checkNumber NEW_LINE",
        "explain": "First number of the series"
    },
    {
        "py": "for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT",
        "explain": "Generate the rest ( p - 2 ) terms of the series"
    },
    {
        "py": "if ( nextval == 0 ) : return True NEW_LINE else : return False NEW_LINE",
        "explain": "now if the ( p - 1 ) the term is 0 return true else false ."
    },
    {
        "py": "p = 7 NEW_LINE checkNumber = 2 ** p - 1 NEW_LINE if isPrime ( p ) : NEW_LINE INDENT print ( checkNumber , ' is \u2581 Prime . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( checkNumber , ' is \u2581 not \u2581 Prime ' ) NEW_LINE DEDENT",
        "explain": "Check whetherr 2 ^ ( p - 1 ) is prime or not ."
    },
    {
        "py": "def sieve ( n , prime ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE DEDENT",
        "explain": "Function to detect prime number here we have used sieve method https : www . geeksforgeeks . org / sieve - of - eratosthenes / to detect prime number"
    },
    {
        "py": "if ( prime [ p ] == True ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE def printSophieGermanNumber ( n ) : NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "prime = [ True ] * ( 2 * n + 1 ) NEW_LINE sieve ( 2 * n + 1 , prime ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE",
        "explain": "We have made array till 2 * n + 1 so that we can check prime number till that and conclude about sophie german prime ."
    },
    {
        "py": "if ( prime [ i ] and prime [ 2 * i + 1 ] ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "checking every i whether it is sophie german prime or not ."
    },
    {
        "py": "n = 25 NEW_LINE printSophieGermanNumber ( n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def ucal ( u , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = u ; NEW_LINE for i in range ( 1 , int ( n / 2 + 1 ) ) : NEW_LINE INDENT temp = temp * ( u - i ) ; NEW_LINE DEDENT for i in range ( 1 , int ( n / 2 ) ) : NEW_LINE INDENT temp = temp * ( u + i ) ; NEW_LINE DEDENT return temp ; NEW_LINE DEDENT",
        "explain": "calculating u mentioned in the formula"
    },
    {
        "py": "def fact ( n ) : NEW_LINE INDENT f = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT",
        "explain": "calculating factorial of given number n"
    },
    {
        "py": "n = 6 ; NEW_LINE x = [ 25 , 26 , 27 , 28 , 29 , 30 ] ; NEW_LINE",
        "explain": "Number of values given"
    },
    {
        "py": "y = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] ; NEW_LINE y [ 0 ] [ 0 ] = 4.000 ; NEW_LINE y [ 1 ] [ 0 ] = 3.846 ; NEW_LINE y [ 2 ] [ 0 ] = 3.704 ; NEW_LINE y [ 3 ] [ 0 ] = 3.571 ; NEW_LINE y [ 4 ] [ 0 ] = 3.448 ; NEW_LINE y [ 5 ] [ 0 ] = 3.333 ; NEW_LINE",
        "explain": "y [ ] [ ] is used for difference table with y [ ] [ 0 ] used for input"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT y [ j ] [ i ] = y [ j + 1 ] [ i - 1 ] - y [ j ] [ i - 1 ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Calculating the central difference table"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT print ( y [ i ] [ j ] , \" TABSYMBOL \" , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( \" \" ) ; NEW_LINE DEDENT",
        "explain": "Displaying the central difference table"
    },
    {
        "py": "value = 27.4 ; NEW_LINE",
        "explain": "value to interpolate at"
    },
    {
        "py": "sum = ( y [ 2 ] [ 0 ] + y [ 3 ] [ 0 ] ) / 2 ; NEW_LINE",
        "explain": "Initializing u and sum"
    },
    {
        "py": "k = 0 ; NEW_LINE",
        "explain": "k is origin thats is f ( 0 )"
    },
    {
        "py": "k = int ( n / 2 ) ; NEW_LINE else : NEW_LINE",
        "explain": "if ( ( n % 2 ) > 0 ) : origin for odd"
    },
    {
        "py": "u = ( value - x [ k ] ) / ( x [ 1 ] - x [ 0 ] ) ; NEW_LINE",
        "explain": "k = int ( n / 2 - 1 ) ; origin for even"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 2 ) : NEW_LINE INDENT sum = sum + ( ( u - 0.5 ) * ucal ( u , i - 1 ) * y [ k ] [ i ] ) / fact ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + ( ucal ( u , i ) * ( y [ k ] [ i ] + y [ k - 1 ] [ i ] ) / ( fact ( i ) * 2 ) ) ; NEW_LINE k -= 1 ; NEW_LINE DEDENT DEDENT print ( \" Value \u2581 at \" , value , \" is \" , round ( sum , 5 ) ) ; NEW_LINE",
        "explain": "Solving using bessel 's formula"
    },
    {
        "py": "def fibonacci ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT",
        "explain": "A simple Python 3 program to check if n - th Fibonacci number is multiple of 10."
    },
    {
        "py": "def isMultipleOf10 ( n ) : NEW_LINE INDENT f = fibonacci ( 30 ) NEW_LINE return ( f % 10 == 0 ) NEW_LINE DEDENT",
        "explain": "Returns true if n - th Fibonacci number is multiple of 10."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 30 NEW_LINE if ( isMultipleOf10 ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def powerof2 ( n ) : NEW_LINE",
        "explain": "function which checks whether a number is a power of 2"
    },
    {
        "py": "if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )"
    },
    {
        "py": "elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "all other odd numbers are not powers of 2"
    },
    {
        "py": "return powerof2 ( n / 2 ) NEW_LINE",
        "explain": "recursive function call"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "INDENT print ( powerof2 ( 64 ) ) NEW_LINE DEDENT",
        "explain": "True"
    },
    {
        "py": "INDENT print ( powerof2 ( 12 ) ) NEW_LINE DEDENT",
        "explain": "False"
    },
    {
        "py": "def isPowerOfTwo ( x ) : NEW_LINE",
        "explain": "Function to check if x is power of 2"
    },
    {
        "py": "return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE",
        "explain": "First x in the below expression is for the case when x is 0"
    },
    {
        "py": "if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isPowerofTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( n & ( ~ ( n - 1 ) ) ) == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT",
        "explain": "Function to check if x is power of 2"
    },
    {
        "py": "if ( isPowerofTwo ( 30 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerofTwo ( 128 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def nextPowerOf2 ( n ) : NEW_LINE",
        "explain": "Function to find the nearest power of 2"
    },
    {
        "py": "p = 1 NEW_LINE",
        "explain": "The number"
    },
    {
        "py": "if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT",
        "explain": "If already a power of 2"
    },
    {
        "py": "while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p NEW_LINE",
        "explain": "Find the next power of 2"
    },
    {
        "py": "def memoryUsed ( arr , n ) : NEW_LINE",
        "explain": "Function to find the memory used"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Sum of array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Traverse and find the sum of array"
    },
    {
        "py": "nearest = nextPowerOf2 ( sum ) NEW_LINE return nearest NEW_LINE",
        "explain": "Function call to find the nearest power of 2"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( memoryUsed ( arr , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def toggleKthBit ( n , k ) : NEW_LINE INDENT return ( n ^ ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT",
        "explain": "Python3 code to toggle k - th bit of n"
    },
    {
        "py": "n = 5 NEW_LINE k = 1 NEW_LINE print ( toggleKthBit ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Python program to find smallest power of 2 greater than or equal to n"
    },
    {
        "py": "if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE",
        "explain": "First n in the below condition is for the case where n is 0"
    },
    {
        "py": "n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def gcd ( A , B ) : NEW_LINE INDENT if ( B == 0 ) : NEW_LINE INDENT return A NEW_LINE DEDENT return gcd ( B , A % B ) NEW_LINE DEDENT",
        "explain": "Function to return the GCD of A and B"
    },
    {
        "py": "def lcm ( A , B ) : NEW_LINE INDENT return ( A * B ) // gcd ( A , B ) NEW_LINE DEDENT",
        "explain": "Function to return the LCM of A and B"
    },
    {
        "py": "def checkA ( A , B , C , K ) : NEW_LINE",
        "explain": "Function to return the Kth element from the required set if it a multiple of A"
    },
    {
        "py": "start = 1 NEW_LINE end = K NEW_LINE",
        "explain": "Start and End for Binary Search"
    },
    {
        "py": "ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = A * mid NEW_LINE divA = mid - 1 NEW_LINE divB = value // B - 1 if ( value % B == 0 ) else value // B NEW_LINE divC = value // C - 1 if ( value % C == 0 ) else value // C NEW_LINE divAB = value // lcm ( A , B ) - 1 if ( value % lcm ( A , B ) == 0 ) else value // lcm ( A , B ) NEW_LINE divBC = value // lcm ( C , B ) - 1 if ( value % lcm ( C , B ) == 0 ) else value // lcm ( C , B ) NEW_LINE divAC = value // lcm ( A , C ) - 1 if ( value % lcm ( A , C ) == 0 ) else value // lcm ( A , C ) NEW_LINE divABC = value // lcm ( A , lcm ( B , C ) ) - 1 if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) else value // lcm ( A , lcm ( B , C ) ) NEW_LINE DEDENT",
        "explain": "If no answer found return - 1"
    },
    {
        "py": "elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT",
        "explain": "Inclusion and Exclusion"
    },
    {
        "py": "elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT",
        "explain": "Multiple should be smaller"
    },
    {
        "py": "else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Multiple should be bigger"
    },
    {
        "py": "def checkB ( A , B , C , K ) : NEW_LINE",
        "explain": "Function to return the Kth element from the required set if it a multiple of B"
    },
    {
        "py": "start = 1 NEW_LINE end = K NEW_LINE",
        "explain": "Start and End for Binary Search"
    },
    {
        "py": "ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = B * mid NEW_LINE divB = mid - 1 NEW_LINE if ( value % A == 0 ) : NEW_LINE INDENT divA = value // A - 1 NEW_LINE DEDENT else : value // A NEW_LINE if ( value % C == 0 ) : NEW_LINE INDENT divC = value // C - 1 NEW_LINE DEDENT else : value // C NEW_LINE if ( value % lcm ( A , B ) == 0 ) : NEW_LINE INDENT divAB = value // lcm ( A , B ) - 1 NEW_LINE DEDENT else : value // lcm ( A , B ) NEW_LINE if ( value % lcm ( C , B ) == 0 ) : NEW_LINE INDENT divBC = value // lcm ( C , B ) - 1 NEW_LINE DEDENT else : value // lcm ( C , B ) NEW_LINE if ( value % lcm ( A , C ) == 0 ) : NEW_LINE INDENT divAC = value // lcm ( A , C ) - 1 NEW_LINE DEDENT else : value // lcm ( A , C ) NEW_LINE if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) : NEW_LINE INDENT divABC = value // lcm ( A , lcm ( B , C ) ) - 1 NEW_LINE DEDENT else : value // lcm ( A , lcm ( B , C ) ) NEW_LINE DEDENT",
        "explain": "If no answer found return - 1"
    },
    {
        "py": "elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT",
        "explain": "Inclusion and Exclusion"
    },
    {
        "py": "elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT",
        "explain": "Multiple should be smaller"
    },
    {
        "py": "else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Multiple should be bigger"
    },
    {
        "py": "def checkC ( A , B , C , K ) : NEW_LINE",
        "explain": "Function to return the Kth element from the required set if it a multiple of C"
    },
    {
        "py": "start = 1 NEW_LINE end = K NEW_LINE",
        "explain": "Start and End for Binary Search"
    },
    {
        "py": "ans = - 1 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE value = C * mid NEW_LINE divC = mid - 1 NEW_LINE if ( value % B == 0 ) : NEW_LINE INDENT divB = value // B - 1 NEW_LINE DEDENT else : value // B NEW_LINE if ( value % A == 0 ) : NEW_LINE INDENT divA = value // A - 1 NEW_LINE DEDENT else : value // A NEW_LINE if ( value % lcm ( A , B ) == 0 ) : NEW_LINE INDENT divAB = value // lcm ( A , B ) - 1 NEW_LINE DEDENT else : value // lcm ( A , B ) NEW_LINE if ( value % lcm ( C , B ) == 0 ) : NEW_LINE INDENT divBC = value // lcm ( C , B ) - 1 NEW_LINE DEDENT else : value // lcm ( C , B ) NEW_LINE if ( value % lcm ( A , C ) == 0 ) : NEW_LINE INDENT divAC = value // lcm ( A , C ) - 1 NEW_LINE DEDENT else : value // lcm ( A , C ) NEW_LINE if ( value % lcm ( A , lcm ( B , C ) ) == 0 ) : NEW_LINE INDENT divABC = value // lcm ( A , lcm ( B , C ) ) - 1 NEW_LINE DEDENT else : value // lcm ( A , lcm ( B , C ) ) NEW_LINE DEDENT",
        "explain": "If no answer found return - 1"
    },
    {
        "py": "elem = divA + divB + divC - divAC - divBC - divAB + divABC NEW_LINE if ( elem == ( K - 1 ) ) : NEW_LINE INDENT ans = value NEW_LINE break NEW_LINE DEDENT",
        "explain": "Inclusion and Exclusion"
    },
    {
        "py": "elif ( elem > ( K - 1 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT",
        "explain": "Multiple should be smaller"
    },
    {
        "py": "else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Multiple should be bigger"
    },
    {
        "py": "def findKthMultiple ( A , B , C , K ) : NEW_LINE",
        "explain": "Function to return the Kth element from the set of multiples of A , B and C"
    },
    {
        "py": "res = checkA ( A , B , C , K ) NEW_LINE",
        "explain": "Apply binary search on the multiples of A"
    },
    {
        "py": "if ( res == - 1 ) : NEW_LINE INDENT res = checkB ( A , B , C , K ) NEW_LINE DEDENT",
        "explain": "If the required element is not a multiple of A then the multiples of B and C need to be checked"
    },
    {
        "py": "if ( res == - 1 ) : NEW_LINE INDENT res = checkC ( A , B , C , K ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "If the required element is neither a multiple of A nor a multiple of B then the multiples of C need to be checked"
    },
    {
        "py": "A = 2 NEW_LINE B = 4 NEW_LINE C = 5 NEW_LINE K = 5 NEW_LINE print ( findKthMultiple ( A , B , C , K ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def variationStalinsort ( arr ) : NEW_LINE INDENT j = 0 NEW_LINE while True : NEW_LINE INDENT moved = 0 NEW_LINE for i in range ( len ( arr ) - 1 - j ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to sort the array"
    },
    {
        "py": "arr . insert ( moved , arr . pop ( i + 1 ) ) NEW_LINE moved += 1 NEW_LINE j += 1 NEW_LINE if moved == 0 : NEW_LINE break NEW_LINE return arr NEW_LINE",
        "explain": "Iterator < Integer > index = arr . iterator ( ) ;"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 , 6 , 5 , 8 , 7 , 10 , 9 ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( variationStalinsort ( arr ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def printArray ( arr , N ) : NEW_LINE",
        "explain": "Function to print array element"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "def sortArray ( arr , N ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT",
        "explain": "Function to sort the array in O ( N )"
    },
    {
        "py": "while i < N : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if arr [ i ] == i + 1 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "If the current element is at correct position"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Else swap the current element with it 's correct position"
    },
    {
        "py": "temp1 = arr [ i ] NEW_LINE temp2 = arr [ arr [ i ] - 1 ] NEW_LINE arr [ i ] = temp2 NEW_LINE arr [ temp1 - 1 ] = temp1 NEW_LINE",
        "explain": "Swap the value of arr [ i ] and arr [ arr [ i ] - 1 ]"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 5 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "sortArray ( arr , N ) NEW_LINE",
        "explain": "Function call to sort the array"
    },
    {
        "py": "printArray ( arr , N ) NEW_LINE",
        "explain": "Function call to print the array"
    },
    {
        "py": "def maximum ( value , weight , weight1 , flag , K , index , val_len ) : NEW_LINE",
        "explain": "Function to find the maximum value"
    },
    {
        "py": "if ( index >= val_len ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "base condition"
    },
    {
        "py": "if ( flag == K ) : NEW_LINE",
        "explain": "K elements already reduced to half of their weight"
    },
    {
        "py": "skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) NEW_LINE full = 0 NEW_LINE",
        "explain": "Dont include item"
    },
    {
        "py": "if ( weight [ index ] <= weight1 ) : NEW_LINE INDENT full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) NEW_LINE DEDENT",
        "explain": "If weight of the item is less than or equal to the remaining weight then include the item"
    },
    {
        "py": "return max ( full , skip ) NEW_LINE",
        "explain": "Return the maximum of both cases"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If the weight reduction to half is possible"
    },
    {
        "py": "skip = maximum ( value , weight , weight1 , flag , K , index + 1 , val_len ) NEW_LINE full = 0 NEW_LINE half = 0 NEW_LINE",
        "explain": "Skip the item"
    },
    {
        "py": "if ( weight [ index ] <= weight1 ) : NEW_LINE INDENT full = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] , flag , K , index + 1 , val_len ) NEW_LINE DEDENT",
        "explain": "Include item with full weight if weight of the item is less than the remaining weight"
    },
    {
        "py": "if ( weight [ index ] / 2 <= weight1 ) : NEW_LINE INDENT half = value [ index ] + maximum ( value , weight , weight1 - weight [ index ] / 2 , flag , K , index + 1 , val_len ) NEW_LINE DEDENT",
        "explain": "Include item with half weight if half weight of the item is less than the remaining weight"
    },
    {
        "py": "return max ( full , max ( skip , half ) ) NEW_LINE",
        "explain": "Return the maximum of all 3 cases"
    },
    {
        "py": "value = [ 17 , 20 , 10 , 15 ] NEW_LINE weight = [ 4 , 2 , 7 , 5 ] NEW_LINE K = 1 NEW_LINE W = 4 NEW_LINE val_len = len ( value ) NEW_LINE print ( maximum ( value , weight , W , 0 , K , 0 , val_len ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 1005 NEW_LINE",
        "explain": "Python3 program to find the size of the minimum dominating set of the tree"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT",
        "explain": "Definition of a tree node"
    },
    {
        "py": "def newNode ( data ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE return node NEW_LINE DEDENT",
        "explain": "Helper function that allocates a new node"
    },
    {
        "py": "dp = [ [ [ - 1 for i in range ( 5 ) ] for j in range ( 5 ) ] for k in range ( N ) ] ; NEW_LINE",
        "explain": "DP array to precompute and store the results"
    },
    {
        "py": "def minDominatingSet ( root , covered , compulsory ) : NEW_LINE",
        "explain": "minDominatingSettion to return the size of the minimum dominating set of the array"
    },
    {
        "py": "if ( not root ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "if ( not root . left and not root . right and not covered ) : NEW_LINE INDENT compulsory = True ; NEW_LINE DEDENT",
        "explain": "Setting the compulsory value if needed"
    },
    {
        "py": "if ( dp [ root . data ] [ covered ] [ compulsory ] != - 1 ) : NEW_LINE INDENT return dp [ root . data ] [ covered ] [ compulsory ] ; NEW_LINE DEDENT",
        "explain": "Check if the answer is already computed"
    },
    {
        "py": "if ( compulsory ) : NEW_LINE INDENT dp [ root . data ] [ covered ] [ compulsory ] = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; NEW_LINE DEDENT",
        "explain": "If it is compulsory to select the node"
    },
    {
        "py": "return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE",
        "explain": "Choose the node and set its children as covered"
    },
    {
        "py": "if ( covered ) : NEW_LINE INDENT dp [ root . data ] [ covered ] [ compulsory ] = min ( 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; NEW_LINE return dp [ root . data ] [ covered ] [ compulsory ] NEW_LINE DEDENT",
        "explain": "If it is covered"
    },
    {
        "py": "ans = 1 + minDominatingSet ( root . left , 1 , 0 ) + minDominatingSet ( root . right , 1 , 0 ) ; NEW_LINE if ( root . left ) : NEW_LINE INDENT ans = min ( ans , minDominatingSet ( root . left , 0 , 1 ) + minDominatingSet ( root . right , 0 , 0 ) ) ; NEW_LINE DEDENT if ( root . right ) : NEW_LINE INDENT ans = min ( ans , minDominatingSet ( root . left , 0 , 0 ) + minDominatingSet ( root . right , 0 , 1 ) ) ; NEW_LINE DEDENT",
        "explain": "If the current node is neither covered nor needs to be selected compulsorily"
    },
    {
        "py": "dp [ root . data ] [ covered ] [ compulsory ] = ans ; NEW_LINE return ans NEW_LINE",
        "explain": "Store the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "root = newNode ( 1 ) ; NEW_LINE root . left = newNode ( 2 ) ; NEW_LINE root . left . left = newNode ( 3 ) ; NEW_LINE root . left . right = newNode ( 4 ) ; NEW_LINE root . left . left . left = newNode ( 5 ) ; NEW_LINE root . left . left . left . left = newNode ( 6 ) ; NEW_LINE root . left . left . left . right = newNode ( 7 ) ; NEW_LINE root . left . left . left . right . right = newNode ( 10 ) ; NEW_LINE root . left . left . left . left . left = newNode ( 8 ) ; NEW_LINE root . left . left . left . left . right = newNode ( 9 ) ; NEW_LINE print ( minDominatingSet ( root , 0 , 0 ) ) NEW_LINE",
        "explain": "Constructing the tree"
    },
    {
        "py": "import numpy as np NEW_LINE maxSum = 100 NEW_LINE arrSize = 51 NEW_LINE",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "dp = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE visit = np . zeros ( ( arrSize , maxSum ) ) ; NEW_LINE",
        "explain": "variable to store states of dp"
    },
    {
        "py": "def SubsetCnt ( i , s , arr , n ) : NEW_LINE",
        "explain": "To find the number of subsets with sum equal to 0. Since S can be negative , we will maxSum to it to make it positive"
    },
    {
        "py": "if ( i == n ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "if ( visit [ i ] [ s + arrSize ] ) : NEW_LINE INDENT return dp [ i ] [ s + arrSize ] ; NEW_LINE DEDENT",
        "explain": "Returns the value if a state is already solved"
    },
    {
        "py": "visit [ i ] [ s + arrSize ] = 1 ; NEW_LINE",
        "explain": "If the state is not visited , then continue"
    },
    {
        "py": "dp [ i ] [ s + arrSize ] = ( SubsetCnt ( i + 1 , s + arr [ i ] , arr , n ) + SubsetCnt ( i + 1 , s , arr , n ) ) ; NEW_LINE",
        "explain": "Recurrence relation"
    },
    {
        "py": "return dp [ i ] [ s + arrSize ] ; NEW_LINE",
        "explain": "Returning the value"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 2 , 2 , - 4 , - 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( SubsetCnt ( 0 , 0 , arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def printTetra ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the N - th tetranacci number"
    },
    {
        "py": "first = 0 ; NEW_LINE second = 1 ; NEW_LINE third = 1 ; NEW_LINE fourth = 2 ; NEW_LINE",
        "explain": "Initialize first four numbers to base cases"
    },
    {
        "py": "curr = 0 ; NEW_LINE if ( n == 0 ) : NEW_LINE INDENT print ( first ) ; NEW_LINE DEDENT elif ( n == 1 or n == 2 ) : NEW_LINE INDENT print ( second ) ; NEW_LINE DEDENT elif ( n == 3 ) : NEW_LINE INDENT print ( fourth ) ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "declare a current variable"
    },
    {
        "py": "for i in range ( 4 , n + 1 ) : NEW_LINE INDENT curr = first + second + third + fourth ; NEW_LINE first = second ; NEW_LINE second = third ; NEW_LINE third = fourth ; NEW_LINE fourth = curr ; NEW_LINE DEDENT print ( curr ) ; NEW_LINE",
        "explain": "Loop to add previous four numbers for each number starting from 4 and then assign first , second , third to second , third , fourth and curr to fourth respectively"
    },
    {
        "py": "n = 10 ; NEW_LINE printTetra ( n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countWays ( n ) : NEW_LINE INDENT res = [ 0 ] * ( n + 2 ) NEW_LINE res [ 0 ] = 1 NEW_LINE res [ 1 ] = 1 NEW_LINE res [ 2 ] = 2 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res [ i ] = res [ i - 1 ] + res [ i - 2 ] + res [ i - 3 ] NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT",
        "explain": "A recursive function used by countWays"
    },
    {
        "py": "n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countWays ( n ) : NEW_LINE",
        "explain": "A recursive function used by countWays"
    },
    {
        "py": "a = 1 NEW_LINE b = 2 NEW_LINE c = 4 NEW_LINE",
        "explain": "declaring three variables and holding the ways for first three stairs"
    },
    {
        "py": "if ( n == 0 or n == 1 or n == 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return c NEW_LINE DEDENT",
        "explain": "d = 0 fourth variable"
    },
    {
        "py": "for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = c + b + a NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE DEDENT return d NEW_LINE",
        "explain": "starting from 4 as already counted for 3 stairs"
    },
    {
        "py": "n = 4 NEW_LINE print ( countWays ( n ) ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "dp [ 0 ] = True NEW_LINE",
        "explain": "initializing with 1 as sum 0 is always possible"
    },
    {
        "py": "for ele in elements : NEW_LINE",
        "explain": "loop to go through every element of the elements array"
    },
    {
        "py": "for j in range ( target , ele - 1 , - 1 ) : NEW_LINE INDENT if dp [ j - ele ] : NEW_LINE INDENT dp [ j ] = True NEW_LINE DEDENT DEDENT",
        "explain": "to change the value o all possible sum values to True"
    },
    {
        "py": "return dp [ target ] NEW_LINE",
        "explain": "If target is possible return True else False"
    },
    {
        "py": "arr = [ 6 , 2 , 5 ] NEW_LINE target = 7 NEW_LINE if isPossible ( arr , target ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxTasks ( high , low , n ) : NEW_LINE",
        "explain": "Returns maximum amount of task that can be done till day n"
    },
    {
        "py": "if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If n is less than equal to 0 , then no solution exists"
    },
    {
        "py": "return max ( high [ n - 1 ] + maxTasks ( high , low , ( n - 2 ) ) , low [ n - 1 ] + maxTasks ( high , low , ( n - 1 ) ) ) ; NEW_LINE",
        "explain": "Determines which task to choose on day n , then returns the maximum till that day"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE high = [ 3 , 6 , 8 , 7 , 6 ] NEW_LINE low = [ 1 , 5 , 4 , 5 , 3 ] NEW_LINE print ( maxTasks ( high , low , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def FindKthChar ( Str , K , X ) : NEW_LINE",
        "explain": "Function to find the Kth character after X days"
    },
    {
        "py": "ans = ' \u2581 ' NEW_LINE Sum = 0 NEW_LINE",
        "explain": "Variable to store the KthChar"
    },
    {
        "py": "for i in range ( len ( Str ) ) : NEW_LINE",
        "explain": "Traverse the string"
    },
    {
        "py": "digit = ord ( Str [ i ] ) - 48 NEW_LINE",
        "explain": "Convert char into int"
    },
    {
        "py": "Range = int ( math . pow ( digit , X ) ) NEW_LINE Sum += Range NEW_LINE",
        "explain": "Calculate characters"
    },
    {
        "py": "if ( K <= Sum ) : NEW_LINE INDENT ans = Str [ i ] NEW_LINE break NEW_LINE DEDENT",
        "explain": "If K is less than sum than ans = str [ i ]"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return answer"
    },
    {
        "py": "Str = \"123\" NEW_LINE K = 9 NEW_LINE X = 3 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "ans = FindKthChar ( Str , K , X ) NEW_LINE print ( ans ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "explain": "Function to get no of set bits in binary representation of positive integer n"
    },
    {
        "py": "def totalPairs ( s1 , s2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr1 = [ 0 ] * 7 ; arr2 = [ 0 ] * 7 ; NEW_LINE DEDENT",
        "explain": "Function to return the count of valid pairs"
    },
    {
        "py": "for i in range ( len ( s1 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s1 [ i ] ) ) NEW_LINE arr1 [ set_bits ] += 1 ; NEW_LINE DEDENT",
        "explain": "Store frequency of number of set bits for s1"
    },
    {
        "py": "for i in range ( len ( s2 ) ) : NEW_LINE INDENT set_bits = countSetBits ( ord ( s2 [ i ] ) ) ; NEW_LINE arr2 [ set_bits ] += 1 ; NEW_LINE DEDENT",
        "explain": "Store frequency of number of set bits for s2"
    },
    {
        "py": "for i in range ( 1 , 7 ) : NEW_LINE INDENT count += ( arr1 [ i ] * arr2 [ i ] ) ; NEW_LINE DEDENT",
        "explain": "Calculate total pairs"
    },
    {
        "py": "return count ; NEW_LINE",
        "explain": "Return the count of valid pairs"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" forgeeks \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countSubstr ( str , n , x , y ) : NEW_LINE",
        "explain": "function to count substrings starting with character X and ending with character Y"
    },
    {
        "py": "tot_count = 0 NEW_LINE",
        "explain": "to store total count of required substrings"
    },
    {
        "py": "count_x = 0 NEW_LINE",
        "explain": "to store count of character ' x ' up to the point the string ' str ' has been traversed so far"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "traverse ' str ' form left to right"
    },
    {
        "py": "' NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT count_x += 1 NEW_LINE DEDENT DEDENT",
        "explain": "if true , increment 'count_x"
    },
    {
        "py": "' NEW_LINE INDENT if str [ i ] == y : NEW_LINE INDENT tot_count += count_x NEW_LINE DEDENT DEDENT",
        "explain": "if true accumulate ' count _ x ' to 'tot_count"
    },
    {
        "py": "return tot_count NEW_LINE",
        "explain": "required count"
    },
    {
        "py": "str = ' abbcaceghcak ' NEW_LINE n = len ( str ) NEW_LINE x , y = ' a ' , ' c ' NEW_LINE print ( ' Count \u2581 = ' , countSubstr ( str , n , x , y ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "OUT = 0 NEW_LINE IN = 1 NEW_LINE",
        "explain": "Python3 program to count words in a given string"
    },
    {
        "py": "def countWords ( string ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT",
        "explain": "Returns number of words in string"
    },
    {
        "py": "wc = 0 NEW_LINE",
        "explain": "word count"
    },
    {
        "py": "for i in range ( len ( string ) ) : NEW_LINE",
        "explain": "Scan all characters one by one"
    },
    {
        "py": "if ( string [ i ] == ' \u2581 ' or string [ i ] ==   ' ' \u2581 or \u2581 string [ i ] \u2581 = = \u2581 ' \t ' ) : NEW_LINE INDENT state = OUT NEW_LINE DEDENT",
        "explain": "If next character is a separator , set the state as OUT"
    },
    {
        "py": "elif state == OUT : NEW_LINE INDENT state = IN NEW_LINE wc += 1 NEW_LINE DEDENT",
        "explain": "If next character is not a word separator and state is OUT , then set the state as IN and increment word count"
    },
    {
        "py": "return wc NEW_LINE",
        "explain": "Return the number of words"
    },
    {
        "py": "string =   \" One two three NEW_LINE INDENT four five   \" NEW_LINE DEDENT print ( \" No . \u2581 of \u2581 words \u2581 : \u2581 \" + str ( countWords ( string ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def nthEnneadecagonal ( n ) : NEW_LINE",
        "explain": "Function to find nth Enneadecagonal number"
    },
    {
        "py": "return ( 17 * n * n - 15 * n ) // 2 NEW_LINE",
        "explain": "Formula to calculate nth Enneadecagonal number"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( n , \" th \u2581 Enneadecagonal \u2581 number \u2581 : \" , nthEnneadecagonal ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "PI = 3.14159265 NEW_LINE",
        "explain": "Python3 Program to find the area of a circumscribed circle"
    },
    {
        "py": "def areacircumscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 ) ) NEW_LINE DEDENT",
        "explain": "Utility Function"
    },
    {
        "py": "a = 6 NEW_LINE print ( \" \u2581 Area \u2581 of \u2581 an \u2581 circumscribed \u2581 circle \u2581 is \u2581 : \" , round ( areacircumscribed ( a ) , 2 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def itemType ( n ) : NEW_LINE",
        "explain": "Function to find the type of the item given out according to the given rules"
    },
    {
        "py": "count = 0 NEW_LINE day = 1 NEW_LINE",
        "explain": "Stores the count of item given out at each step"
    },
    {
        "py": "while ( count + day * ( day + 1 ) // 2 < n ) : NEW_LINE",
        "explain": "Iterate to find the Nth day present is given out"
    },
    {
        "py": "count += day * ( day + 1 ) // 2 ; NEW_LINE day += 1 NEW_LINE type = day NEW_LINE while ( type > 0 ) : NEW_LINE",
        "explain": "Find the number of presents given on day is day * ( day + 1 ) / 2"
    },
    {
        "py": "count += type NEW_LINE",
        "explain": "Iterate over the type"
    },
    {
        "py": "if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT type -= 1 NEW_LINE",
        "explain": "Return the resultant type"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( itemType ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data ; NEW_LINE self . next = next ; NEW_LINE DEDENT DEDENT",
        "explain": "Linked list Node"
    },
    {
        "py": "def isSortedDesc ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT",
        "explain": "function to Check Linked List is sorted in descending order or not"
    },
    {
        "py": "while ( head . next != None ) : NEW_LINE INDENT t = head ; NEW_LINE if ( t . data <= t . next . data ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return True ; NEW_LINE def newNode ( data ) : NEW_LINE temp = Node ( 0 ) ; NEW_LINE temp . next = None ; NEW_LINE temp . data = data ; NEW_LINE return temp ; NEW_LINE",
        "explain": "Traverse the list till last Node and return False if a Node is smaller than or equal its next ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = newNode ( 7 ) ; NEW_LINE head . next = newNode ( 5 ) ; NEW_LINE head . next . next = newNode ( 4 ) ; NEW_LINE head . next . next . next = newNode ( 3 ) ; NEW_LINE if ( isSortedDesc ( head ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxLength ( str , n , c , k ) : NEW_LINE",
        "explain": "Function to find the maximum length continuos segment of character c after flipping at most K characters"
    },
    {
        "py": "ans = - 1 NEW_LINE",
        "explain": "Stores the maximum length"
    },
    {
        "py": "' NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT",
        "explain": "Stores the count of char 'c"
    },
    {
        "py": "left = 0 NEW_LINE for right in range ( 0 , n ) : NEW_LINE INDENT if ( str [ right ] == c ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Start of window"
    },
    {
        "py": "while ( cnt > k ) : NEW_LINE INDENT if ( str [ left ] == c ) : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT DEDENT",
        "explain": "Remove the extra ' c ' from left"
    },
    {
        "py": "left += 1 NEW_LINE",
        "explain": "Increment the value of the left"
    },
    {
        "py": "ans = max ( ans , right - left + 1 ) NEW_LINE return ans NEW_LINE",
        "explain": "Update the resultant maximum length of character ch"
    },
    {
        "py": "def maxConsecutiveSegment ( S , K ) : NEW_LINE INDENT N = len ( S ) NEW_LINE DEDENT",
        "explain": "Function to find the maximum length of consecutive 0 s or 1 s by flipping at most K characters of the string"
    },
    {
        "py": "return max ( maxLength ( S , N , '0' , K ) , maxLength ( S , N , '1' , K ) ) NEW_LINE",
        "explain": "Print the maximum of the maximum length of 0 s or 1 s"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"1001\" NEW_LINE K = 1 NEW_LINE print ( maxConsecutiveSegment ( S , K ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def find ( N ) : NEW_LINE",
        "explain": "Function to find minimum count of { 1 , 2 , 5 } valued coins required to make a change of all values in the range [ 1 , N ]"
    },
    {
        "py": "F = int ( ( N - 4 ) / 5 ) NEW_LINE",
        "explain": "Number of 5 valueds coins required"
    },
    {
        "py": "if ( ( N - 5 * F ) % 2 ) == 0 : NEW_LINE INDENT O = 2 NEW_LINE DEDENT else : NEW_LINE INDENT O = 1 NEW_LINE DEDENT",
        "explain": "Number of 1 valued coins required"
    },
    {
        "py": "T = ( N - 5 * F - O ) // 2 NEW_LINE print ( \" Count \u2581 of \u2581 5 \u2581 valueds \u2581 coins : \u2581 \" , F ) NEW_LINE print ( \" Count \u2581 of \u2581 2 \u2581 valueds \u2581 coins : \u2581 \" , T ) NEW_LINE print ( \" Count \u2581 of \u2581 1 \u2581 valueds \u2581 coins : \u2581 \" , O ) NEW_LINE",
        "explain": "Number of 2 valued coins required"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE find ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "' NEW_LINE def findMaxOccurence ( str , N ) : NEW_LINE",
        "explain": "Function to maximize count of 0 and 10 by replacing character ' ? ' to '0' or '1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the given String"
    },
    {
        "py": "' NEW_LINE INDENT if ( str [ i ] == ' ? ' ) : NEW_LINE DEDENT",
        "explain": "If current character is '?"
    },
    {
        "py": "str = list ( \"10?0?11\" ) NEW_LINE N = len ( str ) NEW_LINE findMaxOccurence ( str , N ) NEW_LINE",
        "explain": "Given String"
    },
    {
        "py": "def checkInfinite ( s ) : NEW_LINE",
        "explain": "Function checks if a given is valid or not and prints the output"
    },
    {
        "py": "flag = 1 NEW_LINE N = len ( s ) NEW_LINE",
        "explain": "Boolean flag variable to mark if given is valid"
    },
    {
        "py": "for i in range ( N - 1 ) : NEW_LINE",
        "explain": "Traverse the given string"
    },
    {
        "py": "if ( s [ i ] == chr ( ord ( s [ i + 1 ] ) + 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If adjacent character differ by 1"
    },
    {
        "py": "elif ( s [ i ] == ' a ' and s [ i + 1 ] == ' z ' ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If character ' a ' is followed by 4"
    },
    {
        "py": "else : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT",
        "explain": "Else flip the flag and break from the loop"
    },
    {
        "py": "if ( flag == 0 ) : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT",
        "explain": "Output according to flag variable"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "s = \" ecbaz \" NEW_LINE",
        "explain": "Given string"
    },
    {
        "py": "checkInfinite ( s ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def minChangeInLane ( barrier , n ) : NEW_LINE INDENT dp = [ 1 , 0 , 1 ] NEW_LINE for j in range ( n ) : NEW_LINE DEDENT",
        "explain": "Function to find the minimum number of changes of lane required"
    },
    {
        "py": "val = barrier [ j ] NEW_LINE if ( val > 0 ) : NEW_LINE INDENT dp [ val - 1 ] = 1000000 NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE",
        "explain": "If there is a barrier , then add very large value"
    },
    {
        "py": "if ( val != i + 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , min ( dp [ ( i + 1 ) % 3 ] , dp [ ( i + 2 ) % 3 ] ) + 1 ) NEW_LINE DEDENT",
        "explain": "Add the minimum value to move forword with or without crossing barrier"
    },
    {
        "py": "return min ( dp [ 0 ] , min ( dp [ 1 ] , dp [ 2 ] ) ) NEW_LINE",
        "explain": "Return the minimum value of dp [ 0 ] , dp [ 1 ] and dp [ 2 ]"
    },
    {
        "py": "barrier = [ 0 , 1 , 2 , 3 , 0 ] NEW_LINE N = len ( barrier ) NEW_LINE print ( minChangeInLane ( barrier , N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def numWays ( ratings , queries , n , k ) : NEW_LINE",
        "explain": "Function to count number of ways to get given sum groups"
    },
    {
        "py": "dp = [ [ 0 for i in range ( 10002 ) ] for j in range ( n ) ] ; NEW_LINE",
        "explain": "Initialise dp array"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE INDENT dp [ 0 ] [ ratings [ 0 ] [ i ] ] += 1 ; NEW_LINE DEDENT",
        "explain": "Mark all 1 st row values as 1 since the mat [ 0 ] [ i ] is all possible sums in first row"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE",
        "explain": "Fix the ith row"
    },
    {
        "py": "for sum in range ( 10001 ) : NEW_LINE",
        "explain": "Fix the sum"
    },
    {
        "py": "for j in range ( k ) : NEW_LINE",
        "explain": "Iterate through all values of ith row"
    },
    {
        "py": "if ( sum >= ratings [ i ] [ j ] ) : NEW_LINE INDENT dp [ i ] [ sum ] += dp [ i - 1 ] [ sum - ratings [ i ] [ j ] ] ; NEW_LINE DEDENT",
        "explain": "If sum can be obtained"
    },
    {
        "py": "for sum in range ( 1 , 10001 ) : NEW_LINE INDENT dp [ n - 1 ] [ sum ] += dp [ n - 1 ] [ sum - 1 ] ; NEW_LINE DEDENT",
        "explain": "Find the prefix sum of last row"
    },
    {
        "py": "for q in range ( len ( queries ) ) : NEW_LINE INDENT a = queries [ q ] [ 0 ] ; NEW_LINE b = queries [ q ] [ 1 ] ; NEW_LINE DEDENT",
        "explain": "Traverse each query"
    },
    {
        "py": "print ( dp [ n - 1 ] [ b ] - dp [ n - 1 ] [ a - 1 ] , end = \" \u2581 \" ) ; NEW_LINE",
        "explain": "No of ways to form groups"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 2 ; NEW_LINE K = 3 ; NEW_LINE",
        "explain": "Given N batches and K students"
    },
    {
        "py": "ratings = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] ] ; NEW_LINE queries = [ [ 6 , 6 ] , [ 1 , 6 ] ] ; NEW_LINE",
        "explain": "Given ratings"
    },
    {
        "py": "numWays ( ratings , queries , N , K ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def numberOfPermWithKInversion ( N , K ) : NEW_LINE",
        "explain": "Function to count permutations with K inversions"
    },
    {
        "py": "dp = [ [ 0 ] * ( K + 1 ) ] * 2 NEW_LINE mod = 1000000007 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 0 , K + 1 ) : NEW_LINE DEDENT",
        "explain": "Store number of permutations with K inversions"
    },
    {
        "py": "if ( i == 1 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 if ( j == 0 ) else 0 NEW_LINE DEDENT",
        "explain": "If N = 1 only 1 permutation with no inversion"
    },
    {
        "py": "elif ( j == 0 ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 1 NEW_LINE DEDENT",
        "explain": "For K = 0 only 1 permutation with no inversion"
    },
    {
        "py": "else : NEW_LINE INDENT var = ( 0 if ( max ( j - ( i - 1 ) , 0 ) == 0 ) else dp [ 1 - i % 2 ] [ max ( j - ( i - 1 ) , 0 ) - 1 ] ) NEW_LINE dp [ i % 2 ] [ j ] = ( ( dp [ i % 2 ] [ j - 1 ] % mod + ( dp [ 1 - i % 2 ] [ j ] - ( var ) + mod ) % mod ) % mod ) NEW_LINE DEDENT",
        "explain": "Otherwise Update each dp state as per the reccurrance relation formed"
    },
    {
        "py": "print ( dp [ N % 2 ] [ K ] ) NEW_LINE",
        "explain": "Print final count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 3 NEW_LINE K = 2 NEW_LINE",
        "explain": "Given N and K"
    },
    {
        "py": "numberOfPermWithKInversion ( N , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def MaxProfit ( treasure , color , n , k , col , A , B ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT",
        "explain": "k is current index and col is previous color ."
    },
    {
        "py": "if k == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "if col == color [ k ] : NEW_LINE INDENT sum += max ( A * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT else : NEW_LINE INDENT sum += max ( B * treasure [ k ] + MaxProfit ( treasure , color , n , k + 1 , color [ k ] , A , B ) , MaxProfit ( treasure , color , n , k + 1 , col , A , B ) ) NEW_LINE DEDENT",
        "explain": "check if color of this city is equal to prev visited city"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "return max of both options"
    },
    {
        "py": "A = - 5 NEW_LINE B = 7 NEW_LINE treasure = [ 4 , 8 , 2 , 9 ] NEW_LINE color = [ 2 , 2 , 6 , 2 ] NEW_LINE n = len ( color ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( MaxProfit ( treasure , color , n , 0 , 0 , A , B ) ) NEW_LINE",
        "explain": "Initially begin with color 0"
    },
    {
        "py": "def printTetraRec ( n ) : NEW_LINE",
        "explain": "Function to return the N - th tetranacci number"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "base cases"
    },
    {
        "py": "if ( n == 1 or n == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT",
        "explain": "base cases"
    },
    {
        "py": "if ( n == 3 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( printTetraRec ( n - 1 ) + printTetraRec ( n - 2 ) + printTetraRec ( n - 3 ) + printTetraRec ( n - 4 ) ) ; NEW_LINE DEDENT",
        "explain": "base cases"
    },
    {
        "py": "def printTetra ( n ) : NEW_LINE INDENT print ( printTetraRec ( n ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "function to print the nth tetranacci number"
    },
    {
        "py": "n = 10 ; NEW_LINE printTetra ( n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def Combination ( a , combi , n , r , depth , index ) : NEW_LINE INDENT global Sum NEW_LINE DEDENT",
        "explain": "to store sum of every combination"
    },
    {
        "py": "if index == r : NEW_LINE",
        "explain": "if we have reached sufficient depth"
    },
    {
        "py": "product = 1 NEW_LINE for i in range ( r ) : NEW_LINE INDENT product = product * combi [ i ] NEW_LINE DEDENT",
        "explain": "find the product of combination"
    },
    {
        "py": "Sum += product NEW_LINE return NEW_LINE",
        "explain": "add the product into sum"
    },
    {
        "py": "for i in range ( depth , n ) : NEW_LINE INDENT combi [ index ] = a [ i ] NEW_LINE Combination ( a , combi , n , r , i + 1 , index + 1 ) NEW_LINE DEDENT",
        "explain": "recursion to produce different combination"
    },
    {
        "py": "def allCombination ( a , n ) : NEW_LINE INDENT global Sum NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE DEDENT",
        "explain": "function to print sum of products of all combination taken 1 - N at a time"
    },
    {
        "py": "combi = [ 0 ] * i NEW_LINE",
        "explain": "creating temporary array for storing combination"
    },
    {
        "py": "Combination ( a , combi , n , i , 0 , 0 ) NEW_LINE",
        "explain": "call combination with r = i for combination taken i at a time"
    },
    {
        "py": "print ( \" f ( \" , i , \" ) \u2581 - - > \u2581 \" , Sum ) NEW_LINE Sum = 0 NEW_LINE",
        "explain": "displaying sum"
    },
    {
        "py": "Sum = 0 NEW_LINE n = 5 NEW_LINE a = [ 0 ] * n NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT",
        "explain": "storing numbers from 1 - N in array"
    },
    {
        "py": "allCombination ( a , n ) NEW_LINE",
        "explain": "calling allCombination"
    },
    {
        "py": "def maxTasks ( high , low , n ) : NEW_LINE",
        "explain": "Returns maximum amount of task that can be done till day n"
    },
    {
        "py": "task_dp = [ 0 ] * ( n + 1 ) ; NEW_LINE",
        "explain": "An array task_dp that stores the maximum task done"
    },
    {
        "py": "task_dp [ 0 ] = 0 ; NEW_LINE",
        "explain": "If n = 0 , no solution exists"
    },
    {
        "py": "task_dp [ 1 ] = high [ 0 ] ; NEW_LINE",
        "explain": "If n = 1 , high effort task on that day will be the solution"
    },
    {
        "py": "for i in range ( 2 , n + 1 ) : NEW_LINE INDENT task_dp [ i ] = max ( high [ i - 1 ] + task_dp [ i - 2 ] , low [ i - 1 ] + task_dp [ i - 1 ] ) ; NEW_LINE DEDENT return task_dp [ n ] ; NEW_LINE",
        "explain": "Fill the entire array determining which task to choose on day i"
    },
    {
        "py": "n = 5 ; NEW_LINE high = [ 3 , 6 , 8 , 7 , 6 ] ; NEW_LINE low = [ 1 , 5 , 4 , 5 , 3 ] ; NEW_LINE print ( maxTasks ( high , low , n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = 10 NEW_LINE k = 2 NEW_LINE print ( \" Value \u2581 of \u2581 P ( \" , n , \" , \u2581 \" , k , \" ) \u2581 is \u2581 \" , permutationCoeff ( n , k ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findPartition ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i , j = 0 , 0 NEW_LINE DEDENT",
        "explain": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return false NEW_LINE DEDENT part = [ [ True for i in range ( n + 1 ) ] for j in range ( sum // 2 + 1 ) ] NEW_LINE",
        "explain": "calculate sum of all elements"
    },
    {
        "py": "for i in range ( 0 , n + 1 ) : NEW_LINE INDENT part [ 0 ] [ i ] = True NEW_LINE DEDENT",
        "explain": "initialize top row as true"
    },
    {
        "py": "for i in range ( 1 , sum // 2 + 1 ) : NEW_LINE INDENT part [ i ] [ 0 ] = False NEW_LINE DEDENT",
        "explain": "initialize leftmost column , except part [ 0 ] [ 0 ] , as 0"
    },
    {
        "py": "for i in range ( 1 , sum // 2 + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT part [ i ] [ j ] = part [ i ] [ j - 1 ] NEW_LINE if i >= arr [ j - 1 ] : NEW_LINE INDENT part [ i ] [ j ] = ( part [ i ] [ j ] or part [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "fill the partition table in bottom up manner"
    },
    {
        "py": "return part [ sum // 2 ] [ n ] NEW_LINE",
        "explain": "uncomment this part to print table"
    },
    {
        "py": "arr = [ 3 , 1 , 1 , 2 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "if findPartition ( arr , n ) == True : NEW_LINE INDENT print ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \" , \" subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 \" , \" two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def minimumOperations ( orig_str , m , n ) : NEW_LINE",
        "explain": "Function to find the minimum operations required to get the given string after appending m or n characters from the end to the front of the string in each operation"
    },
    {
        "py": "orig = orig_str NEW_LINE",
        "explain": "Store the original string"
    },
    {
        "py": "turn = 1 NEW_LINE j = 1 NEW_LINE",
        "explain": "Stores the count of operations"
    },
    {
        "py": "for i in orig_str : NEW_LINE",
        "explain": "Traverse the string"
    },
    {
        "py": "m_cut = orig_str [ - m : ] NEW_LINE orig_str = orig_str . replace ( ' \u2581 ' , ' ' ) [ : - m ] NEW_LINE",
        "explain": "Cut m letters from end"
    },
    {
        "py": "orig_str = m_cut + orig_str NEW_LINE",
        "explain": "Add cut m letters to beginning"
    },
    {
        "py": "j = j + 1 NEW_LINE",
        "explain": "Update j"
    },
    {
        "py": "if orig != orig_str : NEW_LINE INDENT turn = turn + 1 NEW_LINE DEDENT",
        "explain": "Check if strings are the same"
    },
    {
        "py": "n_cut = orig_str [ - n : ] NEW_LINE orig_str = orig_str . replace ( ' \u2581 ' , ' ' ) [ : - n ] NEW_LINE",
        "explain": "Cut n letters from end"
    },
    {
        "py": "orig_str = n_cut + orig_str NEW_LINE",
        "explain": "Add cut n letters to beginning"
    },
    {
        "py": "j = j + 1 NEW_LINE",
        "explain": "Update j"
    },
    {
        "py": "if orig == orig_str : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "Check if strings are the same"
    },
    {
        "py": "turn = turn + 1 NEW_LINE print ( turn ) NEW_LINE",
        "explain": "Update the turn"
    },
    {
        "py": "S = \" GeeksforGeeks \" NEW_LINE X = 5 NEW_LINE Y = 3 NEW_LINE",
        "explain": "Given string S"
    },
    {
        "py": "minimumOperations ( S , X , Y ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def KMPSearch ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE DEDENT",
        "explain": "Prints occurrences of txt [ ] in pat [ ]"
    },
    {
        "py": "lps = [ 0 ] * M NEW_LINE",
        "explain": "Create lps [ ] that will hold the longest prefix suffix values for pattern"
    },
    {
        "py": "computeLPSArray ( pat , M , lps ) NEW_LINE",
        "explain": "Preprocess the pattern ( calculate lps [ ] array )"
    },
    {
        "py": "i = 0 NEW_LINE j = 0 NEW_LINE while i < N : NEW_LINE INDENT if pat [ j ] == txt [ i ] : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT return i - j NEW_LINE j = lps [ j - 1 ] NEW_LINE DEDENT DEDENT",
        "explain": "Index for txt [ ] , index for pat [ ]"
    },
    {
        "py": "elif i < N and pat [ j ] != txt [ i ] : NEW_LINE",
        "explain": "Mismatch after j matches"
    },
    {
        "py": "if j != 0 : NEW_LINE INDENT j = lps [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT",
        "explain": "Do not match lps [ 0. . lps [ j - 1 ] ] characters , they will match anyway"
    },
    {
        "py": "def computeLPSArray ( pat , M , lps ) : NEW_LINE",
        "explain": "Fills lps [ ] for given pattern pat [ 0. . M - 1 ]"
    },
    {
        "py": "_len = 0 NEW_LINE",
        "explain": "Length of the previous longest prefix suffix"
    },
    {
        "py": "lps [ 0 ] = 0 NEW_LINE",
        "explain": "lps [ 0 ] is always 0"
    },
    {
        "py": "i = 1 NEW_LINE while i < M : NEW_LINE INDENT if pat [ i ] == pat [ _len ] : NEW_LINE INDENT _len += 1 NEW_LINE lps [ i ] = _len NEW_LINE i += 1 NEW_LINE DEDENT DEDENT",
        "explain": "The loop calculates lps [ i ] for i = 1 to M - 1"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "( pat [ i ] != pat [ _len ] )"
    },
    {
        "py": "if _len != 0 : NEW_LINE INDENT _len = lps [ _len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step ."
    },
    {
        "py": "def countRotations ( s ) : NEW_LINE",
        "explain": "Returns count of rotations to get the same string back"
    },
    {
        "py": "s1 = s [ 1 : len ( s ) ] + s NEW_LINE",
        "explain": "Form a string excluding the first character and concatenating the string at the end"
    },
    {
        "py": "pat = s [ : ] NEW_LINE text = s1 [ : ] NEW_LINE",
        "explain": "Convert the string to character array"
    },
    {
        "py": "return 1 + KMPSearch ( pat , text ) NEW_LINE",
        "explain": "Use the KMP search algorithm to find it in O ( N ) time"
    },
    {
        "py": "s1 = \" geeks \" NEW_LINE print ( countRotations ( s1 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def start ( c ) : NEW_LINE",
        "explain": "This function is for the starting state ( zeroth ) of DFA"
    },
    {
        "py": "if ( c == ' t ' or c == ' T ' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT",
        "explain": "On receiving ' T ' or ' t ' goto first state ( 1 )"
    },
    {
        "py": "def state1 ( c ) : NEW_LINE",
        "explain": "This function is for the first state of DFA"
    },
    {
        "py": "if ( c == ' t ' or c == ' T ' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT",
        "explain": "On receiving ' T ' or ' t ' goto first state ( 1 )"
    },
    {
        "py": "elif ( c == ' h ' or c == ' H ' ) : NEW_LINE INDENT dfa = 2 NEW_LINE DEDENT",
        "explain": "On receiving ' H ' or ' h ' goto second state ( 2 )"
    },
    {
        "py": "else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT",
        "explain": "else goto starting state ( 0 )"
    },
    {
        "py": "def state2 ( c ) : NEW_LINE",
        "explain": "This function is for the second state of DFA"
    },
    {
        "py": "if ( c == ' e ' or c == ' E ' ) : NEW_LINE INDENT dfa = 3 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT",
        "explain": "On receiving ' E ' or ' e ' goto third state ( 3 ) else goto starting state ( 0 )"
    },
    {
        "py": "def state3 ( c ) : NEW_LINE",
        "explain": "This function is for the third state of DFA"
    },
    {
        "py": "if ( c == ' t ' or c == ' T ' ) : NEW_LINE INDENT dfa = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dfa = 0 NEW_LINE DEDENT def isAccepted ( string ) : NEW_LINE",
        "explain": "On receiving ' T ' or ' t ' goto first state ( 1 ) else goto starting state ( 0 )"
    },
    {
        "py": "length = len ( string ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( dfa == 0 ) : NEW_LINE INDENT start ( string [ i ] ) NEW_LINE DEDENT elif ( dfa == 1 ) : NEW_LINE INDENT state1 ( string [ i ] ) NEW_LINE DEDENT elif ( dfa == 2 ) : NEW_LINE INDENT state2 ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT state3 ( string [ i ] ) NEW_LINE DEDENT DEDENT return ( dfa != 3 ) NEW_LINE",
        "explain": "store length of stringing"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" forTHEgeeks \" NEW_LINE DEDENT dfa = 0 NEW_LINE INDENT if isAccepted ( string ) : NEW_LINE INDENT print ( \" ACCEPTED \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NOT \u2581 ACCEPTED \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "parent = [ 0 ] * 256 NEW_LINE",
        "explain": "Python3 implementation of the above approach ."
    },
    {
        "py": "def find ( x ) : NEW_LINE INDENT if ( x != parent [ x ] ) : NEW_LINE INDENT parent [ x ] = find ( parent [ x ] ) NEW_LINE return parent [ x ] NEW_LINE DEDENT return x NEW_LINE DEDENT",
        "explain": "Function for find from Disjoset algorithm"
    },
    {
        "py": "def join ( x , y ) : NEW_LINE INDENT px = find ( x ) NEW_LINE pz = find ( y ) NEW_LINE if ( px != pz ) : NEW_LINE INDENT parent [ pz ] = px NEW_LINE DEDENT DEDENT",
        "explain": "Function for the union from Disjoset algorithm"
    },
    {
        "py": "def convertible ( s1 , s2 ) : NEW_LINE",
        "explain": "Function to check if one string can be converted to another ."
    },
    {
        "py": "mp = dict ( ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] in mp ) : NEW_LINE INDENT mp [ s1 [ i ] ] = s2 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT if s1 [ i ] in mp and mp [ s1 [ i ] ] != s2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "All the characters are checked whether it 's either not replaced or replaced  by a similar character using a map."
    },
    {
        "py": "for it in mp : NEW_LINE INDENT if ( it == mp [ it ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( find ( ord ( it ) ) == find ( ord ( it ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT join ( ord ( it ) , ord ( it ) ) NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE",
        "explain": "To check if there are cycles . If yes , then they are not convertible . Else , they are convertible ."
    },
    {
        "py": "def initialize ( ) : NEW_LINE INDENT for i in range ( 256 ) : NEW_LINE INDENT parent [ i ] = i NEW_LINE DEDENT DEDENT",
        "explain": "Function to initialize parent array for union and find algorithm ."
    },
    {
        "py": "s1 = \" abbcaa \" NEW_LINE s2 = \" bccdbb \" NEW_LINE initialize ( ) NEW_LINE if ( convertible ( s1 , s2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "SIZE = 26 NEW_LINE from math import sqrt NEW_LINE",
        "explain": "Python 3 implementation of the approach"
    },
    {
        "py": "def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE",
        "explain": "Function to create Sieve to check primes"
    },
    {
        "py": "prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( p_size ) ) , 1 ) : NEW_LINE",
        "explain": "false here indicates that it is not prime"
    },
    {
        "py": "if ( prime [ p ] ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , p_size , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT",
        "explain": "Update all multiples of p , set them to non - prime"
    },
    {
        "py": "def printChar ( str , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE DEDENT",
        "explain": "Function to print the prime frequency characters in the order of their occurrence"
    },
    {
        "py": "SieveOfEratosthenes ( prime , len ( str ) + 1 ) NEW_LINE",
        "explain": "Function to create Sieve to check primes"
    },
    {
        "py": "freq = [ 0 for i in range ( SIZE ) ] NEW_LINE",
        "explain": "To store the frequency of each of the character of the string"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Update the frequency of each character"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse str character by character"
    },
    {
        "py": "if ( prime [ freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] ] ) : NEW_LINE INDENT print ( str [ i ] , end = \" \" ) NEW_LINE DEDENT",
        "explain": "If frequency of current character is prime"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE n = len ( str ) NEW_LINE printChar ( str , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from collections import Counter NEW_LINE import math NEW_LINE",
        "explain": "Python code for the above approach"
    },
    {
        "py": "def prime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT max_div = math . floor ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , 1 + max_div ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def checkString ( s ) : NEW_LINE",
        "explain": "Function to check primes"
    },
    {
        "py": "freq = Counter ( s ) NEW_LINE",
        "explain": "Counting the frequency of all character using Counter function"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE INDENT if prime ( freq [ s [ i ] ] ) : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Traversing string"
    },
    {
        "py": "s = \" geeksforgeeks \" NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "checkString ( s ) NEW_LINE",
        "explain": "passing string to checkString function"
    },
    {
        "py": "SIZE = 26 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def printChar ( string , n ) : NEW_LINE",
        "explain": "Function to print the even frequency characters in the order of their occurrence"
    },
    {
        "py": "freq = [ 0 ] * SIZE NEW_LINE",
        "explain": "To store the frequency of each of the character of the stringing Initialize all elements of freq [ ] to 0"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Update the frequency of each character"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Traverse string character by character"
    },
    {
        "py": "if ( freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT print ( string [ i ] , end = \" \" ) NEW_LINE DEDENT",
        "explain": "If frequency of current character is even"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = \" geeksforgeeks \" NEW_LINE n = len ( string ) NEW_LINE printChar ( string , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def CompareAlphanumeric ( str1 , str2 ) : NEW_LINE",
        "explain": "Function to check alphanumeric equality of both strings"
    },
    {
        "py": "i = 0 NEW_LINE j = 0 NEW_LINE",
        "explain": "variable declaration"
    },
    {
        "py": "len1 = len ( str1 ) NEW_LINE",
        "explain": "Length of first string"
    },
    {
        "py": "len2 = len ( str2 ) NEW_LINE",
        "explain": "Length of second string"
    },
    {
        "py": "while ( i <= len1 and j <= len2 ) : NEW_LINE",
        "explain": "To check each and every character of both string"
    },
    {
        "py": "while ( i < len1 and ( ( ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) or ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) or ( str1 [ i ] >= '0' and str1 [ i ] <= '9' ) ) == False ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "If the current character of the first string is not an alphanumeric character , increase the pointer i"
    },
    {
        "py": "while ( j < len2 and ( ( ( str2 [ j ] >= ' a ' and str2 [ j ] <= ' z ' ) or ( str2 [ j ] >= ' A ' and str2 [ j ] <= ' Z ' ) or ( str2 [ j ] >= '0' and str2 [ j ] <= '9' ) ) == False ) ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT",
        "explain": "If the current character of the second string is not an alphanumeric character , increase the pointer j"
    },
    {
        "py": "if ( i == len1 and j == len2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "if all alphanumeric characters of both strings are same , then return true"
    },
    {
        "py": "elif ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "if any alphanumeric characters of both strings are not same , then return false"
    },
    {
        "py": "else : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "If current character matched , increase both pointers to check the next character"
    },
    {
        "py": "return False NEW_LINE",
        "explain": "If not same , then return false"
    },
    {
        "py": "def CompareAlphanumericUtil ( str1 , str2 ) : NEW_LINE",
        "explain": "Function to print Equal or Unequal if strings are same or not"
    },
    {
        "py": "res = CompareAlphanumeric ( str1 , str2 ) NEW_LINE",
        "explain": "check alphanumeric equality of both strings"
    },
    {
        "py": "if ( res == True ) : NEW_LINE INDENT print ( \" Equal \" ) NEW_LINE DEDENT",
        "explain": "if both are alphanumeric equal , print Equal"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Unequal \" ) NEW_LINE DEDENT",
        "explain": "otherwise print Unequal"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" Ram , \u2581 Shyam \" NEW_LINE str2 = \" \u2581 Ram \u2581 - \u2581 Shyam . \" NEW_LINE CompareAlphanumericUtil ( str1 , str2 ) NEW_LINE str1 = \" abc123\" NEW_LINE str2 = \"123abc \" NEW_LINE CompareAlphanumericUtil ( str1 , str2 ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def solveQueries ( Str , query ) : NEW_LINE",
        "explain": "Function that answers all the queries"
    },
    {
        "py": "ll = len ( Str ) NEW_LINE",
        "explain": "Length of the String"
    },
    {
        "py": "Q = len ( query ) NEW_LINE",
        "explain": "Number of queries"
    },
    {
        "py": "pre = [ [ 0 for i in range ( 256 ) ] for i in range ( ll ) ] NEW_LINE",
        "explain": "Prefix array"
    },
    {
        "py": "for i in range ( ll ) : NEW_LINE",
        "explain": "Iterate for all the characters"
    },
    {
        "py": "pre [ i ] [ ord ( Str [ i ] ) ] += 1 NEW_LINE",
        "explain": "Increase the count of the character"
    },
    {
        "py": "if ( i ) : NEW_LINE",
        "explain": "Presum array for all 26 characters"
    },
    {
        "py": "for j in range ( 256 ) : NEW_LINE INDENT pre [ i ] [ j ] += pre [ i - 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "Update the prefix array"
    },
    {
        "py": "for i in range ( Q ) : NEW_LINE",
        "explain": "Answer every query"
    },
    {
        "py": "l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE maxi = 0 NEW_LINE c = ' a ' NEW_LINE",
        "explain": "Range"
    },
    {
        "py": "for j in range ( 256 ) : NEW_LINE",
        "explain": "Iterate for all characters"
    },
    {
        "py": "times = pre [ r ] [ j ] NEW_LINE",
        "explain": "Times the lowercase character j occurs till r - th index"
    },
    {
        "py": "if ( l ) : NEW_LINE INDENT times -= pre [ l - 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "Subtract the times it occurred till ( l - 1 ) th index"
    },
    {
        "py": "if ( times > maxi ) : NEW_LINE INDENT maxi = times NEW_LINE c = chr ( j ) NEW_LINE DEDENT",
        "explain": "Max times it occurs"
    },
    {
        "py": "print ( \" Query \u2581 \" , i + 1 , \" : \u2581 \" , c ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "Str = \" striver \" NEW_LINE query = [ [ 0 , 1 ] , [ 1 , 6 ] , [ 5 , 6 ] ] NEW_LINE solveQueries ( Str , query ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def startsWith ( str , pre ) : NEW_LINE INDENT strLen = len ( str ) NEW_LINE preLen = len ( pre ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE DEDENT",
        "explain": "Function that return true if pre is a prefix of str"
    },
    {
        "py": "while ( i < strLen and j < preLen ) : NEW_LINE",
        "explain": "While there are characters to match"
    },
    {
        "py": "if ( str [ i ] != pre [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE",
        "explain": "If characters differ at any position"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "str starts with pre"
    },
    {
        "py": "def endsWith ( str , suff ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE j = len ( suff ) - 1 NEW_LINE DEDENT",
        "explain": "Function that return true if suff is a suffix of str"
    },
    {
        "py": "while ( i >= 0 and j >= 0 ) : NEW_LINE",
        "explain": "While there are characters to match"
    },
    {
        "py": "if ( str [ i ] != suff [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i -= 1 NEW_LINE j -= 1 NEW_LINE",
        "explain": "If characters differ at any position"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "str ends with suff"
    },
    {
        "py": "def checkString ( str , a , b ) : NEW_LINE",
        "explain": "Function that returns true if str = a + b or str = b + a"
    },
    {
        "py": "if ( len ( str ) != len ( a ) + len ( b ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "str cannot be generated by concatenating a and b"
    },
    {
        "py": "if ( startsWith ( str , a ) ) : NEW_LINE",
        "explain": "If str starts with a i . e . a is a prefix of str"
    },
    {
        "py": "if ( endsWith ( str , b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Check if the rest of the characters are equal to b i . e . b is a suffix of str"
    },
    {
        "py": "if ( startsWith ( str , b ) ) : NEW_LINE",
        "explain": "If str starts with b i . e . b is a prefix of str"
    },
    {
        "py": "if ( endsWith ( str , a ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "Check if the rest of the characters are equal to a i . e . a is a suffix of str"
    },
    {
        "py": "str = \" GeeksforGeeks \" NEW_LINE a = \" Geeksfo \" NEW_LINE b = \" rGeeks \" NEW_LINE if ( checkString ( str , a , b ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE import math NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def printChar ( str_ , n ) : NEW_LINE",
        "explain": "Function to print the odd frequency characters in the order of their occurrence"
    },
    {
        "py": "freq = [ 0 ] * 26 NEW_LINE",
        "explain": "To store the frequency of each of the character of the string and Initialize all elements of freq [ ] to 0"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Update the frequency of each character"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse str character by character"
    },
    {
        "py": "if ( freq [ ord ( str_ [ i ] ) - ord ( ' a ' ) ] ) % 2 == 1 : NEW_LINE INDENT print ( \" { } \" . format ( str_ [ i ] ) , end = \" \" ) NEW_LINE DEDENT",
        "explain": "If frequency of current character is odd"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str_ = \" geeksforgeeks \" NEW_LINE n = len ( str_ ) NEW_LINE printChar ( str_ , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minOperations ( str , n ) : NEW_LINE",
        "explain": "Function to return the minimum number of operations required"
    },
    {
        "py": "lastUpper = - 1 NEW_LINE firstLower = - 1 NEW_LINE",
        "explain": "To store the indices of the last uppercase and the first lowercase character"
    },
    {
        "py": "for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT lastUpper = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Find the last uppercase character"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT firstLower = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Find the first lowercase character"
    },
    {
        "py": "if ( lastUpper == - 1 or firstLower == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If all the characters are either uppercase or lowercase"
    },
    {
        "py": "countUpper = 0 NEW_LINE for i in range ( firstLower , n ) : NEW_LINE INDENT if ( str [ i ] . isupper ( ) ) : NEW_LINE INDENT countUpper += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count of uppercase characters that appear after the first lowercase character"
    },
    {
        "py": "countLower = 0 NEW_LINE for i in range ( lastUpper ) : NEW_LINE INDENT if ( str [ i ] . islower ( ) ) : NEW_LINE INDENT countLower += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count of lowercase characters that appear before the last uppercase character"
    },
    {
        "py": "return min ( countLower , countUpper ) NEW_LINE",
        "explain": "Return the minimum operations required"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geEksFOrGEekS \" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find the Sum of the all Betrothed numbers up to N"
    },
    {
        "py": "def Betrothed_Sum ( n ) : NEW_LINE",
        "explain": "Function to find the Sum of the all Betrothed numbers"
    },
    {
        "py": "Set = [ ] NEW_LINE for number_1 in range ( 1 , n ) : NEW_LINE",
        "explain": "To store the Betrothed numbers"
    },
    {
        "py": "sum_divisor_1 = 1 NEW_LINE",
        "explain": "Calculate sum of number_1 's divisors"
    },
    {
        "py": "i = 2 NEW_LINE while i * i <= number_1 : NEW_LINE INDENT if ( number_1 % i == 0 ) : NEW_LINE INDENT sum_divisor_1 = sum_divisor_1 + i NEW_LINE if ( i * i != number_1 ) : NEW_LINE INDENT sum_divisor_1 += number_1 // i NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT if ( sum_divisor_1 > number_1 ) : NEW_LINE INDENT number_2 = sum_divisor_1 - 1 NEW_LINE sum_divisor_2 = 1 NEW_LINE j = 2 NEW_LINE while j * j <= number_2 : NEW_LINE INDENT if ( number_2 % j == 0 ) : NEW_LINE INDENT sum_divisor_2 += j NEW_LINE if ( j * j != number_2 ) : NEW_LINE INDENT sum_divisor_2 += number_2 // j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT if ( sum_divisor_2 == number_1 + 1 and number_1 <= n and number_2 <= n ) : NEW_LINE INDENT Set . append ( number_1 ) NEW_LINE Set . append ( number_2 ) NEW_LINE DEDENT DEDENT",
        "explain": "i = 2 because we don 't  want to include  1 as a divisor."
    },
    {
        "py": "Summ = 0 NEW_LINE for i in Set : NEW_LINE INDENT if i <= n : NEW_LINE INDENT Summ += i NEW_LINE DEDENT DEDENT return Summ NEW_LINE",
        "explain": "Sum all Betrothed numbers up to N"
    },
    {
        "py": "n = 78 NEW_LINE print ( Betrothed_Sum ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def rainDayProbability ( a , n ) : NEW_LINE",
        "explain": "Function to find the probability"
    },
    {
        "py": "count = a . count ( 1 ) NEW_LINE",
        "explain": "count occurence of 1"
    },
    {
        "py": "m = count / n NEW_LINE return m NEW_LINE",
        "explain": "find probability"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( rainDayProbability ( a , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Series ( n ) : NEW_LINE INDENT sums = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ser = 1 / ( i ** i ) NEW_LINE sums += ser NEW_LINE DEDENT return sums NEW_LINE DEDENT",
        "explain": "Function to calculate the following series"
    },
    {
        "py": "n = 3 NEW_LINE res = round ( Series ( n ) , 5 ) NEW_LINE print ( res ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def lexicographicallyMaximum ( S , N ) : NEW_LINE",
        "explain": "Function to print the lexicographically the largest string obtained in process of obtaining a string containing first N lower case english alphabtes"
    },
    {
        "py": "M = { } NEW_LINE",
        "explain": "Store the frequency of each character"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if S [ i ] in M : NEW_LINE M [ S [ i ] ] += 1 NEW_LINE else : NEW_LINE INDENT M [ S [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the string S"
    },
    {
        "py": "V = [ ] NEW_LINE for i in range ( ord ( ' a ' ) , ord ( ' a ' ) + min ( N , 25 ) ) : NEW_LINE INDENT if i not in M : NEW_LINE INDENT V . append ( chr ( i ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Stores the characters which are not appearing in S"
    },
    {
        "py": "j = len ( V ) - 1 NEW_LINE",
        "explain": "Stores the index of the largest character in the array V , that need to be replaced"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the string , S"
    },
    {
        "py": "if ( ord ( S [ i ] ) >= ( ord ( ' a ' ) + min ( N , 25 ) ) or ( S [ i ] in M and M [ S [ i ] ] > 1 ) ) : NEW_LINE INDENT if ( ord ( V [ j ] ) < ord ( S [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT",
        "explain": "If frequency of S [ i ] is greater than 1 or it is outside the range"
    },
    {
        "py": "M [ S [ i ] ] -= 1 NEW_LINE",
        "explain": "Decrement its frequency by 1"
    },
    {
        "py": "S = S [ 0 : i ] + V [ j ] + S [ ( i + 1 ) : ] NEW_LINE",
        "explain": "Update S [ i ]"
    },
    {
        "py": "j -= 1 NEW_LINE if ( j < 0 ) : NEW_LINE break NEW_LINE l = 0 NEW_LINE",
        "explain": "Decrement j by 1"
    },
    {
        "py": "for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( l > j ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( ord ( S [ i ] ) >= ( ord ( ' a ' ) + min ( N , 25 ) ) or S [ i ] in M and M [ S [ i ] ] > 1 ) : NEW_LINE DEDENT",
        "explain": "Traverse the string , S"
    },
    {
        "py": "M [ S [ i ] ] -= 1 NEW_LINE",
        "explain": "Decrement its frequency by 1"
    },
    {
        "py": "S = S [ 0 : i ] + V [ l ] + S [ ( i + 1 ) : ] NEW_LINE",
        "explain": "Update S [ i ]"
    },
    {
        "py": "l += 1 NEW_LINE s = list ( S ) NEW_LINE s [ len ( s ) - 1 ] = ' d ' NEW_LINE S = \" \" . join ( s ) NEW_LINE",
        "explain": "Increment l by 1"
    },
    {
        "py": "return S NEW_LINE",
        "explain": "Return S"
    },
    {
        "py": "S = \" abccefghh \" NEW_LINE N = len ( S ) NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( lexicographicallyMaximum ( S , N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def isConsistingSubarrayUtil ( arr , n ) : NEW_LINE",
        "explain": "A Utility Function to check if a subarray can be palindromic by replacing less than half of the elements present in it"
    },
    {
        "py": "mp = { } ; NEW_LINE",
        "explain": "Stores frequency of array elements"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT",
        "explain": "Update frequency of each array element"
    },
    {
        "py": "for it in mp : NEW_LINE",
        "explain": "Iterator over the Map"
    },
    {
        "py": "if ( mp [ it ] > 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT",
        "explain": "If frequency of any element exceeds 1"
    },
    {
        "py": "return False ; NEW_LINE",
        "explain": "If no repetition is found"
    },
    {
        "py": "def isConsistingSubarray ( arr , N ) : NEW_LINE INDENT if ( isConsistingSubarrayUtil ( arr , N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to check and print if any subarray can be made palindromic by replacing less than half of its elements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 , 1 ] ; NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "N = len ( arr ) ; NEW_LINE",
        "explain": "Size of array"
    },
    {
        "py": "isConsistingSubarray ( arr , N ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def createhashmap ( Max ) : NEW_LINE",
        "explain": "Function to find all Fibonacci numbers up to Max"
    },
    {
        "py": "hashmap = { \" \" } NEW_LINE",
        "explain": "Store all Fibonacci numbers upto Max"
    },
    {
        "py": "curr = 1 NEW_LINE",
        "explain": "Stores previous element of Fibonacci sequence"
    },
    {
        "py": "prev = 0 NEW_LINE",
        "explain": "Stores previous element of Fibonacci sequence"
    },
    {
        "py": "hashmap . add ( prev ) NEW_LINE",
        "explain": "Insert prev into hashmap"
    },
    {
        "py": "while ( curr <= Max ) : NEW_LINE",
        "explain": "Insert all the Fibonacci numbers up to Max"
    },
    {
        "py": "hashmap . add ( curr ) NEW_LINE",
        "explain": "Insert curr into hashmap"
    },
    {
        "py": "temp = curr NEW_LINE",
        "explain": "Stores curr into temp"
    },
    {
        "py": "curr = curr + prev NEW_LINE",
        "explain": "Update curr"
    },
    {
        "py": "prev = temp NEW_LINE return hashmap NEW_LINE",
        "explain": "Update prev"
    },
    {
        "py": "def SieveOfEratosthenes ( Max ) : NEW_LINE",
        "explain": "Function to find all Composite numbers up to Max"
    },
    {
        "py": "isPrime = [ 1 for x in range ( Max + 1 ) ] NEW_LINE isPrime [ 0 ] = 0 NEW_LINE isPrime [ 1 ] = 0 NEW_LINE",
        "explain": "isPrime [ i ] : Stores if i is a prime number or not"
    },
    {
        "py": "for p in range ( 0 , int ( math . sqrt ( Max ) ) ) : NEW_LINE",
        "explain": "Calculate all prime numbers up to Max using Sieve of Eratosthenes"
    },
    {
        "py": "if ( isPrime [ p ] ) : NEW_LINE",
        "explain": "If P is a prime number"
    },
    {
        "py": "for i in range ( 2 * p , Max , p ) : NEW_LINE INDENT isPrime [ i ] = 0 NEW_LINE DEDENT return isPrime NEW_LINE",
        "explain": "Set all multiple of P as non - prime"
    },
    {
        "py": "def cntFibonacciPrime ( arr , N ) : NEW_LINE",
        "explain": "Function to find the numbers which is both a composite and Fibonacci number"
    },
    {
        "py": "Max = arr [ 0 ] NEW_LINE",
        "explain": "Stores the largest element of the array"
    },
    {
        "py": "for i in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "Max = max ( Max , arr [ i ] ) NEW_LINE",
        "explain": "Update Max"
    },
    {
        "py": "isPrime = SieveOfEratosthenes ( Max ) NEW_LINE",
        "explain": "isPrim [ i ] check i is a prime number or not"
    },
    {
        "py": "hashmap = createhashmap ( Max ) NEW_LINE",
        "explain": "Stores all the Fibonacci numbers"
    },
    {
        "py": "for i in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if arr [ i ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Current element is not a composite number"
    },
    {
        "py": "if ( ( arr [ i ] in hashmap ) and ( not ( isPrime [ arr [ i ] ] ) ) ) : NEW_LINE",
        "explain": "If current element is a Fibonacci and composite number"
    },
    {
        "py": "print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print current element"
    },
    {
        "py": "arr = [ 13 , 55 , 7 , 3 , 5 , 21 , 233 , 144 , 89 ] NEW_LINE N = len ( arr ) NEW_LINE cntFibonacciPrime ( arr , N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program of the above approach"
    },
    {
        "py": "def key ( N ) : NEW_LINE",
        "explain": "Function to find the key of the given number"
    },
    {
        "py": "num = \" \" + str ( N ) NEW_LINE ans = 0 NEW_LINE j = 0 NEW_LINE",
        "explain": "Convert the integer to String"
    },
    {
        "py": "while j < len ( num ) : NEW_LINE",
        "explain": "Iterate the num - string to get the result"
    },
    {
        "py": "if ( ( ord ( num [ j ] ) - 48 ) % 2 == 0 ) : NEW_LINE INDENT add = 0 NEW_LINE DEDENT",
        "explain": "Check if digit is even or odd"
    },
    {
        "py": "i = j NEW_LINE while j < len ( num ) : NEW_LINE INDENT add += ord ( num [ j ] ) - 48 NEW_LINE DEDENT",
        "explain": "Iterate until odd sum is obtained by adding consecutive digits"
    },
    {
        "py": "if ( add % 2 == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE if ( add == 0 ) : NEW_LINE ans *= 10 NEW_LINE else : NEW_LINE digit = int ( math . floor ( math . log10 ( add ) + 1 ) ) NEW_LINE ans *= ( pow ( 10 , digit ) ) NEW_LINE",
        "explain": "Check if sum becomes odd"
    },
    {
        "py": "ans += add NEW_LINE",
        "explain": "Add the result in ans"
    },
    {
        "py": "i = j NEW_LINE else : NEW_LINE",
        "explain": "Assign the digit index to num string"
    },
    {
        "py": "add = 0 NEW_LINE",
        "explain": "If the number is odd"
    },
    {
        "py": "i = j NEW_LINE while j < len ( num ) : NEW_LINE INDENT add += ord ( num [ j ] ) - 48 NEW_LINE DEDENT",
        "explain": "Iterate until odd sum is obtained by adding consecutive digits"
    },
    {
        "py": "if ( add % 2 == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE if ( add == 0 ) : NEW_LINE ans *= 10 NEW_LINE else : NEW_LINE digit = int ( math . floor ( math . log10 ( add ) + 1 ) ) NEW_LINE ans *= ( pow ( 10 , digit ) ) NEW_LINE",
        "explain": "Check if sum becomes even"
    },
    {
        "py": "ans += add NEW_LINE",
        "explain": "Add the result in ans"
    },
    {
        "py": "i = j NEW_LINE j += 1 NEW_LINE",
        "explain": "assign the digit index to main numstring"
    },
    {
        "py": "if ( j + 1 ) >= len ( num ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT ans += ord ( num [ len ( num ) - 1 ] ) - 48 NEW_LINE return ans NEW_LINE DEDENT",
        "explain": "Check if all digits are visited or not"
    },
    {
        "py": "def sentinelSearch ( arr , n , key ) : NEW_LINE",
        "explain": "Python3 implementation of the approach Function to search key in the given array"
    },
    {
        "py": "def sentinelSearch ( arr , n , key ) : NEW_LINE",
        "explain": "Function to search x in the given array"
    },
    {
        "py": "last = arr [ n - 1 ] NEW_LINE",
        "explain": "Last element of the array"
    },
    {
        "py": "arr [ n - 1 ] = key NEW_LINE i = 0 NEW_LINE while ( arr [ i ] != key ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "Element to be searched is placed at the last index"
    },
    {
        "py": "arr [ n - 1 ] = last NEW_LINE if ( ( i < n - 1 ) or ( arr [ n - 1 ] == key ) ) : NEW_LINE INDENT print ( key , \" is \u2581 present \u2581 at \u2581 index \" , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element \u2581 Not \u2581 found \" ) NEW_LINE DEDENT",
        "explain": "Put the last element back"
    },
    {
        "py": "arr = [ 10 , 20 , 180 , 30 , 60 , 50 , 110 , 100 , 70 ] NEW_LINE n = len ( arr ) NEW_LINE key = 180 NEW_LINE sentinelSearch ( arr , n , key ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def maximum_middle_value ( n , k , arr ) : NEW_LINE",
        "explain": "Function to calculate maximum possible middle value of the array after deleting exactly k elements"
    },
    {
        "py": "ans = - 1 NEW_LINE",
        "explain": "Initialize answer as - 1"
    },
    {
        "py": "low = ( n + 1 - k ) // 2 NEW_LINE high = ( n + 1 - k ) // 2 + k NEW_LINE",
        "explain": "Calculate range of elements that can give maximum possible middle value of the array since index of maximum possible middle value after deleting exactly k elements from array will lie in between low and high"
    },
    {
        "py": "for i in range ( low , high + 1 ) : NEW_LINE",
        "explain": "Find maximum element of the array in range low and high"
    },
    {
        "py": "ans = max ( ans , arr [ i - 1 ] ) NEW_LINE",
        "explain": "since indexing is 1 based so check element at index i - 1"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the maximum possible middle value of the array after deleting exactly k elements from the array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE arr = [ 9 , 5 , 3 , 7 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr ) ) NEW_LINE n , k = 9 , 3 NEW_LINE arr1 = [ 2 , 4 , 3 , 9 , 5 , 8 , 7 , 6 , 10 ] NEW_LINE print ( maximum_middle_value ( n , k , arr1 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 program to illustrate recursive approach to ternary search"
    },
    {
        "py": "def ternarySearch ( l , r , key , ar ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE DEDENT",
        "explain": "Function to perform Ternary Search"
    },
    {
        "py": "mid1 = l + ( r - l ) // 3 NEW_LINE mid2 = r - ( r - l ) // 3 NEW_LINE",
        "explain": "Find the mid1 and mid2"
    },
    {
        "py": "if ( ar [ mid1 ] == key ) : NEW_LINE INDENT return mid1 NEW_LINE DEDENT if ( ar [ mid2 ] == key ) : NEW_LINE INDENT return mid2 NEW_LINE DEDENT",
        "explain": "Check if key is present at any mid"
    },
    {
        "py": "if ( key < ar [ mid1 ] ) : NEW_LINE",
        "explain": "Since key is not present at mid , check in which region it is present then repeat the Search operation in that region"
    },
    {
        "py": "return ternarySearch ( l , mid1 - 1 , key , ar ) NEW_LINE elif ( key > ar [ mid2 ] ) : NEW_LINE",
        "explain": "The key lies in between l and mid1"
    },
    {
        "py": "return ternarySearch ( mid2 + 1 , r , key , ar ) NEW_LINE else : NEW_LINE",
        "explain": "The key lies in between mid2 and r"
    },
    {
        "py": "return ternarySearch ( mid1 + 1 , mid2 - 1 , key , ar ) NEW_LINE",
        "explain": "The key lies in between mid1 and mid2"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "Key not found"
    },
    {
        "py": "l , r , p = 0 , 9 , 5 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE",
        "explain": "Get the array Sort the array if not sorted"
    },
    {
        "py": "l = 0 NEW_LINE",
        "explain": "Starting index"
    },
    {
        "py": "r = 9 NEW_LINE",
        "explain": "length of array"
    },
    {
        "py": "key = 5 NEW_LINE",
        "explain": "Key to be searched in the array"
    },
    {
        "py": "p = ternarySearch ( l , r , key , ar ) NEW_LINE",
        "explain": "Search the key using ternarySearch"
    },
    {
        "py": "print ( \" Index \u2581 of \" , key , \" is \" , p ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "key = 50 NEW_LINE",
        "explain": "Key to be searched in the array"
    },
    {
        "py": "p = ternarySearch ( l , r , key , ar ) NEW_LINE",
        "explain": "Search the key using ternarySearch"
    },
    {
        "py": "print ( \" Index \u2581 of \" , key , \" is \" , p ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "def findmin ( p , n ) : NEW_LINE INDENT a , b , c , d = 0 , 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "Function to find the minimum number of points"
    },
    {
        "py": "if ( p [ i ] [ 0 ] <= 0 ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT",
        "explain": "Number of points on the left of Y - axis ."
    },
    {
        "py": "elif ( p [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT",
        "explain": "Number of points on the right of Y - axis ."
    },
    {
        "py": "if ( p [ i ] [ 1 ] >= 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT",
        "explain": "Number of points above X - axis ."
    },
    {
        "py": "elif ( p [ i ] [ 1 ] <= 0 ) : NEW_LINE INDENT d += 1 NEW_LINE DEDENT return min ( [ a , b , c , d ] ) NEW_LINE",
        "explain": "Number of points below X - axis ."
    },
    {
        "py": "p = [ [ 1 , 1 ] , [ 2 , 2 ] , [ - 1 , - 1 ] , [ - 2 , 2 ] ] NEW_LINE n = len ( p ) NEW_LINE print ( findmin ( p , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def maxOps ( a , b , c ) : NEW_LINE",
        "explain": "Function to count the maximum number of pair reductions possible on a given triplet"
    },
    {
        "py": "INDENT arr = [ a , b , c ] NEW_LINE DEDENT",
        "explain": "Convert them into an array"
    },
    {
        "py": "INDENT count = 0 NEW_LINE while True : NEW_LINE DEDENT",
        "explain": "Stores count of operations"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "if not arr [ 0 ] and not arr [ 1 ] : NEW_LINE break NEW_LINE",
        "explain": "If the first two array elements reduce to 0"
    },
    {
        "py": "arr [ 1 ] -= 1 NEW_LINE arr [ 2 ] -= 1 NEW_LINE",
        "explain": "Apply the operations"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "INDENT print ( count ) NEW_LINE DEDENT",
        "explain": "Print the maximum count"
    },
    {
        "py": "a , b , c = 4 , 3 , 2 NEW_LINE maxOps ( a , b , c ) NEW_LINE",
        "explain": "Given triplet"
    },
    {
        "py": "MAX = 26 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def getSortedString ( s , n ) : NEW_LINE",
        "explain": "Function to return the sorted string"
    },
    {
        "py": "lower = [ 0 ] * MAX ; NEW_LINE upper = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store the frequencies of the lowercase and the uppercase characters in the given string"
    },
    {
        "py": "if ( s [ i ] . islower ( ) ) : NEW_LINE INDENT lower [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT",
        "explain": "If current character is lowercase then increment its frequency in the lower [ ] array"
    },
    {
        "py": "elif ( s [ i ] . isupper ( ) ) : NEW_LINE INDENT upper [ ord ( s [ i ] ) - ord ( ' A ' ) ] += 1 ; NEW_LINE DEDENT",
        "explain": "Else increment in the upper [ ] array"
    },
    {
        "py": "i = 0 ; j = 0 ; NEW_LINE while ( i < MAX and lower [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT while ( j < MAX and upper [ j ] == 0 ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT",
        "explain": "Pointers that point to the smallest lowercase and the smallest uppercase characters respectively in the given string"
    },
    {
        "py": "for k in range ( n ) : NEW_LINE",
        "explain": "For every character in the given string"
    },
    {
        "py": "if ( s [ k ] . islower ( ) ) : NEW_LINE INDENT while ( lower [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT s [ k ] = chr ( i + ord ( ' a ' ) ) ; NEW_LINE DEDENT",
        "explain": "If the current character is lowercase then replace it with the smallest lowercase character available"
    },
    {
        "py": "lower [ i ] -= 1 ; NEW_LINE",
        "explain": "Decrement the frequency of the used character"
    },
    {
        "py": "elif ( s [ k ] . isupper ( ) ) : NEW_LINE INDENT while ( upper [ j ] == 0 ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT s [ k ] = chr ( j + ord ( ' A ' ) ) ; NEW_LINE DEDENT",
        "explain": "Else replace it with the smallest uppercase character available"
    },
    {
        "py": "upper [ j ] -= 1 ; NEW_LINE",
        "explain": "Decrement the frequency of the used character"
    },
    {
        "py": "return \" \" . join ( s ) ; NEW_LINE",
        "explain": "Return the sorted string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" gEeksfOrgEEkS \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( getSortedString ( list ( s ) , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import numpy as np NEW_LINE",
        "explain": "Python3 implementation to pr the character and its frequency in order of its occurrence"
    },
    {
        "py": "def prCharWithFreq ( str ) : NEW_LINE",
        "explain": "Function to print the character and its frequency in order of its occurrence"
    },
    {
        "py": "' NEW_LINE INDENT n = len ( str ) NEW_LINE DEDENT",
        "explain": "Size of the 'str"
    },
    {
        "py": "freq = np . zeros ( 26 , dtype = np . int ) NEW_LINE",
        "explain": "Initialize all elements of freq [ ] to 0"
    },
    {
        "py": "' NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Accumulate frequency of each character in 'str"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Traverse ' str ' from left to right"
    },
    {
        "py": "if ( freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] != 0 ) : NEW_LINE",
        "explain": "if frequency of character str [ i ] is not equal to 0"
    },
    {
        "py": "print ( str [ i ] , freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] , end = \" \u2581 \" ) NEW_LINE",
        "explain": "print the character along with its frequency"
    },
    {
        "py": "freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] = 0 NEW_LINE",
        "explain": "Update frequency of str [ i ] to 0 so that the same character is not printed again"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE prCharWithFreq ( str ) ; NEW_LINE DEDENT ' NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "s = \" i \u2581 like \u2581 this \u2581 program \u2581 very \u2581 much \" NEW_LINE words = s . split ( ' \u2581 ' ) NEW_LINE string = [ ] NEW_LINE for word in words : NEW_LINE INDENT string . insert ( 0 , word ) NEW_LINE DEDENT print ( \" Reversed \u2581 String : \" ) NEW_LINE print ( \" \u2581 \" . join ( string ) ) NEW_LINE",
        "explain": "Python3 program to reverse a string s = input ( )"
    },
    {
        "py": "def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE DEDENT",
        "explain": "Function to generate prime numbers using Sieve of Eratosthenes"
    },
    {
        "py": "if ( prime [ p ] == True ) : NEW_LINE",
        "explain": "If prime [ p ] is unchanged , then it is a prime"
    },
    {
        "py": "i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "def segregatePrimeNonPrime ( prime , arr , N ) : NEW_LINE",
        "explain": "Function to segregate the primes and non - primes"
    },
    {
        "py": "SieveOfEratosthenes ( prime , 10000000 ) NEW_LINE",
        "explain": "Generate all primes till 10 ^ 7"
    },
    {
        "py": "left , right = 0 , N - 1 NEW_LINE",
        "explain": "Initialize left and right"
    },
    {
        "py": "while ( left < right ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "while ( prime [ arr [ left ] ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT",
        "explain": "Increment left while array element at left is prime"
    },
    {
        "py": "while ( not prime [ arr [ right ] ] ) : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT",
        "explain": "Decrement right while array element at right is non - prime"
    },
    {
        "py": "if ( left < right ) : NEW_LINE",
        "explain": "If left < right , then swap arr [ left ] and arr [ right ]"
    },
    {
        "py": "arr [ left ] , arr [ right ] = arr [ right ] , arr [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE",
        "explain": "Swap arr [ left ] and arr [ right ]"
    },
    {
        "py": "for num in arr : NEW_LINE INDENT print ( num , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print segregated array"
    },
    {
        "py": "arr = [ 2 , 3 , 4 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE prime = [ True ] * 10000001 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "segregatePrimeNonPrime ( prime , arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findDepthRec ( tree , n , index ) : NEW_LINE INDENT if ( index [ 0 ] >= n or tree [ index [ 0 ] ] == ' l ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "function to return max of left subtree height or right subtree height"
    },
    {
        "py": "index [ 0 ] += 1 NEW_LINE left = findDepthRec ( tree , n , index ) NEW_LINE",
        "explain": "calc height of left subtree ( In preorder left subtree is processed before right )"
    },
    {
        "py": "index [ 0 ] += 1 NEW_LINE right = findDepthRec ( tree , n , index ) NEW_LINE return ( max ( left , right ) + 1 ) NEW_LINE",
        "explain": "calc height of right subtree"
    },
    {
        "py": "def findDepth ( tree , n ) : NEW_LINE INDENT index = [ 0 ] NEW_LINE return findDepthRec ( tree , n , index ) NEW_LINE DEDENT",
        "explain": "Wrapper over findDepthRec ( )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT tree = \" nlnnlll \" NEW_LINE n = len ( tree ) NEW_LINE print ( findDepth ( tree , n ) ) NEW_LINE DEDENT",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT",
        "explain": "Constructor to create a new node"
    },
    {
        "py": "def insert ( node , key ) : NEW_LINE",
        "explain": "To insert a new node in BST"
    },
    {
        "py": "if node == None : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT",
        "explain": "if tree is empty return new node"
    },
    {
        "py": "if key < node . key : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif key > node . key : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT",
        "explain": "if key is less then or greater then node value then recur down the tree"
    },
    {
        "py": "return node NEW_LINE",
        "explain": "return the ( unchanged ) node pointer"
    },
    {
        "py": "def findMaxforN ( root , N ) : NEW_LINE",
        "explain": "function to find max value less then N"
    },
    {
        "py": "if root == None : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if root . key == N : NEW_LINE INDENT return N NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "elif root . key < N : NEW_LINE INDENT k = findMaxforN ( root . right , N ) NEW_LINE if k == - 1 : NEW_LINE INDENT return root . key NEW_LINE DEDENT else : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT",
        "explain": "If root 's value is smaller, try in  right subtree"
    },
    {
        "py": "elif root . key > N : NEW_LINE INDENT return findMaxforN ( root . left , N ) NEW_LINE DEDENT",
        "explain": "If root 's key is greater, return  value from left subtree."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "root = None NEW_LINE root = insert ( root , 25 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 12 ) NEW_LINE insert ( root , 9 ) NEW_LINE insert ( root , 21 ) NEW_LINE insert ( root , 19 ) NEW_LINE insert ( root , 25 ) NEW_LINE print ( findMaxforN ( root , N ) ) NEW_LINE",
        "explain": "creating following BST 5 / \\ 2 12 / \\ / \\ 1 3 9 21 / \\ 19 25"
    },
    {
        "py": "class newNode : NEW_LINE",
        "explain": "Python3 code to find the largest value smaller than or equal to N"
    },
    {
        "py": "def __init__ ( self , data ) : NEW_LINE INDENT self . key = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT",
        "explain": "To create new BST Node"
    },
    {
        "py": "def insert ( node , key ) : NEW_LINE",
        "explain": "To insert a new node in BST"
    },
    {
        "py": "if ( node == None ) : NEW_LINE INDENT return newNode ( key ) NEW_LINE DEDENT",
        "explain": "If tree is empty return new node"
    },
    {
        "py": "if ( key < node . key ) : NEW_LINE INDENT node . left = insert ( node . left , key ) NEW_LINE DEDENT elif ( key > node . key ) : NEW_LINE INDENT node . right = insert ( node . right , key ) NEW_LINE DEDENT",
        "explain": "If key is less then or greater then node value then recur down the tree"
    },
    {
        "py": "return node NEW_LINE",
        "explain": "Return the ( unchanged ) node pointer"
    },
    {
        "py": "def findMaxforN ( root , N ) : NEW_LINE",
        "explain": "Function to find max value less then N"
    },
    {
        "py": "while ( root != None and root . right != None ) : NEW_LINE",
        "explain": "Start from root and keep looking for larger"
    },
    {
        "py": "if ( N > root . key and N >= root . right . key ) : NEW_LINE INDENT root = root . right NEW_LINE DEDENT",
        "explain": "If root is smaller go to right side"
    },
    {
        "py": "elif ( N < root . key ) : NEW_LINE INDENT root = root . left NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT if ( root == None or root . key > N ) : NEW_LINE print ( - 1 ) NEW_LINE else : NEW_LINE print ( root . key ) NEW_LINE",
        "explain": "If root is greater go to left side"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE root = None NEW_LINE root = insert ( root , 5 ) NEW_LINE insert ( root , 2 ) NEW_LINE insert ( root , 1 ) NEW_LINE insert ( root , 3 ) NEW_LINE insert ( root , 12 ) NEW_LINE insert ( root , 9 ) NEW_LINE insert ( root , 21 ) NEW_LINE insert ( root , 19 ) NEW_LINE insert ( root , 25 ) NEW_LINE findMaxforN ( root , N ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "class createNode : NEW_LINE",
        "explain": "Python 3 program to find maximum element in the path between two Nodes of Binary Search Tree . Create and return a pointer of new Node ."
    },
    {
        "py": "def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT",
        "explain": "Constructor to create a new node"
    },
    {
        "py": "def insertNode ( root , x ) : NEW_LINE INDENT p , q = root , None NEW_LINE while p != None : NEW_LINE INDENT q = p NEW_LINE if p . data < x : NEW_LINE INDENT p = p . right NEW_LINE DEDENT else : NEW_LINE INDENT p = p . left NEW_LINE DEDENT DEDENT if q == None : NEW_LINE INDENT p = createNode ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT if q . data < x : NEW_LINE INDENT q . right = createNode ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT q . left = createNode ( x ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Insert a new Node in Binary Search Tree ."
    },
    {
        "py": "def maxelpath ( q , x ) : NEW_LINE INDENT p = q NEW_LINE mx = - 999999999999 NEW_LINE DEDENT",
        "explain": "Return the maximum element between a Node and its given ancestor ."
    },
    {
        "py": "while p . data != x : NEW_LINE INDENT if p . data > x : NEW_LINE INDENT mx = max ( mx , p . data ) NEW_LINE p = p . left NEW_LINE DEDENT else : NEW_LINE INDENT mx = max ( mx , p . data ) NEW_LINE p = p . right NEW_LINE DEDENT DEDENT return max ( mx , x ) NEW_LINE",
        "explain": "Traversing the path between ansector and Node and finding maximum element ."
    },
    {
        "py": "def maximumElement ( root , x , y ) : NEW_LINE INDENT p = root NEW_LINE DEDENT",
        "explain": "Return maximum element in the path between two given Node of BST ."
    },
    {
        "py": "while ( ( x < p . data and y < p . data ) or ( x > p . data and y > p . data ) ) : NEW_LINE",
        "explain": "Finding the LCA of Node x and Node y"
    },
    {
        "py": "if x < p . data and y < p . data : NEW_LINE INDENT p = p . left NEW_LINE DEDENT",
        "explain": "Checking if both the Node lie on the left side of the parent p ."
    },
    {
        "py": "elif x > p . data and y > p . data : NEW_LINE INDENT p = p . right NEW_LINE DEDENT",
        "explain": "Checking if both the Node lie on the right side of the parent p ."
    },
    {
        "py": "return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) NEW_LINE",
        "explain": "Return the maximum of maximum elements occur in path from ancestor to both Node ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 ] NEW_LINE a , b = 1 , 10 NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "root = createNode ( arr [ 0 ] ) NEW_LINE",
        "explain": "Creating the root of Binary Search Tree"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT insertNode ( root , arr [ i ] ) NEW_LINE DEDENT print ( maximumElement ( root , a , b ) ) NEW_LINE",
        "explain": "Inserting Nodes in Binary Search Tree"
    },
    {
        "py": "class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE DEDENT",
        "explain": "Insertion in Threaded Binary Search Tree ."
    },
    {
        "py": "self . info = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE self . lthread = True NEW_LINE",
        "explain": "True if left pointer points to predecessor in Inorder Traversal"
    },
    {
        "py": "self . rthread = True NEW_LINE",
        "explain": "True if right pointer points to successor in Inorder Traversal"
    },
    {
        "py": "def insert ( root , ikey ) : NEW_LINE",
        "explain": "Insert a Node in Binary Threaded Tree"
    },
    {
        "py": "ptr = root NEW_LINE",
        "explain": "Searching for a Node with given value"
    },
    {
        "py": "par = None NEW_LINE while ptr != None : NEW_LINE",
        "explain": "Parent of key to be inserted"
    },
    {
        "py": "if ikey == ( ptr . info ) : NEW_LINE INDENT print ( \" Duplicate \u2581 Key \u2581 ! \" ) NEW_LINE return root NEW_LINE DEDENT",
        "explain": "If key already exists , return"
    },
    {
        "py": "par = ptr NEW_LINE",
        "explain": "Update parent pointer"
    },
    {
        "py": "if ikey < ptr . info : NEW_LINE INDENT if ptr . lthread == False : NEW_LINE INDENT ptr = ptr . left NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "Moving on left subtree ."
    },
    {
        "py": "else : NEW_LINE INDENT if ptr . rthread == False : NEW_LINE INDENT ptr = ptr . right NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "Moving on right subtree ."
    },
    {
        "py": "tmp = newNode ( ikey ) NEW_LINE if par == None : NEW_LINE INDENT root = tmp NEW_LINE tmp . left = None NEW_LINE tmp . right = None NEW_LINE DEDENT elif ikey < ( par . info ) : NEW_LINE INDENT tmp . left = par . left NEW_LINE tmp . right = par NEW_LINE par . lthread = False NEW_LINE par . left = tmp NEW_LINE DEDENT else : NEW_LINE INDENT tmp . left = par NEW_LINE tmp . right = par . right NEW_LINE par . rthread = False NEW_LINE par . right = tmp NEW_LINE DEDENT return root NEW_LINE",
        "explain": "Create a new node"
    },
    {
        "py": "def inorderSuccessor ( ptr ) : NEW_LINE",
        "explain": "Returns inorder successor using rthread"
    },
    {
        "py": "if ptr . rthread == True : NEW_LINE INDENT return ptr . right NEW_LINE DEDENT",
        "explain": "If rthread is set , we can quickly find"
    },
    {
        "py": "ptr = ptr . right NEW_LINE while ptr . lthread == False : NEW_LINE INDENT ptr = ptr . left NEW_LINE DEDENT return ptr NEW_LINE",
        "explain": "Else return leftmost child of right subtree"
    },
    {
        "py": "def inorder ( root ) : NEW_LINE INDENT if root == None : NEW_LINE INDENT print ( \" Tree \u2581 is \u2581 empty \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Printing the threaded tree"
    },
    {
        "py": "ptr = root NEW_LINE while ptr . lthread == False : NEW_LINE INDENT ptr = ptr . left NEW_LINE DEDENT",
        "explain": "Reach leftmost node"
    },
    {
        "py": "while ptr != None : NEW_LINE INDENT print ( ptr . info , end = \" \u2581 \" ) NEW_LINE ptr = inorderSuccessor ( ptr ) NEW_LINE DEDENT",
        "explain": "One by one print successors"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE root = insert ( root , 20 ) NEW_LINE root = insert ( root , 10 ) NEW_LINE root = insert ( root , 30 ) NEW_LINE root = insert ( root , 5 ) NEW_LINE root = insert ( root , 16 ) NEW_LINE root = insert ( root , 14 ) NEW_LINE root = insert ( root , 17 ) NEW_LINE root = insert ( root , 13 ) NEW_LINE inorder ( root ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 1000 NEW_LINE def checkHV ( arr , N , M ) : NEW_LINE",
        "explain": "Python3 program to find if a matrix is symmetric ."
    },
    {
        "py": "horizontal = True NEW_LINE vertical = True NEW_LINE",
        "explain": "Initializing as both horizontal and vertical symmetric ."
    },
    {
        "py": "i = 0 NEW_LINE k = N - 1 NEW_LINE while ( i < N // 2 ) : NEW_LINE",
        "explain": "Checking for Horizontal Symmetry . We compare first row with last row , second row with second last row and so on ."
    },
    {
        "py": "for j in range ( M ) : NEW_LINE",
        "explain": "Checking each cell of a column ."
    },
    {
        "py": "if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) : NEW_LINE INDENT horizontal = False NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE k -= 1 NEW_LINE",
        "explain": "check if every cell is identical"
    },
    {
        "py": "i = 0 NEW_LINE k = M - 1 NEW_LINE while ( i < M // 2 ) : NEW_LINE",
        "explain": "Checking for Vertical Symmetry . We compare first column with last column , second xolumn with second last column and so on ."
    },
    {
        "py": "for j in range ( N ) : NEW_LINE",
        "explain": "Checking each cell of a row ."
    },
    {
        "py": "if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) : NEW_LINE INDENT vertical = False NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE k -= 1 NEW_LINE if ( not horizontal and not vertical ) : NEW_LINE print ( \" NO \" ) NEW_LINE elif ( horizontal and not vertical ) : NEW_LINE print ( \" HORIZONTAL \" ) NEW_LINE elif ( vertical and not horizontal ) : NEW_LINE print ( \" VERTICAL \" ) NEW_LINE else : NEW_LINE print ( \" BOTH \" ) NEW_LINE",
        "explain": "check if every cell is identical"
    },
    {
        "py": "mat = [ [ 1 , 0 , 1 ] , [ 0 , 0 , 0 ] , [ 1 , 0 , 1 ] ] NEW_LINE checkHV ( mat , 3 , 3 ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "R = 3 NEW_LINE C = 4 NEW_LINE",
        "explain": "Python3 program to replace each each element with maximum of GCD of row or column ."
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT",
        "explain": "returning the greatest common divisor of two number"
    },
    {
        "py": "def replacematrix ( mat , n , m ) : NEW_LINE INDENT rgcd = [ 0 ] * R NEW_LINE cgcd = [ 0 ] * C NEW_LINE DEDENT",
        "explain": "Finding GCD of each row and column and replacing with each element with maximum of GCD of row or column ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) NEW_LINE cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Calculating GCD of each row and each column in O ( mn ) and store in arrays ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Replacing matrix element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT m = [ [ 1 , 2 , 3 , 3 ] , [ 4 , 5 , 6 , 6 ] , [ 7 , 8 , 9 , 9 ] ] NEW_LINE replacematrix ( m , R , C ) NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT print ( m [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Python3 program for addition of two matrices"
    },
    {
        "py": "def add ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "This function adds A [ ] [ ] and B [ ] [ ] , and stores the result in C [ ] [ ]"
    },
    {
        "py": "A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE add ( A , B , C ) NEW_LINE print ( \" Result \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "driver code"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Python 3 program for subtraction of matrices"
    },
    {
        "py": "def subtract ( A , B , C ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "This function returns 1 if A [ ] [ ] and B [ ] [ ] are identical otherwise returns 0"
    },
    {
        "py": "A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE B = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE C = A [ : ] [ : ] NEW_LINE subtract ( A , B , C ) NEW_LINE print ( \" Result \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( C [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def linearSearch ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] is i : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Python program to check fixed point in an array using linear search"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "If no fixed point present then return - 1"
    },
    {
        "py": "arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Fixed \u2581 Point \u2581 is \u2581 \" + str ( linearSearch ( arr , n ) ) ) NEW_LINE",
        "explain": "Driver program to check above functions"
    },
    {
        "py": "def binarySearch ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE DEDENT",
        "explain": "Python program to check fixed point in an array using binary search"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "Return - 1 if there is no Fixed Point"
    },
    {
        "py": "arr = [ - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Fixed \u2581 Point \u2581 is \u2581 \" + str ( binarySearch ( arr , 0 , n - 1 ) ) ) NEW_LINE",
        "explain": "Driver program to check above functions"
    },
    {
        "py": "def maxTripletSum ( arr , n ) : NEW_LINE",
        "explain": "Python 3 code to find maximum triplet sum"
    },
    {
        "py": "sm = - 1000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( sm < ( arr [ i ] + arr [ j ] + arr [ k ] ) ) : NEW_LINE INDENT sm = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return sm NEW_LINE",
        "explain": "Initialize sum with INT_MIN"
    },
    {
        "py": "arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxTripletSum ( arr , n ) ) NEW_LINE",
        "explain": "Driven code"
    },
    {
        "py": "def maxTripletSum ( arr , n ) : NEW_LINE",
        "explain": "This function assumes that there are at least three elements in arr [ ] ."
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "sort the given array"
    },
    {
        "py": "return ( arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ) NEW_LINE",
        "explain": "After sorting the array . Add last three element of the given array"
    },
    {
        "py": "arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxTripletSum ( arr , n ) ) NEW_LINE",
        "explain": "Driven code"
    },
    {
        "py": "def maxTripletSum ( arr , n ) : NEW_LINE",
        "explain": "This function assumes that there are at least three elements in arr [ ] ."
    },
    {
        "py": "maxA = - 100000000 NEW_LINE maxB = - 100000000 NEW_LINE maxC = - 100000000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Initialize Maximum , second maximum and third maximum element"
    },
    {
        "py": "if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT",
        "explain": "Update Maximum , second maximum and third maximum element"
    },
    {
        "py": "elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT",
        "explain": "Update second maximum and third maximum element"
    },
    {
        "py": "elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxC = arr [ i ] NEW_LINE DEDENT return ( maxA + maxB + maxC ) NEW_LINE",
        "explain": "Update third maximum element"
    },
    {
        "py": "arr = [ 1 , 0 , 8 , 6 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxTripletSum ( arr , n ) ) NEW_LINE",
        "explain": "Driven code"
    },
    {
        "py": "def search ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT",
        "explain": "Python3 code to linearly search x in arr [ ] . If x is present then return its location , otherwise return - 1"
    },
    {
        "py": "arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "result = search ( arr , n , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( \" Element \u2581 is \u2581 not \u2581 present \u2581 in \u2581 array \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Element \u2581 is \u2581 present \u2581 at \u2581 index \" , result ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def search ( arr , search_Element ) : NEW_LINE INDENT left = 0 NEW_LINE length = len ( arr ) NEW_LINE position = - 1 NEW_LINE right = length - 1 NEW_LINE DEDENT",
        "explain": "Python3 program for linear search"
    },
    {
        "py": "for left in range ( 0 , right , 1 ) : NEW_LINE",
        "explain": "Run loop from 0 to right"
    },
    {
        "py": "if ( arr [ left ] == search_Element ) : NEW_LINE INDENT position = left NEW_LINE print ( \" Element \u2581 found \u2581 in \u2581 Array \u2581 at \u2581 \" , position + 1 , \" \u2581 Position \u2581 with \u2581 \" , left + 1 , \" \u2581 Attempt \" ) NEW_LINE break NEW_LINE DEDENT",
        "explain": "If search_element is found with left variable"
    },
    {
        "py": "if ( arr [ right ] == search_Element ) : NEW_LINE INDENT position = right NEW_LINE print ( \" Element \u2581 found \u2581 in \u2581 Array \u2581 at \u2581 \" , position + 1 , \" \u2581 Position \u2581 with \u2581 \" , length - right , \" \u2581 Attempt \" ) NEW_LINE break NEW_LINE DEDENT left += 1 NEW_LINE right -= 1 NEW_LINE",
        "explain": "If search_element is found with right variable"
    },
    {
        "py": "if ( position == - 1 ) : NEW_LINE INDENT print ( \" Not \u2581 found \u2581 in \u2581 Array \u2581 with \u2581 \" , left , \" \u2581 Attempt \" ) NEW_LINE DEDENT",
        "explain": "If element not found"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE search_element = 5 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "search ( arr , search_element ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def countSort ( arr ) : NEW_LINE",
        "explain": "The main function that sort the given string arr [ ] in alphabetical order"
    },
    {
        "py": "output = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE",
        "explain": "The output character array that will have sorted arr"
    },
    {
        "py": "count = [ 0 for i in range ( 256 ) ] NEW_LINE",
        "explain": "Create a count array to store count of inidividul characters and initialize count array as 0"
    },
    {
        "py": "for i in arr : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT",
        "explain": "Store count of each character"
    },
    {
        "py": "for i in range ( 256 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Change count [ i ] so that count [ i ] now contains actual position of this character in output array"
    },
    {
        "py": "for i in range ( len ( arr ) ) : NEW_LINE INDENT output [ count [ ord ( arr [ i ] ) ] - 1 ] = arr [ i ] NEW_LINE count [ ord ( arr [ i ] ) ] -= 1 NEW_LINE DEDENT",
        "explain": "Build the output character array"
    },
    {
        "py": "ans = [ \" \" for _ in arr ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT ans [ i ] = output [ i ] NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Copy the output array to arr , so that arr now contains sorted characters"
    },
    {
        "py": "arr = \" geeksforgeeks \" NEW_LINE ans = countSort ( arr ) NEW_LINE print ( \" Sorted \u2581 character \u2581 array \u2581 is \u2581 % \u2581 s \" % ( \" \" . join ( ans ) ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def count_sort ( arr ) : NEW_LINE INDENT max_element = int ( max ( arr ) ) NEW_LINE min_element = int ( min ( arr ) ) NEW_LINE range_of_elements = max_element - min_element + 1 NEW_LINE count_arr = [ 0 for _ in range ( range_of_elements ) ] NEW_LINE output_arr = [ 0 for _ in range ( len ( arr ) ) ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT count_arr [ arr [ i ] - min_element ] += 1 NEW_LINE DEDENT for i in range ( 1 , len ( count_arr ) ) : NEW_LINE INDENT count_arr [ i ] += count_arr [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( arr ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT output_arr [ count_arr [ arr [ i ] - min_element ] - 1 ] = arr [ i ] NEW_LINE count_arr [ arr [ i ] - min_element ] -= 1 NEW_LINE DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = output_arr [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT",
        "explain": "The function that sorts the given arr [ ]"
    },
    {
        "py": "arr = [ - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 ] NEW_LINE ans = count_sort ( arr ) NEW_LINE print ( \" Sorted \u2581 character \u2581 array \u2581 is \u2581 \" + str ( ans ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def binomialCoeff ( n , k ) : NEW_LINE",
        "explain": "Returns value of Binomial Coefficient C ( n , k )"
    },
    {
        "py": "if k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if k == 0 or k == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Base Cases"
    },
    {
        "py": "return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) NEW_LINE",
        "explain": "Recursive Call"
    },
    {
        "py": "n = 5 NEW_LINE k = 2 NEW_LINE print \" Value \u2581 of \u2581 C ( % d , % d ) \u2581 is \u2581 ( % d ) \" % ( n , k , binomialCoeff ( n , k ) ) NEW_LINE",
        "explain": "Driver Program to test ht above function"
    },
    {
        "py": "def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 for i in xrange ( k + 1 ) ] NEW_LINE DEDENT",
        "explain": "Python program for Optimized Dynamic Programming solution to Binomail Coefficient . This one uses the concept of pascal Triangle and less memory"
    },
    {
        "py": "C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "since nC0 is 1"
    },
    {
        "py": "j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT return C [ k ] NEW_LINE",
        "explain": "Compute next row of pascal triangle using the previous row"
    },
    {
        "py": "n = 5 NEW_LINE k = 2 NEW_LINE print \" Value \u2581 of \u2581 C ( % d , % d ) \u2581 is \u2581 % d \" % ( n , k , binomialCoeff ( n , k ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE class GFG : NEW_LINE",
        "explain": "Python code for the above approach"
    },
    {
        "py": "def nCr ( self , n , r ) : NEW_LINE INDENT if r > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Base case"
    },
    {
        "py": "if n - r > r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT",
        "explain": "C ( n , r ) = C ( n , n - r ) Complexity for this code is lesser for lower n - r"
    },
    {
        "py": "SPF = [ i for i in range ( n + 1 ) ] NEW_LINE",
        "explain": "set smallest prime factor of each number as itself"
    },
    {
        "py": "for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT SPF [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "set smallest prime factor of all even numbers as 2"
    },
    {
        "py": "if SPF [ i ] == i : NEW_LINE",
        "explain": "Check if i is prime"
    },
    {
        "py": "for j in range ( i * i , n + 1 , i ) : NEW_LINE INDENT if SPF [ j ] == j : NEW_LINE INDENT SPF [ j ] = i NEW_LINE DEDENT DEDENT",
        "explain": "All multiples of i are composite ( and divisible by i ) so add i to their prime factorization getpow ( j , i ) times"
    },
    {
        "py": "prime_pow = { } NEW_LINE",
        "explain": "dictionary to store power of each prime in C ( n , r )"
    },
    {
        "py": "for i in range ( r + 1 , n + 1 ) : NEW_LINE INDENT t = i NEW_LINE DEDENT",
        "explain": "For numerator count frequency of each prime factor"
    },
    {
        "py": "while t > 1 : NEW_LINE INDENT if not SPF [ t ] in prime_pow : NEW_LINE INDENT prime_pow [ SPF [ t ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT prime_pow [ SPF [ t ] ] += 1 NEW_LINE DEDENT t //= SPF [ t ] NEW_LINE DEDENT",
        "explain": "Recursive division to find prime factorization of i"
    },
    {
        "py": "for i in range ( 1 , n - r + 1 ) : NEW_LINE INDENT t = i NEW_LINE DEDENT",
        "explain": "For denominator subtract the power of each prime factor"
    },
    {
        "py": "while t > 1 : NEW_LINE INDENT prime_pow [ SPF [ t ] ] -= 1 NEW_LINE t //= SPF [ t ] NEW_LINE DEDENT",
        "explain": "Recursive division to find prime factorization of i"
    },
    {
        "py": "for i in prime_pow : NEW_LINE",
        "explain": "Use ( a * b ) % mod = ( a % mod * b % mod ) % mod"
    },
    {
        "py": "ans = ( ans * pow ( i , prime_pow [ i ] , mod ) ) % mod NEW_LINE return ans NEW_LINE",
        "explain": "pow ( base , exp , mod ) is used to find ( base ^ exp ) % mod fast"
    },
    {
        "py": "n = 5 NEW_LINE k = 2 NEW_LINE ob = GFG ( ) NEW_LINE print ( \" Value \u2581 of \u2581 C ( \" + str ( n ) + \" , \u2581 \" + str ( k ) + \" ) \u2581 is \" , ob . nCr ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def binomialCoeff ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = 1000000007 NEW_LINE inv = [ 0 for i in range ( r + 1 ) ] NEW_LINE inv [ 0 ] = 1 NEW_LINE if ( r + 1 >= 2 ) : NEW_LINE INDENT inv [ 1 ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to find binomial coefficient"
    },
    {
        "py": "for i in range ( 2 , r + 1 ) : NEW_LINE INDENT inv [ i ] = m - ( m // i ) * inv [ m % i ] % m NEW_LINE DEDENT ans = 1 NEW_LINE",
        "explain": "Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007"
    },
    {
        "py": "for i in range ( 2 , r + 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m NEW_LINE DEDENT",
        "explain": "for 1 / ( r ! ) part"
    },
    {
        "py": "for i in range ( n , n - r , - 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( i % m ) ) % m NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part"
    },
    {
        "py": "n = 5 NEW_LINE r = 2 NEW_LINE print ( \" Value \u2581 of \u2581 C ( \" , n , \" , \u2581 \" , r , \" ) \u2581 is \u2581 \" , binomialCoeff ( n , r ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findPartiion ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE DEDENT",
        "explain": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT part = [ 0 ] * ( ( Sum // 2 ) + 1 ) NEW_LINE",
        "explain": "Calculate sum of all elements"
    },
    {
        "py": "for i in range ( ( Sum // 2 ) + 1 ) : NEW_LINE INDENT part [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Initialze the part array as 0"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Fill the partition table in bottom up manner"
    },
    {
        "py": "for j in range ( Sum // 2 , arr [ i ] - 1 , - 1 ) : NEW_LINE",
        "explain": "the element to be included in the sum cannot be greater than the sum"
    },
    {
        "py": "if ( part [ j - arr [ i ] ] == 1 or j == arr [ i ] ) : NEW_LINE INDENT part [ j ] = 1 NEW_LINE DEDENT return part [ Sum // 2 ] NEW_LINE",
        "explain": "check if sum - arr [ i ] could be formed from a subset using elements before index i"
    },
    {
        "py": "arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Drive code"
    },
    {
        "py": "if ( findPartiion ( arr , n ) == 1 ) : NEW_LINE INDENT print ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def isSubsetSum ( set , n , sum ) : NEW_LINE",
        "explain": "Returns true if there is a subset of set [ ] with sun equal to given sum"
    },
    {
        "py": "if ( sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Base Cases"
    },
    {
        "py": "if ( set [ n - 1 ] > sum ) : NEW_LINE INDENT return isSubsetSum ( set , n - 1 , sum ) NEW_LINE DEDENT",
        "explain": "If last element is greater than sum , then ignore it"
    },
    {
        "py": "return isSubsetSum ( set , n - 1 , sum ) or isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) NEW_LINE",
        "explain": "else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element"
    },
    {
        "py": "set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isSubsetSum ( set , n , sum ) : NEW_LINE",
        "explain": "Returns true if there is a subset of set [ ] with sun equal to given sum"
    },
    {
        "py": "subset = ( [ [ False for i in range ( sum + 1 ) ] for i in range ( n + 1 ) ] ) NEW_LINE",
        "explain": "The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT",
        "explain": "If sum is 0 , then answer is true"
    },
    {
        "py": "for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT",
        "explain": "If sum is not 0 and set is empty , then answer is false"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , sum + 1 ) : NEW_LINE INDENT if j < set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT if j >= set [ i - 1 ] : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - set [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Fill the subset table in botton up manner"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( sum + 1 ) : NEW_LINE INDENT print ( subset [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE print ( ) NEW_LINE DEDENT DEDENT return subset [ n ] [ sum ] NEW_LINE",
        "explain": "print table"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set = [ 3 , 34 , 4 , 12 , 5 , 2 ] NEW_LINE sum = 9 NEW_LINE n = len ( set ) NEW_LINE if ( isSubsetSum ( set , n , sum ) == True ) : NEW_LINE INDENT print ( \" Found \u2581 a \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 subset \u2581 with \u2581 given \u2581 sum \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findoptimal ( N ) : NEW_LINE",
        "explain": "A recursive function that returns the optimal length string for N keystrokes"
    },
    {
        "py": "if N <= 6 : NEW_LINE INDENT return N NEW_LINE DEDENT",
        "explain": "The optimal string length is N when N is smaller than"
    },
    {
        "py": "maxi = 0 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "for b in range ( N - 3 , 0 , - 1 ) : NEW_LINE",
        "explain": "TRY ALL POSSIBLE BREAK - POINTS For any keystroke N , we need to loop from N - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have Ctrl - A , Ctrl - C and then only Ctrl - V all the way ."
    },
    {
        "py": "curr = ( N - b - 1 ) * findoptimal ( b ) NEW_LINE if curr > maxi : NEW_LINE INDENT maxi = curr NEW_LINE DEDENT return maxi NEW_LINE",
        "explain": "If the breakpoint is s at b 'th  keystroke then the optimal string  would have length  (n-b-1)*screen[b-1];"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "for n in range ( 1 , 21 ) : NEW_LINE INDENT print ( ' Maximum \u2581 Number \u2581 of \u2581 As \u2581 with \u2581 ' , n , ' keystrokes \u2581 is \u2581 ' , findoptimal ( n ) ) NEW_LINE DEDENT",
        "explain": "for the rest of the array we will rely on the previous entries to compute new ones"
    },
    {
        "py": "def findoptimal ( N ) : NEW_LINE",
        "explain": "this function returns the optimal length string for N keystrokes"
    },
    {
        "py": "if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT",
        "explain": "The optimal string length is N when N is smaller than 7"
    },
    {
        "py": "screen = [ 0 ] * N NEW_LINE",
        "explain": "An array to store result of subproblems"
    },
    {
        "py": "for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT",
        "explain": "Initializing the optimal lengths array for uptil 6 input strokes ."
    },
    {
        "py": "for n in range ( 7 , N + 1 ) : NEW_LINE",
        "explain": "Solve all subproblems in bottom manner"
    },
    {
        "py": "screen [ n - 1 ] = 0 NEW_LINE",
        "explain": "Initialize length of optimal string for n keystrokes"
    },
    {
        "py": "for b in range ( n - 3 , 0 , - 1 ) : NEW_LINE",
        "explain": "For any keystroke n , we need to loop from n - 3 keystrokes back to 1 keystroke to find a breakpoint ' b ' after which we will have ctrl - a , ctrl - c and then only ctrl - v all the way ."
    },
    {
        "py": "curr = ( n - b - 1 ) * screen [ b - 1 ] NEW_LINE if ( curr > screen [ n - 1 ] ) : NEW_LINE INDENT screen [ n - 1 ] = curr NEW_LINE DEDENT return screen [ N - 1 ] NEW_LINE",
        "explain": "if the breakpoint is at b 'th keystroke then  the optimal string would have length  (n-b-1)*screen[b-1];"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "for N in range ( 1 , 21 ) : NEW_LINE INDENT print ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 \" , N , \" \u2581 keystrokes \u2581 is \u2581 \" , findoptimal ( N ) ) NEW_LINE DEDENT",
        "explain": "for the rest of the array we will rely on the previous entries to compute new ones"
    },
    {
        "py": "def findoptimal ( N ) : NEW_LINE",
        "explain": "this function returns the optimal length string for N keystrokes"
    },
    {
        "py": "if ( N <= 6 ) : NEW_LINE INDENT return N NEW_LINE DEDENT",
        "explain": "The optimal string length is N when N is smaller than 7"
    },
    {
        "py": "screen = [ 0 ] * N NEW_LINE",
        "explain": "An array to store result of subproblems"
    },
    {
        "py": "for n in range ( 1 , 7 ) : NEW_LINE INDENT screen [ n - 1 ] = n NEW_LINE DEDENT",
        "explain": "Initializing the optimal lengths array for uptil 6 input strokes ."
    },
    {
        "py": "for n in range ( 7 , N + 1 ) : NEW_LINE",
        "explain": "Solve all subproblems in bottom manner"
    },
    {
        "py": "screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; NEW_LINE return screen [ N - 1 ] NEW_LINE",
        "explain": "for any keystroke n , we will need to choose between : - 1. pressing Ctrl - V once after copying the A ' s \u2581 obtained \u2581 by \u2581 n - 3 \u2581 keystrokes . \u2581 \u2581 2 . \u2581 pressing \u2581 Ctrl - V \u2581 twice \u2581 after \u2581 copying \u2581 the \u2581 A ' s obtained by n - 4 keystrokes . 3. pressing Ctrl - V thrice after copying the A 's  obtained by n-5 keystrokes."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "for N in range ( 1 , 21 ) : NEW_LINE INDENT print ( \" Maximum \u2581 Number \u2581 of \u2581 A ' s \u2581 with \u2581 \" , N , \" \u2581 keystrokes \u2581 is \u2581 \" , findoptimal ( N ) ) NEW_LINE DEDENT",
        "explain": "for the rest of the array we will rely on the previous entries to compute new ones"
    },
    {
        "py": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE elif ( int ( y % 2 ) == 0 ) : NEW_LINE INDENT return ( power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * power ( x , int ( y / 2 ) ) * power ( x , int ( y / 2 ) ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to calculate x raised to the power y"
    },
    {
        "py": "x = 2 ; y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def power ( x , y ) : NEW_LINE INDENT temp = 0 NEW_LINE if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to calculate x raised to the power y in O ( logn )"
    },
    {
        "py": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : return 1 NEW_LINE temp = power ( x , int ( y / 2 ) ) NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp NEW_LINE DEDENT else : NEW_LINE INDENT if ( y > 0 ) : return x * temp * temp NEW_LINE else : return ( temp * temp ) / x NEW_LINE DEDENT DEDENT",
        "explain": "Python3 code for extended version of power function that can work for float x and negative y"
    },
    {
        "py": "x , y = 2 , - 3 NEW_LINE print ( ' % .6f ' % ( power ( x , y ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def power ( x , y ) : NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If x ^ 0 return 1"
    },
    {
        "py": "if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If we need to find of 0 ^ y"
    },
    {
        "py": "return x * power ( x , y - 1 ) NEW_LINE",
        "explain": "For all other cases"
    },
    {
        "py": "x = 2 NEW_LINE y = 3 NEW_LINE print ( power ( x , y ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def squareRoot ( n ) : NEW_LINE",
        "explain": "Returns the square root of n . Note that the function"
    },
    {
        "py": "x = n NEW_LINE y = 1 NEW_LINE",
        "explain": "We are using n itself as initial approximation This can definitely be improved"
    },
    {
        "py": "e = 0.000001 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE",
        "explain": "e decides the accuracy level"
    },
    {
        "py": "n = 50 NEW_LINE print ( \" Square \u2581 root \u2581 of \" , n , \" is \" , round ( squareRoot ( n ) , 6 ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def getAvg ( prev_avg , x , n ) : NEW_LINE INDENT return ( ( prev_avg * n + x ) / ( n + 1 ) ) ; NEW_LINE DEDENT",
        "explain": "Returns the new average after including x"
    },
    {
        "py": "def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( avg , arr [ i ] , i ) ; NEW_LINE print ( \" Average \u2581 of \u2581 \" , i + 1 , \" \u2581 numbers \u2581 is \u2581 \" , avg ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Prints average of a stream of numbers"
    },
    {
        "py": "arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def getAvg ( x , n , sum ) : NEW_LINE INDENT sum = sum + x ; NEW_LINE return float ( sum ) / n ; NEW_LINE DEDENT",
        "explain": "Returns the new average after including x"
    },
    {
        "py": "def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] , i + 1 , sum ) ; NEW_LINE sum = avg * ( i + 1 ) ; NEW_LINE print ( \" Average \u2581 of \u2581 \" , end = \" \" ) ; NEW_LINE print ( i + 1 , end = \" \" ) ; NEW_LINE print ( \" \u2581 numbers \u2581 is \u2581 \" , end = \" \" ) ; NEW_LINE print ( avg ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT",
        "explain": "Prints average of a stream of numbers"
    },
    {
        "py": "arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def binomialCoefficient ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT",
        "explain": "Returns value of Binomial Coefficient C ( n , k )"
    },
    {
        "py": "if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT",
        "explain": "since C ( n , k ) = C ( n , n - k )"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ]"
    },
    {
        "py": "n = 8 NEW_LINE k = 2 NEW_LINE res = binomialCoefficient ( n , k ) NEW_LINE print ( \" Value \u2581 of \u2581 C ( % \u2581 d , \u2581 % \u2581 d ) \u2581 is \u2581 % \u2581 d \" % ( n , k , res ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program to print prime factors"
    },
    {
        "py": "def primeFactors ( n ) : NEW_LINE",
        "explain": "A function to print all prime factors of a given number n"
    },
    {
        "py": "while n % 2 == 0 : NEW_LINE INDENT print 2 , NEW_LINE n = n / 2 NEW_LINE DEDENT",
        "explain": "Print the number of two 's that divide n"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE",
        "explain": "n must be odd at this point so a skip of 2 ( i = i + 2 ) can be used"
    },
    {
        "py": "while n % i == 0 : NEW_LINE INDENT print i , NEW_LINE n = n / i NEW_LINE DEDENT",
        "explain": "while i divides n , print i ad divide n"
    },
    {
        "py": "if n > 2 : NEW_LINE INDENT print n NEW_LINE DEDENT",
        "explain": "Condition if n is a prime number greater than 2"
    },
    {
        "py": "n = 315 NEW_LINE primeFactors ( n ) NEW_LINE",
        "explain": "Driver Program to test above function"
    },
    {
        "py": "def printCombination ( arr , n , r ) : NEW_LINE",
        "explain": "The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )"
    },
    {
        "py": "data = [ 0 ] * r ; NEW_LINE",
        "explain": "A temporary array to store all combination one by one"
    },
    {
        "py": "combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; NEW_LINE",
        "explain": "Print all combination using temprary array 'data[]"
    },
    {
        "py": "def combinationUtil ( arr , data , start , end , index , r ) : NEW_LINE",
        "explain": "arr [ ] -- -> Input Array data [ ] -- -> Temporary array to store current combination start & end -- -> Staring and Ending indexes in arr [ ] index -- -> Current index in data [ ] r -- -> Size of a combination to be printed"
    },
    {
        "py": "if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "Current combination is ready to be printed , print it"
    },
    {
        "py": "i = start ; NEW_LINE while ( i <= end and end - i + 1 >= r - index ) : NEW_LINE INDENT data [ index ] = arr [ i ] ; NEW_LINE combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT",
        "explain": "replace index with all possible elements . The condition \" end - i + 1 \u2581 > = \u2581 \u2581 r - index \" makes sure that including one element at index will make a combination with remaining elements at remaining positions"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE r = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE printCombination ( arr , n , r ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printCombination ( arr , n , r ) : NEW_LINE",
        "explain": "The main function that prints all combinations of size r in arr [ ] of size n . This function mainly uses combinationUtil ( )"
    },
    {
        "py": "data = [ 0 ] * r NEW_LINE",
        "explain": "A temporary array to store all combination one by one"
    },
    {
        "py": "combinationUtil ( arr , n , r , 0 , data , 0 ) NEW_LINE",
        "explain": "Print all combination using temprary array 'data[]"
    },
    {
        "py": "def combinationUtil ( arr , n , r , index , data , i ) : NEW_LINE",
        "explain": "arr [ ] -- -> Input Array n -- -> Size of input array r -- -> Size of a combination to be printed index -- -> Current index in data [ ] data [ ] -- -> Temporary array to store current combination i -- -> index of current element in arr [ ]"
    },
    {
        "py": "if ( index == r ) : NEW_LINE INDENT for j in range ( r ) : NEW_LINE INDENT print ( data [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Current cobination is ready , print it"
    },
    {
        "py": "if ( i >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "When no more elements are there to put in data [ ]"
    },
    {
        "py": "data [ index ] = arr [ i ] NEW_LINE combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) NEW_LINE",
        "explain": "current is included , put next at next location"
    },
    {
        "py": "combinationUtil ( arr , n , r , index , data , i + 1 ) NEW_LINE",
        "explain": "current is excluded , replace it with next ( Note that i + 1 is passed , but index is not changed )"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE r = 3 NEW_LINE n = len ( arr ) NEW_LINE printCombination ( arr , n , r ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findgroups ( arr , n ) : NEW_LINE",
        "explain": "Returns count of all possible groups that can be formed from elements of a [ ] ."
    },
    {
        "py": "c = [ 0 , 0 , 0 ] NEW_LINE",
        "explain": "Create an array C [ 3 ] to store counts of elements with remainder 0 , 1 and 2. c [ i ] would store count of elements with remainder i"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "To store the result"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT c [ arr [ i ] % 3 ] += 1 NEW_LINE DEDENT",
        "explain": "Count elements with remainder 0 , 1 and 2"
    },
    {
        "py": "res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) NEW_LINE",
        "explain": "Case 3. a : Count groups of size 2 from 0 remainder elements"
    },
    {
        "py": "res += c [ 1 ] * c [ 2 ] NEW_LINE",
        "explain": "Case 3. b : Count groups of size 2 with one element with 1 remainder and other with 2 remainder"
    },
    {
        "py": "res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 NEW_LINE",
        "explain": "Case 4. a : Count groups of size 3 with all 0 remainder elements"
    },
    {
        "py": "res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 NEW_LINE",
        "explain": "Case 4. b : Count groups of size 3 with all 1 remainder elements"
    },
    {
        "py": "res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) NEW_LINE",
        "explain": "Case 4. c : Count groups of size 3 with all 2 remainder elements"
    },
    {
        "py": "res += c [ 0 ] * c [ 1 ] * c [ 2 ] NEW_LINE",
        "explain": "Case 4. c : Count groups of size 3 with different remainders"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return total count stored in res"
    },
    {
        "py": "arr = [ 3 , 6 , 7 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Required \u2581 number \u2581 of \u2581 groups \u2581 are \" , int ( findgroups ( arr , n ) ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count ; NEW_LINE",
        "explain": "First n in the below condition is for the case where n is 0"
    },
    {
        "py": "n = 0 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = 5 NEW_LINE print ( nextPowerOf2 ( n ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def nextPowerOf2 ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE n += 1 NEW_LINE return n NEW_LINE DEDENT",
        "explain": "Finds next power of two for n . If n itself is a power of two then returns n"
    },
    {
        "py": "n = 5 NEW_LINE print ( nextPowerOf2 ( n ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def segregate0and1 ( arr , n ) : NEW_LINE",
        "explain": "Function to segregate 0 s and 1 s"
    },
    {
        "py": "count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT",
        "explain": "Counts the no of zeros in arr"
    },
    {
        "py": "for i in range ( 0 , count ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Loop fills the arr with 0 until count"
    },
    {
        "py": "for i in range ( count , n ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT",
        "explain": "Loop fills remaining arr space with 1"
    },
    {
        "py": "def print_arr ( arr , n ) : NEW_LINE INDENT print ( \" Array \u2581 after \u2581 segregation \u2581 is \u2581 \" , end = \" \" ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to print segregated array"
    },
    {
        "py": "arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE segregate0and1 ( arr , n ) NEW_LINE print_arr ( arr , n ) NEW_LINE",
        "explain": "Driver function"
    },
    {
        "py": "def segregate0and1 ( arr , size ) : NEW_LINE",
        "explain": "Function to put all 0 s on left and all 1 s on right"
    },
    {
        "py": "left , right = 0 , size - 1 NEW_LINE while left < right : NEW_LINE",
        "explain": "Initialize left and right indexes"
    },
    {
        "py": "while arr [ left ] == 0 and left < right : NEW_LINE INDENT left += 1 NEW_LINE DEDENT",
        "explain": "Increment left index while we see 0 at left"
    },
    {
        "py": "while arr [ right ] == 1 and left < right : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT",
        "explain": "Decrement right index while we see 1 at right"
    },
    {
        "py": "if left < right : NEW_LINE INDENT arr [ left ] = 0 NEW_LINE arr [ right ] = 1 NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return arr NEW_LINE",
        "explain": "If left is smaller than right then there is a 1 at left and a 0 at right . Exchange arr [ left ] and arr [ right ]"
    },
    {
        "py": "arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE print ( \" Array \u2581 after \u2581 segregation \" ) NEW_LINE print ( segregate0and1 ( arr , arr_size ) ) NEW_LINE",
        "explain": "driver program to test"
    },
    {
        "py": "def segregate0and1 ( arr , size ) : NEW_LINE INDENT type0 = 0 NEW_LINE type1 = size - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT ( arr [ type0 ] , arr [ type1 ] ) = ( arr [ type1 ] , arr [ type0 ] ) NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to put all 0 s on left and all 1 s on right"
    },
    {
        "py": "arr = [ 0 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE segregate0and1 ( arr , arr_size ) NEW_LINE print ( \" Array \u2581 after \u2581 segregation \u2581 is \" , end = \" \u2581 \" ) NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def distantAdjacentElement ( a , n ) : NEW_LINE",
        "explain": "Python program to check if we can make neighbors distinct ."
    },
    {
        "py": "m = dict ( ) NEW_LINE",
        "explain": "dict used to count the frequency of each element occurring in the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if a [ i ] in m : NEW_LINE INDENT m [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ a [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "In this loop we count the frequency of element through map m"
    },
    {
        "py": "mx = 0 NEW_LINE",
        "explain": "mx store the frequency of element which occurs most in array ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if mx < m [ a [ i ] ] : NEW_LINE INDENT mx = m [ a [ i ] ] NEW_LINE DEDENT DEDENT",
        "explain": "In this loop we calculate the maximum frequency and store it in variable mx ."
    },
    {
        "py": "if mx > ( n + 1 ) // 2 : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT",
        "explain": "By swapping we can adjust array only when the frequency of the element which occurs most is less than or equal to ( n + 1 ) / 2 ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 7 , 7 , 7 ] NEW_LINE n = len ( a ) NEW_LINE distantAdjacentElement ( a , n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxIndexDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = n - 1 NEW_LINE while ( j > i ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] and maxDiff < ( j - i ) : NEW_LINE INDENT maxDiff = j - i NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT return maxDiff NEW_LINE DEDENT",
        "explain": "For a given array arr [ ] , returns the maximum j a i such that arr [ j ] > arr [ i ]"
    },
    {
        "py": "arr = [ 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE maxDiff = maxIndexDiff ( arr , n ) NEW_LINE print ( maxDiff ) NEW_LINE",
        "explain": "driver code"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT v = [ 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 ] ; NEW_LINE n = len ( v ) ; NEW_LINE maxFromEnd = [ - 38749432 ] * ( n + 1 ) ; NEW_LINE DEDENT",
        "explain": "For a given array arr , calculates the maximum j a i such that arr [ j ] > arr [ i ]"
    },
    {
        "py": "for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT maxFromEnd [ i ] = max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; NEW_LINE DEDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT low = i + 1 ; high = n - 1 ; ans = i ; NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) ; NEW_LINE if ( v [ i ] <= maxFromEnd [ mid ] ) : NEW_LINE DEDENT DEDENT",
        "explain": "Create an array maxfromEnd"
    },
    {
        "py": "ans = max ( ans , mid ) ; NEW_LINE low = mid + 1 ; NEW_LINE else : NEW_LINE high = mid - 1 ; NEW_LINE",
        "explain": "We store this as current answer and look for further larger number to the right side"
    },
    {
        "py": "result = max ( result , ans - i ) ; NEW_LINE print ( result , end = \" \" ) ; NEW_LINE",
        "explain": "Keeping a track of the maximum difference in indices"
    },
    {
        "py": "def printRepeating ( arr , size ) : NEW_LINE",
        "explain": "Python3 program to print sorted distinct elements ."
    },
    {
        "py": "s = set ( ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Create a set using array elements"
    },
    {
        "py": "for i in s : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print contents of the set ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE printRepeating ( arr , size ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minSwapsToSort ( arr , n ) : NEW_LINE",
        "explain": "Function returns the minimum number of swaps required to sort the array This method is taken from below post https : www . geeksforgeeks . org / minimum - number - swaps - required - sort - array /"
    },
    {
        "py": "arrPos = [ [ 0 for x in range ( 2 ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT arrPos [ i ] [ 0 ] = arr [ i ] NEW_LINE arrPos [ i ] [ 1 ] = i NEW_LINE DEDENT",
        "explain": "Create an array of pairs where first element is array element and second element is position of first element"
    },
    {
        "py": "arrPos . sort ( ) NEW_LINE",
        "explain": "Sort the array by array element values to get right position of every element as second element of pair ."
    },
    {
        "py": "vis = [ False ] * ( n ) NEW_LINE",
        "explain": "To keep track of visited elements . Initialize all elements as not visited or false ."
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse array elements"
    },
    {
        "py": "if ( vis [ i ] or arrPos [ i ] [ 1 ] == i ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Already swapped and corrected or already present at correct pos"
    },
    {
        "py": "cycle_size = 0 NEW_LINE j = i NEW_LINE while ( not vis [ j ] ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE DEDENT",
        "explain": "Find out the number of node in this cycle and add in ans"
    },
    {
        "py": "j = arrPos [ j ] [ 1 ] NEW_LINE cycle_size += 1 NEW_LINE",
        "explain": "Move to next node"
    },
    {
        "py": "ans += ( cycle_size - 1 ) NEW_LINE",
        "explain": "Update answer by adding current cycle ."
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return result"
    },
    {
        "py": "def minSwapToMakeArraySame ( a , b , n ) : NEW_LINE",
        "explain": "Method returns minimum number of swap to mak array B same as array A"
    },
    {
        "py": "mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ b [ i ] ] = i NEW_LINE DEDENT",
        "explain": "map to store position of elements in array B we basically store element to index mapping ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT b [ i ] = mp [ a [ i ] ] NEW_LINE DEDENT",
        "explain": "now we 're storing position  of array A elements  in array B."
    },
    {
        "py": "return minSwapsToSort ( b , n ) NEW_LINE",
        "explain": "Returing minimum swap for sorting in modified array B as final answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 3 , 6 , 4 , 8 ] NEW_LINE b = [ 4 , 6 , 8 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minSwapToMakeArraySame ( a , b , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def missingK ( a , k , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE count = k NEW_LINE flag = 0 NEW_LINE DEDENT",
        "explain": "Function to find k - th missing element"
    },
    {
        "py": "for i in range ( 0 , n - 1 ) : NEW_LINE INDENT difference = 0 NEW_LINE DEDENT",
        "explain": "interating over the array"
    },
    {
        "py": "if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) : NEW_LINE",
        "explain": "check if i - th and ( i + 1 ) - th element are not consecutive"
    },
    {
        "py": "difference += ( a [ i + 1 ] - a [ i ] ) - 1 NEW_LINE",
        "explain": "save their difference"
    },
    {
        "py": "if ( difference >= count ) : NEW_LINE INDENT ans = a [ i ] + count NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT count -= difference NEW_LINE DEDENT",
        "explain": "check for difference and given k"
    },
    {
        "py": "if ( flag ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "if found"
    },
    {
        "py": "a = [ 1 , 5 , 11 , 19 ] NEW_LINE",
        "explain": "Input array"
    },
    {
        "py": "k = 11 NEW_LINE n = len ( a ) NEW_LINE",
        "explain": "k - th missing element to be found in the array"
    },
    {
        "py": "missing = missingK ( a , k , n ) NEW_LINE print ( missing ) NEW_LINE",
        "explain": "calling function to find missing element"
    },
    {
        "py": "def missingK ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE l = 0 NEW_LINE u = n - 1 NEW_LINE mid = 0 NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = ( l + u ) // 2 ; NEW_LINE numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to find kth missing number"
    },
    {
        "py": "if ( numbers_less_than_mid == k ) : NEW_LINE",
        "explain": "If the total missing number count is equal to k we can iterate backwards for the first missing number and that will be the answer ."
    },
    {
        "py": "if ( mid > 0 and ( arr [ mid - 1 ] - ( mid ) ) == k ) : NEW_LINE INDENT u = mid - 1 ; NEW_LINE continue ; NEW_LINE DEDENT",
        "explain": "To further optimize we check if the previous element ' s \u2581 \u2581 missing \u2581 number \u2581 count \u2581 is \u2581 equal \u2581 \u2581 to \u2581 k . \u2581 Eg : \u2581 arr \u2581 = \u2581 [ 4,5,6,7,8 ] \u2581 \u2581 If \u2581 you \u2581 observe \u2581 in \u2581 the \u2581 example \u2581 array , \u2581 \u2581 the \u2581 total \u2581 count \u2581 of \u2581 missing \u2581 numbers \u2581 for \u2581 all \u2581 \u2581 the \u2581 indices \u2581 are \u2581 same , \u2581 and \u2581 we \u2581 are \u2581 \u2581 aiming \u2581 to \u2581 narrow \u2581 down \u2581 the \u2581 \u2581 search \u2581 window \u2581 and \u2581 achieve \u2581 O ( logn ) \u2581 \u2581 time \u2581 complexity \u2581 which \u2581 \u2581 otherwise \u2581 would ' ve been O ( n ) ."
    },
    {
        "py": "return arr [ mid ] - 1 ; NEW_LINE",
        "explain": "Else we return arr [ mid ] - 1."
    },
    {
        "py": "if ( numbers_less_than_mid < k ) : NEW_LINE l = mid + 1 ; NEW_LINE elif ( k < numbers_less_than_mid ) : NEW_LINE u = mid - 1 ; NEW_LINE",
        "explain": "Here we appropriately narrow down the search window ."
    },
    {
        "py": "INDENT if ( u < 0 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT DEDENT",
        "explain": "In case the upper limit is - ve it means the missing number set is 1 , 2 , . . , k and hence we directly return k ."
    },
    {
        "py": "INDENT less = arr [ u ] - ( u + 1 ) ; NEW_LINE k -= less ; NEW_LINE DEDENT",
        "explain": "Else we find the residual count of numbers which we 'd then add to  arr[u] and get the missing kth number."
    },
    {
        "py": "INDENT return arr [ u ] + k ; NEW_LINE DEDENT",
        "explain": "Return arr [ u ] + k"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 7 , 11 ] ; NEW_LINE k = 5 ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( \" Missing \u2581 kth \u2581 number \u2581 = \u2581 \" + str ( missingK ( arr , k ) ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT",
        "explain": "Link list node"
    },
    {
        "py": "def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" \" ) NEW_LINE DEDENT",
        "explain": "A utility function to print linked list"
    },
    {
        "py": "def newNode ( key ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = key NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT",
        "explain": "Function to create newNode in a linkedlist"
    },
    {
        "py": "def insertBeg ( head , val ) : NEW_LINE INDENT temp = newNode ( val ) NEW_LINE temp . next = head NEW_LINE head = temp NEW_LINE return head NEW_LINE DEDENT",
        "explain": "Function to insert at beginning"
    },
    {
        "py": "def rearrangeOddEven ( head ) : NEW_LINE INDENT odd = [ ] NEW_LINE even = [ ] NEW_LINE i = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( head . data % 2 != 0 and i % 2 == 0 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to rearrange the odd and even nodes"
    },
    {
        "py": "odd . append ( head ) NEW_LINE elif ( head . data % 2 == 0 and i % 2 != 0 ) : NEW_LINE",
        "explain": "Odd Value in Even Position Add pointer to current node in odd stack"
    },
    {
        "py": "even . append ( head ) NEW_LINE head = head . next NEW_LINE i = i + 1 NEW_LINE while ( len ( odd ) != 0 and len ( even ) != 0 ) : NEW_LINE",
        "explain": "Even Value in Odd Position Add pointer to current node in even stack"
    },
    {
        "py": "odd [ - 1 ] . data , even [ - 1 ] . data = even [ - 1 ] . data , odd [ - 1 ] . data NEW_LINE odd . pop ( ) NEW_LINE even . pop ( ) NEW_LINE return head NEW_LINE",
        "explain": "Swap Data at the top of two stacks"
    },
    {
        "py": "head = newNode ( 8 ) NEW_LINE head = insertBeg ( head , 7 ) NEW_LINE head = insertBeg ( head , 6 ) NEW_LINE head = insertBeg ( head , 5 ) NEW_LINE head = insertBeg ( head , 3 ) NEW_LINE head = insertBeg ( head , 2 ) NEW_LINE head = insertBeg ( head , 1 ) NEW_LINE print ( \" Linked \u2581 List : \" ) NEW_LINE printList ( head ) NEW_LINE rearrangeOddEven ( head ) NEW_LINE print ( \" Linked \u2581 List \u2581 after \u2581 \" , \" Rearranging : \" ) NEW_LINE printList ( head ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . data = 0 NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Structure node"
    },
    {
        "py": "def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE node = node . next NEW_LINE DEDENT print ( \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "A utility function to print linked list"
    },
    {
        "py": "def newNode ( key ) : NEW_LINE INDENT temp = Node ( ) NEW_LINE temp . data = key NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT",
        "explain": "Function to create newNode in a linkedlist"
    },
    {
        "py": "def insertBeg ( head , val ) : NEW_LINE INDENT temp = newNode ( val ) NEW_LINE temp . next = head NEW_LINE head = temp NEW_LINE return head NEW_LINE DEDENT",
        "explain": "Function to insert at beginning"
    },
    {
        "py": "def rearrange ( head ) : NEW_LINE",
        "explain": "Function to rearrange the odd and even nodes"
    },
    {
        "py": "even = None NEW_LINE temp = None NEW_LINE prev_temp = None NEW_LINE i = None NEW_LINE j = None NEW_LINE k = None NEW_LINE l = None NEW_LINE ptr = None NEW_LINE",
        "explain": "Step 1 : Segregate even and odd nodes Step 2 : Split odd and even lists Step 3 : Merge even list into odd list"
    },
    {
        "py": "temp = ( head ) . next NEW_LINE prev_temp = head NEW_LINE while ( temp != None ) : NEW_LINE",
        "explain": "Step 1 : Segregate Odd and Even Nodes"
    },
    {
        "py": "x = temp . next NEW_LINE",
        "explain": "Backup next pointer of temp"
    },
    {
        "py": "if ( temp . data % 2 != 0 ) : NEW_LINE INDENT prev_temp . next = x NEW_LINE temp . next = ( head ) NEW_LINE ( head ) = temp NEW_LINE DEDENT else : NEW_LINE INDENT prev_temp = temp NEW_LINE DEDENT",
        "explain": "If temp is odd move the node to beginning of list"
    },
    {
        "py": "temp = x NEW_LINE",
        "explain": "Advance Temp Pointer"
    },
    {
        "py": "temp = ( head ) . next NEW_LINE prev_temp = ( head ) NEW_LINE while ( temp != None and temp . data % 2 != 0 ) : NEW_LINE INDENT prev_temp = temp NEW_LINE temp = temp . next NEW_LINE DEDENT even = temp NEW_LINE",
        "explain": "Step 2 Split the List into Odd and even"
    },
    {
        "py": "prev_temp . next = None NEW_LINE",
        "explain": "End the odd List ( Make last node None )"
    },
    {
        "py": "i = head NEW_LINE j = even NEW_LINE while ( j != None and i != None ) : NEW_LINE",
        "explain": "Step 3 : Merge Even List into odd"
    },
    {
        "py": "k = i . next NEW_LINE l = j . next NEW_LINE i . next = j NEW_LINE j . next = k NEW_LINE",
        "explain": "While both lists are not exhausted Backup next pointers of i and j"
    },
    {
        "py": "ptr = j NEW_LINE",
        "explain": "ptr points to the latest node added"
    },
    {
        "py": "i = k NEW_LINE j = l NEW_LINE if ( i == None ) : NEW_LINE",
        "explain": "Advance i and j pointers"
    },
    {
        "py": "ptr . next = j NEW_LINE",
        "explain": "Odd list exhausts before even , append remainder of even list to odd ."
    },
    {
        "py": "return head NEW_LINE",
        "explain": "The case where even list exhausts before odd list is automatically handled since we merge the even list into the odd list"
    },
    {
        "py": "head = newNode ( 8 ) NEW_LINE head = insertBeg ( head , 7 ) NEW_LINE head = insertBeg ( head , 6 ) NEW_LINE head = insertBeg ( head , 3 ) NEW_LINE head = insertBeg ( head , 5 ) NEW_LINE head = insertBeg ( head , 1 ) NEW_LINE head = insertBeg ( head , 2 ) NEW_LINE head = insertBeg ( head , 10 ) NEW_LINE print ( \" Linked \u2581 List : \" ) NEW_LINE printList ( head ) NEW_LINE print ( \" Rearranged \u2581 List \" ) NEW_LINE head = rearrange ( head ) NEW_LINE printList ( head ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printMat ( mat ) : NEW_LINE",
        "explain": "Function to print the matrix"
    },
    {
        "py": "for i in range ( len ( mat ) ) : NEW_LINE",
        "explain": "Iterate over the rows"
    },
    {
        "py": "for j in range ( len ( mat [ 0 ] ) ) : NEW_LINE",
        "explain": "Iterate over the columns"
    },
    {
        "py": "print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE print ( ) NEW_LINE",
        "explain": "Print the value"
    },
    {
        "py": "def performSwap ( mat , i , j ) : NEW_LINE INDENT N = len ( mat ) NEW_LINE DEDENT",
        "explain": "Function to perform the swapping of matrix elements in clockwise manner"
    },
    {
        "py": "ei = N - 1 - i NEW_LINE",
        "explain": "Stores the last row"
    },
    {
        "py": "ej = N - 1 - j NEW_LINE",
        "explain": "Stores the last column"
    },
    {
        "py": "temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ ej ] [ i ] NEW_LINE mat [ ej ] [ i ] = mat [ ei ] [ ej ] NEW_LINE mat [ ei ] [ ej ] = mat [ j ] [ ei ] NEW_LINE mat [ j ] [ ei ] = temp NEW_LINE",
        "explain": "Perform the swaps"
    },
    {
        "py": "def rotate ( mat , N , K ) : NEW_LINE",
        "explain": "Function to rotate non - diagonal elements of the matrix K times in clockwise direction"
    },
    {
        "py": "K = K % 4 NEW_LINE",
        "explain": "Update K to K % 4"
    },
    {
        "py": "while ( K > 0 ) : NEW_LINE",
        "explain": "Iterate until K is positive"
    },
    {
        "py": "for i in range ( int ( N / 2 ) ) : NEW_LINE",
        "explain": "Iterate each up to N / 2 - th row"
    },
    {
        "py": "for j in range ( i , N - i - 1 ) : NEW_LINE",
        "explain": "Iterate each column from i to N - i - 1"
    },
    {
        "py": "if ( i != j and ( i + j ) != N - 1 ) : NEW_LINE",
        "explain": "Check if the element at i , j is not a diagonal element"
    },
    {
        "py": "performSwap ( mat , i , j ) NEW_LINE K -= 1 NEW_LINE",
        "explain": "Perform the swapping"
    },
    {
        "py": "printMat ( mat ) NEW_LINE",
        "explain": "Print the matrix"
    },
    {
        "py": "K = 5 NEW_LINE mat = [ [ 1 , 2 , 3 , 4 ] , [ 6 , 7 , 8 , 9 ] , [ 11 , 12 , 13 , 14 ] , [ 16 , 17 , 18 , 19 ] ] NEW_LINE N = len ( mat ) NEW_LINE rotate ( mat , N , K ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findRotations ( str ) : NEW_LINE",
        "explain": "Returns count of rotations to get the same string back ."
    },
    {
        "py": "tmp = str + str NEW_LINE n = len ( str ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "tmp is the concatenated string ."
    },
    {
        "py": "substring = tmp [ i : i + n ] NEW_LINE",
        "explain": "substring from i index of original string size ."
    },
    {
        "py": "if ( str == substring ) : NEW_LINE INDENT return i NEW_LINE DEDENT return n NEW_LINE",
        "explain": "if substring matches with original string then we will come out of the loop ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" abc \" NEW_LINE print ( findRotations ( str ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 10000 NEW_LINE",
        "explain": "Python3 implementation to find elements that are a power of two"
    },
    {
        "py": "prefix = [ 0 ] * ( MAX + 1 ) NEW_LINE def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x and ( not ( x & ( x - 1 ) ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "prefix [ i ] is going to store the number of elements which are a power of two till i ( including i ) ."
    },
    {
        "py": "def computePrefix ( n , a ) : NEW_LINE",
        "explain": "Function to find the maximum range whose sum is divisible by M ."
    },
    {
        "py": "if ( isPowerOfTwo ( a [ 0 ] ) ) : NEW_LINE INDENT prefix [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] NEW_LINE if ( isPowerOfTwo ( a [ i ] ) ) : NEW_LINE INDENT prefix [ i ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Calculate the prefix sum"
    },
    {
        "py": "def query ( L , R ) : NEW_LINE INDENT return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT",
        "explain": "Function to return the number of elements which are a power of two in a subarray"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 8 , 5 , 2 , 5 , 10 ] NEW_LINE N = len ( A ) NEW_LINE Q = 2 NEW_LINE computePrefix ( N , A ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 3 , 5 ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countIntgralPoints ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) NEW_LINE DEDENT",
        "explain": "Function to calculate the integral points inside a square"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 1 NEW_LINE y1 = 1 NEW_LINE x2 = 4 NEW_LINE y2 = 4 NEW_LINE countIntgralPoints ( x1 , y1 , x2 , y2 ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findNextNumber ( n ) : NEW_LINE INDENT h = [ 0 for i in range ( 10 ) ] NEW_LINE i = 0 NEW_LINE msb = n NEW_LINE rem = 0 NEW_LINE next_num = - 1 NEW_LINE count = 0 NEW_LINE DEDENT",
        "explain": "Function to find the next distinct digits number"
    },
    {
        "py": "while ( msb > 9 ) : NEW_LINE INDENT rem = msb % 10 NEW_LINE h [ rem ] = 1 NEW_LINE msb //= 10 NEW_LINE count += 1 NEW_LINE DEDENT h [ msb ] = 1 NEW_LINE count += 1 NEW_LINE",
        "explain": "Loop to find the distinct digits using hash array and the number of digits"
    },
    {
        "py": "for i in range ( msb + 1 , 10 , 1 ) : NEW_LINE INDENT if ( h [ i ] == 0 ) : NEW_LINE INDENT next_num = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Loop to find the most significant distinct digit of the next number"
    },
    {
        "py": "if ( next_num == - 1 ) : NEW_LINE INDENT for i in range ( 1 , msb , 1 ) : NEW_LINE INDENT if ( h [ i ] == 0 ) : NEW_LINE INDENT next_num = i NEW_LINE count += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Condition to check if the number is possible with the same number of digits count"
    },
    {
        "py": "if ( next_num > 0 ) : NEW_LINE",
        "explain": "Condition to check if the desired most siginificant distinct digit is found"
    },
    {
        "py": "for i in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( h [ i ] == 0 ) : NEW_LINE INDENT msb = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Loop to find the minimum next digit which is not present in the number"
    },
    {
        "py": "for i in range ( 1 , count , 1 ) : NEW_LINE INDENT next_num = ( ( next_num * 10 ) + msb ) NEW_LINE DEDENT",
        "explain": "Computation of the number"
    },
    {
        "py": "if ( next_num > n ) : NEW_LINE INDENT print ( next_num ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE DEDENT else : NEW_LINE print ( \" Not \u2581 Possible \" ) NEW_LINE",
        "explain": "Condition to check if the number is greater than the given number"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2019 NEW_LINE findNextNumber ( n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def CalculateValues ( N ) : NEW_LINE",
        "explain": "Function to find a triplet ( A , B , C ) such that 3 * A + 5 * B + 7 * C is N"
    },
    {
        "py": "for C in range ( 0 , N // 7 + 1 ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , N7 ]"
    },
    {
        "py": "for B in range ( 0 , N // 5 + 1 ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , N5 ]"
    },
    {
        "py": "A = N - 7 * C - 5 * B NEW_LINE",
        "explain": "Find the value of A"
    },
    {
        "py": "if ( A >= 0 and A % 3 == 0 ) : NEW_LINE INDENT print ( \" A \u2581 = \" , A / 3 , \" , \u2581 B \u2581 = \" , B , \" , \u2581 \\ \u2581 C \u2581 = \" , C , sep = \" \u2581 \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If A is greater than or equal to 0 and divisible by 3"
    },
    {
        "py": "print ( - 1 ) NEW_LINE return NEW_LINE",
        "explain": "Otherwise , print - 1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 19 NEW_LINE CalculateValues ( 19 ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minimumTime ( arr , n ) : NEW_LINE",
        "explain": "Function to find the minimum time to visit all the cities such that both the person never meets"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Initialize sum as 0"
    },
    {
        "py": "T = max ( arr ) NEW_LINE",
        "explain": "Find the maximum element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "sum += arr [ i ] NEW_LINE",
        "explain": "Increment sum by arr [ i ]"
    },
    {
        "py": "print ( max ( 2 * T , sum ) ) NEW_LINE",
        "explain": "Prmaximum of 2 * T and sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 8 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "minimumTime ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def lexicographicallyMax ( s ) : NEW_LINE",
        "explain": "Function to find the lexicographically maximum string by reversing substrings having even numbers of 1 s"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "Store size of string"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the string"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Count the number of 1 s"
    },
    {
        "py": "beg = i NEW_LINE",
        "explain": "Stores the starting index"
    },
    {
        "py": "end = i NEW_LINE",
        "explain": "Stores the end index"
    },
    {
        "py": "if ( s [ i ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Increment count , when 1 is encountered"
    },
    {
        "py": "for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( s [ j ] == '1' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count % 2 == 0 and count != 0 ) : NEW_LINE INDENT end = j NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the remaining string"
    },
    {
        "py": "temp = s [ beg : end + 1 ] NEW_LINE temp = temp [ : : - 1 ] NEW_LINE s = s [ 0 : beg ] + temp + s [ end + 1 : ] NEW_LINE",
        "explain": "temp is for Reverse the string from starting and end index"
    },
    {
        "py": "print ( s ) NEW_LINE",
        "explain": "Printing the string"
    },
    {
        "py": "S = \"0101\" NEW_LINE lexicographicallyMax ( S ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def maxPairs ( nums , k ) : NEW_LINE",
        "explain": "Function to count the maximum number of pairs from given array with sum K"
    },
    {
        "py": "nums = sorted ( nums ) NEW_LINE",
        "explain": "Sort array in increasing order"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Stores the final result"
    },
    {
        "py": "start , end = 0 , len ( nums ) - 1 NEW_LINE",
        "explain": "Initialize the left and right pointers"
    },
    {
        "py": "while ( start < end ) : NEW_LINE INDENT if ( nums [ start ] + nums [ end ] > k ) : NEW_LINE DEDENT",
        "explain": "Traverse array until start < end"
    },
    {
        "py": "end -= 1 NEW_LINE elif ( nums [ start ] + nums [ end ] < k ) : NEW_LINE",
        "explain": "Decrement right by 1"
    },
    {
        "py": "start += 1 NEW_LINE",
        "explain": "Increment left by 1"
    },
    {
        "py": "else : NEW_LINE INDENT start += 1 NEW_LINE end -= 1 NEW_LINE result += 1 NEW_LINE DEDENT",
        "explain": "Increment result and left pointer by 1 and decrement right pointer by 1"
    },
    {
        "py": "print ( result ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 5 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "maxPairs ( arr , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def maxPairs ( nums , k ) : NEW_LINE",
        "explain": "Function to find the maximum number of pairs with a sum K such that same element can 't be used twice"
    },
    {
        "py": "m = { } NEW_LINE",
        "explain": "Initialize a hashm"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Store the final result"
    },
    {
        "py": "for i in nums : NEW_LINE",
        "explain": "Iterate over the array nums [ ]"
    },
    {
        "py": "if ( ( i in m ) and m [ i ] > 0 ) : NEW_LINE INDENT m [ i ] = m [ i ] - 1 NEW_LINE result += 1 NEW_LINE DEDENT",
        "explain": "Decrement its frequency in m and increment the result by 1"
    },
    {
        "py": "else : NEW_LINE INDENT if k - i in m : NEW_LINE INDENT m [ k - i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ k - i ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Increment its frequency by 1 if it is already present in m . Otherwise , set its frequency to 1"
    },
    {
        "py": "print ( result ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 5 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "maxPairs ( arr , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def removeIndicesToMakeSumEqual ( arr ) : NEW_LINE",
        "explain": "Function to find indices of array elements whose removal makes the sum of odd and even indexed array elements equal"
    },
    {
        "py": "N = len ( arr ) ; NEW_LINE",
        "explain": "Stores size of array"
    },
    {
        "py": "odd = [ 0 ] * N ; NEW_LINE",
        "explain": "Store prefix sum of odd index array elements"
    },
    {
        "py": "even = [ 0 ] * N ; NEW_LINE",
        "explain": "Store prefix sum of even index array elements"
    },
    {
        "py": "even [ 0 ] = arr [ 0 ] ; NEW_LINE",
        "explain": "Update even [ 0 ]"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Traverse the given array"
    },
    {
        "py": "odd [ i ] = odd [ i - 1 ] ; NEW_LINE",
        "explain": "Update odd [ i ]"
    },
    {
        "py": "even [ i ] = even [ i - 1 ] ; NEW_LINE",
        "explain": "Update even [ i ]"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE",
        "explain": "If the current index is an even number"
    },
    {
        "py": "even [ i ] += arr [ i ] ; NEW_LINE",
        "explain": "Update even [ i ]"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If the current index is an odd number"
    },
    {
        "py": "odd [ i ] += arr [ i ] ; NEW_LINE",
        "explain": "Update odd [ i ]"
    },
    {
        "py": "find = False ; NEW_LINE",
        "explain": "Check if at least one index found or not that satisfies the condition"
    },
    {
        "py": "p = odd [ N - 1 ] ; NEW_LINE",
        "explain": "Store odd indices sum by removing 0 - th index"
    },
    {
        "py": "q = even [ N - 1 ] - arr [ 0 ] ; NEW_LINE",
        "explain": "Store even indices sum by removing 0 - th index"
    },
    {
        "py": "if ( p == q ) : NEW_LINE INDENT print ( \"0 \u2581 \" ) ; NEW_LINE find = True ; NEW_LINE DEDENT",
        "explain": "If p and q are equal"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Traverse the array arr"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE",
        "explain": "If i is an even number"
    },
    {
        "py": "p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; NEW_LINE",
        "explain": "Update p by removing the i - th element"
    },
    {
        "py": "q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; NEW_LINE else : NEW_LINE",
        "explain": "Update q by removing the i - th element"
    },
    {
        "py": "q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; NEW_LINE",
        "explain": "Update q by removing the i - th element"
    },
    {
        "py": "p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; NEW_LINE",
        "explain": "Update p by removing the i - th element"
    },
    {
        "py": "if ( p == q ) : NEW_LINE",
        "explain": "If odd index values sum is equal to even index values sum"
    },
    {
        "py": "find = True ; NEW_LINE",
        "explain": "Set the find variable"
    },
    {
        "py": "print ( i , end = \" \" ) ; NEW_LINE",
        "explain": "Print the current index"
    },
    {
        "py": "if ( find == False ) : NEW_LINE",
        "explain": "If no index found"
    },
    {
        "py": "print ( - 1 ) ; NEW_LINE",
        "explain": "Print not possible"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 6 , 2 ] ; NEW_LINE removeIndicesToMakeSumEqual ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def min_element_removal ( arr , N ) : NEW_LINE",
        "explain": "Function to coutnt minimum array elements required to be removed to make an array bitonic"
    },
    {
        "py": "left = [ 1 ] * N NEW_LINE",
        "explain": "left [ i ] : Stores the length of LIS up to i - th index"
    },
    {
        "py": "right = [ 1 ] * ( N ) NEW_LINE",
        "explain": "right [ i ] : Stores the length of decreasing subsequence over the range [ i , N ]"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Calculate the length of LIS up to i - th index"
    },
    {
        "py": "for j in range ( i ) : NEW_LINE",
        "explain": "Traverse the array upto i - th index"
    },
    {
        "py": "if ( arr [ j ] < arr [ i ] ) : NEW_LINE",
        "explain": "If arr [ j ] is less than arr [ i ]"
    },
    {
        "py": "left [ i ] = max ( left [ i ] , left [ j ] + 1 ) NEW_LINE",
        "explain": "Update left [ i ]"
    },
    {
        "py": "for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Calculate the length of decreasing subsequence over the range [ i , N ]"
    },
    {
        "py": "for j in range ( N - 1 , i , - 1 ) : NEW_LINE",
        "explain": "Traverse right [ ] array"
    },
    {
        "py": "if ( arr [ i ] > arr [ j ] ) : NEW_LINE",
        "explain": "If arr [ i ] is greater than arr [ j ]"
    },
    {
        "py": "right [ i ] = max ( right [ i ] , right [ j ] + 1 ) NEW_LINE",
        "explain": "Update right [ i ]"
    },
    {
        "py": "maxLen = 0 NEW_LINE",
        "explain": "Stores length of the longest bitonic array"
    },
    {
        "py": "for i in range ( 1 , N - 1 ) : NEW_LINE",
        "explain": "Traverse left [ ] and right [ ] array"
    },
    {
        "py": "maxLen = max ( maxLen , left [ i ] + right [ i ] - 1 ) NEW_LINE print ( ( N - maxLen ) ) NEW_LINE",
        "explain": "Update maxLen"
    },
    {
        "py": "def makeBitonic ( arr , N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE return NEW_LINE DEDENT if ( N == 2 ) : NEW_LINE INDENT if ( arr [ 0 ] != arr [ 1 ] ) : NEW_LINE INDENT print ( \"0\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"1\" ) NEW_LINE DEDENT return NEW_LINE DEDENT min_element_removal ( arr , N ) NEW_LINE DEDENT",
        "explain": "Function to prminimum removals required to make given array bitonic"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE makeBitonic ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countSubarrays ( A , N ) : NEW_LINE",
        "explain": "Function to count subarrays having equal count of 0 s and 1 s with all 0 s and all 1 s grouped together"
    },
    {
        "py": "ans = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE",
        "explain": "Stores the count of subarrays"
    },
    {
        "py": "if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE",
        "explain": "If current element is different from the next array element"
    },
    {
        "py": "ans += 1 ; NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "j = i - 1 ; k = i + 2 ; NEW_LINE while ( j >= 0 and k < N and A [ j ] == A [ i ] and A [ k ] == A [ i + 1 ] ) : NEW_LINE",
        "explain": "Count the frequency of 1 s and 0 s"
    },
    {
        "py": "ans += 1 ; NEW_LINE j -= 1 ; NEW_LINE k += 1 ; NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "print ( ans ) ; NEW_LINE",
        "explain": "Print the final count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 1 , 0 , 0 , 1 , 0 ] ; NEW_LINE N = len ( A ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "countSubarrays ( A , N ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "maxN = 2002 NEW_LINE",
        "explain": "Python3 program of the above approach"
    },
    {
        "py": "lcount = [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] NEW_LINE",
        "explain": "lcount [ i ] [ j ] : Stores the count of i on left of index j"
    },
    {
        "py": "rcount = [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] NEW_LINE",
        "explain": "rcount [ i ] [ j ] : Stores the count of i on right of index j"
    },
    {
        "py": "def fill_counts ( a , n ) : NEW_LINE",
        "explain": "Function to count unique elements on left and right of any index"
    },
    {
        "py": "maxA = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > maxA ) : NEW_LINE INDENT maxA = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT lcount [ a [ i ] ] [ i ] = 1 NEW_LINE rcount [ a [ i ] ] [ i ] = 1 NEW_LINE DEDENT for i in range ( maxA + 1 ) : NEW_LINE",
        "explain": "Find the maximum array element"
    },
    {
        "py": "for j in range ( n ) : NEW_LINE INDENT lcount [ i ] [ j ] = ( lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ) NEW_LINE DEDENT",
        "explain": "Calculate prefix sum of counts of each value"
    },
    {
        "py": "for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rcount [ i ] [ j ] = ( rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ) NEW_LINE DEDENT",
        "explain": "Calculate suffix sum of counts of each value"
    },
    {
        "py": "def countSubsequence ( a , n ) : NEW_LINE INDENT fill_counts ( a , n ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT answer += ( lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT",
        "explain": "Function to count quadruples of the required type"
    },
    {
        "py": "a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] NEW_LINE print ( countSubsequence ( a , 7 ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def removeOuterParentheses ( S ) : NEW_LINE",
        "explain": "Function to remove the outermost parentheses of every primitive substring from the given string"
    },
    {
        "py": "res = \" \" NEW_LINE",
        "explain": "Stores the resultant string"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the count of opened parentheses"
    },
    {
        "py": "for c in S : NEW_LINE",
        "explain": "Traverse the string"
    },
    {
        "py": "if ( c == ' ( ' and count > 0 ) : NEW_LINE",
        "explain": "If opening parenthesis is encountered and their count exceeds 0"
    },
    {
        "py": "res += c NEW_LINE",
        "explain": "Include the character"
    },
    {
        "py": "if ( c == ' ( ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( c == ' ) ' and count > 1 ) : NEW_LINE",
        "explain": "If closing parenthesis is encountered and their count is less than count of opening parentheses"
    },
    {
        "py": "res += c NEW_LINE if ( c == ' ) ' ) : NEW_LINE count -= 1 NEW_LINE",
        "explain": "Include the character"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the resultant string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" ( ( ) ( ) ) ( ( ) ) ( ) \" NEW_LINE print ( removeOuterParentheses ( S ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxiConsecutiveSubarray ( arr , N ) : NEW_LINE",
        "explain": "Function to find the longest subarray with increasing contiguous elements"
    },
    {
        "py": "maxi = 0 ; NEW_LINE for i in range ( N - 1 ) : NEW_LINE",
        "explain": "Stores the length of required longest subarray"
    },
    {
        "py": "cnt = 1 ; NEW_LINE for j in range ( i , N - 1 ) : NEW_LINE",
        "explain": "Stores the length of length of longest such subarray from ith index"
    },
    {
        "py": "if ( arr [ j + 1 ] == arr [ j ] + 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT",
        "explain": "If consecutive elements are increasing and differ by 1"
    },
    {
        "py": "else : NEW_LINE INDENT break ; NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "maxi = max ( maxi , cnt ) ; NEW_LINE i = j ; NEW_LINE",
        "explain": "Update the longest subarray obtained so far"
    },
    {
        "py": "return maxi ; NEW_LINE",
        "explain": "Return the length obtained"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 ; NEW_LINE arr = [ 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 ] ; NEW_LINE print ( maxiConsecutiveSubarray ( arr , N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "N = 100005 NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE",
        "explain": "Function to generate prime numbers using Sieve of Eratosthenes"
    },
    {
        "py": "prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= p_size : NEW_LINE",
        "explain": "Set 0 and 1 as non - prime"
    },
    {
        "py": "if ( prime [ p ] ) : NEW_LINE",
        "explain": "If p is a prime"
    },
    {
        "py": "for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Set all multiples of p as non - prime"
    },
    {
        "py": "def digitSum ( number ) : NEW_LINE",
        "explain": "Function to find the digit sum of a given number"
    },
    {
        "py": "sum = 0 NEW_LINE while ( number > 0 ) : NEW_LINE",
        "explain": "Stores the sum of digits"
    },
    {
        "py": "sum += ( number % 10 ) NEW_LINE number //= 10 NEW_LINE",
        "explain": "Extract digits and add to the sum"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "Return the sum of the digits"
    },
    {
        "py": "def longestCompositeDigitSumSubsequence ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE prime = [ True ] * ( N + 1 ) NEW_LINE SieveOfEratosthenes ( prime , N ) NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "Function to find the longest subsequence with sum of digits of each element equal to a composite number"
    },
    {
        "py": "res = digitSum ( arr [ i ] ) NEW_LINE",
        "explain": "Calculate sum of digits of current array element"
    },
    {
        "py": "if ( res == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If sum of digits equal to 1"
    },
    {
        "py": "if ( not prime [ res ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE",
        "explain": "If sum of digits is a prime"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "longestCompositeDigitSumSubsequence ( arr , n ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT",
        "explain": "Structure of Binary Tree"
    },
    {
        "py": "def newnode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE DEDENT",
        "explain": "Function to create a new node"
    },
    {
        "py": "return temp NEW_LINE",
        "explain": "Return the created node"
    },
    {
        "py": "def insert ( s , i , N , root , temp ) : NEW_LINE INDENT if ( i == N ) : NEW_LINE INDENT return temp NEW_LINE DEDENT DEDENT",
        "explain": "Function to insert a node in the tree"
    },
    {
        "py": "if ( s [ i ] == ' L ' ) : NEW_LINE INDENT root . left = insert ( s , i + 1 , N , root . left , temp ) NEW_LINE DEDENT",
        "explain": "Left insertion"
    },
    {
        "py": "else : NEW_LINE INDENT root . right = insert ( s , i + 1 , N , root . right , temp ) NEW_LINE DEDENT",
        "explain": "Right insertion"
    },
    {
        "py": "return root NEW_LINE",
        "explain": "Return the root node"
    },
    {
        "py": "def SBTUtil ( root , sum ) : NEW_LINE",
        "explain": "Function to find sum of specially balanced nodes in the Tree"
    },
    {
        "py": "if ( root == None ) : NEW_LINE INDENT return [ 0 , sum ] NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return [ root . data , sum ] NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "left , sum = SBTUtil ( root . left , sum ) NEW_LINE",
        "explain": "Find the left subtree sum"
    },
    {
        "py": "right , sum = SBTUtil ( root . right , sum ) NEW_LINE",
        "explain": "Find the right subtree sum"
    },
    {
        "py": "if ( root . left and root . right ) : NEW_LINE",
        "explain": "Condition of specially balanced node"
    },
    {
        "py": "if ( ( left % 2 == 0 and right % 2 != 0 ) or ( left % 2 != 0 and right % 2 == 0 ) ) : NEW_LINE INDENT sum += root . data NEW_LINE DEDENT",
        "explain": "Condition of specially balanced node"
    },
    {
        "py": "return [ left + right + root . data , sum ] NEW_LINE",
        "explain": "Return the sum"
    },
    {
        "py": "def build_tree ( R , N , str , values ) : NEW_LINE",
        "explain": "Function to build the binary tree"
    },
    {
        "py": "root = newnode ( R ) NEW_LINE",
        "explain": "Form root node of the tree"
    },
    {
        "py": "for i in range ( 0 , N - 1 ) : NEW_LINE INDENT s = str [ i ] NEW_LINE x = values [ i ] NEW_LINE DEDENT",
        "explain": "Insert nodes into tree"
    },
    {
        "py": "temp = newnode ( x ) NEW_LINE",
        "explain": "Create a new Node"
    },
    {
        "py": "root = insert ( s , 0 , len ( s ) , root , temp ) NEW_LINE",
        "explain": "Insert the node"
    },
    {
        "py": "return root NEW_LINE",
        "explain": "Return the root of the Tree"
    },
    {
        "py": "def speciallyBalancedNodes ( R , N , str , values ) : NEW_LINE",
        "explain": "Function to find the sum of specially balanced nodes"
    },
    {
        "py": "root = build_tree ( R , N , str , values ) NEW_LINE",
        "explain": "Build Tree"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Stores the sum of specially balanced node"
    },
    {
        "py": "tmp , sum = SBTUtil ( root , sum ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "print ( sum , end = ' \u2581 ' ) NEW_LINE",
        "explain": "Print required sum"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "N = 7 NEW_LINE",
        "explain": "Given nodes"
    },
    {
        "py": "R = 12 NEW_LINE",
        "explain": "Given root"
    },
    {
        "py": "str = [ \" L \" , \" R \" , \" RL \" , \" RR \" , \" RLL \" , \" RLR \" ] NEW_LINE",
        "explain": "Given path info of nodes from root"
    },
    {
        "py": "values = [ 17 , 16 , 4 , 9 , 2 , 3 ] NEW_LINE",
        "explain": "Given node values"
    },
    {
        "py": "speciallyBalancedNodes ( R , N , str , values ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def position ( arr , N ) : NEW_LINE",
        "explain": "Function to find the position of the pair that covers every pair in the array arr"
    },
    {
        "py": "pos = - 1 ; NEW_LINE",
        "explain": "Stores the index of the resultant pair"
    },
    {
        "py": "count = 0 ; NEW_LINE",
        "explain": "To count the occurences"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate to check every pair"
    },
    {
        "py": "count = 0 ; NEW_LINE for j in range ( N ) : NEW_LINE",
        "explain": "Set count to 0"
    },
    {
        "py": "if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] and arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT",
        "explain": "Condition to checked for overlapping of pairs"
    },
    {
        "py": "if ( count == N ) : NEW_LINE INDENT pos = i ; NEW_LINE DEDENT",
        "explain": "If that pair can cover all other pairs then store its position"
    },
    {
        "py": "if ( pos == - 1 ) : NEW_LINE INDENT print ( pos ) ; NEW_LINE DEDENT",
        "explain": "If position not found"
    },
    {
        "py": "else : NEW_LINE INDENT print ( pos + 1 ) ; NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ [ 3 , 3 ] , [ 1 , 3 ] , [ 2 , 2 ] , [ 2 , 3 ] , [ 1 , 2 ] ] ; NEW_LINE N = len ( arr ) ; NEW_LINE",
        "explain": "Given array of pairs"
    },
    {
        "py": "position ( arr , N ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def position ( arr , N ) : NEW_LINE",
        "explain": "Function to find the position of the pair that covers every pair in the array arr [ ] [ ]"
    },
    {
        "py": "pos = - 1 NEW_LINE",
        "explain": "Position to store the index"
    },
    {
        "py": "right = - sys . maxsize - 1 NEW_LINE",
        "explain": "Stores the minimum second value"
    },
    {
        "py": "left = sys . maxsize NEW_LINE",
        "explain": "Stores the maximum first value"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate over the array of pairs"
    },
    {
        "py": "if ( arr [ i ] [ 1 ] > right ) : NEW_LINE INDENT right = arr [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Update right maximum"
    },
    {
        "py": "if ( arr [ i ] [ 0 ] < left ) : NEW_LINE INDENT left = arr [ i ] [ 0 ] NEW_LINE DEDENT",
        "explain": "Update left minimum"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate over the array of pairs"
    },
    {
        "py": "if ( arr [ i ] [ 0 ] == left and arr [ i ] [ 1 ] == right ) : NEW_LINE INDENT pos = i + 1 NEW_LINE DEDENT",
        "explain": "If any pair exists with value { left , right then store it"
    },
    {
        "py": "print ( pos ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ [ 3 , 3 ] , [ 1 , 3 ] , [ 2 , 2 ] , [ 2 , 3 ] , [ 1 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Given array of pairs"
    },
    {
        "py": "position ( arr , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def ctMinEdits ( str1 , str2 ) : NEW_LINE INDENT N1 = len ( str1 ) NEW_LINE N2 = len ( str2 ) NEW_LINE DEDENT",
        "explain": "Function to minimize the count of operations to make str1 and str2 permutations of each other"
    },
    {
        "py": "freq1 = [ 0 ] * 256 NEW_LINE for i in range ( N1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT",
        "explain": "Store the frequency of each character of str1"
    },
    {
        "py": "freq2 = [ 0 ] * 256 NEW_LINE for i in range ( N2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE DEDENT",
        "explain": "Store the frequency of each character of str2"
    },
    {
        "py": "for i in range ( 256 ) : NEW_LINE",
        "explain": "Traverse the freq1 [ ] and freq2 [ ]"
    },
    {
        "py": "if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT freq1 [ i ] = freq1 [ i ] - freq2 [ i ] NEW_LINE freq2 [ i ] = 0 NEW_LINE DEDENT",
        "explain": "If frequency of character in str1 is greater than str2"
    },
    {
        "py": "else : NEW_LINE INDENT freq2 [ i ] = freq2 [ i ] - freq1 [ i ] NEW_LINE freq1 [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "sum1 = 0 NEW_LINE",
        "explain": "Store sum of freq1 [ ]"
    },
    {
        "py": "sum2 = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT sum1 += freq1 [ i ] NEW_LINE sum2 += freq2 [ i ] NEW_LINE DEDENT return max ( sum1 , sum2 ) NEW_LINE",
        "explain": "Store sum of freq2 [ ]"
    },
    {
        "py": "str1 = \" geeksforgeeks \" NEW_LINE str2 = \" geeksforcoder \" NEW_LINE print ( ctMinEdits ( str1 , str2 ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def CountPairs ( a , b , n ) : NEW_LINE",
        "explain": "Function to count the pairs such that given condition is satisfied"
    },
    {
        "py": "C = [ 0 ] * n NEW_LINE",
        "explain": "Stores the sum of element at each corresponding index"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT C [ i ] = a [ i ] + b [ i ] NEW_LINE DEDENT",
        "explain": "Find the sum of each index of both array"
    },
    {
        "py": "freqCount = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if C [ i ] in freqCount . keys ( ) : NEW_LINE INDENT freqCount [ C [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freqCount [ C [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Stores frequency of each element present in sumArr"
    },
    {
        "py": "NoOfPairs = 0 NEW_LINE for x in freqCount : NEW_LINE INDENT y = freqCount [ x ] NEW_LINE DEDENT",
        "explain": "Initialize number of pairs"
    },
    {
        "py": "NoOfPairs = ( NoOfPairs + y * ( y - 1 ) // 2 ) NEW_LINE",
        "explain": "Add possible vaid pairs"
    },
    {
        "py": "print ( NoOfPairs ) NEW_LINE",
        "explain": "Return Number of Pairs"
    },
    {
        "py": "arr = [ 1 , 4 , 20 , 3 , 10 , 5 ] NEW_LINE brr = [ 9 , 6 , 1 , 7 , 11 , 6 ] NEW_LINE",
        "explain": "Given array arr [ ] and brr [ ]"
    },
    {
        "py": "N = len ( arr ) NEW_LINE",
        "explain": "Size of given array"
    },
    {
        "py": "CountPairs ( arr , brr , N ) NEW_LINE",
        "explain": "Function calling"
    },
    {
        "py": "def medianChange ( arr1 , arr2 ) : NEW_LINE INDENT N = len ( arr1 ) NEW_LINE DEDENT",
        "explain": "Function to find the median change after removing elements from arr2 [ ]"
    },
    {
        "py": "median = [ ] NEW_LINE",
        "explain": "To store the median"
    },
    {
        "py": "if ( N & 1 ) : NEW_LINE INDENT median . append ( arr1 [ N // 2 ] * 1 ) NEW_LINE DEDENT",
        "explain": "If N is odd"
    },
    {
        "py": "else : NEW_LINE INDENT median . append ( ( arr1 [ N // 2 ] + arr1 [ ( N - 1 ) // 2 ] ) // 2 ) NEW_LINE DEDENT for x in arr2 : NEW_LINE",
        "explain": "If N is even"
    },
    {
        "py": "it = arr1 . index ( x ) NEW_LINE",
        "explain": "Find the current element in arr1"
    },
    {
        "py": "arr1 . pop ( it ) NEW_LINE",
        "explain": "Erase the element"
    },
    {
        "py": "N -= 1 NEW_LINE",
        "explain": "Decrement N"
    },
    {
        "py": "if ( N & 1 ) : NEW_LINE INDENT median . append ( arr1 [ N // 2 ] * 1 ) NEW_LINE DEDENT",
        "explain": "If N is odd"
    },
    {
        "py": "else : NEW_LINE INDENT median . append ( ( arr1 [ N // 2 ] + arr1 [ ( N - 1 ) // 2 ] ) // 2 ) NEW_LINE DEDENT",
        "explain": "If N is even"
    },
    {
        "py": "for i in range ( len ( median ) - 1 ) : NEW_LINE INDENT print ( median [ i + 1 ] - median [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT",
        "explain": "Print the corresponding difference of median"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr1 = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE arr2 = [ 4 , 6 ] NEW_LINE",
        "explain": "Given arrays"
    },
    {
        "py": "medianChange ( arr1 , arr2 ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "nfa = 1 NEW_LINE",
        "explain": "NFA variable that keeps track of the state while transaction ."
    },
    {
        "py": "flag = 0 NEW_LINE",
        "explain": "This checks for invalid input ."
    },
    {
        "py": "def state1 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q2"
    },
    {
        "py": "if ( c == ' a ' ) : NEW_LINE INDENT nfa = 2 NEW_LINE DEDENT elif ( c == ' b ' or c == ' c ' ) : NEW_LINE INDENT nfa = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' a ' takes to Q4 , and ' b ' and ' c ' remain at Q2"
    },
    {
        "py": "def state2 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q3"
    },
    {
        "py": "if ( c == ' a ' ) : NEW_LINE INDENT nfa = 3 NEW_LINE DEDENT elif ( c == ' b ' or c == ' c ' ) : NEW_LINE INDENT nfa = 2 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' a ' takes to Q3 , and ' b ' and ' c ' remain at Q4"
    },
    {
        "py": "def state3 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q4"
    },
    {
        "py": "if ( c == ' a ' ) : NEW_LINE INDENT nfa = 1 NEW_LINE DEDENT elif ( c == ' b ' or c == ' c ' ) : NEW_LINE INDENT nfa = 3 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' a ' takes to Q2 , and ' b ' and ' c ' remain at Q3"
    },
    {
        "py": "def state4 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q5"
    },
    {
        "py": "if ( c == ' b ' ) : NEW_LINE INDENT nfa = 5 NEW_LINE DEDENT elif ( c == ' a ' or c == ' c ' ) : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' b ' takes to Q6 , and ' a ' and ' c ' remain at Q5"
    },
    {
        "py": "def state5 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q6"
    },
    {
        "py": "if ( c == ' b ' ) : NEW_LINE INDENT nfa = 6 NEW_LINE DEDENT elif ( c == ' a ' or c == ' c ' ) : NEW_LINE INDENT nfa = 5 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' b ' takes to Q7 , and ' a ' and ' c ' remain at Q7"
    },
    {
        "py": "def state6 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q7"
    },
    {
        "py": "if ( c == ' b ' ) : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT elif ( c == ' a ' or c == ' c ' ) : NEW_LINE INDENT nfa = 6 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' b ' takes to Q5 , and ' a ' and ' c ' remain at Q7"
    },
    {
        "py": "def state7 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q8"
    },
    {
        "py": "if ( c == ' c ' ) : NEW_LINE INDENT nfa = 8 NEW_LINE DEDENT elif ( c == ' b ' or c == ' a ' ) : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' c ' takes to Q9 , and ' a ' and ' b ' remain at Q8"
    },
    {
        "py": "def state8 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q9"
    },
    {
        "py": "if ( c == ' c ' ) : NEW_LINE INDENT nfa = 9 NEW_LINE DEDENT elif ( c == ' b ' or c == ' a ' ) : NEW_LINE INDENT nfa = 8 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' c ' takes to Q10 , and ' a ' and ' b ' remain at Q9"
    },
    {
        "py": "def state9 ( c ) : NEW_LINE INDENT global nfa , flag NEW_LINE DEDENT",
        "explain": "Function for the state Q10"
    },
    {
        "py": "if ( c == ' c ' ) : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT elif ( c == ' b ' or c == ' a ' ) : NEW_LINE INDENT nfa = 9 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "State transitions ' c ' takes to Q8 , and ' a ' and ' b ' remain at Q10"
    },
    {
        "py": "def checkA ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 1 ) : NEW_LINE INDENT state1 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 2 ) : NEW_LINE INDENT state2 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 3 ) : NEW_LINE INDENT state3 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT nfa = 4 NEW_LINE DEDENT DEDENT",
        "explain": "Function to check for 3 a 's"
    },
    {
        "py": "def checkB ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 4 ) : NEW_LINE INDENT state4 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 5 ) : NEW_LINE INDENT state5 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 6 ) : NEW_LINE INDENT state6 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT nfa = 7 NEW_LINE DEDENT DEDENT",
        "explain": "Function to check for 3 b 's"
    },
    {
        "py": "def checkC ( s , x ) : NEW_LINE INDENT global nfa , flag NEW_LINE for i in range ( x ) : NEW_LINE INDENT if ( nfa == 7 ) : NEW_LINE INDENT state7 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 8 ) : NEW_LINE INDENT state8 ( s [ i ] ) NEW_LINE DEDENT elif ( nfa == 9 ) : NEW_LINE INDENT state9 ( s [ i ] ) NEW_LINE DEDENT DEDENT if ( nfa == 7 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT",
        "explain": "Function to check for 3 c 's"
    },
    {
        "py": "s = \" bbbca \" NEW_LINE x = 5 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "if ( checkA ( s , x ) or checkB ( s , x ) or checkC ( s , x ) ) : NEW_LINE INDENT print ( \" ACCEPTED \" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" NOT \u2581 ACCEPTED \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" INPUT \u2581 OUT \u2581 OF \u2581 DICTIONARY . \" ) NEW_LINE DEDENT DEDENT",
        "explain": "If any of the states is True , that is , if either the number of a ' s \u2581 or \u2581 number \u2581 of \u2581 b ' s or number of c 's is a multiple of three, then the is accepted"
    },
    {
        "py": "def getPositionCount ( a , n ) : NEW_LINE",
        "explain": "Function to count positions such that all elements before it are greater"
    },
    {
        "py": "count = 1 ; NEW_LINE",
        "explain": "Count is initially 1 for the first element"
    },
    {
        "py": "min = a [ 0 ] ; NEW_LINE",
        "explain": "Initial Minimum"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( a [ i ] <= min ) : NEW_LINE",
        "explain": "If current element is new minimum"
    },
    {
        "py": "min = a [ i ] ; NEW_LINE",
        "explain": "Update minimum"
    },
    {
        "py": "count += 1 ; NEW_LINE return count ; NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 4 , 6 , 1 , 3 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( getPositionCount ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxSum ( arr , n , k ) : NEW_LINE",
        "explain": "Function to return the maximum sum in a subarray of size k"
    },
    {
        "py": "if ( n < k ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT",
        "explain": "k must be greater"
    },
    {
        "py": "res = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT res += arr [ i ] ; NEW_LINE DEDENT",
        "explain": "Compute sum of first window of size k"
    },
    {
        "py": "curr_sum = res ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] ; NEW_LINE res = max ( res , curr_sum ) ; NEW_LINE DEDENT return res ; NEW_LINE",
        "explain": "Compute sums of remaining windows by removing first element of previous window and adding last element of current window ."
    },
    {
        "py": "def solve ( arr , n , k ) : NEW_LINE INDENT max_len = 0 ; l = 0 ; r = n ; NEW_LINE DEDENT",
        "explain": "Function to return the length of subarray Sum of all the subarray of this length is less than or equal to K"
    },
    {
        "py": "while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 ; NEW_LINE DEDENT",
        "explain": "Binary search from l to r as all the array elements are positive so that the maximum subarray sum is monotonically increasing"
    },
    {
        "py": "if ( maxSum ( arr , n , m ) > k ) : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT",
        "explain": "Check if the subarray sum is greater than K or not"
    },
    {
        "py": "max_len = m ; NEW_LINE return max_len ; NEW_LINE",
        "explain": "Update the maximum length"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 10 ; NEW_LINE print ( solve ( arr , n , k ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 100001 NEW_LINE ROW = 10 NEW_LINE COL = 3 NEW_LINE indices = [ 0 ] * MAX NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "test = [ [ 2 , 3 , 6 ] , [ 2 , 4 , 4 ] , [ 2 , 6 , 3 ] , [ 3 , 2 , 6 ] , [ 3 , 3 , 3 ] , [ 3 , 6 , 2 ] , [ 4 , 2 , 4 ] , [ 4 , 4 , 2 ] , [ 6 , 2 , 3 ] , [ 6 , 3 , 2 ] ] NEW_LINE",
        "explain": "All possible solutions of the equation 1 / a + 1 / b + 1 / c = 1"
    },
    {
        "py": "def find_triplet ( array , n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT indices [ i ] = [ ] NEW_LINE DEDENT DEDENT",
        "explain": "Function to find the triplets"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT indices [ array [ i ] ] . append ( i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT y = array [ i ] NEW_LINE for j in range ( ROW ) : NEW_LINE INDENT s = test [ j ] [ 1 ] * y NEW_LINE DEDENT DEDENT",
        "explain": "Storing indices of the elements"
    },
    {
        "py": "if s % test [ j ] [ 0 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if s % test [ j ] [ 2 ] != 0 : NEW_LINE INDENT continue NEW_LINE DEDENT x = s // test [ j ] [ 0 ] NEW_LINE z = s // test [ j ] [ 2 ] NEW_LINE if x > MAX or z > MAX : NEW_LINE INDENT continue NEW_LINE DEDENT l = 0 NEW_LINE r = len ( indices [ x ] ) - 1 NEW_LINE first = - 1 NEW_LINE",
        "explain": "Check if y can act as the middle element of triplet with the given solution of 1 / a + 1 / b + 1 / c = 1"
    },
    {
        "py": "while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if indices [ x ] [ m ] < i : NEW_LINE INDENT first = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT l = 0 NEW_LINE r = len ( indices [ z ] ) - 1 NEW_LINE third = - 1 NEW_LINE",
        "explain": "Binary search to find the number of possible values of the first element"
    },
    {
        "py": "while l <= r : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if indices [ z ] [ m ] > i : NEW_LINE INDENT third = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if first != - 1 and third != - 1 : NEW_LINE",
        "explain": "Binary search to find the number of possible values of the third element"
    },
    {
        "py": "answer += ( first + 1 ) * ( len ( indices [ z ] ) - third ) NEW_LINE return answer NEW_LINE",
        "explain": "Contribution to the answer would be the multiplication of the possible values for the first and the third element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT array = [ 2 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( array ) NEW_LINE print ( find_triplet ( array , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def distinct ( arr ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "if len ( arr ) == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 0 , len ( arr ) - 1 ) : NEW_LINE",
        "explain": "if array has only one element , return 1"
    },
    {
        "py": "if ( i == 0 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "For first element compare with only next element"
    },
    {
        "py": "elif ( i > 0 & i < len ( arr ) - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "For remaining elements compare with both prev and next elements"
    },
    {
        "py": "if ( arr [ len ( arr ) - 1 ] != arr [ len ( arr ) - 2 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "For last element compare with only prev element"
    },
    {
        "py": "arr = [ 0 , 0 , 0 , 0 , 0 , 1 , 0 ] NEW_LINE print ( distinct ( arr ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isSorted ( arr , N ) : NEW_LINE",
        "explain": "Function to check if an array is sorted or not"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "Return true"
    },
    {
        "py": "def isPossibleToSort ( arr , N ) : NEW_LINE",
        "explain": "Function to check if it is possible to sort the array w . r . t . first element"
    },
    {
        "py": "group = arr [ 0 ] [ 1 ] NEW_LINE",
        "explain": "Stores the ID of the first element"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if ( arr [ i ] [ 1 ] != group ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT",
        "explain": "If arr [ i ] [ 1 ] is not equal to that of the group"
    },
    {
        "py": "if ( isSorted ( arr , N ) ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT",
        "explain": "If array is sorted"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 340000 , 2 ] , [ 45000 , 1 ] , [ 30000 , 2 ] , [ 50000 , 4 ] ] NEW_LINE N = len ( arr ) NEW_LINE print ( isPossibleToSort ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE total_sum = 0 NEW_LINE mod = 1000000007 NEW_LINE",
        "explain": "Structure of a node"
    },
    {
        "py": "def getAlphaScore ( node ) : NEW_LINE INDENT global sum NEW_LINE global total_sum NEW_LINE DEDENT",
        "explain": "Function to calculate and return the Alpha Score of the journey"
    },
    {
        "py": "if node . left != None : NEW_LINE INDENT getAlphaScore ( node . left ) NEW_LINE DEDENT",
        "explain": "Traverse left subtree"
    },
    {
        "py": "sum = ( sum + node . data ) % mod NEW_LINE",
        "explain": "Calculate the alpha score of the current step"
    },
    {
        "py": "total_sum = ( total_sum + sum ) % mod NEW_LINE",
        "explain": "Update alpha score of the journey"
    },
    {
        "py": "if node . right != None : NEW_LINE INDENT getAlphaScore ( node . right ) NEW_LINE DEDENT",
        "explain": "Traverse right subtree"
    },
    {
        "py": "return total_sum NEW_LINE",
        "explain": "Return"
    },
    {
        "py": "def constructBST ( arr , start , end , root ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return None NEW_LINE DEDENT mid = ( start + end ) // 2 NEW_LINE DEDENT",
        "explain": "Function to construct a BST from the sorted array arr [ ]"
    },
    {
        "py": "if root == None : NEW_LINE INDENT root = Node ( arr [ mid ] ) NEW_LINE DEDENT",
        "explain": "Insert root"
    },
    {
        "py": "root . left = constructBST ( arr , start , mid - 1 , root . left ) NEW_LINE",
        "explain": "Construct left subtree"
    },
    {
        "py": "root . right = constructBST ( arr , mid + 1 , end , root . right ) NEW_LINE",
        "explain": "Construct right subtree"
    },
    {
        "py": "return root NEW_LINE",
        "explain": "Return root"
    },
    {
        "py": "arr = [ 10 , 11 , 12 ] NEW_LINE length = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr . sort ( ) NEW_LINE root = None NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "root = constructBST ( arr , 0 , length - 1 , root ) NEW_LINE print ( getAlphaScore ( root ) ) NEW_LINE",
        "explain": "Construct BST from the sorted array"
    },
    {
        "py": "def sortByFreq ( arr , n ) : NEW_LINE",
        "explain": "Function that return the index upto all the array elements are updated ."
    },
    {
        "py": "maxE = - 1 ; NEW_LINE",
        "explain": "Initialise maxE = - 1"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT maxE = max ( maxE , arr [ i ] ) NEW_LINE DEDENT",
        "explain": "Find the maximum element of arr [ ]"
    },
    {
        "py": "freq = [ 0 ] * ( maxE + 1 ) ; NEW_LINE",
        "explain": "Create frequency array freq [ ]"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 ; NEW_LINE DEDENT",
        "explain": "Update the frequency array as per the occurrence of element in arr [ ]"
    },
    {
        "py": "cnt = 0 ; NEW_LINE",
        "explain": "Initialise cnt to 0"
    },
    {
        "py": "for i in range ( maxE + 1 ) : NEW_LINE",
        "explain": "Traversing freq [ ]"
    },
    {
        "py": "if ( freq [ i ] > 0 ) : NEW_LINE INDENT value = 100000 - i ; NEW_LINE arr [ cnt ] = 100000 * freq [ i ] + value ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT",
        "explain": "If freq of an element is greater than 0 update the value of arr [ ] at index cnt & increment cnt"
    },
    {
        "py": "return cnt ; NEW_LINE",
        "explain": "Return cnt"
    },
    {
        "py": "def printSortedArray ( arr , cnt ) : NEW_LINE",
        "explain": "Function that print array arr [ ] elements in sorted order"
    },
    {
        "py": "for i in range ( cnt ) : NEW_LINE",
        "explain": "Traversing arr [ ] till index cnt"
    },
    {
        "py": "frequency = arr [ i ] / 100000 ; NEW_LINE",
        "explain": "Find frequency of elements"
    },
    {
        "py": "value = 100000 - ( arr [ i ] % 100000 ) ; NEW_LINE",
        "explain": "Find value at index i"
    },
    {
        "py": "for j in range ( int ( frequency ) ) : NEW_LINE INDENT print ( value , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Traversing till frequency to print value at index i"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 ] NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "n = len ( arr ) NEW_LINE",
        "explain": "Size of array arr [ ]"
    },
    {
        "py": "cnt = sortByFreq ( arr , n ) ; NEW_LINE",
        "explain": "Function call to get cnt"
    },
    {
        "py": "arr . sort ( reverse = True ) NEW_LINE",
        "explain": "Sort the arr [ ] in decreasing order"
    },
    {
        "py": "printSortedArray ( arr , cnt ) ; NEW_LINE",
        "explain": "Function that prints elements in decreasing order"
    },
    {
        "py": "def checkRectangles ( arr , n ) : NEW_LINE INDENT ans = True NEW_LINE DEDENT",
        "explain": "Function to check whether we can make n rectangles of equal area"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "area = arr [ 0 ] * arr [ 4 * n - 1 ] NEW_LINE",
        "explain": "Find the area of any one rectangle"
    },
    {
        "py": "for i in range ( 0 , 2 * n , 2 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] or arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] or arr [ i ] * arr [ 4 * n - i - 1 ] != area ) : NEW_LINE DEDENT",
        "explain": "Check whether we have two equal sides for each rectangle and that area of each rectangle formed is the same"
    },
    {
        "py": "ans = False NEW_LINE break NEW_LINE",
        "explain": "Update the answer to false if any condition fails"
    },
    {
        "py": "if ( ans ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If possible"
    },
    {
        "py": "arr = [ 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 ] NEW_LINE n = 2 NEW_LINE if ( checkRectangles ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def cntElements ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count of elements which are not in the correct position when sorted"
    },
    {
        "py": "copy_arr = [ 0 ] * n NEW_LINE",
        "explain": "To store a copy of the original array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT copy_arr [ i ] = arr [ i ] NEW_LINE DEDENT",
        "explain": "Copy the elements of the given array to the new array"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "To store the required count"
    },
    {
        "py": "arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Sort the original array"
    },
    {
        "py": "if ( arr [ i ] != copy_arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "If current element was not at the right position"
    },
    {
        "py": "arr = [ 1 , 2 , 6 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntElements ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findPairs ( arr , n , k , d ) : NEW_LINE",
        "explain": "Function to find the required pairs"
    },
    {
        "py": "if ( n < 2 * k ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "There has to be atleast 2 * k elements"
    },
    {
        "py": "pairs = [ ] NEW_LINE",
        "explain": "To store the pairs"
    },
    {
        "py": "arr = sorted ( arr ) NEW_LINE",
        "explain": "Sort the given array"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE",
        "explain": "For every possible pair"
    },
    {
        "py": "if ( arr [ n - k + i ] - arr [ i ] >= d ) : NEW_LINE",
        "explain": "If the current pair is valid"
    },
    {
        "py": "pairs . append ( [ arr [ i ] , arr [ n - k + i ] ] ) NEW_LINE",
        "explain": "Insert it into the pair vector"
    },
    {
        "py": "if ( len ( pairs ) < k ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If k pairs are not possible"
    },
    {
        "py": "for v in pairs : NEW_LINE INDENT print ( \" ( \" , v [ 0 ] , \" , \u2581 \" , v [ 1 ] , \" ) \" ) NEW_LINE DEDENT",
        "explain": "Print the pairs"
    },
    {
        "py": "arr = [ 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE d = 3 NEW_LINE findPairs ( arr , n , k , d ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def pairs_count ( arr , n , sum ) : NEW_LINE",
        "explain": "Function to return the count of pairs from arr with the given sum"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "To store the count of pairs"
    },
    {
        "py": "arr = sorted ( arr ) NEW_LINE",
        "explain": "Sort the given array"
    },
    {
        "py": "i , j = 0 , n - 1 NEW_LINE while ( i < j ) : NEW_LINE",
        "explain": "Take two pointers"
    },
    {
        "py": "if ( arr [ i ] + arr [ j ] < sum ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "If sum is greater"
    },
    {
        "py": "elif ( arr [ i ] + arr [ j ] > sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT",
        "explain": "If sum is lesser"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If sum is equal"
    },
    {
        "py": "x = arr [ i ] NEW_LINE xx = i NEW_LINE while ( i < j and arr [ i ] == x ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "Find the frequency of arr [ i ]"
    },
    {
        "py": "y = arr [ j ] NEW_LINE yy = j NEW_LINE while ( j >= i and arr [ j ] == y ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT",
        "explain": "Find the frequency of arr [ j ]"
    },
    {
        "py": "if ( x == y ) : NEW_LINE INDENT temp = i - xx + yy - j - 1 NEW_LINE ans += ( temp * ( temp + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( i - xx ) * ( yy - j ) NEW_LINE DEDENT",
        "explain": "If arr [ i ] and arr [ j ] are same then remove the extra number counted"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "arr = [ 1 , 5 , 7 , 5 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( pairs_count ( arr , n , sum ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE def check ( str ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE max = - sys . maxsize - 1 NEW_LINE sum = 0 NEW_LINE DEDENT",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "for i in range ( len ( str ) ) : NEW_LINE",
        "explain": "For all the characters of the string"
    },
    {
        "py": "ascii = str [ i ] NEW_LINE",
        "explain": "Find the ascii value of the character"
    },
    {
        "py": "if ( ord ( ascii ) < 96 or ord ( ascii ) > 122 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check if if its a valid character , if not then return false"
    },
    {
        "py": "sum += ord ( ascii ) NEW_LINE",
        "explain": "Calculate sum of all the characters ascii values"
    },
    {
        "py": "if ( min > ord ( ascii ) ) : NEW_LINE INDENT min = ord ( ascii ) NEW_LINE DEDENT",
        "explain": "Find minimum ascii value from the string"
    },
    {
        "py": "if ( max < ord ( ascii ) ) : NEW_LINE INDENT max = ord ( ascii ) NEW_LINE DEDENT",
        "explain": "Find maximum ascii value from the string"
    },
    {
        "py": "min -= 1 NEW_LINE",
        "explain": "To get the previous element of the minimum ASCII value"
    },
    {
        "py": "eSum = ( ( ( max * ( max + 1 ) ) // 2 ) - ( ( min * ( min + 1 ) ) // 2 ) ) NEW_LINE",
        "explain": "Take the expected sum from the above equation"
    },
    {
        "py": "return sum == eSum NEW_LINE",
        "explain": "Check if the expected sum is equals to the calculated sum or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "str = \" dcef \" NEW_LINE if ( check ( str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "1 st example"
    },
    {
        "py": "str1 = \" xyza \" NEW_LINE if ( check ( str1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "2 nd example"
    },
    {
        "py": "def findKth ( arr , n , k ) : NEW_LINE INDENT missing = dict ( ) NEW_LINE count = 0 NEW_LINE DEDENT",
        "explain": "Function to find the sum of minimum of all subarrays"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT missing [ arr [ i ] ] = 1 NEW_LINE DEDENT",
        "explain": "Insert all the elements in a set"
    },
    {
        "py": "maxm = max ( arr ) NEW_LINE minm = min ( arr ) NEW_LINE",
        "explain": "Find the maximum and minimum element"
    },
    {
        "py": "for i in range ( minm + 1 , maxm ) : NEW_LINE",
        "explain": "Traverse from the minimum to maximum element"
    },
    {
        "py": "if ( i not in missing . keys ( ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Check if \" i \" is missing"
    },
    {
        "py": "if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT",
        "explain": "Check if it is kth missing"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "If no kth element is missing"
    },
    {
        "py": "arr = [ 2 , 10 , 9 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( findKth ( arr , n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to sort linked list containing values from 1 to N"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "A linked list node"
    },
    {
        "py": "def sortList ( head ) : NEW_LINE INDENT startVal = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT head . data = startVal NEW_LINE startVal = startVal + 1 NEW_LINE head = head . next NEW_LINE DEDENT DEDENT",
        "explain": "Function to sort linked list"
    },
    {
        "py": "def push ( head_ref , new_data ) : NEW_LINE",
        "explain": "Function to add a node at the beginning of Linked List"
    },
    {
        "py": "new_node = Node ( new_data ) NEW_LINE",
        "explain": "allocate node"
    },
    {
        "py": "new_node . data = new_data NEW_LINE",
        "explain": "put in the data"
    },
    {
        "py": "new_node . next = head_ref NEW_LINE",
        "explain": "link the old list off the new node"
    },
    {
        "py": "head_ref = new_node NEW_LINE return head_ref NEW_LINE",
        "explain": "move the head to po to the new node"
    },
    {
        "py": "def prList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE node = node . next NEW_LINE DEDENT DEDENT",
        "explain": "This function prs contents of linked list starting from the given node"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "head = push ( head , 2 ) NEW_LINE head = push ( head , 1 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 3 ) NEW_LINE sortList ( head ) NEW_LINE prList ( head ) NEW_LINE",
        "explain": "The constructed linked list is : 3.5 . 4.6 .1 . 2"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Linked list node"
    },
    {
        "py": "def isSortedDesc ( head ) : NEW_LINE",
        "explain": "Function to Check Linked List is sorted in descending order or not"
    },
    {
        "py": "if ( head == None or head . next == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "return ( head . data > head . next . data and isSortedDesc ( head . next ) ) NEW_LINE def newNode ( data ) : NEW_LINE INDENT temp = Node ( data ) NEW_LINE return temp NEW_LINE DEDENT",
        "explain": "Check first two nodes and recursively check remaining ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT head = newNode ( 7 ) NEW_LINE head . next = newNode ( 5 ) NEW_LINE head . next . next = newNode ( 4 ) NEW_LINE head . next . next . next = newNode ( 3 ) NEW_LINE if isSortedDesc ( head ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minSum ( arr , n ) : NEW_LINE",
        "explain": "Python 3 program to sort an array such that sum of product of alternate element is minimum ."
    },
    {
        "py": "evenArr = [ ] NEW_LINE oddArr = [ ] NEW_LINE",
        "explain": "create evenArr [ ] and oddArr [ ]"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "sort main array in ascending order"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT oddArr . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT evenArr . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Put elements in oddArr [ ] and evenArr [ ] as per desired value ."
    },
    {
        "py": "evenArr . sort ( reverse = True ) NEW_LINE",
        "explain": "sort evenArr [ ] in descending order"
    },
    {
        "py": "i = 0 NEW_LINE sum = 0 NEW_LINE for j in range ( len ( evenArr ) ) : NEW_LINE INDENT arr [ i ] = evenArr [ j ] NEW_LINE i += 1 NEW_LINE arr [ i ] = oddArr [ j ] NEW_LINE i += 1 NEW_LINE sum += evenArr [ j ] * oddArr [ j ] NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "merge both sub - array and calculate minimum sum of product of alternate elements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 required \u2581 sum \u2581 = \" , minSum ( arr , n ) ) NEW_LINE print ( \" Sorted \u2581 array \u2581 in \u2581 required \u2581 format \u2581 : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minTime ( word ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT",
        "explain": "Function to calculate minimum time to print all characters in the string"
    },
    {
        "py": "curr = 0 NEW_LINE for i in range ( len ( word ) ) : NEW_LINE",
        "explain": "Current element where the pointer is pointing"
    },
    {
        "py": "k = ord ( word [ i ] ) - 97 NEW_LINE",
        "explain": "Find index of that element"
    },
    {
        "py": "a = abs ( curr - k ) NEW_LINE",
        "explain": "Calculate absolute difference between pointer index and character index as clockwise distance"
    },
    {
        "py": "b = 26 - abs ( curr - k ) NEW_LINE",
        "explain": "Subtract clockwise time from 26 to get anti - clockwise time"
    },
    {
        "py": "ans += min ( a , b ) NEW_LINE",
        "explain": "Add minimum of both times to the answer"
    },
    {
        "py": "ans += 1 NEW_LINE curr = ord ( word [ i ] ) - 97 NEW_LINE",
        "explain": "Add one unit time to print the character"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the final answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "str = \" zjpc \" NEW_LINE",
        "explain": "Given string word"
    },
    {
        "py": "minTime ( str ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def reduceToOne ( N ) : NEW_LINE",
        "explain": "Function to find the minimum number of steps required to reduce N to 1"
    },
    {
        "py": "cnt = 0 NEW_LINE while ( N != 1 ) : NEW_LINE",
        "explain": "Stores the number of steps required"
    },
    {
        "py": "if ( N == 2 or ( N % 2 == 1 ) ) : NEW_LINE",
        "explain": "If the value of N is equal to 2 or N is odd"
    },
    {
        "py": "N = N - 1 NEW_LINE",
        "explain": "Decrement N by 1"
    },
    {
        "py": "cnt += 1 NEW_LINE",
        "explain": "Increment cnt by 1"
    },
    {
        "py": "elif ( N % 2 == 0 ) : NEW_LINE",
        "explain": "If N is even"
    },
    {
        "py": "N = N / ( N / 2 ) NEW_LINE",
        "explain": "Update N"
    },
    {
        "py": "cnt += 1 NEW_LINE",
        "explain": "Increment cnt by 1"
    },
    {
        "py": "return cnt NEW_LINE",
        "explain": "Return the number of steps obtained"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( reduceToOne ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxDiamonds ( A , N , K ) : NEW_LINE",
        "explain": "Function to find the maximum number of diamonds that can be gained in exactly K minutes"
    },
    {
        "py": "pq = [ ] NEW_LINE",
        "explain": "Stores all the array elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT pq . append ( A [ i ] ) NEW_LINE DEDENT pq . sort ( ) NEW_LINE",
        "explain": "Push all the elements to the priority queue"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the required result"
    },
    {
        "py": "while ( len ( pq ) > 0 and K > 0 ) : NEW_LINE INDENT pq . sort ( ) NEW_LINE DEDENT",
        "explain": "Loop while the queue is not empty and K is positive"
    },
    {
        "py": "top = pq [ len ( pq ) - 1 ] NEW_LINE",
        "explain": "Store the top element from the pq"
    },
    {
        "py": "pq = pq [ 0 : len ( pq ) - 1 ] NEW_LINE",
        "explain": "Pop it from the pq"
    },
    {
        "py": "ans += top NEW_LINE",
        "explain": "Add it to the answer"
    },
    {
        "py": "top = top // 2 ; NEW_LINE pq . append ( top ) NEW_LINE K -= 1 NEW_LINE",
        "explain": "Divide it by 2 and push it back to the pq"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 1 , 7 , 4 , 2 ] NEW_LINE K = 3 NEW_LINE N = len ( A ) NEW_LINE maxDiamonds ( A , N , K ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MinimumCost ( A , B , N ) : NEW_LINE",
        "explain": "Function to find the minimum cost to make A [ i ] multiple of B [ i ] or vice - versa for every array element"
    },
    {
        "py": "totalCost = 0 NEW_LINE",
        "explain": "Stores the minimum cost"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "mod_A = B [ i ] % A [ i ] NEW_LINE totalCost_A = min ( mod_A , A [ i ] - mod_A ) NEW_LINE",
        "explain": "Case 1 : Update A [ i ]"
    },
    {
        "py": "mod_B = A [ i ] % B [ i ] NEW_LINE totalCost_B = min ( mod_B , B [ i ] - mod_B ) NEW_LINE",
        "explain": "Case 2 : Update B [ i ]"
    },
    {
        "py": "totalCost += min ( totalCost_A , totalCost_B ) NEW_LINE",
        "explain": "Add the minimum of the above two cases"
    },
    {
        "py": "return totalCost NEW_LINE",
        "explain": "Return the resultant cost"
    },
    {
        "py": "A = [ 3 , 6 , 3 ] NEW_LINE B = [ 4 , 8 , 13 ] NEW_LINE N = len ( A ) NEW_LINE print ( MinimumCost ( A , B , N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printLargestDivisible ( arr , N ) : NEW_LINE INDENT count0 = 0 ; count7 = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE DEDENT",
        "explain": "Print the largest number divisible by 50"
    },
    {
        "py": "if ( arr [ i ] == 0 ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count7 += 1 ; NEW_LINE DEDENT",
        "explain": "Counting number of 0 s and 7 s"
    },
    {
        "py": "if ( count7 % 50 == 0 ) : NEW_LINE INDENT while ( count7 ) : NEW_LINE INDENT count7 -= 1 ; NEW_LINE print ( 7 , end = \" \" ) ; NEW_LINE DEDENT while ( count0 ) : NEW_LINE INDENT count0 -= 1 ; NEW_LINE print ( count0 , end = \" \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "If count of 7 is divisible by 50"
    },
    {
        "py": "elif ( count7 < 5 ) : NEW_LINE INDENT if ( count0 == 0 ) : NEW_LINE INDENT print ( \" No \" , end = \" \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "If count of 7 is less than 5"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If count of 7 is not divisible by 50"
    },
    {
        "py": "count7 = count7 - count7 % 5 ; NEW_LINE while ( count7 ) : NEW_LINE INDENT count7 -= 1 ; NEW_LINE print ( 7 , end = \" \" ) ; NEW_LINE DEDENT while ( count0 ) : NEW_LINE INDENT count0 -= 1 ; NEW_LINE print ( 0 , end = \" \" ) ; NEW_LINE DEDENT",
        "explain": "Count of groups of 5 in which count of 7 s can be grouped"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 ] ; NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) ; NEW_LINE printLargestDivisible ( arr , N ) ; NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "def findMaxValByRearrArr ( arr , N ) : NEW_LINE",
        "explain": "Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array in ascending order"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements"
    },
    {
        "py": "while ( True ) : NEW_LINE",
        "explain": "Generate all possible permutations of the array"
    },
    {
        "py": "Sum = 0 NEW_LINE",
        "explain": "Stores sum of GCD ( arr [ i ] , i )"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "Sum += __gcd ( i + 1 , arr [ i ] ) NEW_LINE",
        "explain": "Update sum"
    },
    {
        "py": "res = max ( res , Sum ) NEW_LINE if ( not next_permutation ( arr ) ) : NEW_LINE INDENT break NEW_LINE DEDENT return res NEW_LINE def __gcd ( a , b ) : NEW_LINE if b == 0 : NEW_LINE return a NEW_LINE else : NEW_LINE return __gcd ( b , a % b ) NEW_LINE def next_permutation ( p ) : NEW_LINE for a in range ( len ( p ) - 2 , - 1 , - 1 ) : NEW_LINE if ( p [ a ] < p [ a + 1 ] ) : NEW_LINE INDENT b = len ( p ) - 1 NEW_LINE while True : NEW_LINE INDENT if ( p [ b ] > p [ a ] ) : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE a += 1 NEW_LINE b = len ( p ) - 1 NEW_LINE while a < b : NEW_LINE INDENT t = p [ a ] NEW_LINE p [ a ] = p [ b ] NEW_LINE p [ b ] = t NEW_LINE a += 1 NEW_LINE b -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT b -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "arr = [ 3 , 2 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findMaxValByRearrArr ( arr , N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def min_elements ( arr , N ) : NEW_LINE",
        "explain": "Function to find the minimum count of elements required to be removed such that frequency of arr [ i ] equal to arr [ i ]"
    },
    {
        "py": "mp = { } ; NEW_LINE",
        "explain": "Stores frequency of each element of the array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 ; NEW_LINE DEDENT",
        "explain": "Update frequency of arr [ i ]"
    },
    {
        "py": "cntMinRem = 0 ; NEW_LINE",
        "explain": "Stores minimum count of removals"
    },
    {
        "py": "for it in mp : NEW_LINE",
        "explain": "Traverse the map"
    },
    {
        "py": "i = it ; NEW_LINE",
        "explain": "Stores key value of the map"
    },
    {
        "py": "if ( mp [ i ] < i ) : NEW_LINE",
        "explain": "If frequency of i is less than i"
    },
    {
        "py": "cntMinRem += mp [ i ] ; NEW_LINE",
        "explain": "Update cntMinRem"
    },
    {
        "py": "elif ( mp [ i ] > i ) : NEW_LINE",
        "explain": "If frequency of i is greater than i"
    },
    {
        "py": "cntMinRem += ( mp [ i ] - i ) ; NEW_LINE return cntMinRem ; NEW_LINE",
        "explain": "Update cntMinRem"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 1 , 4 , 2 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( min_elements ( arr , N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def CheckAllarrayEqual ( arr , N ) : NEW_LINE",
        "explain": "Function to check if an array of equal elements with sum equal to the given array can be obtained or not"
    },
    {
        "py": "if ( N == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "totalSum = arr [ 0 ] NEW_LINE",
        "explain": "Stores sum of array elements"
    },
    {
        "py": "secMax = - 10 ** 19 NEW_LINE",
        "explain": "Stores second largest array element"
    },
    {
        "py": "Max = arr [ 0 ] NEW_LINE",
        "explain": "Stores the largest array element"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] >= Max ) : NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "secMax = Max NEW_LINE",
        "explain": "Update secMax"
    },
    {
        "py": "Max = arr [ i ] NEW_LINE elif ( arr [ i ] > secMax ) : NEW_LINE",
        "explain": "Update Max"
    },
    {
        "py": "secMax = arr [ i ] NEW_LINE",
        "explain": "Update secMax"
    },
    {
        "py": "totalSum += arr [ i ] NEW_LINE",
        "explain": "Update totalSum"
    },
    {
        "py": "if ( ( secMax * ( N - 1 ) ) > totalSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If totalSum is less than secMax * ( N - 1 ) )"
    },
    {
        "py": "if ( totalSum % ( N - 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "If totalSum is not divisible by ( N - 1 )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 6 , 2 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE if ( CheckAllarrayEqual ( arr , N ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def Remove_one_element ( arr , n ) : NEW_LINE",
        "explain": "Function to count ways to make Bitwise XOR of odd and even indexed elements equal by removing an array element"
    },
    {
        "py": "post_odd = 0 NEW_LINE post_even = 0 NEW_LINE",
        "explain": "Stores xor of odd and even indexed elements from the end"
    },
    {
        "py": "curr_odd = 0 NEW_LINE curr_even = 0 NEW_LINE",
        "explain": "Stores xor of odd and even indexed elements from the start"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores the required count"
    },
    {
        "py": "for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Traverse the array in reverse"
    },
    {
        "py": "if ( i % 2 ) : NEW_LINE INDENT post_odd ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "If i is odd"
    },
    {
        "py": "else : NEW_LINE INDENT post_even ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "If i is even"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( i % 2 ) : NEW_LINE INDENT post_odd ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "If i is odd"
    },
    {
        "py": "else : NEW_LINE INDENT post_even ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "If i is even"
    },
    {
        "py": "X = curr_odd ^ post_even NEW_LINE",
        "explain": "Removing arr [ i ] , post_even stores XOR of odd indexed elements"
    },
    {
        "py": "Y = curr_even ^ post_odd NEW_LINE",
        "explain": "Removing arr [ i ] , post_odd stores XOR of even indexed elements"
    },
    {
        "py": "if ( X == Y ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT",
        "explain": "Check if they are equal"
    },
    {
        "py": "if ( i % 2 ) : NEW_LINE INDENT curr_odd ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "If i is odd , xor it with curr_odd"
    },
    {
        "py": "else : NEW_LINE INDENT curr_even ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "If i is even , xor it with curr_even"
    },
    {
        "py": "print ( res ) NEW_LINE",
        "explain": "Finally print res"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Drivers Code"
    },
    {
        "py": "arr = [ 1 , 0 , 1 , 0 , 1 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE",
        "explain": "Given size"
    },
    {
        "py": "Remove_one_element ( arr , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def cntIndexesToMakeBalance ( arr , n ) : NEW_LINE",
        "explain": "Function to count array indices whose removal makes sum of odd and even indexed elements equal"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If size of the array is 1"
    },
    {
        "py": "if ( n == 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If size of the array is 2"
    },
    {
        "py": "sumEven = 0 NEW_LINE",
        "explain": "Stores sum of even - indexed elements of the given array"
    },
    {
        "py": "sumOdd = 0 NEW_LINE",
        "explain": "Stores sum of odd - indexed elements of the given array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE",
        "explain": "If i is an even number"
    },
    {
        "py": "sumEven += arr [ i ] NEW_LINE",
        "explain": "Update sumEven"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If i is an odd number"
    },
    {
        "py": "sumOdd += arr [ i ] NEW_LINE",
        "explain": "Update sumOdd"
    },
    {
        "py": "currOdd = 0 NEW_LINE",
        "explain": "Stores sum of even - indexed array elements till i - th index"
    },
    {
        "py": "currEven = arr [ 0 ] NEW_LINE",
        "explain": "Stores sum of odd - indexed array elements till i - th index"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores count of indices whose removal makes sum of odd and even indexed elements equal"
    },
    {
        "py": "newEvenSum = 0 NEW_LINE",
        "explain": "Stores sum of even - indexed elements after removing the i - th element"
    },
    {
        "py": "newOddSum = 0 NEW_LINE",
        "explain": "Stores sum of odd - indexed elements after removing the i - th element"
    },
    {
        "py": "for i in range ( 1 , n - 1 ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( i % 2 ) : NEW_LINE",
        "explain": "If i is an odd number"
    },
    {
        "py": "currOdd += arr [ i ] NEW_LINE",
        "explain": "Update currOdd"
    },
    {
        "py": "newEvenSum = ( currEven + sumOdd - currOdd ) NEW_LINE",
        "explain": "Update newEvenSum"
    },
    {
        "py": "newOddSum = ( currOdd + sumEven - currEven - arr [ i ] ) NEW_LINE",
        "explain": "Update newOddSum"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If i is an even number"
    },
    {
        "py": "currEven += arr [ i ] NEW_LINE",
        "explain": "Update currEven"
    },
    {
        "py": "newOddSum = ( currOdd + sumEven - currEven ) NEW_LINE",
        "explain": "Update newOddSum"
    },
    {
        "py": "newEvenSum = ( currEven + sumOdd - currOdd - arr [ i ] ) NEW_LINE",
        "explain": "Update newEvenSum"
    },
    {
        "py": "if ( newEvenSum == newOddSum ) : NEW_LINE",
        "explain": "If newEvenSum is equal to newOddSum"
    },
    {
        "py": "res += 1 NEW_LINE",
        "explain": "Increase the count"
    },
    {
        "py": "if ( sumOdd == sumEven - arr [ 0 ] ) : NEW_LINE",
        "explain": "If sum of even - indexed and odd - indexed elements is equal by removing the first element"
    },
    {
        "py": "res += 1 NEW_LINE",
        "explain": "Increase the count"
    },
    {
        "py": "if ( n % 2 == 1 ) : NEW_LINE",
        "explain": "If length of the array is an odd number"
    },
    {
        "py": "if ( sumOdd == sumEven - arr [ n - 1 ] ) : NEW_LINE",
        "explain": "If sum of even - indexed and odd - indexed elements is equal by removing the last element"
    },
    {
        "py": "res += 1 NEW_LINE",
        "explain": "Increase the count"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If length of the array is an even number"
    },
    {
        "py": "if ( sumEven == sumOdd - arr [ n - 1 ] ) : NEW_LINE",
        "explain": "If sum of even - indexed and odd - indexed elements is equal by removing the last element"
    },
    {
        "py": "res += 1 NEW_LINE return res NEW_LINE",
        "explain": "Increase the count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntIndexesToMakeBalance ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findNums ( X , Y ) : NEW_LINE",
        "explain": "Function to find the value of A and B whose sum is X and xor is Y"
    },
    {
        "py": "A = 0 ; NEW_LINE B = 0 ; NEW_LINE",
        "explain": "Initialize the two numbers"
    },
    {
        "py": "if ( X < Y ) : NEW_LINE INDENT A = - 1 ; NEW_LINE B = - 1 ; NEW_LINE DEDENT",
        "explain": "Case 1 : X < Y"
    },
    {
        "py": "elif ( ( ( abs ( X - Y ) ) & 1 ) != 0 ) : NEW_LINE INDENT A = - 1 ; NEW_LINE B = - 1 ; NEW_LINE DEDENT",
        "explain": "Case 2 : X - Y is odd"
    },
    {
        "py": "elif ( X == Y ) : NEW_LINE INDENT A = 0 ; NEW_LINE B = Y ; NEW_LINE DEDENT",
        "explain": "Case 3 : If both Sum and XOR are equal"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Case 4 : If above cases fails"
    },
    {
        "py": "A = ( X - Y ) // 2 ; NEW_LINE",
        "explain": "Update the value of A"
    },
    {
        "py": "if ( ( A & Y ) == 0 ) : NEW_LINE",
        "explain": "Check if A & Y value is 0"
    },
    {
        "py": "B = ( A + Y ) ; NEW_LINE",
        "explain": "If True , update B"
    },
    {
        "py": "else : NEW_LINE INDENT A = - 1 ; NEW_LINE B = - 1 ; NEW_LINE DEDENT",
        "explain": "Otherwise assign - 1 to A , - 1 to B"
    },
    {
        "py": "print A ; NEW_LINE print B ; NEW_LINE",
        "explain": "Prthe numbers A and B"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "X = 17 ; NEW_LINE Y = 13 ; NEW_LINE",
        "explain": "Given Sum and XOR of 2 numbers"
    },
    {
        "py": "findNums ( X , Y ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def checkCount ( A , Q , q ) : NEW_LINE",
        "explain": "Function to check if given range have equal number of increasing as well as decreasing subarrays"
    },
    {
        "py": "for i in range ( q ) : NEW_LINE INDENT L = Q [ i ] [ 0 ] NEW_LINE R = Q [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Traverse each query"
    },
    {
        "py": "L -= 1 NEW_LINE R -= 1 NEW_LINE",
        "explain": "For 0 - based indexing"
    },
    {
        "py": "if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Condition for same count of increasing & decreasing subarray"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 13 , 12 , 14 ] NEW_LINE Q = [ [ 1 , 4 ] , [ 2 , 4 ] ] NEW_LINE q = len ( Q ) NEW_LINE checkCount ( arr , Q , q ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def pairProductMean ( arr , N ) : NEW_LINE",
        "explain": "Function to find the mean of pair product array of arr"
    },
    {
        "py": "pairArray = [ ] ; NEW_LINE",
        "explain": "Store product of pairs"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT pairProduct = arr [ i ] * arr [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Generate all unordered pairs"
    },
    {
        "py": "pairArray . append ( pairProduct ) ; NEW_LINE",
        "explain": "Store product of pairs"
    },
    {
        "py": "length = len ( pairArray ) ; NEW_LINE",
        "explain": "Size of pairArray"
    },
    {
        "py": "sum = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT sum += pairArray [ i ] ; NEW_LINE DEDENT",
        "explain": "Store sum of pairArray"
    },
    {
        "py": "mean = 0 ; NEW_LINE",
        "explain": "Stores the mean of pairArray"
    },
    {
        "py": "if ( length != 0 ) : NEW_LINE INDENT mean = sum / length ; NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 ; NEW_LINE DEDENT",
        "explain": "Find mean of pairArray"
    },
    {
        "py": "return mean ; NEW_LINE",
        "explain": "Return the resultant mean"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 1 , 2 , 4 , 8 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE",
        "explain": "Given array arr"
    },
    {
        "py": "print ( \" { 0 : . 2f } \" . format ( pairProductMean ( arr , N ) ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findPlayer ( str , n ) : NEW_LINE",
        "explain": "Function to find the player who loses the game"
    },
    {
        "py": "move_first = 0 NEW_LINE",
        "explain": "Moves for the first player"
    },
    {
        "py": "move_sec = 0 NEW_LINE",
        "explain": "Moves for the second player"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate over array of strings"
    },
    {
        "py": "if ( str [ i ] [ 0 ] == str [ i ] [ len ( str [ i ] ) - 1 ] ) : NEW_LINE",
        "explain": "Check if the first and last character are the same"
    },
    {
        "py": "' NEW_LINE INDENT if ( str [ i ] [ 0 ] == 48 ) : NEW_LINE INDENT move_first += 1 NEW_LINE DEDENT else : NEW_LINE INDENT move_sec += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Check if string start and end with character '0"
    },
    {
        "py": "if ( move_first <= move_sec ) : NEW_LINE INDENT print ( \" Player \u2581 2 \u2581 wins \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Player \u2581 1 \u2581 wins \" ) NEW_LINE DEDENT",
        "explain": "If first player have less moves"
    },
    {
        "py": "str = [ \"010\" , \"101\" ] NEW_LINE N = len ( str ) NEW_LINE",
        "explain": "Given array of strings"
    },
    {
        "py": "findPlayer ( str , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def find_next ( n , k ) : NEW_LINE",
        "explain": "Function to find the number greater than n whose Kth bit is set"
    },
    {
        "py": "M = n + 1 ; NEW_LINE while ( True ) : NEW_LINE",
        "explain": "Iterate from N + 1"
    },
    {
        "py": "if ( ( M & ( 1 << k ) ) > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT",
        "explain": "Check if Kth bit is set or not"
    },
    {
        "py": "M += 1 ; NEW_LINE",
        "explain": "Increment M for next number"
    },
    {
        "py": "return M ; NEW_LINE",
        "explain": "Return the minimum value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 15 ; K = 2 ; NEW_LINE",
        "explain": "Given N and K"
    },
    {
        "py": "print ( find_next ( N , K ) ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def find_next ( n , k ) : NEW_LINE",
        "explain": "Function to find the number greater than n whose Kth bit is set"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the resultant number"
    },
    {
        "py": "if ( ( n & ( 1 << k ) ) == 0 ) : NEW_LINE INDENT cur = 0 NEW_LINE DEDENT",
        "explain": "If Kth bit is not set"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE",
        "explain": "cur will be the sum of all powers of 2 < k"
    },
    {
        "py": "if ( n & ( 1 << i ) ) : NEW_LINE INDENT cur += 1 << i NEW_LINE DEDENT",
        "explain": "If the current bit is set"
    },
    {
        "py": "ans = n - cur + ( 1 << k ) NEW_LINE",
        "explain": "Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set"
    },
    {
        "py": "else : NEW_LINE INDENT first_unset_bit , cur = - 1 , 0 NEW_LINE for i in range ( 64 ) : NEW_LINE DEDENT",
        "explain": "If the kth bit is set"
    },
    {
        "py": "if ( ( n & ( 1 << i ) ) == 0 ) : NEW_LINE INDENT first_unset_bit = i NEW_LINE break NEW_LINE DEDENT",
        "explain": "First unset bit position"
    },
    {
        "py": "else : NEW_LINE INDENT cur += ( 1 << i ) NEW_LINE DEDENT",
        "explain": "Sum of bits that are set"
    },
    {
        "py": "ans = n - cur + ( 1 << first_unset_bit ) NEW_LINE",
        "explain": "Add Kth power of 2 to n and subtract the all powers of 2 less than K that are set"
    },
    {
        "py": "if ( ( ans & ( 1 << k ) ) == 0 ) : NEW_LINE INDENT ans += ( 1 << k ) NEW_LINE DEDENT",
        "explain": "If Kth bit became unset then set it again"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the resultant number"
    },
    {
        "py": "N , K = 15 , 2 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( find_next ( N , K ) ) NEW_LINE",
        "explain": "Print ans"
    },
    {
        "py": "def largestString ( num , k ) : NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "ans = [ ] NEW_LINE for i in range ( len ( num ) ) : NEW_LINE",
        "explain": "Final result string"
    },
    {
        "py": "while ( len ( ans ) and ans [ - 1 ] < num [ i ] and k > 0 ) : NEW_LINE",
        "explain": "If the current char exceeds the character at the top of the stack"
    },
    {
        "py": "ans . pop ( ) NEW_LINE",
        "explain": "Remove from the end of the string"
    },
    {
        "py": "k -= 1 NEW_LINE",
        "explain": "Decrease k for the removal"
    },
    {
        "py": "ans . append ( num [ i ] ) NEW_LINE",
        "explain": "Insert current character"
    },
    {
        "py": "while ( len ( ans ) and k ) : NEW_LINE INDENT k -= 1 NEW_LINE ans . pop ( ) NEW_LINE DEDENT",
        "explain": "Perform remaining K deletions from the end of the string"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the string"
    },
    {
        "py": "str = \" zyxedcba \" NEW_LINE k = 1 NEW_LINE print ( * largestString ( str , k ) , sep = \" \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def maxLengthSubArray ( A , N ) : NEW_LINE",
        "explain": "Function that finds the maximum length of the sub - array that contains equal element on both halves of sub - array"
    },
    {
        "py": "forward = [ 0 ] * N NEW_LINE backward = [ 0 ] * N NEW_LINE",
        "explain": "To store continuous occurence of the element"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if i == 0 or A [ i ] != A [ i - 1 ] : NEW_LINE INDENT forward [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT forward [ i ] = forward [ i - 1 ] + 1 NEW_LINE DEDENT DEDENT",
        "explain": "To store continuous forward occurence"
    },
    {
        "py": "for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if i == N - 1 or A [ i ] != A [ i + 1 ] : NEW_LINE INDENT backward [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT backward [ i ] = backward [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT",
        "explain": "To store continuous backward occurence"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "To store the maximum length"
    },
    {
        "py": "for i in range ( N - 1 ) : NEW_LINE INDENT if ( A [ i ] != A [ i + 1 ] ) : NEW_LINE INDENT ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Find maximum length"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "maxLengthSubArray ( arr , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def minNum ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 210 * ( 10 ** ( n - 1 ) // 210 + 1 ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to find the minimum number of n digits divisible by all prime digits ."
    },
    {
        "py": "n = 5 NEW_LINE minNum ( n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def helper ( d , s ) : NEW_LINE",
        "explain": "Function to return the minimum string of length d having the sum of digits s"
    },
    {
        "py": "ans = [ '0' ] * d NEW_LINE for i in range ( d - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Return a string of length d"
    },
    {
        "py": "if ( s >= 9 ) : NEW_LINE INDENT ans [ i ] = '9' NEW_LINE s -= 9 NEW_LINE DEDENT",
        "explain": "Greedily put 9 's  in the end"
    },
    {
        "py": "else : NEW_LINE INDENT c = chr ( s + ord ( '0' ) ) NEW_LINE ans [ i ] = c ; NEW_LINE s = 0 ; NEW_LINE DEDENT return ' ' . join ( ans ) ; NEW_LINE",
        "explain": "Put remaining sum"
    },
    {
        "py": "def findMin ( x , Y ) : NEW_LINE",
        "explain": "Function to find the smallest number greater than Y whose sum of digits is X"
    },
    {
        "py": "y = str ( Y ) ; NEW_LINE n = len ( y ) NEW_LINE p = [ 0 ] * n NEW_LINE",
        "explain": "Convert number y to string"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT p [ i ] = ( ord ( y [ i ] ) - ord ( '0' ) ) NEW_LINE if ( i > 0 ) : NEW_LINE INDENT p [ i ] += p [ i - 1 ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Maintain prefix sum of digits"
    },
    {
        "py": "n - 1 NEW_LINE k = 0 NEW_LINE while True : NEW_LINE",
        "explain": "Iterate over Y from the back where k is current length of suffix"
    },
    {
        "py": "d = 0 ; NEW_LINE if ( i >= 0 ) : NEW_LINE INDENT d = ( ord ( y [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT",
        "explain": "Stores current digit"
    },
    {
        "py": "for j in range ( d + 1 , 10 ) : NEW_LINE",
        "explain": "Increase current digit"
    },
    {
        "py": "r = ( ( i > 0 ) * p [ i - 1 ] + j ) ; NEW_LINE",
        "explain": "Sum upto current prefix"
    },
    {
        "py": "if ( x - r >= 0 and x - r <= 9 * k ) : NEW_LINE",
        "explain": "Return answer if remaining sum can be obtained in suffix"
    },
    {
        "py": "suf = helper ( k , x - r ) ; NEW_LINE pre = \" \" ; NEW_LINE if ( i > 0 ) : NEW_LINE INDENT pre = y [ 0 : i ] NEW_LINE DEDENT",
        "explain": "Find suffix of length k having sum of digits x - r"
    },
    {
        "py": "cur = chr ( j + ord ( '0' ) ) NEW_LINE pre += cur ; NEW_LINE",
        "explain": "Append current character"
    },
    {
        "py": "return pre + suf ; NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "x = 18 ; NEW_LINE y = 99 ; NEW_LINE",
        "explain": "Given Number and Sum"
    },
    {
        "py": "print ( findMin ( x , y ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def largestNumber ( n , X , Y ) : NEW_LINE INDENT maxm = max ( X , Y ) NEW_LINE DEDENT",
        "explain": "Function to generate and return the largest number"
    },
    {
        "py": "Y = X + Y - maxm NEW_LINE",
        "explain": "Store the smaller in Y"
    },
    {
        "py": "X = maxm NEW_LINE",
        "explain": "Store the larger in X"
    },
    {
        "py": "Xs = 0 NEW_LINE Ys = 0 NEW_LINE while ( n > 0 ) : NEW_LINE",
        "explain": "Stores respective counts"
    },
    {
        "py": "if ( n % Y == 0 ) : NEW_LINE",
        "explain": "If N is divisible by Y"
    },
    {
        "py": "Xs += n NEW_LINE",
        "explain": "Append X , N times to the answer"
    },
    {
        "py": "n = 0 NEW_LINE else : NEW_LINE",
        "explain": "Reduce N to zero"
    },
    {
        "py": "n -= X NEW_LINE",
        "explain": "Reduce N by x"
    },
    {
        "py": "Ys += X NEW_LINE",
        "explain": "Append Y , X times to the answer"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT while ( Xs > 0 ) : NEW_LINE INDENT Xs -= 1 NEW_LINE print ( X , end = ' ' ) NEW_LINE DEDENT while ( Ys > 0 ) : NEW_LINE INDENT Ys -= 1 NEW_LINE print ( Y , end = ' ' ) NEW_LINE DEDENT DEDENT",
        "explain": "If number can be formed"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "n = 19 NEW_LINE X = 7 NEW_LINE Y = 5 NEW_LINE largestNumber ( n , X , Y ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minChanges ( str , N ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE DEDENT",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "for x in str : NEW_LINE INDENT count0 += ( x == '0' ) NEW_LINE DEDENT res = count0 NEW_LINE",
        "explain": "Traverse input string and store the count of 0"
    },
    {
        "py": "for x in str : NEW_LINE INDENT count0 -= ( x == '0' ) NEW_LINE count1 += ( x == '1' ) NEW_LINE res = min ( res , count1 + count0 ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Traverse the input string again to find minimum number of flips"
    },
    {
        "py": "N = 9 NEW_LINE str = \"000101001\" NEW_LINE print ( minChanges ( str , N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 implementation of the missing number such that maximum absolute difference between adjacent element is minimum"
    },
    {
        "py": "def missingnumber ( n , arr ) -> int : NEW_LINE INDENT mn = sys . maxsize ; NEW_LINE mx = - sys . maxsize - 1 ; NEW_LINE DEDENT",
        "explain": "Function to find the missing number such that maximum absolute difference is minimum"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( i > 0 and arr [ i ] == - 1 and arr [ i - 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i - 1 ] ) ; NEW_LINE mx = max ( mx , arr [ i - 1 ] ) ; NEW_LINE DEDENT if ( i < ( n - 1 ) and arr [ i ] == - 1 and arr [ i + 1 ] != - 1 ) : NEW_LINE INDENT mn = min ( mn , arr [ i + 1 ] ) ; NEW_LINE mx = max ( mx , arr [ i + 1 ] ) ; NEW_LINE DEDENT DEDENT res = ( mx + mn ) / 2 ; NEW_LINE return res ; NEW_LINE",
        "explain": "Loop to find the maximum and minimum adjacent element to missing number"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE arr = [ - 1 , 10 , - 1 , 12 , - 1 ] ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "res = missingnumber ( n , arr ) ; NEW_LINE print ( res ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def LCSubStr ( A , B , m , n ) : NEW_LINE",
        "explain": "Function to find the length of the longest common substring of the string X and Y"
    },
    {
        "py": "LCSuff = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE",
        "explain": "LCSuff [ i ] [ j ] stores the lengths of the longest common suffixes of substrings"
    },
    {
        "py": "for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE DEDENT",
        "explain": "Itearate over strings A and B"
    },
    {
        "py": "if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT",
        "explain": "If first row or column"
    },
    {
        "py": "elif ( A [ i - 1 ] == B [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT",
        "explain": "If matching is found"
    },
    {
        "py": "else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT",
        "explain": "Otherwise , if matching is not found"
    },
    {
        "py": "return result NEW_LINE",
        "explain": "Finally , return the resultant maximum value LCS"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \"0110\" NEW_LINE B = \"1101\" NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( LCSubStr ( A , B , M , N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "maxN = 20 ; NEW_LINE maxSum = 50 ; NEW_LINE minSum = 50 ; NEW_LINE Base = 50 ; NEW_LINE",
        "explain": "Python program for the above approach"
    },
    {
        "py": "dp = [ [ 0 for i in range ( maxSum + minSum ) ] for j in range ( maxN ) ] ; NEW_LINE v = [ [ False for i in range ( maxSum + minSum ) ] for j in range ( maxN ) ] ; NEW_LINE",
        "explain": "To store the states of DP"
    },
    {
        "py": "def findCnt ( arr , i , required_sum , n ) : NEW_LINE",
        "explain": "Function to find count of subsets with a given sum"
    },
    {
        "py": "if ( i == n ) : NEW_LINE INDENT if ( required_sum == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT",
        "explain": "Base case"
    },
    {
        "py": "if ( v [ i ] [ required_sum + Base ] ) : NEW_LINE INDENT return dp [ i ] [ required_sum + Base ] ; NEW_LINE DEDENT",
        "explain": "If an already computed subproblem occurs"
    },
    {
        "py": "v [ i ] [ required_sum + Base ] = True ; NEW_LINE",
        "explain": "Set the state as solved"
    },
    {
        "py": "dp [ i ] [ required_sum + Base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; NEW_LINE return dp [ i ] [ required_sum + Base ] ; NEW_LINE",
        "explain": "Recurrence relation"
    },
    {
        "py": "def countSubsets ( arr , K , n ) : NEW_LINE",
        "explain": "Function to count ways to split array into pair of subsets with difference K"
    },
    {
        "py": "sum = 0 ; NEW_LINE",
        "explain": "Store the total sum of element of the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "sum += arr [ i ] ; NEW_LINE",
        "explain": "Calculate sum of array elements"
    },
    {
        "py": "S1 = ( sum + K ) // 2 ; NEW_LINE",
        "explain": "Store the required sum"
    },
    {
        "py": "print ( findCnt ( arr , 0 , S1 , n ) ) ; NEW_LINE",
        "explain": "Prthe number of subsets with sum equal to S1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE K = 1 ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "countSubsets ( arr , K , N ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "dp = [ [ 0 for i in range ( 605 ) ] for j in range ( 105 ) ] ; NEW_LINE",
        "explain": "Python program for above approach"
    },
    {
        "py": "def find ( N , sum ) : NEW_LINE INDENT if ( N < 0 sum < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ N ] [ sum ] > 0 ) : NEW_LINE INDENT return dp [ N ] [ sum ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to calculate the probability for the given sum to be equal to sum in N throws of dice"
    },
    {
        "py": "if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return ( float ) ( 1.0 / 6 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT for i in range ( 1 , 7 ) : NEW_LINE INDENT dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; NEW_LINE DEDENT return dp [ N ] [ sum ] ; NEW_LINE",
        "explain": "Base cases"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; a = 13 ; b = 17 ; NEW_LINE probability = 0.0 NEW_LINE f = 0 ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "for sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + find ( N , sum ) ; NEW_LINE DEDENT",
        "explain": "Calculate probability of all sums from a to b"
    },
    {
        "py": "print ( \" % .6f \" % probability ) ; NEW_LINE",
        "explain": "Prthe answer"
    },
    {
        "py": "def count ( n ) : NEW_LINE",
        "explain": "Function to find the minimum number to steps to reduce N to 0"
    },
    {
        "py": "dp = dict ( ) NEW_LINE",
        "explain": "Dictionary for storing the precomputed sum"
    },
    {
        "py": "dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE",
        "explain": "Bases Cases"
    },
    {
        "py": "if n not in dp : NEW_LINE INDENT dp [ n ] = 1 + min ( n % 2 + count ( n // 2 ) , n % 3 + count ( n // 3 ) ) NEW_LINE DEDENT",
        "explain": "Check if n is not in dp then only call the function so as to reduce no of recursive calls"
    },
    {
        "py": "return dp [ n ] NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "N = 6 NEW_LINE",
        "explain": "Given Number N"
    },
    {
        "py": "print ( str ( count ( N ) ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def find_minimum_operations ( n , b , k ) : NEW_LINE",
        "explain": "Function to find the minimum number of operations required to change all the array of zeros such that every element is greater than the given array"
    },
    {
        "py": "d = [ 0 for i in range ( n + 1 ) ] NEW_LINE",
        "explain": "Declaring the difference array of size N"
    },
    {
        "py": "operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Number of operations"
    },
    {
        "py": "d [ i ] += d [ i - 1 ] NEW_LINE",
        "explain": "First update the D [ i ] value with the previous value"
    },
    {
        "py": "if b [ i ] > d [ i ] : NEW_LINE",
        "explain": "The index i has to be incremented"
    },
    {
        "py": "operations += ( b [ i ] - d [ i ] ) NEW_LINE need = ( b [ i ] - d [ i ] ) NEW_LINE",
        "explain": "We have to perform ( b [ i ] - d [ i ] ) operations more"
    },
    {
        "py": "d [ i ] += need NEW_LINE",
        "explain": "Increment the range i to i + k by need"
    },
    {
        "py": "if i + k <= n : NEW_LINE INDENT d [ i + k ] -= need NEW_LINE DEDENT return operations NEW_LINE",
        "explain": "Check if i + k is valid index"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE b = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE k = 2 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( find_minimum_operations ( n , b , k ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def ways ( arr , k ) : NEW_LINE INDENT R = len ( arr ) NEW_LINE C = len ( arr [ 0 ] ) NEW_LINE K = k NEW_LINE preSum = [ [ 0 for _ in range ( C ) ] \\ for _ in range ( R ) ] NEW_LINE DEDENT",
        "explain": "Function to find the number of ways to cut the matrix into the K parts such that each part have atleast one filled cell"
    },
    {
        "py": "for r in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for c in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT preSum [ r ] = arr [ r ] NEW_LINE if r + 1 < R : NEW_LINE INDENT preSum [ r ] += preSum [ r + 1 ] NEW_LINE DEDENT if c + 1 < C : NEW_LINE INDENT preSum [ r ] += preSum [ r ] NEW_LINE DEDENT if r + 1 < R and c + 1 < C : NEW_LINE INDENT preSum [ r ] -= preSum [ r + 1 ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Loop to find prefix sum of the given matrix"
    },
    {
        "py": "dp = [ [ [ 0 for _ in range ( C ) ] \\ for _ in range ( R ) ] \\ for _ in range ( K + 1 ) ] NEW_LINE",
        "explain": "dp ( r , c , 1 ) = 1 if preSum [ r ] else 0"
    },
    {
        "py": "for k in range ( 1 , K + 1 ) : NEW_LINE INDENT for r in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT for c in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT dp [ k ] [ r ] = 1 if preSum [ r ] > 0 else 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ k ] [ r ] = 0 NEW_LINE for r1 in range ( r + 1 , R ) : NEW_LINE DEDENT DEDENT DEDENT DEDENT",
        "explain": "Loop to iterate over the dp table of the given matrix"
    },
    {
        "py": "if preSum [ r ] - preSum [ r1 ] > 0 : NEW_LINE INDENT dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] NEW_LINE DEDENT for c1 in range ( c + 1 , C ) : NEW_LINE",
        "explain": "Check if can cut horizontally at r1 , at least one apple in matrix ( r , c ) -> r1 , C - 1"
    },
    {
        "py": "if preSum [ r ] - preSum [ r ] [ c1 ] > 0 : NEW_LINE INDENT dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] NEW_LINE DEDENT return dp [ K ] [ 0 ] [ 0 ] NEW_LINE",
        "explain": "Check if we can cut vertically at c1 , at least one apple in matrix ( r , c ) -> R - 1 , c1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ [ 1 , 0 , 0 ] , [ 1 , 1 , 1 ] , [ 0 , 0 , 0 ] ] NEW_LINE k = 3 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( ways ( arr , k ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "p = 1000000007 NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE DEDENT",
        "explain": "Iterative Function to calculate ( x ^ y ) % p in O ( log y )"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT",
        "explain": "If y is odd , multiply x with result"
    },
    {
        "py": "y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE return res NEW_LINE",
        "explain": "y must be even now"
    },
    {
        "py": "def nCr ( n , p , f , m ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Iterative Function to calculate ( nCr ) % p and save in f [ n ] [ r ]"
    },
    {
        "py": "if ( j > i ) : NEW_LINE INDENT f [ i ] [ j ] = 0 NEW_LINE DEDENT",
        "explain": "If j > i then C ( i , j ) = 0"
    },
    {
        "py": "elif ( j == 0 or j == i ) : NEW_LINE INDENT f [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p NEW_LINE DEDENT",
        "explain": "If i is equal to j then C ( i , j ) = 1"
    },
    {
        "py": "def ProductOfSubsets ( arr , n , m ) : NEW_LINE INDENT f = [ [ 0 for i in range ( 100 ) ] for j in range ( n + 1 ) ] NEW_LINE nCr ( n , p - 1 , f , m ) NEW_LINE arr . sort ( reverse = False ) NEW_LINE DEDENT",
        "explain": "Function calculate the Final answer"
    },
    {
        "py": "ans = 1 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Initialize ans"
    },
    {
        "py": "x = 0 NEW_LINE for j in range ( 1 , m + 1 , 1 ) : NEW_LINE",
        "explain": "x is count of occurence of arr [ i ] in different set such that index of arr [ i ] in those sets divides K completely ."
    },
    {
        "py": "if ( m % j == 0 ) : NEW_LINE",
        "explain": "Finding the count of arr [ i ] by placing it at index which divides K completely"
    },
    {
        "py": "x = ( ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ) NEW_LINE ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) NEW_LINE print ( ans ) NEW_LINE",
        "explain": "By Fermat 's theorem"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 7 , 9 , 3 ] NEW_LINE K = 4 NEW_LINE N = len ( arr ) ; NEW_LINE ProductOfSubsets ( arr , N , K ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countWays ( n , m ) : NEW_LINE",
        "explain": "Function to count the number of ways to write N as sum of k non - negative integers"
    },
    {
        "py": "dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE",
        "explain": "Initialise dp [ ] [ ] array"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE DEDENT",
        "explain": "Only 1 way to choose the value with sum K"
    },
    {
        "py": "sum = 0 NEW_LINE for i in range ( 2 , m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT DEDENT",
        "explain": "Initialise sum"
    },
    {
        "py": "for k in range ( j + 1 ) : NEW_LINE INDENT sum += dp [ i - 1 ] [ k ] NEW_LINE DEDENT",
        "explain": "Count the ways from previous states"
    },
    {
        "py": "dp [ i ] [ j ] = sum NEW_LINE",
        "explain": "Update the sum"
    },
    {
        "py": "return dp [ m ] [ n ] NEW_LINE",
        "explain": "Return the final count of ways"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE K = 3 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( countWays ( N , K ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def countWays ( n , m ) : NEW_LINE",
        "explain": "Function to count the number of ways to write N as sum of k non - negative integers"
    },
    {
        "py": "dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE",
        "explain": "Initialise dp [ ] [ ] array"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = 1 NEW_LINE if ( i != 0 ) : NEW_LINE INDENT dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] NEW_LINE DEDENT DEDENT",
        "explain": "Fill the dp [ ] [ ] with sum = m"
    },
    {
        "py": "for i in range ( 2 , m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE DEDENT",
        "explain": "Iterate the dp [ ] [ ] to fill the dp [ ] [ ] array"
    },
    {
        "py": "if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "Condition for first column"
    },
    {
        "py": "else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "Else fill the dp [ ] [ ] with sum till ( i , j )"
    },
    {
        "py": "if ( i == m and j == n ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT",
        "explain": "If reach the end , then return the value"
    },
    {
        "py": "dp [ i ] [ j ] += dp [ i ] [ j - 1 ] NEW_LINE",
        "explain": "Update at current index"
    },
    {
        "py": "N = 2 NEW_LINE K = 3 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( countWays ( N , K ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def SieveOfEratosthenes ( MAX , primes ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) ; NEW_LINE DEDENT",
        "explain": "Function to pre - store primes"
    },
    {
        "py": "for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE DEDENT",
        "explain": "Sieve method to check if prime or not"
    },
    {
        "py": "for i in range ( p ** 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT",
        "explain": "Multiples"
    },
    {
        "py": "for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Pre - store all the primes"
    },
    {
        "py": "def findLongest ( A , n ) : NEW_LINE",
        "explain": "Function to find the longest subsequence"
    },
    {
        "py": "mpp = { } ; NEW_LINE primes = [ ] ; NEW_LINE",
        "explain": "Hash map"
    },
    {
        "py": "SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; NEW_LINE dp = [ 0 ] * n ; NEW_LINE",
        "explain": "Call the function to pre - store the primes"
    },
    {
        "py": "dp [ n - 1 ] = 1 ; NEW_LINE mpp [ A [ n - 1 ] ] = n - 1 ; NEW_LINE",
        "explain": "Initialize last element with 1 as that is the longest possible"
    },
    {
        "py": "for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Iterate from the back and find the longest"
    },
    {
        "py": "num = A [ i ] ; NEW_LINE",
        "explain": "Get the number"
    },
    {
        "py": "dp [ i ] = 1 ; NEW_LINE maxi = 0 ; NEW_LINE",
        "explain": "Initialize dp [ i ] as 1 as the element will only me in the subsequence"
    },
    {
        "py": "for it in primes : NEW_LINE",
        "explain": "Iterate in all the primes and multiply to get the next element"
    },
    {
        "py": "xx = num * it ; NEW_LINE",
        "explain": "Next element if multiplied with it"
    },
    {
        "py": "if ( xx > A [ n - 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT",
        "explain": "If exceeds the last element then break"
    },
    {
        "py": "elif xx in mpp : NEW_LINE",
        "explain": "If the number is there in the array"
    },
    {
        "py": "dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; NEW_LINE",
        "explain": "Get the maximum most element"
    },
    {
        "py": "mpp [ A [ i ] ] = i ; NEW_LINE ans = 1 ; NEW_LINE",
        "explain": "Hash the element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) ; NEW_LINE DEDENT return ans ; NEW_LINE",
        "explain": "Find the longest"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( findLongest ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def waysToKAdjacentSetBits ( n , k , currentIndex , adjacentSetBits , lastBit ) : NEW_LINE",
        "explain": "Function to find the number of Bit Strings of length N with K adjacent set bits"
    },
    {
        "py": "if ( currentIndex == n ) : NEW_LINE",
        "explain": "Base Case when we form bit string of length n"
    },
    {
        "py": "if ( adjacentSetBits == k ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 NEW_LINE noOfWays = 0 NEW_LINE",
        "explain": "if f ( bit string ) = k , count this way"
    },
    {
        "py": "if ( lastBit == 1 ) : NEW_LINE",
        "explain": "Check if the last bit was set , if it was set then call for next index by incrementing the adjacent bit count else just call the next index with same value of adjacent bit count and either set the bit at current index or let it remain unset"
    },
    {
        "py": "noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; NEW_LINE",
        "explain": "set the bit at currentIndex"
    },
    {
        "py": "noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE elif ( lastBit != 1 ) : NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; NEW_LINE noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; NEW_LINE return noOfWays ; NEW_LINE",
        "explain": "unset the bit at currentIndex"
    },
    {
        "py": "n = 5 ; k = 2 ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "totalWays = ( waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ) ; NEW_LINE print ( \" Number \u2581 of \u2581 ways \u2581 = \" , totalWays ) ; NEW_LINE",
        "explain": "total ways = ( ways by placing 1 st bit as 1 + ways by placing 1 st bit as 0 )"
    },
    {
        "py": "def postfix ( a , n ) : NEW_LINE INDENT for i in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT a [ i - 1 ] = a [ i - 1 ] + a [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Find the postfix sum array"
    },
    {
        "py": "def modify ( a , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i - 1 ] = i * a [ i ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Modify the array such that we don 't have to compute the products which are obtained before"
    },
    {
        "py": "def allCombination ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT",
        "explain": "Finding sum of all combination taken 1 to N at a time"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT print ( \" f ( 1 ) \u2581 - - > \u2581 \" , sum ) NEW_LINE",
        "explain": "sum taken 1 at time is simply sum of 1 - N"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE",
        "explain": "for sum of products for all combination"
    },
    {
        "py": "postfix ( a , n - i + 1 ) NEW_LINE",
        "explain": "finding postfix array"
    },
    {
        "py": "sum = 0 NEW_LINE for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT sum += ( j * a [ j ] ) NEW_LINE DEDENT print ( \" f ( \" , i + 1 , \" ) \u2581 - - > \u2581 \" , sum ) NEW_LINE",
        "explain": "sum of products taken i + 1 at a time"
    },
    {
        "py": "modify ( a , n ) NEW_LINE",
        "explain": "modify the array for overlapping problem"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 NEW_LINE a = [ 0 ] * n NEW_LINE DEDENT",
        "explain": "Driver 's Code"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT a [ i ] = i + 1 NEW_LINE DEDENT",
        "explain": "storing numbers from 1 to N"
    },
    {
        "py": "allCombination ( a , n ) NEW_LINE",
        "explain": "calling allCombination"
    },
    {
        "py": "def findStep ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n == 2 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) NEW_LINE DEDENT DEDENT",
        "explain": "Returns count of ways to reach n - th stair using 1 or 2 or 3 steps ."
    },
    {
        "py": "n = 4 NEW_LINE print ( findStep ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isSubsetSum ( arr , n , sum ) : NEW_LINE",
        "explain": "A utility function that returns true if there is a subset of arr [ ] with sun equal to given sum"
    },
    {
        "py": "if sum == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 and sum != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Base Cases"
    },
    {
        "py": "if arr [ n - 1 ] > sum : NEW_LINE INDENT return isSubsetSum ( arr , n - 1 , sum ) NEW_LINE DEDENT",
        "explain": "If last element is greater than sum , then ignore it"
    },
    {
        "py": "return isSubsetSum ( arr , n - 1 , sum ) or isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) NEW_LINE",
        "explain": "else , check if sum can be obtained by any of the following ( a ) including the last element ( b ) excluding the last element"
    },
    {
        "py": "def findPartion ( arr , n ) : NEW_LINE",
        "explain": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"
    },
    {
        "py": "sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Calculate sum of the elements in array"
    },
    {
        "py": "if sum % 2 != 0 : NEW_LINE INDENT return false NEW_LINE DEDENT",
        "explain": "If sum is odd , there cannot be two subsets with equal sum"
    },
    {
        "py": "return isSubsetSum ( arr , n , sum // 2 ) NEW_LINE",
        "explain": "Find if there is subset with sum equal to half of total sum"
    },
    {
        "py": "arr = [ 3 , 1 , 5 , 9 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "if findPartion ( arr , n ) == True : NEW_LINE INDENT print ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def findPartiion ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE DEDENT",
        "explain": "Returns true if arr [ ] can be partitioned in two subsets of equal sum , otherwise false"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT part = [ 0 ] * ( ( Sum // 2 ) + 1 ) NEW_LINE",
        "explain": "Calculate sum of all elements"
    },
    {
        "py": "for i in range ( ( Sum // 2 ) + 1 ) : NEW_LINE INDENT part [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Initialize the part array as 0"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Fill the partition table in bottom up manner"
    },
    {
        "py": "for j in range ( Sum // 2 , arr [ i ] - 1 , - 1 ) : NEW_LINE",
        "explain": "the element to be included in the sum cannot be greater than the sum"
    },
    {
        "py": "if ( part [ j - arr [ i ] ] == 1 or j == arr [ i ] ) : NEW_LINE INDENT part [ j ] = 1 NEW_LINE DEDENT return part [ Sum // 2 ] NEW_LINE",
        "explain": "check if sum - arr [ i ] could be formed from a subset using elements before index i"
    },
    {
        "py": "arr = [ 1 , 3 , 3 , 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Drive code"
    },
    {
        "py": "if ( findPartiion ( arr , n ) == 1 ) : NEW_LINE INDENT print ( \" Can \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Can \u2581 not \u2581 be \u2581 divided \u2581 into \u2581 two \u2581 subsets \u2581 of \u2581 equal \u2581 sum \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def binomialCoeff ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT m = 1000000007 NEW_LINE inv = [ 0 for i in range ( r + 1 ) ] NEW_LINE inv [ 0 ] = 1 ; NEW_LINE if ( r + 1 >= 2 ) NEW_LINE inv [ 1 ] = 1 ; NEW_LINE DEDENT",
        "explain": "Function to find binomial coefficient"
    },
    {
        "py": "for i in range ( 2 , r + 1 ) : NEW_LINE INDENT inv [ i ] = m - ( m // i ) * inv [ m % i ] % m NEW_LINE DEDENT ans = 1 NEW_LINE",
        "explain": "Getting the modular inversion for all the numbers from 2 to r with respect to m here m = 1000000007"
    },
    {
        "py": "for i in range ( 2 , r + 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m NEW_LINE DEDENT",
        "explain": "for 1 / ( r ! ) part"
    },
    {
        "py": "for i in range ( n , n - r , - 1 ) : NEW_LINE INDENT ans = ( ( ans % m ) * ( i % m ) ) % m NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "for ( n ) * ( n - 1 ) * ( n - 2 ) * ... * ( n - r + 1 ) part"
    },
    {
        "py": "n = 5 NEW_LINE r = 2 NEW_LINE print ( \" Value \u2581 of \u2581 C ( \" , n , \" , \u2581 \" , r , \" ) \u2581 is \u2581 \" , binomialCoeff ( n , r ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE",
        "explain": "Function to find the gcd of two numbers"
    },
    {
        "py": "if ( a < b ) : NEW_LINE INDENT t = a NEW_LINE a = b NEW_LINE b = t NEW_LINE DEDENT if ( a % b == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "return gcd ( b , a % b ) NEW_LINE",
        "explain": "Recurse"
    },
    {
        "py": "def printAnswer ( x , y ) : NEW_LINE",
        "explain": "Function to print the answer"
    },
    {
        "py": "val = gcd ( x , y ) NEW_LINE",
        "explain": "GCD of X and Y"
    },
    {
        "py": "if ( ( val & ( val - 1 ) ) == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "If GCD is power of 2"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "x = 4 NEW_LINE y = 7 NEW_LINE",
        "explain": "Given X and Y"
    },
    {
        "py": "printAnswer ( x , y ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def getElement ( N , r , c ) : NEW_LINE",
        "explain": "Function to return the element in the rth row and cth column from the required matrix"
    },
    {
        "py": "if ( r > c ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Condition for lower half of matrix"
    },
    {
        "py": "if ( r == 1 ) : NEW_LINE INDENT return c ; NEW_LINE DEDENT",
        "explain": "Condition if element is in first row"
    },
    {
        "py": "a = ( r + 1 ) * pow ( 2 , r - 2 ) ; NEW_LINE",
        "explain": "Starting element of AP in row r"
    },
    {
        "py": "d = pow ( 2 , r - 1 ) ; NEW_LINE",
        "explain": "Common difference of AP in row r"
    },
    {
        "py": "c = c - r ; NEW_LINE element = a + d * c ; NEW_LINE return element ; NEW_LINE",
        "explain": "Position of element to find in AP in row r"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; R = 3 ; C = 4 ; NEW_LINE print ( getElement ( N , R , C ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MinValue ( N , X ) : NEW_LINE",
        "explain": "Function to insert X in N and return the minimum value string"
    },
    {
        "py": "N = list ( N ) ; NEW_LINE ln = len ( N ) NEW_LINE",
        "explain": "Variable to store length of string N"
    },
    {
        "py": "position = ln + 1 NEW_LINE",
        "explain": "Variable to denote the position where X must be added"
    },
    {
        "py": "if ( N [ 0 ] == ' - ' ) : NEW_LINE",
        "explain": "If the given string N represent a negative value"
    },
    {
        "py": "for i in range ( ln - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( ( ord ( N [ i ] ) - ord ( '0' ) ) < X ) : NEW_LINE INDENT position = i NEW_LINE DEDENT DEDENT else : NEW_LINE",
        "explain": "X must be place at the last index where is greater than N [ i ]"
    },
    {
        "py": "for i in range ( ln - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( ( ord ( N [ i ] ) - ord ( '0' ) ) > X ) : NEW_LINE INDENT position = i NEW_LINE DEDENT DEDENT",
        "explain": "For positive numbers , X must be placed at the last index where it is smaller than N [ i ]"
    },
    {
        "py": "c = chr ( X + ord ( '0' ) ) NEW_LINE str = N . insert ( position , c ) ; NEW_LINE",
        "explain": "Insert X at that position"
    },
    {
        "py": "return ' ' . join ( N ) NEW_LINE",
        "explain": "Return the string"
    },
    {
        "py": "N = \"89\" NEW_LINE X = 1 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( MinValue ( N , X ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def divisibleByk ( s , n , k ) : NEW_LINE",
        "explain": "Function to check the binary number is divisible by K"
    },
    {
        "py": "poweroftwo = [ 0 for i in range ( n ) ] NEW_LINE",
        "explain": "Array poweroftwo will store pow ( 2 , i ) % k"
    },
    {
        "py": "poweroftwo [ 0 ] = 1 % k NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE",
        "explain": "Initializing the first element in Array"
    },
    {
        "py": "poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k NEW_LINE",
        "explain": "Storing every pow ( 2 , i ) % k value in the array"
    },
    {
        "py": "rem = 0 NEW_LINE",
        "explain": "To store the remaining"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterating till N"
    },
    {
        "py": "if ( s [ n - i - 1 ] == '1' ) : NEW_LINE",
        "explain": "If current bit is 1"
    },
    {
        "py": "rem += ( poweroftwo [ i ] ) NEW_LINE rem %= k NEW_LINE",
        "explain": "Updating rem"
    },
    {
        "py": "if ( rem == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT",
        "explain": "If completely divisible"
    },
    {
        "py": "else : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT",
        "explain": "If not Completely divisible"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "s = \"1010001\" NEW_LINE k = 9 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "length of string s"
    },
    {
        "py": "print ( divisibleByk ( s , n , k ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def maxSumbySplittingstring ( str , N ) : NEW_LINE",
        "explain": "Function to find the maximum sum of count of 0 s in the left suband count of 1 s in the right subby splitting the string"
    },
    {
        "py": "cntOne = 0 NEW_LINE",
        "explain": "Stores count of 1 s the in binary string"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the binary string"
    },
    {
        "py": "' NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE DEDENT",
        "explain": "If current character is '1"
    },
    {
        "py": "cntOne += 1 NEW_LINE",
        "explain": "Update cntOne"
    },
    {
        "py": "zero = 0 NEW_LINE",
        "explain": "Stores count of 0 s"
    },
    {
        "py": "one = 0 NEW_LINE",
        "explain": "Stores count of 1 s"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores maximum sum of count of 0 s and 1 s by splitting the string"
    },
    {
        "py": "for i in range ( N - 1 ) : NEW_LINE",
        "explain": "Traverse the binary string"
    },
    {
        "py": "' NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE DEDENT",
        "explain": "If current character is '0"
    },
    {
        "py": "zero += 1 NEW_LINE",
        "explain": "Update zero"
    },
    {
        "py": "' NEW_LINE INDENT else : NEW_LINE DEDENT",
        "explain": "If current character is '1"
    },
    {
        "py": "one += 1 NEW_LINE",
        "explain": "Update one"
    },
    {
        "py": "res = max ( res , zero + cntOne - one ) NEW_LINE return res NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"00111\" NEW_LINE N = len ( str ) NEW_LINE print ( maxSumbySplittingstring ( str , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def cntBalancedParenthesis ( s , N ) : NEW_LINE",
        "explain": "Function to find the maximum count of pairs required to be removed such that subsequence of string does not contain any valid parenthesis"
    },
    {
        "py": "cntPairs = 0 ; NEW_LINE",
        "explain": "Stores count of pairs of balanced parenthesis"
    },
    {
        "py": "cntCurly = 0 ; NEW_LINE",
        "explain": "Stores count of curly balanced parenthesis"
    },
    {
        "py": "cntSml = 0 ; NEW_LINE",
        "explain": "Stores count of small balanced parenthesis"
    },
    {
        "py": "cntSqr = 0 ; NEW_LINE",
        "explain": "Stores count of square balanced parenthesis"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( ord ( s [ i ] ) == ord ( ' { ' ) ) : NEW_LINE DEDENT",
        "explain": "Iterate over characters of the string"
    },
    {
        "py": "cntCurly += 1 ; NEW_LINE elif ( ord ( s [ i ] ) == ord ( ' ( ' ) ) : NEW_LINE",
        "explain": "Update cntCurly"
    },
    {
        "py": "cntSml += 1 ; NEW_LINE elif ( ord ( s [ i ] ) == ord ( ' [ ' ) ) : NEW_LINE",
        "explain": "Update cntSml"
    },
    {
        "py": "cntSqr += 1 ; NEW_LINE elif ( ord ( s [ i ] ) == ord ( ' } ' ) and cntCurly > 0 ) : NEW_LINE",
        "explain": "Update cntSqr"
    },
    {
        "py": "cntCurly -= 1 ; NEW_LINE",
        "explain": "Update cntCurly"
    },
    {
        "py": "cntPairs += 1 ; NEW_LINE elif ( ord ( s [ i ] ) == ord ( ' ) ' ) and cntSml > 0 ) : NEW_LINE",
        "explain": "Update cntPairs"
    },
    {
        "py": "cntSml -= 1 ; NEW_LINE",
        "explain": "Update cntSml"
    },
    {
        "py": "cntPairs += 1 ; NEW_LINE elif ( ord ( s [ i ] ) == ord ( ' ] ' ) and cntSqr > 0 ) : NEW_LINE",
        "explain": "Update cntPairs"
    },
    {
        "py": "cntSqr -= 1 ; NEW_LINE",
        "explain": "Update cntSml"
    },
    {
        "py": "cntPairs += 1 ; NEW_LINE print ( cntPairs ) ; NEW_LINE",
        "explain": "Update cntPairs"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "s = \" { ( } ) \" ; NEW_LINE N = len ( s ) ; NEW_LINE",
        "explain": "Given String"
    },
    {
        "py": "cntBalancedParenthesis ( s , N ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def arcIntersection ( S , lenn ) : NEW_LINE INDENT stk = [ ] NEW_LINE DEDENT",
        "explain": "Function to check if there is arc intersection or not"
    },
    {
        "py": "for i in range ( lenn ) : NEW_LINE",
        "explain": "Traverse the string S"
    },
    {
        "py": "stk . append ( S [ i ] ) NEW_LINE if ( len ( stk ) >= 2 ) : NEW_LINE",
        "explain": "Insert all the elements in the stack one by one"
    },
    {
        "py": "temp = stk [ - 1 ] NEW_LINE",
        "explain": "Extract the top element"
    },
    {
        "py": "del stk [ - 1 ] NEW_LINE",
        "explain": "Pop out the top element"
    },
    {
        "py": "if ( stk [ - 1 ] == temp ) : NEW_LINE INDENT del stk [ - 1 ] NEW_LINE DEDENT",
        "explain": "Check if the top element is same as the popped element"
    },
    {
        "py": "else : NEW_LINE INDENT stk . append ( temp ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if ( len ( stk ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE",
        "explain": "If the stack is empty"
    },
    {
        "py": "def countString ( arr , N ) : NEW_LINE",
        "explain": "Function to check if there is arc intersection or not for the given array of strings"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores count of string not having arc intersection"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate through array"
    },
    {
        "py": "lenn = len ( arr [ i ] ) NEW_LINE",
        "explain": "Length of every string"
    },
    {
        "py": "count += arcIntersection ( arr [ i ] , lenn ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "print ( count ) NEW_LINE",
        "explain": "Print the desired count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"0101\" , \"0011\" , \"0110\" ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "countString ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def ConvertequivalentBase8 ( S ) : NEW_LINE",
        "explain": "Function to convert the binary string into octal representation"
    },
    {
        "py": "mp = { } NEW_LINE",
        "explain": "Stores binary representation of the decimal value [ 0 - 7 ]"
    },
    {
        "py": "mp [ \"000\" ] = '0' NEW_LINE mp [ \"001\" ] = '1' NEW_LINE mp [ \"010\" ] = '2' NEW_LINE mp [ \"011\" ] = '3' NEW_LINE mp [ \"100\" ] = '4' NEW_LINE mp [ \"101\" ] = '5' NEW_LINE mp [ \"110\" ] = '6' NEW_LINE mp [ \"111\" ] = '7' NEW_LINE",
        "explain": "Stores the decimal values of binary strings [ 0 - 7 ]"
    },
    {
        "py": "N = len ( S ) NEW_LINE if ( N % 3 == 2 ) : NEW_LINE",
        "explain": "Stores length of S"
    },
    {
        "py": "S = \"0\" + S NEW_LINE elif ( N % 3 == 1 ) : NEW_LINE",
        "explain": "Update S"
    },
    {
        "py": "S = \"00\" + S NEW_LINE",
        "explain": "Update S"
    },
    {
        "py": "N = len ( S ) NEW_LINE",
        "explain": "Update N"
    },
    {
        "py": "octal = \" \" NEW_LINE",
        "explain": "Stores octal representation of the binary string"
    },
    {
        "py": "for i in range ( 0 , N , 3 ) : NEW_LINE",
        "explain": "Traverse the binary string"
    },
    {
        "py": "temp = S [ i : i + 3 ] NEW_LINE",
        "explain": "Stores 3 consecutive characters of the binary string"
    },
    {
        "py": "if temp in mp : NEW_LINE octal += ( mp [ temp ] ) NEW_LINE return octal NEW_LINE",
        "explain": "Append octal representation of temp"
    },
    {
        "py": "def binString_div_9 ( S , N ) : NEW_LINE",
        "explain": "Function to check if binary string is divisible by 9 or not"
    },
    {
        "py": "octal = ConvertequivalentBase8 ( S ) NEW_LINE",
        "explain": "Stores octal representation of S"
    },
    {
        "py": "oddSum = 0 NEW_LINE",
        "explain": "Stores sum of elements present at odd positions of oct"
    },
    {
        "py": "evenSum = 0 NEW_LINE",
        "explain": "Stores sum of elements present at odd positions of oct"
    },
    {
        "py": "M = len ( octal ) NEW_LINE",
        "explain": "Stores length of oct"
    },
    {
        "py": "for i in range ( 0 , M , 2 ) : NEW_LINE",
        "explain": "Traverse the string oct"
    },
    {
        "py": "oddSum += ord ( octal [ i ] ) - ord ( '0' ) NEW_LINE",
        "explain": "Update oddSum"
    },
    {
        "py": "for i in range ( 1 , M , 2 ) : NEW_LINE",
        "explain": "Traverse the string oct"
    },
    {
        "py": "evenSum += ord ( octal [ i ] ) - ord ( '0' ) NEW_LINE",
        "explain": "Update evenSum"
    },
    {
        "py": "Oct_9 = 11 NEW_LINE",
        "explain": "Stores cotal representation of 9"
    },
    {
        "py": "if ( abs ( oddSum - evenSum ) % Oct_9 == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE",
        "explain": "If absolute value of ( oddSum - evenSum ) is divisible by Oct_9"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"1010001\" NEW_LINE N = len ( S ) NEW_LINE print ( binString_div_9 ( S , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def min_cost ( S ) : NEW_LINE",
        "explain": "Function to calculate the minimum cost"
    },
    {
        "py": "cost = 0 NEW_LINE",
        "explain": "Stores the minimum cost"
    },
    {
        "py": "F = 0 NEW_LINE",
        "explain": "Stores the count of characters found"
    },
    {
        "py": "B = 0 NEW_LINE",
        "explain": "Stores the count of blank spaces found"
    },
    {
        "py": "n = len ( S ) - S . count ( ' \u2581 ' ) NEW_LINE",
        "explain": "Stores the count of total characters"
    },
    {
        "py": "if n == 1 : NEW_LINE INDENT return cost NEW_LINE DEDENT",
        "explain": "If the count of characters is equal to 1"
    },
    {
        "py": "for char in S : NEW_LINE",
        "explain": "Iterate over the string"
    },
    {
        "py": "if char != ' \u2581 ' : NEW_LINE",
        "explain": "Consider the previous character together with current character"
    },
    {
        "py": "if B != 0 : NEW_LINE",
        "explain": "If not together already"
    },
    {
        "py": "cost += min ( n - F , F ) * B NEW_LINE B = 0 NEW_LINE",
        "explain": "Add the cost to group them together"
    },
    {
        "py": "F += 1 NEW_LINE",
        "explain": "Increase count of characters found"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "B += 1 NEW_LINE",
        "explain": "Increase count of spaces found"
    },
    {
        "py": "return cost NEW_LINE",
        "explain": "Return the total cost obtained"
    },
    {
        "py": "S = \" \u2581 @ TABSYMBOL $ \" NEW_LINE print ( min_cost ( S ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT",
        "explain": "Function that return true if the given character is a vowel"
    },
    {
        "py": "def minCost ( S ) : NEW_LINE",
        "explain": "Function to return the minimum cost to convert all the vowels of a string to a single one"
    },
    {
        "py": "cA = 0 ; NEW_LINE cE = 0 ; NEW_LINE cI = 0 ; NEW_LINE cO = 0 ; NEW_LINE cU = 0 ; NEW_LINE",
        "explain": "Stores count of respective vowels"
    },
    {
        "py": "for i in range ( len ( S ) ) : NEW_LINE",
        "explain": "Iterate through the string"
    },
    {
        "py": "if ( isVowel ( S [ i ] ) ) : NEW_LINE",
        "explain": "If a vowel is encountered"
    },
    {
        "py": "cA += abs ( ord ( S [ i ] ) - ord ( ' a ' ) ) ; NEW_LINE cE += abs ( ord ( S [ i ] ) - ord ( ' e ' ) ) ; NEW_LINE cI += abs ( ord ( S [ i ] ) - ord ( ' i ' ) ) ; NEW_LINE cO += abs ( ord ( S [ i ] ) - ord ( ' o ' ) ) ; NEW_LINE cU += abs ( ord ( S [ i ] ) - ord ( ' u ' ) ) ; NEW_LINE",
        "explain": "Calculate the cost"
    },
    {
        "py": "return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) ; NEW_LINE",
        "explain": "Return the minimum cost"
    },
    {
        "py": "S = \" geeksforgeeks \" ; NEW_LINE print ( minCost ( S ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def decode_String ( st , K ) : NEW_LINE INDENT ans = \" \" NEW_LINE DEDENT",
        "explain": "Function to return the required required string"
    },
    {
        "py": "for i in range ( 0 , len ( st ) , K ) : NEW_LINE",
        "explain": "Iterate the given string"
    },
    {
        "py": "ans += st [ i ] NEW_LINE",
        "explain": "Append the first character of every substring of length K"
    },
    {
        "py": "for i in range ( len ( st ) - ( K - 1 ) , len ( st ) ) : NEW_LINE INDENT ans += st [ i ] NEW_LINE DEDENT print ( ans ) NEW_LINE",
        "explain": "Consider all characters from the last substring"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT K = 3 NEW_LINE st = \" abcbcscsesesesd \" NEW_LINE decode_String ( st , K ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxVowelSubString ( str1 , K ) : NEW_LINE",
        "explain": "Function that prints the lexicographically smallest K - length substring containing maximum number of vowels"
    },
    {
        "py": "N = len ( str1 ) NEW_LINE",
        "explain": "Store the length of the string"
    },
    {
        "py": "pref = [ 0 for i in range ( N ) ] NEW_LINE",
        "explain": "Initialize a prefix sum array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Loop through the string to create the prefix sum array"
    },
    {
        "py": "if ( str1 [ i ] == ' a ' or str1 [ i ] == ' e ' or str1 [ i ] == ' i ' or str1 [ i ] == ' o ' or str1 [ i ] == ' u ' ) : NEW_LINE INDENT pref [ i ] = 1 NEW_LINE DEDENT",
        "explain": "Store 1 at the index if it is a vowel"
    },
    {
        "py": "else : NEW_LINE INDENT pref [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Otherwise , store 0"
    },
    {
        "py": "if ( i ) : NEW_LINE INDENT pref [ i ] += pref [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Process the prefix array"
    },
    {
        "py": "maxCount = pref [ K - 1 ] NEW_LINE",
        "explain": "Initialize the variable to store maximum count of vowels"
    },
    {
        "py": "res = str1 [ 0 : K ] NEW_LINE",
        "explain": "Initialize the variable to store substring with maximum count of vowels"
    },
    {
        "py": "for i in range ( K , N ) : NEW_LINE",
        "explain": "Loop through the prefix array"
    },
    {
        "py": "currCount = pref [ i ] - pref [ i - K ] NEW_LINE",
        "explain": "Store the current count of vowels"
    },
    {
        "py": "if ( currCount > maxCount ) : NEW_LINE INDENT maxCount = currCount NEW_LINE res = str1 [ i - K + 1 : i + 1 ] NEW_LINE DEDENT",
        "explain": "Update the result if current count is greater than maximum count"
    },
    {
        "py": "elif ( currCount == maxCount ) : NEW_LINE INDENT temp = str1 [ i - K + 1 : i + 1 ] NEW_LINE if ( temp < res ) : NEW_LINE INDENT res = temp NEW_LINE DEDENT DEDENT",
        "explain": "Update lexicographically smallest substring if the current count is equal to the maximum count"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" ceebbaceeffo \" NEW_LINE K = 3 NEW_LINE print ( maxVowelSubString ( str1 , K ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def decodeStr ( str , len ) : NEW_LINE",
        "explain": "Function to decode and print the original string"
    },
    {
        "py": "c = [ \" \" for i in range ( len ) ] NEW_LINE pos = 1 NEW_LINE",
        "explain": "To store the decoded string"
    },
    {
        "py": "if ( len % 2 == 1 ) : NEW_LINE INDENT med = int ( len / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT med = int ( len / 2 - 1 ) NEW_LINE DEDENT",
        "explain": "Getting the mid element"
    },
    {
        "py": "c [ med ] = str [ 0 ] NEW_LINE",
        "explain": "Storing the first element of the string at the median position"
    },
    {
        "py": "if ( len % 2 == 0 ) : NEW_LINE INDENT c [ med + 1 ] = str [ 1 ] NEW_LINE DEDENT",
        "explain": "If the length is even then store the second element also"
    },
    {
        "py": "if ( len & 1 ) : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 2 NEW_LINE DEDENT for i in range ( k , len , 2 ) : NEW_LINE INDENT c [ med - pos ] = str [ i ] NEW_LINE DEDENT",
        "explain": "k represents the number of characters that are already stored in the c [ ]"
    },
    {
        "py": "if ( len % 2 == 1 ) : NEW_LINE INDENT c [ med + pos ] = str [ i + 1 ] NEW_LINE DEDENT",
        "explain": "If string length is odd"
    },
    {
        "py": "else : NEW_LINE INDENT c [ med + pos + 1 ] = str [ i + 1 ] NEW_LINE DEDENT pos += 1 NEW_LINE",
        "explain": "If it is even"
    },
    {
        "py": "print ( * c , sep = \" \" ) NEW_LINE",
        "explain": "Print the decoded string"
    },
    {
        "py": "str = \" ofrsgkeeeekgs \" NEW_LINE len = len ( str ) NEW_LINE decodeStr ( str , len ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findCount ( s , L , R ) : NEW_LINE",
        "explain": "Python3 program for Naive Approach"
    },
    {
        "py": "distinct = 0 NEW_LINE",
        "explain": "Counter to count distinct char"
    },
    {
        "py": "frequency = [ 0 for i in range ( 26 ) ] NEW_LINE",
        "explain": "Initializing frequency array to count characters as the appear in substring S [ L : R ]"
    },
    {
        "py": "for i in range ( L , R + 1 , 1 ) : NEW_LINE",
        "explain": "Iterating over S [ L ] to S [ R ]"
    },
    {
        "py": "frequency [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE for i in range ( 26 ) : NEW_LINE",
        "explain": "Incrementing the count of s [ i ] character in frequency array"
    },
    {
        "py": "if ( frequency [ i ] > 0 ) : NEW_LINE INDENT distinct += 1 NEW_LINE DEDENT print ( distinct ) NEW_LINE",
        "explain": "If frequency of any character is > 0 then increment the counter"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" geeksforgeeksisacomputerscienceportal \" NEW_LINE queries = 3 NEW_LINE Q = [ [ 0 , 10 ] , [ 15 , 18 ] , [ 12 , 20 ] ] NEW_LINE for i in range ( queries ) : NEW_LINE INDENT findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def ReverseComplement ( s , n , k ) : NEW_LINE",
        "explain": "Function to perform K operations upon the string and find modified string"
    },
    {
        "py": "rev = ( k + 1 ) // 2 NEW_LINE",
        "explain": "Number of reverse operations"
    },
    {
        "py": "complement = k - rev NEW_LINE",
        "explain": "Number of complement operations"
    },
    {
        "py": "if ( rev % 2 ) : NEW_LINE INDENT s = s [ : : - 1 ] NEW_LINE DEDENT",
        "explain": "If rev is odd parity"
    },
    {
        "py": "if ( complement % 2 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "If complement is odd parity"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE INDENT s [ i ] = '1' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = '0' NEW_LINE DEDENT",
        "explain": "Complementing each position"
    },
    {
        "py": "return s NEW_LINE",
        "explain": "Return the modified string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \"10011\" NEW_LINE k = 5 NEW_LINE n = len ( str1 ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( ReverseComplement ( str1 , n , k ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def repeatingString ( s , n , k ) : NEW_LINE",
        "explain": "Function to check that permutation of the given string is a K times repeating String"
    },
    {
        "py": "if ( n % k != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If length of string is not divisible by K"
    },
    {
        "py": "frequency = [ 0 for i in range ( 123 ) ] NEW_LINE",
        "explain": "Frequency Array"
    },
    {
        "py": "for i in range ( 123 ) : NEW_LINE INDENT frequency [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Initially frequency of each character is 0"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT frequency [ s [ i ] ] += 1 NEW_LINE DEDENT repeat = n // k NEW_LINE",
        "explain": "Computing the frequency of each character in the string"
    },
    {
        "py": "for i in range ( 123 ) : NEW_LINE INDENT if ( frequency [ i ] % repeat != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "Loop to check that frequency of every character of the string is divisible by K"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" abcdcba \" NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE if ( repeatingString ( s , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findPhoneNumber ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE DEDENT",
        "explain": "Function to find the last two digits of the number and print the complete number"
    },
    {
        "py": "while ( temp != 0 ) : NEW_LINE INDENT sum += temp % 10 NEW_LINE temp = temp // 10 NEW_LINE DEDENT",
        "explain": "Sum of the first eight digits of the number"
    },
    {
        "py": "if ( sum < 10 ) : NEW_LINE INDENT print ( n , \"0\" , sum ) NEW_LINE DEDENT",
        "explain": "if sum < 10 , then the two digits are '0' and the value of sum"
    },
    {
        "py": "else : NEW_LINE INDENT n = str ( n ) NEW_LINE sum = str ( sum ) NEW_LINE n += sum NEW_LINE print ( n ) NEW_LINE DEDENT",
        "explain": "if sum > 10 , then the two digits are the value of sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 98765432 NEW_LINE findPhoneNumber ( n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def cntSplits ( s ) : NEW_LINE",
        "explain": "Function to return the required count"
    },
    {
        "py": "if ( s [ len ( s ) - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "If the splitting is not possible"
    },
    {
        "py": "c_zero = 0 ; NEW_LINE",
        "explain": "To store the count of zeroes"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE INDENT c_zero += ( s [ i ] == '0' ) ; NEW_LINE DEDENT",
        "explain": "Counting the number of zeroes"
    },
    {
        "py": "return int ( pow ( 2 , c_zero - 1 ) ) ; NEW_LINE",
        "explain": "Return the final answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"10010\" ; NEW_LINE print ( cntSplits ( s ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findNumbers ( s ) : NEW_LINE",
        "explain": "Function to return the number of substrings of same characters"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "Size of the string"
    },
    {
        "py": "count = 1 NEW_LINE result = 0 NEW_LINE",
        "explain": "Initialize count to 1"
    },
    {
        "py": "left = 0 NEW_LINE right = 1 NEW_LINE while ( right < n ) : NEW_LINE",
        "explain": "Initialize left to 0 and right to 1 to traverse the string"
    },
    {
        "py": "if ( s [ left ] == s [ right ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Checking if consecutive characters are same and increment the count"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "When we encounter a different characters"
    },
    {
        "py": "result += count * ( count + 1 ) // 2 NEW_LINE",
        "explain": "Increment the result"
    },
    {
        "py": "left = right NEW_LINE count = 1 NEW_LINE right += 1 NEW_LINE",
        "explain": "To repeat the whole process set left equals right and count variable to 1"
    },
    {
        "py": "result += count * ( count + 1 ) // 2 NEW_LINE print ( result ) NEW_LINE",
        "explain": "Store the final value of result"
    },
    {
        "py": "s = \" bbbcbb \" NEW_LINE findNumbers ( s ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isVowel ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE if ( ch == ' A ' or ch == ' E ' or ch == ' I ' or ch == ' O ' or ch == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check for the Vowel"
    },
    {
        "py": "def duplicateVowels ( S ) : NEW_LINE INDENT t = len ( S ) NEW_LINE DEDENT",
        "explain": "Function to get the resultant String with vowels duplicated"
    },
    {
        "py": "res = \" \" NEW_LINE",
        "explain": "Another to store the resultant String"
    },
    {
        "py": "for i in range ( t ) : NEW_LINE INDENT if ( isVowel ( S [ i ] ) ) : NEW_LINE INDENT res += S [ i ] NEW_LINE DEDENT res += S [ i ] NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Loop to check for each character"
    },
    {
        "py": "S = \" helloworld \" NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( \" Original \u2581 String : \u2581 \" , S ) NEW_LINE res = duplicateVowels ( S ) NEW_LINE",
        "explain": "Print the original String"
    },
    {
        "py": "print ( \" String \u2581 with \u2581 Vowels \u2581 duplicated : \u2581 \" , res ) NEW_LINE",
        "explain": "Print the resultant String"
    },
    {
        "py": "def stringToInt ( str ) : NEW_LINE",
        "explain": "Recursive function to convert string to integer"
    },
    {
        "py": "if ( len ( str ) == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE DEDENT",
        "explain": "If the number represented as a string contains only a single digit then returns its value"
    },
    {
        "py": "y = stringToInt ( str [ 1 : ] ) ; NEW_LINE",
        "explain": "Recursive call for the sub - string starting at the second character"
    },
    {
        "py": "x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE",
        "explain": "First digit of the number"
    },
    {
        "py": "x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEW_LINE return int ( x ) ; NEW_LINE",
        "explain": "First digit multiplied by the appropriate power of 10 and then add the recursive result For example , xy = ( ( x * 10 ) + y )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \"1235\" ; NEW_LINE print ( stringToInt ( str ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 26 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def largestSubSeq ( arr , n ) : NEW_LINE",
        "explain": "Function to return the length of the longest sub - sequence with at least one common character in every string"
    },
    {
        "py": "count = [ 0 ] * MAX NEW_LINE",
        "explain": "count [ 0 ] will store the number of strings which contain ' a ' , count [ 1 ] will store the number of strings which contain ' b ' and so on . ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT string = arr [ i ] NEW_LINE DEDENT",
        "explain": "For every string"
    },
    {
        "py": "_hash = [ False ] * MAX NEW_LINE for j in range ( len ( string ) ) : NEW_LINE INDENT _hash [ ord ( string [ j ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for j in range ( MAX ) : NEW_LINE",
        "explain": "Hash array to set which character is present in the current string"
    },
    {
        "py": "if _hash [ j ] == True : NEW_LINE INDENT count [ j ] += 1 NEW_LINE DEDENT return max ( count ) NEW_LINE",
        "explain": "If current character appears in the string then update its count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" ab \" , \" bc \" , \" de \" ] NEW_LINE n = len ( arr ) NEW_LINE print ( largestSubSeq ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isPalindrome ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ l - 1 - i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "Function that returns true if str is a palindrome"
    },
    {
        "py": "def createStringAndCheckPalindrome ( N ) : NEW_LINE",
        "explain": "Function that returns true if the generated string is a palindrome"
    },
    {
        "py": "sub = \" \" + chr ( N ) NEW_LINE res_str = \" \" NEW_LINE sum = 0 NEW_LINE",
        "explain": "sub contains N as a string"
    },
    {
        "py": "while ( N > 0 ) : NEW_LINE INDENT digit = N % 10 NEW_LINE sum += digit NEW_LINE N = N // 10 NEW_LINE DEDENT",
        "explain": "Calculate the sum of the digits"
    },
    {
        "py": "while ( len ( res_str ) < sum ) : NEW_LINE INDENT res_str += sub NEW_LINE DEDENT",
        "explain": "Repeat the substring until the length of the resultant string < sum"
    },
    {
        "py": "if ( len ( res_str ) > sum ) : NEW_LINE INDENT res_str = res_str [ 0 : sum ] NEW_LINE DEDENT",
        "explain": "If length of the resultant string exceeded sum then take substring from 0 to sum - 1"
    },
    {
        "py": "if ( isPalindrome ( res_str ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If the generated string is a palindrome"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10101 NEW_LINE if ( createStringAndCheckPalindrome ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minimumLength ( s ) : NEW_LINE INDENT maxOcc = 0 NEW_LINE n = len ( s ) NEW_LINE arr = [ 0 ] * 26 NEW_LINE DEDENT",
        "explain": "Function to find the minimum length"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Count the frequency of each alphabet"
    },
    {
        "py": "for i in range ( 26 ) : NEW_LINE INDENT if arr [ i ] > maxOcc : NEW_LINE INDENT maxOcc = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Find the alphabets with maximum frequency"
    },
    {
        "py": "return n - maxOcc NEW_LINE",
        "explain": "Subtract the frequency of character from length of string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" afddewqd \" NEW_LINE print ( minimumLength ( str ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def removeSpecialCharacter ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while i < len ( s ) : NEW_LINE DEDENT",
        "explain": "function to remove characters and pr new string"
    },
    {
        "py": "if ( ord ( s [ i ] ) < ord ( ' A ' ) or ord ( s [ i ] ) > ord ( ' Z ' ) and ord ( s [ i ] ) < ord ( ' a ' ) or ord ( s [ i ] ) > ord ( ' z ' ) ) : NEW_LINE",
        "explain": "Finding the character whose ASCII value fall under this range"
    },
    {
        "py": "del s [ i ] NEW_LINE i -= 1 NEW_LINE i += 1 NEW_LINE print ( \" \" . join ( s ) ) NEW_LINE",
        "explain": "erase function to erase the character"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" NEW_LINE s = [ i for i in s ] NEW_LINE removeSpecialCharacter ( s ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def removeSpecialCharacter ( s ) : NEW_LINE INDENT t = \" \" NEW_LINE for i in s : NEW_LINE DEDENT",
        "explain": "Function to remove special characters and store it in another variable"
    },
    {
        "py": "if ( i >= ' A ' and i <= ' Z ' ) or ( i >= ' a ' and i <= ' z ' ) : NEW_LINE INDENT t += i NEW_LINE DEDENT print ( t ) NEW_LINE",
        "explain": "Store only valid characters"
    },
    {
        "py": "s = \" $ Gee * k ; s . . fo , \u2581 r ' Ge ^ eks ? \" NEW_LINE removeSpecialCharacter ( s ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findRepeatFirstN2 ( s ) : NEW_LINE",
        "explain": "Python3 program to find the first character that is repeated"
    },
    {
        "py": "p = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT p = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( p != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return p NEW_LINE",
        "explain": "this is O ( N ^ 2 ) method"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE pos = findRepeatFirstN2 ( str ) NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( \" Not \u2581 found \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( str [ pos ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def prCharWithFreq ( str ) : NEW_LINE",
        "explain": "Python3 implementation to print the characters and frequencies in order of its occurrence"
    },
    {
        "py": "d = { } NEW_LINE for i in str : NEW_LINE INDENT if i in d : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Store all characters and their frequencies in dictionary"
    },
    {
        "py": "for i in str : NEW_LINE",
        "explain": "Print characters and their frequencies in same order of their appearance"
    },
    {
        "py": "if d [ i ] != 0 : NEW_LINE INDENT print ( \" { } { } \" . format ( i , d [ i ] ) , end = \" \u2581 \" ) NEW_LINE d [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Print only if this character is not printed before ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" ; NEW_LINE prCharWithFreq ( str ) ; NEW_LINE DEDENT ' NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def possibleStrings ( n , r , b , g ) : NEW_LINE",
        "explain": "Function to calculate number of strings"
    },
    {
        "py": "fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT",
        "explain": "Store factorial of numbers up to n for further computation"
    },
    {
        "py": "left = n - ( r + g + b ) NEW_LINE sum = 0 NEW_LINE",
        "explain": "Find the remaining values to be added"
    },
    {
        "py": "for i in range ( 0 , left + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , left - i + 1 , 1 ) : NEW_LINE INDENT k = left - ( i + j ) NEW_LINE DEDENT DEDENT",
        "explain": "Make all possible combinations of R , B and G for the remaining value"
    },
    {
        "py": "sum = ( sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ) NEW_LINE",
        "explain": "Compute permutation of each combination one by one and add them ."
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "Return total no . of strings / permutation"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE r = 2 NEW_LINE b = 0 NEW_LINE g = 1 NEW_LINE print ( int ( possibleStrings ( n , r , b , g ) ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "CHARS = 26 NEW_LINE",
        "explain": "Python 3 program to find minimum number of characters to be removed to make two strings anagram ."
    },
    {
        "py": "def remAnagram ( str1 , str2 ) : NEW_LINE",
        "explain": "function to calculate minimum numbers of characters to be removed to make two strings anagram"
    },
    {
        "py": "count1 = [ 0 ] * CHARS NEW_LINE count2 = [ 0 ] * CHARS NEW_LINE",
        "explain": "make hash array for both string and calculate frequency of each character"
    },
    {
        "py": "i = 0 NEW_LINE while i < len ( str1 ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "count frequency of each character in first string"
    },
    {
        "py": "i = 0 NEW_LINE while i < len ( str2 ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "count frequency of each character in second string"
    },
    {
        "py": "result = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT result += abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT return result NEW_LINE",
        "explain": "traverse count arrays to find number of characters to be removed"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" bcadeh \" NEW_LINE str2 = \" hea \" NEW_LINE print ( remAnagram ( str1 , str2 ) ) NEW_LINE DEDENT",
        "explain": "Driver program to run the case"
    },
    {
        "py": "CHARS = 26 NEW_LINE",
        "explain": "Assuming only lower case characters"
    },
    {
        "py": "def isValidString ( str ) : NEW_LINE INDENT freq = [ 0 ] * CHARS NEW_LINE DEDENT",
        "explain": "To check a string S can be converted to a valid string by removing less than or equal to one character ."
    },
    {
        "py": "for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "freq [ ] : stores the frequency of each character of a string"
    },
    {
        "py": "freq1 = 0 NEW_LINE count_freq1 = 0 NEW_LINE for i in range ( CHARS ) : NEW_LINE INDENT if ( freq [ i ] != 0 ) : NEW_LINE INDENT freq1 = freq [ i ] NEW_LINE count_freq1 = 1 NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Find first character with non - zero frequency"
    },
    {
        "py": "freq2 = 0 NEW_LINE count_freq2 = 0 NEW_LINE for j in range ( i + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ j ] != 0 ) : NEW_LINE INDENT if ( freq [ j ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_freq2 = 1 NEW_LINE freq2 = freq [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Find a character with frequency different from freq1 ."
    },
    {
        "py": "for k in range ( j + 1 , CHARS ) : NEW_LINE INDENT if ( freq [ k ] != 0 ) : NEW_LINE INDENT if ( freq [ k ] == freq1 ) : NEW_LINE INDENT count_freq1 += 1 NEW_LINE DEDENT if ( freq [ k ] == freq2 ) : NEW_LINE INDENT count_freq2 += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "If we find a third non - zero frequency or count of both frequencies become more than 1 , then return false"
    },
    {
        "py": "else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If we find a third non - zero freq"
    },
    {
        "py": "if ( count_freq1 > 1 and count_freq2 > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If counts of both frequencies is more than 1"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "Return true if we reach here"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" abcbc \" NEW_LINE if ( isValidString ( str ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def checkForVariation ( strr ) : NEW_LINE INDENT if ( len ( strr ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT mapp = { } NEW_LINE DEDENT",
        "explain": "To check a string S can be converted to a variation string"
    },
    {
        "py": "for i in range ( len ( strr ) ) : NEW_LINE INDENT if strr [ i ] in mapp : NEW_LINE INDENT mapp [ strr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mapp [ strr [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Run loop form 0 to length of string"
    },
    {
        "py": "first = True NEW_LINE second = True NEW_LINE val1 = 0 NEW_LINE val2 = 0 NEW_LINE countOfVal1 = 0 NEW_LINE countOfVal2 = 0 NEW_LINE for itr in mapp : NEW_LINE INDENT i = itr NEW_LINE DEDENT",
        "explain": "declaration of variables"
    },
    {
        "py": "if ( first ) : NEW_LINE INDENT val1 = i NEW_LINE first = False NEW_LINE countOfVal1 += 1 NEW_LINE continue NEW_LINE DEDENT if ( i == val1 ) : NEW_LINE INDENT countOfVal1 += 1 NEW_LINE continue NEW_LINE DEDENT",
        "explain": "if first is true than countOfVal1 increase"
    },
    {
        "py": "if ( second ) : NEW_LINE INDENT val2 = i NEW_LINE countOfVal2 += 1 NEW_LINE second = False NEW_LINE continue NEW_LINE DEDENT if ( i == val2 ) : NEW_LINE INDENT countOfVal2 += 1 NEW_LINE continue NEW_LINE DEDENT if ( countOfVal1 > 1 and countOfVal2 > 1 ) : NEW_LINE return False NEW_LINE else : NEW_LINE return True NEW_LINE",
        "explain": "if second is true than countOfVal2 increase"
    },
    {
        "py": "print ( checkForVariation ( \" abcbc \" ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countCompletePairs ( set1 , set2 , n , m ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT",
        "explain": "Returns count of complete pairs from set [ 0. . n - 1 ] and set2 [ 0. . m - 1 ]"
    },
    {
        "py": "con_s1 , con_s2 = [ 0 ] * n , [ 0 ] * m NEW_LINE",
        "explain": "con_s1 [ i ] is going to store an integer whose set bits represent presence / absence of characters in set1 [ i ] . Similarly con_s2 [ i ] is going to store an integer whose set bits represent presence / absence of characters in set2 [ i ]"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Process all strings in set1 [ ]"
    },
    {
        "py": "con_s1 [ i ] = 0 NEW_LINE for j in range ( len ( set1 [ i ] ) ) : NEW_LINE",
        "explain": "initializing all bits to 0"
    },
    {
        "py": "con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( ord ( set1 [ i ] [ j ] ) - ord ( ' a ' ) ) ) NEW_LINE",
        "explain": "Setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer ."
    },
    {
        "py": "for i in range ( m ) : NEW_LINE",
        "explain": "Process all strings in set2 [ ]"
    },
    {
        "py": "con_s2 [ i ] = 0 NEW_LINE for j in range ( len ( set2 [ i ] ) ) : NEW_LINE",
        "explain": "initializing all bits to 0"
    },
    {
        "py": "con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( ord ( set2 [ i ] [ j ] ) - ord ( ' a ' ) ) ) NEW_LINE",
        "explain": "setting the ascii code of char s [ i ] [ j ] to 1 in the compressed integer ."
    },
    {
        "py": "complete = ( 1 << 26 ) - 1 NEW_LINE",
        "explain": "assigning a variable whose all 26 ( 0. . 25 ) bits are set to 1"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT",
        "explain": "Now consider every pair of integer in con_s1 [ ] and con_s2 [ ] and check if the pair is complete ."
    },
    {
        "py": "if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT return result NEW_LINE",
        "explain": "if all bits are set , the strings are complete !"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set1 = [ \" abcdefgh \" , \" geeksforgeeks \" , \" lmnopqrst \" , \" abc \" ] NEW_LINE set2 = [ \" ijklmnopqrstuvwxyz \" , \" abcdefghijklmnopqrstuvwxyz \" , \" defghijklmnopqrstuvwxyz \" ] NEW_LINE n = len ( set1 ) NEW_LINE m = len ( set2 ) NEW_LINE print ( countCompletePairs ( set1 , set2 , n , m ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def encodeString ( Str ) : NEW_LINE INDENT map = { } NEW_LINE res = \" \" NEW_LINE i = 0 NEW_LINE DEDENT",
        "explain": "Function to encode given string"
    },
    {
        "py": "for ch in Str : NEW_LINE",
        "explain": "For each character in given string"
    },
    {
        "py": "if ch not in map : NEW_LINE INDENT map [ ch ] = i NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "If the character is occurring for the first time , assign next unique number to that char"
    },
    {
        "py": "res += str ( map [ ch ] ) NEW_LINE return res NEW_LINE",
        "explain": "Append the number associated with current character into the output string"
    },
    {
        "py": "def findMatchedWords ( dict , pattern ) : NEW_LINE",
        "explain": "Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"
    },
    {
        "py": "Len = len ( pattern ) NEW_LINE",
        "explain": "len is length of the pattern"
    },
    {
        "py": "hash = encodeString ( pattern ) NEW_LINE",
        "explain": "Encode the string"
    },
    {
        "py": "for word in dict : NEW_LINE",
        "explain": "For each word in the dictionary array"
    },
    {
        "py": "if ( len ( word ) == Len and encodeString ( word ) == hash ) : NEW_LINE INDENT print ( word , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If size of pattern is same as size of current dictionary word and both pattern and the word has same hash , print the word"
    },
    {
        "py": "dict = [ \" abb \" , \" abc \" , \" xyz \" , \" xyy \" ] NEW_LINE pattern = \" foo \" NEW_LINE findMatchedWords ( dict , pattern ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def check ( pattern , word ) : NEW_LINE INDENT if ( len ( pattern ) != len ( word ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT ch = [ 0 for i in range ( 128 ) ] NEW_LINE Len = len ( word ) NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( ch [ ord ( pattern [ i ] ) ] == 0 ) : NEW_LINE INDENT ch [ ord ( pattern [ i ] ) ] = word [ i ] NEW_LINE DEDENT elif ( ch [ ord ( pattern [ i ] ) ] != word [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "Python3 program to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"
    },
    {
        "py": "def findMatchedWords ( Dict , pattern ) : NEW_LINE",
        "explain": "Function to print all the strings that match the given pattern where every character in the pattern is uniquely mapped to a character in the dictionary"
    },
    {
        "py": "Len = len ( pattern ) NEW_LINE",
        "explain": "len is length of the pattern"
    },
    {
        "py": "for word in range ( len ( Dict ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( check ( pattern , Dict [ word ] ) ) : NEW_LINE INDENT print ( Dict [ word ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "For each word in the dictionary"
    },
    {
        "py": "Dict = [ \" abb \" , \" abc \" , \" xyz \" , \" xyy \" ] NEW_LINE pattern = \" foo \" NEW_LINE findMatchedWords ( Dict , pattern ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countWords ( Str ) : NEW_LINE",
        "explain": "Function to count total number of words in the string"
    },
    {
        "py": "if ( Str == None or len ( Str ) == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT wordCount = 0 NEW_LINE isWord = False NEW_LINE endOfLine = len ( Str ) - 1 NEW_LINE",
        "explain": "Check if the string is null or empty then return zero"
    },
    {
        "py": "ch = list ( Str ) NEW_LINE for i in range ( len ( ch ) ) : NEW_LINE",
        "explain": "Converting the given string into a character array"
    },
    {
        "py": "if ( ch [ i ] . isalpha ( ) and i != endOfLine ) : NEW_LINE INDENT isWord = True NEW_LINE DEDENT",
        "explain": "Check if the character is a letter and index of character array doesn 't  equal to end of line that means, it is  a word and set isWord by true"
    },
    {
        "py": "elif ( not ch [ i ] . isalpha ( ) and isWord ) : NEW_LINE INDENT wordCount += 1 NEW_LINE isWord = False NEW_LINE DEDENT",
        "explain": "Check if the character is not a letter that means there is a space , then we increment the wordCount by one and set the isWord by false"
    },
    {
        "py": "elif ( ch [ i ] . isalpha ( ) and i == endOfLine ) : NEW_LINE INDENT wordCount += 1 NEW_LINE DEDENT",
        "explain": "Check for the last word of the sentence and increment the wordCount by one"
    },
    {
        "py": "return wordCount NEW_LINE",
        "explain": "Return the total number of words in the string"
    },
    {
        "py": "Str =   \" One two three NEW_LINE INDENT four five   \" NEW_LINE DEDENT",
        "explain": "Given String str"
    },
    {
        "py": "print ( \" No \u2581 of \u2581 words \u2581 : \" , countWords ( Str ) ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "def RevString ( s , l ) : NEW_LINE",
        "explain": "Reverse the string"
    },
    {
        "py": "INDENT if l % 2 == 0 : NEW_LINE DEDENT",
        "explain": "Check if number of words is even"
    },
    {
        "py": "j = int ( l / 2 ) NEW_LINE",
        "explain": "Find the middle word"
    },
    {
        "py": "while ( j <= l - 1 ) : NEW_LINE s [ j ] , s [ l - j - 1 ] = s [ l - j - 1 ] , s [ j ] NEW_LINE j += 1 NEW_LINE",
        "explain": "Starting from the middle start swapping words at jth position and l - 1 - j position"
    },
    {
        "py": "INDENT else : NEW_LINE DEDENT",
        "explain": "Check if number of words is odd"
    },
    {
        "py": "j = int ( l / 2 + 1 ) NEW_LINE",
        "explain": "Find the middle word"
    },
    {
        "py": "while ( j <= l - 1 ) : NEW_LINE s [ j ] , s [ l - 1 - j ] = s [ l - j - 1 ] , s [ j ] NEW_LINE j += 1 NEW_LINE",
        "explain": "Starting from the middle start swapping the words at jth position and l - 1 - j position"
    },
    {
        "py": "return s ; NEW_LINE",
        "explain": "return the reversed sentence"
    },
    {
        "py": "s = ' getting \u2581 good \u2581 at \u2581 coding \u2581 needs \u2581 a \u2581 lot \u2581 of \u2581 practice ' NEW_LINE string = s . split ( ' \u2581 ' ) NEW_LINE string = RevString ( string , len ( string ) ) NEW_LINE print ( \" \u2581 \" . join ( string ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printPath ( res , nThNode , kThNode ) : NEW_LINE",
        "explain": "Function to print path of all the nodes nth node represent as given node kth node represents as left and right node"
    },
    {
        "py": "if kThNode > nThNode : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "base condition if kth node value is greater then nth node then its means kth node is not valid so we not store it into the res simply we just return"
    },
    {
        "py": "res . append ( kThNode ) NEW_LINE",
        "explain": "Storing node into res"
    },
    {
        "py": "for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the path from root to node"
    },
    {
        "py": "printPath ( res [ : ] , nThNode , kThNode * 2 ) NEW_LINE",
        "explain": "store left path of a tree So for left we will go node ( kThNode * 2 )"
    },
    {
        "py": "printPath ( res [ : ] , nThNode , kThNode * 2 + 1 ) NEW_LINE",
        "explain": "right path of a tree and for right we will go node ( kThNode * 2 + 1 )"
    },
    {
        "py": "def printPathToCoverAllNodeUtil ( nThNode ) : NEW_LINE",
        "explain": "Function to print path from root to all of the nodes"
    },
    {
        "py": "res = [ ] NEW_LINE",
        "explain": "res is for store the path from root to particulate node"
    },
    {
        "py": "printPath ( res , nThNode , 1 ) NEW_LINE",
        "explain": "Print path from root to all node . third argument 1 because of we have to consider root node is 1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "nThNode = 7 NEW_LINE",
        "explain": "Given Node"
    },
    {
        "py": "printPathToCoverAllNodeUtil ( nThNode ) NEW_LINE",
        "explain": "Print path from root to all node ."
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python code to implement above approach"
    },
    {
        "py": "def getMid ( s : int , e : int ) -> int : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT",
        "explain": "A utility function to get the middle index of given range ."
    },
    {
        "py": "def isArmstrong ( x : int ) -> bool : NEW_LINE INDENT n = len ( str ( x ) ) NEW_LINE sum1 = 0 NEW_LINE temp = x NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT digit = temp % 10 NEW_LINE sum1 += pow ( digit , n ) NEW_LINE temp //= 10 NEW_LINE DEDENT if ( sum1 == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "Function that return true if num is armstrong else return false"
    },
    {
        "py": "def MaxUtil ( st , ss , se , l , r , node ) : NEW_LINE",
        "explain": "A recursive function to get the sum of values in the given range of the array . The following are parameters for this function . st -> Pointer to segment tree node -> Index of current node in the segment tree . ss & se -> Starting and ending indexes of the segment represented by current node , i . e . , st [ node ] l & r -> Starting and ending indexes of range query"
    },
    {
        "py": "if ( l <= ss and r >= se ) : NEW_LINE INDENT return st [ node ] NEW_LINE DEDENT",
        "explain": "If segment of this node is completely part of given range , then return the max of segment ."
    },
    {
        "py": "if ( se < l or ss > r ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "If segment of this node does not belong to given range"
    },
    {
        "py": "mid = getMid ( ss , se ) NEW_LINE return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) NEW_LINE",
        "explain": "If segment of this node is partially the part of given range"
    },
    {
        "py": "def updateValue ( arr , st , ss , se , index , value , node ) : NEW_LINE INDENT if ( index < ss or index > se ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return NEW_LINE DEDENT if ( ss == se ) : NEW_LINE DEDENT",
        "explain": "A recursive function to update the nodes which have the given the index in their range . The following are parameters st , ss and se are same as defined above index -> index of the element to be updated ."
    },
    {
        "py": "arr [ index ] = value NEW_LINE if ( isArmstrong ( value ) ) : NEW_LINE INDENT st [ node ] = value NEW_LINE DEDENT else : NEW_LINE INDENT st [ node ] = - 1 NEW_LINE DEDENT else : NEW_LINE mid = getMid ( ss , se ) NEW_LINE if ( index >= ss and index <= mid ) : NEW_LINE INDENT updateValue ( arr , st , ss , mid , index , value , 2 * node + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 2 ) NEW_LINE DEDENT st [ node ] = max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) NEW_LINE return NEW_LINE",
        "explain": "update value in array and in segment tree"
    },
    {
        "py": "def getMax ( st , n , l , r ) : NEW_LINE",
        "explain": "Return max of elements in range from index l ( query start ) to r ( query end ) ."
    },
    {
        "py": "if ( l < 0 or r > n - 1 or l > r ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) NEW_LINE",
        "explain": "Check for erroneous input values"
    },
    {
        "py": "def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE",
        "explain": "A recursive function that constructs Segment Tree for array [ ss . . se ] . si is index of current node in segment tree st"
    },
    {
        "py": "if ( ss == se ) : NEW_LINE INDENT if ( isArmstrong ( arr [ ss ] ) ) : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = - 1 NEW_LINE DEDENT return st [ si ] NEW_LINE DEDENT",
        "explain": "If there is one element in array , store it in current node of segment tree and return"
    },
    {
        "py": "mid = getMid ( ss , se ) NEW_LINE st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) NEW_LINE return st [ si ] NEW_LINE",
        "explain": "If there are more than one elements , then recur for left and right subtrees and store the max of values in this node"
    },
    {
        "py": "def constructST ( arr , n ) : NEW_LINE",
        "explain": "Function to construct a segment tree from given array . This function allocates memory for segment tree ."
    },
    {
        "py": "x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE",
        "explain": "Height of segment tree"
    },
    {
        "py": "max_size = 2 * int ( math . pow ( 2 , x ) ) - 1 NEW_LINE",
        "explain": "Maximum size of segment tree"
    },
    {
        "py": "st = [ 0 for _ in range ( max_size ) ] NEW_LINE",
        "explain": "Allocate memory"
    },
    {
        "py": "constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE",
        "explain": "Fill the allocated memory st"
    },
    {
        "py": "return st NEW_LINE",
        "explain": "Return the constructed segment tree"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 192 , 113 , 535 , 7 , 19 , 111 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "st = constructST ( arr , n ) NEW_LINE",
        "explain": "Build segment tree from given array"
    },
    {
        "py": "print ( \" Maximum \u2581 armstrong \u2581 number \u2581 in \u2581 given \u2581 range \u2581 = \u2581 { } \" . format ( getMax ( st , n , 1 , 3 ) ) ) NEW_LINE",
        "explain": "Print max of values in array from index 1 to 3"
    },
    {
        "py": "updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) NEW_LINE",
        "explain": "Update : set arr [ 1 ] = 153 and update corresponding segment tree nodes ."
    },
    {
        "py": "print ( \" Updated \u2581 Maximum \u2581 armstrong \u2581 number \u2581 in \u2581 given \u2581 range \u2581 = \u2581 { } \" . format ( getMax ( st , n , 1 , 3 ) ) ) NEW_LINE",
        "explain": "Find max after the value is updated"
    },
    {
        "py": "def maxRegions ( n ) : NEW_LINE INDENT num = n * ( n + 1 ) // 2 + 1 NEW_LINE DEDENT",
        "explain": "Function to find the maximum number of regions on a plane"
    },
    {
        "py": "print ( num ) NEW_LINE",
        "explain": "print the maximum number of regions"
    },
    {
        "py": "n = 10 NEW_LINE maxRegions ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def checkSolveable ( n , m ) : NEW_LINE",
        "explain": "Function to check if the jigsaw Puzzle is solveable or not"
    },
    {
        "py": "if n == 1 or m == 1 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "elif m == 2 and n == 2 : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "By placing the blank tabs as a chain"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1 NEW_LINE m = 3 NEW_LINE checkSolveable ( n , m ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def GCD ( a , b ) : NEW_LINE",
        "explain": "Function to find the GCD of two numbers a and b"
    },
    {
        "py": "if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "else : NEW_LINE INDENT return GCD ( b , a % b ) NEW_LINE DEDENT",
        "explain": "Recursively find the GCD"
    },
    {
        "py": "def check ( x , y ) : NEW_LINE",
        "explain": "Function to check if ( x , y ) can be reached from ( 1 , 0 ) from given moves"
    },
    {
        "py": "if ( GCD ( x , y ) == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "If GCD is 1 , then pr \" Yes \""
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "X = 2 NEW_LINE Y = 7 NEW_LINE",
        "explain": "Given X and Y"
    },
    {
        "py": "check ( X , Y ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "size = 1000001 NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def seiveOfEratosthenes ( prime ) : NEW_LINE INDENT prime [ 0 ] = 1 NEW_LINE prime [ 1 ] = 0 NEW_LINE i = 2 NEW_LINE while ( i * i < 1000001 ) : NEW_LINE DEDENT",
        "explain": "Seieve of Erotosthenes to compute all primes"
    },
    {
        "py": "if ( prime [ i ] == 0 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j < 1000001 ) : NEW_LINE DEDENT",
        "explain": "If prime"
    },
    {
        "py": "prime [ j ] = 1 NEW_LINE j = j + i NEW_LINE i += 1 NEW_LINE",
        "explain": "Mark all its multiples as non - prime"
    },
    {
        "py": "def probabiltyEuler ( prime , L , R , M ) : NEW_LINE INDENT arr = [ 0 ] * size NEW_LINE eulerTotient = [ 0 ] * size NEW_LINE count = 0 NEW_LINE DEDENT",
        "explain": "Function to find the probability of Euler 's Totient Function in a given range"
    },
    {
        "py": "for i in range ( L , R + 1 ) : NEW_LINE",
        "explain": "Initializing two arrays with values from L to R for Euler 's totient"
    },
    {
        "py": "eulerTotient [ i - L ] = i NEW_LINE arr [ i - L ] = i NEW_LINE for i in range ( 2 , 1000001 ) : NEW_LINE",
        "explain": "Indexing from 0"
    },
    {
        "py": "if ( prime [ i ] == 0 ) : NEW_LINE",
        "explain": "If the current number is prime"
    },
    {
        "py": "for j in range ( ( L // i ) * i , R + 1 , i ) : NEW_LINE INDENT if ( j - L >= 0 ) : NEW_LINE DEDENT",
        "explain": "Checking if i is prime factor of numbers in range L to R"
    },
    {
        "py": "eulerTotient [ j - L ] = ( eulerTotient [ j - L ] // i * ( i - 1 ) ) NEW_LINE while ( arr [ j - L ] % i == 0 ) : NEW_LINE INDENT arr [ j - L ] = arr [ j - L ] // i NEW_LINE DEDENT",
        "explain": "Update all the numbers which has prime factor i"
    },
    {
        "py": "for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( arr [ i - L ] > 1 ) : NEW_LINE INDENT eulerTotient [ i - L ] = ( ( eulerTotient [ i - L ] // arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ) NEW_LINE DEDENT DEDENT for i in range ( L , R + 1 ) : NEW_LINE",
        "explain": "If number in range has a prime factor > Math . sqrt ( number )"
    },
    {
        "py": "if ( ( eulerTotient [ i - L ] % M ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Count those which are divisible by M"
    },
    {
        "py": "return ( float ) ( 1.0 * count / ( R + 1 - L ) ) NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "prime = [ 0 ] * size NEW_LINE seiveOfEratosthenes ( prime ) NEW_LINE L , R , M = 1 , 7 , 3 NEW_LINE print ( probabiltyEuler ( prime , L , R , M ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation to find the Largest Odd Divisor Game to check which player wins"
    },
    {
        "py": "def findWinner ( n , k ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE DEDENT",
        "explain": "Function to find the Largest Odd Divisor Game to check which player wins"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "explain": "Check if n == 1 then player 2 will win"
    },
    {
        "py": "elif ( ( n & 1 ) or n == 2 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tmp = n ; NEW_LINE val = 1 ; NEW_LINE DEDENT",
        "explain": "Check if n == 2 or n is odd"
    },
    {
        "py": "while ( tmp > k and tmp % 2 == 0 ) : NEW_LINE INDENT tmp //= 2 ; NEW_LINE val *= 2 ; NEW_LINE DEDENT",
        "explain": "While n is greater than k and divisible by 2 keep incrementing tha val"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( tmp ) ) + 1 ) : NEW_LINE INDENT while ( tmp % i == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE tmp //= i ; NEW_LINE DEDENT DEDENT if ( tmp > 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT",
        "explain": "Loop to find greatest odd divisor"
    },
    {
        "py": "if ( val == n ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT elif ( n / tmp == 2 and cnt == 1 ) : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "explain": "Check if n is a power of 2"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT",
        "explain": "Check if cnt is not one then player 1 wins"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 1 ; k = 1 ; NEW_LINE findWinner ( n , k ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program of the above approach"
    },
    {
        "py": "def pen_hex ( n ) : NEW_LINE INDENT pn = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE DEDENT",
        "explain": "Function to print numbers upto N which are both pentagonal as well as hexagonal numbers"
    },
    {
        "py": "pn = ( int ) ( i * ( 3 * i - 1 ) / 2 ) NEW_LINE if ( pn > n ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "Calculate i - th pentagonal number"
    },
    {
        "py": "seqNum = ( 1 + math . sqrt ( 8 * pn + 1 ) ) / 4 NEW_LINE if ( seqNum == ( int ) ( seqNum ) ) : NEW_LINE INDENT print ( pn , end = \" , \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Check if the pentagonal number pn is hexagonal or not"
    },
    {
        "py": "N = 1000000 NEW_LINE pen_hex ( N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isPal ( a , n , m ) : NEW_LINE",
        "explain": "Function to check if row - major order traversal of the matrix is is palindrome"
    },
    {
        "py": "for i in range ( 0 , n // 2 ) : NEW_LINE INDENT for j in range ( 0 , m - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE",
        "explain": "Loop to check if the matrix is matrix is palindrome or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 4 ] , [ 3 , 2 , 1 ] ] ; NEW_LINE if ( isPal ( a , n , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def getSum ( n ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT sum1 = sum1 + n % 10 ; NEW_LINE n = n // 10 ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT",
        "explain": "Function to get sum of digits"
    },
    {
        "py": "def smallestNumber ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE DEDENT",
        "explain": "Function to find the smallest number whose sum of digits is also N"
    },
    {
        "py": "if ( getSum ( i ) == N ) : NEW_LINE INDENT print ( i ) ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE",
        "explain": "Checking if number has sum of digits = N"
    },
    {
        "py": "N = 10 ; NEW_LINE smallestNumber ( N ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation to check if N is a Rare number"
    },
    {
        "py": "def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT",
        "explain": "Iterative function to reverse digits of num"
    },
    {
        "py": "def isPerfectSquare ( x ) : NEW_LINE",
        "explain": "Function to check if N is perfect square"
    },
    {
        "py": "sr = math . sqrt ( x ) NEW_LINE",
        "explain": "Find floating point value of square root of x ."
    },
    {
        "py": "return ( ( sr - int ( sr ) ) == 0 ) NEW_LINE",
        "explain": "If square root is an integer"
    },
    {
        "py": "def isRare ( N ) : NEW_LINE",
        "explain": "Function to check if N is an Rare number"
    },
    {
        "py": "reverseN = reversDigits ( N ) NEW_LINE",
        "explain": "Find reverse of N"
    },
    {
        "py": "if ( reverseN == N ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( isPerfectSquare ( N + reverseN ) and isPerfectSquare ( N - reverseN ) ) NEW_LINE",
        "explain": "Number should be non - palindromic"
    },
    {
        "py": "N = 65 NEW_LINE if ( isRare ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def calc_ans ( l , r ) : NEW_LINE INDENT power2 = [ ] ; power3 = [ ] ; NEW_LINE DEDENT",
        "explain": "Function which will calculate the elements in the given range"
    },
    {
        "py": "mul2 = 1 ; NEW_LINE while ( mul2 <= r ) : NEW_LINE INDENT power2 . append ( mul2 ) ; NEW_LINE mul2 *= 2 ; NEW_LINE DEDENT",
        "explain": "Store the current power of 2"
    },
    {
        "py": "mul3 = 1 ; NEW_LINE while ( mul3 <= r ) : NEW_LINE INDENT power3 . append ( mul3 ) ; NEW_LINE mul3 *= 3 ; NEW_LINE DEDENT",
        "explain": "Store the current power of 3"
    },
    {
        "py": "power23 = [ ] ; NEW_LINE for x in range ( len ( power2 ) ) : NEW_LINE INDENT for y in range ( len ( power3 ) ) : NEW_LINE INDENT mul = power2 [ x ] * power3 [ y ] ; NEW_LINE if ( mul == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "power23 [ ] will store pairwise product of elements of power2 and power3 that are <= r"
    },
    {
        "py": "if ( mul <= r ) : NEW_LINE INDENT power23 . append ( mul ) ; NEW_LINE DEDENT",
        "explain": "Insert in power23 ] [ ] only if mul <= r"
    },
    {
        "py": "ans = 0 ; NEW_LINE for x in power23 : NEW_LINE INDENT if ( x >= l and x <= r ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Store the required answer"
    },
    {
        "py": "print ( ans ) ; NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 1 ; r = 10 ; NEW_LINE calc_ans ( l , r ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def nCr ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE DEDENT",
        "explain": "Function to calculate nCr"
    },
    {
        "py": "def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT",
        "explain": "Returns factorial of n"
    },
    {
        "py": "def countSubsequences ( arr , n , k ) : NEW_LINE INDENT countOdd = 0 NEW_LINE DEDENT",
        "explain": "Function for finding number of K length subsequences whose product is even number"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT countOdd += 1 ; NEW_LINE DEDENT DEDENT ans = nCr ( n , k ) - nCr ( countOdd , k ) ; NEW_LINE return ans NEW_LINE",
        "explain": "Counting odd numbers in the array"
    },
    {
        "py": "arr = [ 2 , 4 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE print ( countSubsequences ( arr , N , K ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find the first digit of X in base Y"
    },
    {
        "py": "def first_digit ( x , y ) : NEW_LINE",
        "explain": "Function to find the first digit of X in base Y"
    },
    {
        "py": "length = int ( math . log ( x ) / math . log ( y ) + 1 ) NEW_LINE",
        "explain": "Calculating number of digits of x in base y"
    },
    {
        "py": "first_digit = x / math . pow ( y , length - 1 ) NEW_LINE print ( int ( first_digit ) ) NEW_LINE",
        "explain": "Finding first digit of x in base y"
    },
    {
        "py": "X = 55 NEW_LINE Y = 3 NEW_LINE first_digit ( X , Y ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def checkIfCurzonNumber ( N ) : NEW_LINE INDENT powerTerm , productTerm = 0 , 0 NEW_LINE DEDENT",
        "explain": "Function to check if a number is a Curzon number or not"
    },
    {
        "py": "powerTerm = pow ( 2 , N ) + 1 NEW_LINE",
        "explain": "Find 2 ^ N + 1"
    },
    {
        "py": "productTerm = 2 * N + 1 NEW_LINE",
        "explain": "Find 2 * N + 1"
    },
    {
        "py": "if ( powerTerm % productTerm == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Check for divisibility"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE checkIfCurzonNumber ( N ) NEW_LINE N = 10 NEW_LINE checkIfCurzonNumber ( N ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minCount ( n ) : NEW_LINE",
        "explain": "Function to return the count of minimum numbers ending with 7 required such that the sum of these numbers is n"
    },
    {
        "py": "hasharr = [ 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 ] NEW_LINE",
        "explain": "hasharr [ i ] will store the minimum numbers ending with 7 so that it sums to number ending with digit i"
    },
    {
        "py": "if ( n > 69 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Its always possible to write numbers > 69 to write as numbers ending with 7"
    },
    {
        "py": "if ( n >= hasharr [ n % 10 ] * 7 ) : NEW_LINE INDENT return hasharr [ n % 10 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "If the number is atleast equal to the sum of minimum numbers ending with 7"
    },
    {
        "py": "n = 38 ; NEW_LINE print ( minCount ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def modifiedBinaryPattern ( n ) : NEW_LINE",
        "explain": "Function to print the modified binary pattern"
    },
    {
        "py": "for i in range ( 1 , n + 1 , 1 ) : NEW_LINE",
        "explain": "Loop to traverse the rows"
    },
    {
        "py": "for j in range ( 1 , i + 1 , 1 ) : NEW_LINE",
        "explain": "Loop to traverse the numbers in each row"
    },
    {
        "py": "if ( j == 1 or j == i ) : NEW_LINE INDENT print ( 1 , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Check if j is 1 or i In either case print 1"
    },
    {
        "py": "else : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Else print 0"
    },
    {
        "py": "print ( ' ' , end = \" \" ) NEW_LINE",
        "explain": "Change the cursor to next line after each row"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "modifiedBinaryPattern ( n ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findRealAndImag ( s ) : NEW_LINE",
        "explain": "Function to find real and imaginary parts of a complex number"
    },
    {
        "py": "l = len ( s ) NEW_LINE",
        "explain": "string length stored in variable l"
    },
    {
        "py": "i = 0 NEW_LINE",
        "explain": "variable for the index of the separator"
    },
    {
        "py": "' NEW_LINE INDENT if ( s . find ( ' + ' ) != - 1 ) : NEW_LINE INDENT i = s . find ( ' + ' ) NEW_LINE DEDENT DEDENT",
        "explain": "Storing the index of '+"
    },
    {
        "py": "' NEW_LINE INDENT else : NEW_LINE INDENT i = s . find ( ' - ' ) ; NEW_LINE DEDENT DEDENT",
        "explain": "else storing the index of '-"
    },
    {
        "py": "real = s [ : i ] NEW_LINE",
        "explain": "Finding the real part of the complex number"
    },
    {
        "py": "imaginary = s [ i + 1 : l - 1 ] NEW_LINE print ( \" Real \u2581 part : \" , real ) NEW_LINE print ( \" Imaginary \u2581 part : \" , imaginary ) NEW_LINE",
        "explain": "Finding the imaginary part of the complex number"
    },
    {
        "py": "s = \"3 + 4i \" ; NEW_LINE findRealAndImag ( s ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import pow NEW_LINE",
        "explain": "Python 3 implementation to find distinct powers of N that add up to K"
    },
    {
        "py": "def highestPower ( n , k ) : NEW_LINE INDENT i = 0 NEW_LINE a = pow ( n , i ) NEW_LINE DEDENT",
        "explain": "Function to return the highest power of N not exceeding K"
    },
    {
        "py": "while ( a <= k ) : NEW_LINE INDENT i += 1 NEW_LINE a = pow ( n , i ) NEW_LINE DEDENT return i - 1 NEW_LINE",
        "explain": "Loop to find the highest power less than K"
    },
    {
        "py": "b = [ 0 for i in range ( 50 ) ] NEW_LINE",
        "explain": "Initializing the PowerArray with all 0 's."
    },
    {
        "py": "def PowerArray ( n , k ) : NEW_LINE INDENT while ( k ) : NEW_LINE DEDENT",
        "explain": "Function to print the distinct powers of N that add upto K"
    },
    {
        "py": "t = highestPower ( n , k ) NEW_LINE",
        "explain": "Getting the highest power of n before k"
    },
    {
        "py": "if ( b [ t ] ) : NEW_LINE",
        "explain": "To check if the power is being used twice or not"
    },
    {
        "py": "print ( - 1 ) NEW_LINE return 0 NEW_LINE else : NEW_LINE",
        "explain": "Print - 1 if power is being used twice"
    },
    {
        "py": "b [ t ] = 1 NEW_LINE",
        "explain": "If the power is not visited , then mark the power as visited"
    },
    {
        "py": "k -= pow ( n , t ) NEW_LINE",
        "explain": "Decrementing the value of K"
    },
    {
        "py": "for i in range ( 50 ) : NEW_LINE INDENT if ( b [ i ] ) : NEW_LINE INDENT print ( i , end = ' , \u2581 ' ) NEW_LINE DEDENT DEDENT",
        "explain": "Printing the powers of N that sum up to K"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE K = 40 NEW_LINE PowerArray ( N , K ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "N = 100005 NEW_LINE",
        "explain": "Python3 program to find sum of elements in an array having composite frequency"
    },
    {
        "py": "def SieveOfEratosthenes ( composite ) : NEW_LINE INDENT for p in range ( 2 , N ) : NEW_LINE INDENT if p * p > N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to create Sieve to check primes"
    },
    {
        "py": "if ( composite [ p ] == False ) : NEW_LINE",
        "explain": "If composite [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( 2 * p , N , p ) : NEW_LINE INDENT composite [ i ] = True NEW_LINE DEDENT",
        "explain": "Update all multiples of p , set them to composite"
    },
    {
        "py": "def sumOfElements ( arr , n ) : NEW_LINE INDENT composite = [ False ] * N NEW_LINE SieveOfEratosthenes ( composite ) NEW_LINE DEDENT",
        "explain": "Function to return the sum of elements in an array having composite frequency"
    },
    {
        "py": "m = dict ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] = m . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Map is used to store element frequencies"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "To store sum"
    },
    {
        "py": "for it in m : NEW_LINE",
        "explain": "Traverse the map using iterators"
    },
    {
        "py": "if ( composite [ m [ it ] ] ) : NEW_LINE INDENT sum += ( it ) NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "Count the number of elements having composite frequencies"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( sumOfElements ( arr , n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def remove ( arr , n ) : NEW_LINE",
        "explain": "Function that removes the elements which have odd frequencies in the array"
    },
    {
        "py": "m = dict . fromkeys ( arr , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 ; NEW_LINE DEDENT",
        "explain": "Create a map to store the frequency of each element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Remove the elements which have odd frequencies"
    },
    {
        "py": "if ( ( m [ arr [ i ] ] & 1 ) ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT print ( arr [ i ] , end = \" , \u2581 \" ) ; NEW_LINE",
        "explain": "If the element has odd frequency then skip"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "remove ( arr , n ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def getmax ( arr , n , x ) : NEW_LINE",
        "explain": "Maximum value of the first array element that can be attained"
    },
    {
        "py": "s = 0 NEW_LINE",
        "explain": "Variable to store the sum"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT s = s + arr [ i ] NEW_LINE DEDENT",
        "explain": "Loop to find the sum of array"
    },
    {
        "py": "print ( min ( s , x ) ) NEW_LINE",
        "explain": "Desired maximum value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE x = 5 NEW_LINE arr_size = len ( arr ) NEW_LINE getmax ( arr , arr_size , x ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def shortestLength ( n , x , y ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT",
        "explain": "function to get the minimum length of the shorter side of the triangle"
    },
    {
        "py": "i = 0 NEW_LINE while n > 0 : NEW_LINE",
        "explain": "traversing through each points on the plane"
    },
    {
        "py": "if ( x [ i ] + y [ i ] > answer ) : NEW_LINE INDENT answer = x [ i ] + y [ i ] NEW_LINE DEDENT i += 1 NEW_LINE n -= 1 NEW_LINE",
        "explain": "if sum of a points is greater than the previous one , the maximum gets replaced"
    },
    {
        "py": "print ( \" Length \u2581 - > \u2581 \" + str ( answer ) ) NEW_LINE print ( \" Path \u2581 - > \u2581 \" + \" ( \u2581 1 , \u2581 \" + str ( answer ) + \" \u2581 ) \" + \" and \u2581 ( \u2581 \" + str ( answer ) + \" , \u2581 1 \u2581 ) \" ) NEW_LINE",
        "explain": "print the length"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = 4 NEW_LINE",
        "explain": "initialize the number of points"
    },
    {
        "py": "x = [ 1 , 4 , 2 , 1 ] NEW_LINE y = [ 4 , 1 , 1 , 2 ] NEW_LINE shortestLength ( n , x , y ) NEW_LINE",
        "explain": "points on the plane"
    },
    {
        "py": "def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE",
        "explain": "function to find intersection rectangle of given two rectangles ."
    },
    {
        "py": "x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE",
        "explain": "gives bottom - left point of intersection rectangle"
    },
    {
        "py": "x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE",
        "explain": "gives top - right point of intersection rectangle"
    },
    {
        "py": "if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( \" No \u2581 intersection \" ) NEW_LINE return NEW_LINE DEDENT print ( \" ( \" , x5 , \" , \u2581 \" , y5 , \" ) \u2581 \" , end = \" \u2581 \" ) NEW_LINE print ( \" ( \" , x6 , \" , \u2581 \" , y6 , \" ) \u2581 \" , end = \" \u2581 \" ) NEW_LINE",
        "explain": "no intersection"
    },
    {
        "py": "x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( \" ( \" , x7 , \" , \u2581 \" , y7 , \" ) \u2581 \" , end = \" \u2581 \" ) NEW_LINE",
        "explain": "gives top - left point of intersection rectangle"
    },
    {
        "py": "x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( \" ( \" , x8 , \" , \u2581 \" , y8 , \" ) \u2581 \" ) NEW_LINE",
        "explain": "gives bottom - right point of intersection rectangle"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE",
        "explain": "bottom - left and top - right corners of first rectangle"
    },
    {
        "py": "x3 = 2 NEW_LINE y3 = 3 NEW_LINE x4 = 7 NEW_LINE y4 = 9 NEW_LINE",
        "explain": "bottom - left and top - right corners of first rectangle"
    },
    {
        "py": "FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE",
        "explain": "function call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find corner points of a rectangle using given length and middle points ."
    },
    {
        "py": "class Point : NEW_LINE INDENT def __init__ ( self , a = 0 , b = 0 ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE DEDENT DEDENT",
        "explain": "Structure to represent a co - ordinate point"
    },
    {
        "py": "def printCorners ( p , q , l ) : NEW_LINE INDENT a , b , c , d = Point ( ) , Point ( ) , Point ( ) , Point ( ) NEW_LINE DEDENT",
        "explain": "This function receives two points and length of the side of rectangle and prints the 4 corner points of the rectangle"
    },
    {
        "py": "if ( p . x == q . x ) : NEW_LINE INDENT a . x = p . x - ( l / 2.0 ) NEW_LINE a . y = p . y NEW_LINE d . x = p . x + ( l / 2.0 ) NEW_LINE d . y = p . y NEW_LINE b . x = q . x - ( l / 2.0 ) NEW_LINE b . y = q . y NEW_LINE c . x = q . x + ( l / 2.0 ) NEW_LINE c . y = q . y NEW_LINE DEDENT",
        "explain": "Horizontal rectangle"
    },
    {
        "py": "elif ( p . y == q . y ) : NEW_LINE INDENT a . y = p . y - ( l / 2.0 ) NEW_LINE a . x = p . x NEW_LINE d . y = p . y + ( l / 2.0 ) NEW_LINE d . x = p . x NEW_LINE b . y = q . y - ( l / 2.0 ) NEW_LINE b . x = q . x NEW_LINE c . y = q . y + ( l / 2.0 ) NEW_LINE c . x = q . x NEW_LINE DEDENT",
        "explain": "Vertical rectangle"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Slanted rectangle"
    },
    {
        "py": "m = ( p . x - q . x ) / ( q . y - p . y ) NEW_LINE",
        "explain": "Calculate slope of the side"
    },
    {
        "py": "dx = ( l / math . sqrt ( 1 + ( m * m ) ) ) * 0.5 NEW_LINE dy = m * dx NEW_LINE a . x = p . x - dx NEW_LINE a . y = p . y - dy NEW_LINE d . x = p . x + dx NEW_LINE d . y = p . y + dy NEW_LINE b . x = q . x - dx NEW_LINE b . y = q . y - dy NEW_LINE c . x = q . x + dx NEW_LINE c . y = q . y + dy NEW_LINE print ( int ( a . x ) , \" , \u2581 \" , int ( a . y ) , sep = \" \" ) NEW_LINE print ( int ( b . x ) , \" , \u2581 \" , int ( b . y ) , sep = \" \" ) NEW_LINE print ( int ( c . x ) , \" , \u2581 \" , int ( c . y ) , sep = \" \" ) NEW_LINE print ( int ( d . x ) , \" , \u2581 \" , int ( d . y ) , sep = \" \" ) NEW_LINE print ( ) NEW_LINE",
        "explain": "Calculate displacements along axes"
    },
    {
        "py": "p1 = Point ( 1 , 0 ) NEW_LINE q1 = Point ( 1 , 2 ) NEW_LINE printCorners ( p1 , q1 , 2 ) NEW_LINE p = Point ( 1 , 1 ) NEW_LINE q = Point ( - 1 , - 1 ) NEW_LINE printCorners ( p , q , 2 * math . sqrt ( 2 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minimumCost ( arr , N , X , Y ) : NEW_LINE",
        "explain": "Function to find the minimum cost to modify the array according to the given criteria"
    },
    {
        "py": "even_count = 0 NEW_LINE odd_count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE",
        "explain": "Count of wrong positioned odd and even elements"
    },
    {
        "py": "if ( ( arr [ i ] & 1 ) and ( i % 2 == 0 ) ) : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT",
        "explain": "Odd Count"
    },
    {
        "py": "if ( ( arr [ i ] % 2 ) == 0 and ( i & 1 ) ) : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT",
        "explain": "Even Count"
    },
    {
        "py": "cost1 = X * min ( odd_count , even_count ) NEW_LINE",
        "explain": "Swapping Cost"
    },
    {
        "py": "cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) NEW_LINE",
        "explain": "Decrementing cost after swapping"
    },
    {
        "py": "cost3 = ( odd_count + even_count ) * Y NEW_LINE",
        "explain": "Only decrementing cost"
    },
    {
        "py": "return min ( cost1 + cost2 , cost3 ) NEW_LINE",
        "explain": "Return the minimum cost of the two cases"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 ] NEW_LINE X = 10 NEW_LINE Y = 2 NEW_LINE N = len ( arr ) NEW_LINE print ( minimumCost ( arr , N , X , Y ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findMinMax ( a ) : NEW_LINE",
        "explain": "Function to find the minimum product of the minimum and maximum among all the possible subarrays"
    },
    {
        "py": "min_val = 1000000000 NEW_LINE",
        "explain": "Stores resultant minimum product"
    },
    {
        "py": "for i in range ( 1 , len ( a ) ) : NEW_LINE",
        "explain": "Traverse the given array arr [ ]"
    },
    {
        "py": "min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) NEW_LINE",
        "explain": "Min of product of all two pair of consecutive elements"
    },
    {
        "py": "return min_val NEW_LINE",
        "explain": "Return the resultant value"
    },
    {
        "py": "if __name__ == ( \" _ _ main _ _ \" ) : NEW_LINE INDENT arr = [ 6 , 4 , 5 , 6 , 2 , 4 , 1 ] NEW_LINE print ( findMinMax ( arr ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "sum = 0 NEW_LINE class Node : NEW_LINE",
        "explain": "Structure of Tree"
    },
    {
        "py": "def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT",
        "explain": "A constructor to create a new node"
    },
    {
        "py": "def kDistanceDownSum ( root , k ) : NEW_LINE INDENT global sum NEW_LINE DEDENT",
        "explain": "Function to add the node to the sum below the target node"
    },
    {
        "py": "if ( root == None or k < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if ( k == 0 ) : NEW_LINE INDENT sum += root . data NEW_LINE return NEW_LINE DEDENT",
        "explain": "If Kth distant node is reached"
    },
    {
        "py": "kDistanceDownSum ( root . left , k - 1 ) NEW_LINE kDistanceDownSum ( root . right , k - 1 ) NEW_LINE",
        "explain": "Recur for the left and the right subtrees"
    },
    {
        "py": "def kDistanceSum ( root , target , k ) : NEW_LINE INDENT global sum NEW_LINE DEDENT",
        "explain": "Function to find the K distant nodes from target node , it returns - 1 if target node is not present in tree"
    },
    {
        "py": "if ( root == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Base Case 1"
    },
    {
        "py": "if ( root . data == target ) : NEW_LINE INDENT kDistanceDownSum ( root . left , k - 1 ) NEW_LINE return 0 NEW_LINE DEDENT",
        "explain": "If target is same as root ."
    },
    {
        "py": "dl = - 1 NEW_LINE",
        "explain": "Recurr for the left subtree"
    },
    {
        "py": "if ( target < root . data ) : NEW_LINE INDENT dl = kDistanceSum ( root . left , target , k ) NEW_LINE DEDENT",
        "explain": "Tree is BST so reduce the search space"
    },
    {
        "py": "if ( dl != - 1 ) : NEW_LINE",
        "explain": "Check if target node was found in left subtree"
    },
    {
        "py": "if ( dl + 1 == k ) : NEW_LINE INDENT sum += root . data NEW_LINE DEDENT",
        "explain": "If root is at distance k from the target"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "Node less than target will be present in left"
    },
    {
        "py": "dr = - 1 NEW_LINE if ( target > root . data ) : NEW_LINE INDENT dr = kDistanceSum ( root . right , target , k ) NEW_LINE DEDENT if ( dr != - 1 ) : NEW_LINE",
        "explain": "When node is not present in the left subtree"
    },
    {
        "py": "if ( dr + 1 == k ) : NEW_LINE INDENT sum += root . data NEW_LINE DEDENT",
        "explain": "If Kth distant node is reached"
    },
    {
        "py": "else : NEW_LINE INDENT kDistanceDownSum ( root . left , k - dr - 2 ) NEW_LINE DEDENT return 1 + dr NEW_LINE",
        "explain": "Node less than target at k distance maybe present in the left tree"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "If target was not present in the left nor in right subtree"
    },
    {
        "py": "def insertNode ( data , root ) : NEW_LINE",
        "explain": "Function to insert a node in BST"
    },
    {
        "py": "if ( root == None ) : NEW_LINE INDENT node = Node ( data ) NEW_LINE return node NEW_LINE DEDENT",
        "explain": "If root is NULL"
    },
    {
        "py": "elif ( data > root . data ) : NEW_LINE INDENT root . right = insertNode ( data , root . right ) NEW_LINE DEDENT",
        "explain": "Insert the data in right half"
    },
    {
        "py": "elif ( data <= root . data ) : NEW_LINE INDENT root . left = insertNode ( data , root . left ) NEW_LINE DEDENT",
        "explain": "Insert the data in left half"
    },
    {
        "py": "return root NEW_LINE",
        "explain": "Return the root node"
    },
    {
        "py": "def findSum ( root , target , K ) : NEW_LINE",
        "explain": "Function to find the sum of K distant nodes from the target node having value less than target node"
    },
    {
        "py": "kDistanceSum ( root , target , K ) NEW_LINE",
        "explain": "Stores the sum of nodes having values < target at K distance"
    },
    {
        "py": "print ( sum ) NEW_LINE",
        "explain": "Print the resultant sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = None NEW_LINE N = 11 NEW_LINE tree = [ 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT root = insertNode ( tree [ i ] , root ) NEW_LINE DEDENT target = 7 NEW_LINE K = 2 NEW_LINE findSum ( root , target , K ) NEW_LINE",
        "explain": "Create the Tree"
    },
    {
        "py": "def itemType ( n ) : NEW_LINE",
        "explain": "Function to find the type of the item given out according to the given rules"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the count of item given out at each step"
    },
    {
        "py": "day = 1 NEW_LINE while ( True ) : NEW_LINE",
        "explain": "Iterate over the days from 1"
    },
    {
        "py": "for type in range ( day , 0 , - 1 ) : NEW_LINE INDENT count += type NEW_LINE DEDENT",
        "explain": "Iterate over type of item on that day"
    },
    {
        "py": "if ( count >= n ) : NEW_LINE INDENT return type NEW_LINE DEDENT",
        "explain": "Count of items given out should exceed n"
    },
    {
        "py": "N = 10 NEW_LINE print ( itemType ( N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "from math import log2 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def FindSum ( arr , N ) : NEW_LINE",
        "explain": "Function to prthe sum of array elements that are equidistant from two consecutive powers of 2"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores the resultant sum of the array elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "power = int ( log2 ( arr [ i ] ) ) NEW_LINE",
        "explain": "Stores the power of 2 of the number arr [ i ]"
    },
    {
        "py": "LesserValue = pow ( 2 , power ) NEW_LINE",
        "explain": "Stores the number which is power of 2 and lesser than or equal to arr [ i ]"
    },
    {
        "py": "LargerValue = pow ( 2 , power + 1 ) NEW_LINE",
        "explain": "Stores the number which is power of 2 and greater than or equal to arr [ i ]"
    },
    {
        "py": "if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) : NEW_LINE",
        "explain": "If arr [ i ] - LesserValue is the same as LargerValue - arr [ i ]"
    },
    {
        "py": "res += arr [ i ] NEW_LINE",
        "explain": "Increment res by arr [ i ]"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the resultant sum res"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 24 , 17 , 3 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE print ( FindSum ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findLast ( mat ) : NEW_LINE INDENT m = len ( mat ) NEW_LINE n = len ( mat [ 0 ] ) NEW_LINE DEDENT",
        "explain": "Function to find the person who will finish last"
    },
    {
        "py": "rows = set ( ) NEW_LINE cols = set ( ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] : NEW_LINE INDENT rows . add ( i ) NEW_LINE cols . add ( j ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "To keep track of rows and columns having 1"
    },
    {
        "py": "avRows = m - len ( list ( rows ) ) NEW_LINE avCols = n - len ( list ( cols ) ) NEW_LINE",
        "explain": "Available rows and columns"
    },
    {
        "py": "choices = min ( avRows , avCols ) NEW_LINE",
        "explain": "Minimum number of choices we have"
    },
    {
        "py": "if choices & 1 : NEW_LINE",
        "explain": "If number of choices are odd"
    },
    {
        "py": "print ( ' P1' ) NEW_LINE",
        "explain": "P1 will finish last"
    },
    {
        "py": "else : NEW_LINE INDENT print ( ' P2' ) NEW_LINE DEDENT",
        "explain": "Otherwise , P2 will finish last"
    },
    {
        "py": "mat = [ [ 1 , 0 , 0 ] , [ 0 , 0 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE findLast ( mat ) NEW_LINE",
        "explain": "Given matrix"
    },
    {
        "py": "from math import log2 , pow NEW_LINE MOD = 1000000007 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def sumOfBinaryNumbers ( n ) : NEW_LINE",
        "explain": "Function to find the sum of first N natural numbers represented in binary representation"
    },
    {
        "py": "ans = 0 NEW_LINE one = 1 NEW_LINE",
        "explain": "Stores the resultant sum"
    },
    {
        "py": "while ( 1 ) : NEW_LINE",
        "explain": "Iterate until the value of N is greater than 0"
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT ans = ( ans + n ) % MOD NEW_LINE break NEW_LINE DEDENT",
        "explain": "If N is less than 2"
    },
    {
        "py": "x = int ( log2 ( n ) ) NEW_LINE cur = 0 NEW_LINE add = ( one << ( x - 1 ) ) NEW_LINE",
        "explain": "Store the MSB position of N"
    },
    {
        "py": "for i in range ( 1 , x + 1 , 1 ) : NEW_LINE",
        "explain": "Iterate in the range [ 1 , x ] and add the contribution of the numbers from 1 to ( 2 ^ x - 1 )"
    },
    {
        "py": "cur = ( cur + add ) % MOD NEW_LINE add = ( add * 10 % MOD ) NEW_LINE",
        "explain": "Update the value of the cur and add"
    },
    {
        "py": "ans = ( ans + cur ) % MOD NEW_LINE",
        "explain": "Add the cur to ans"
    },
    {
        "py": "rem = n - ( one << x ) + 1 NEW_LINE",
        "explain": "Store the remaining numbers"
    },
    {
        "py": "p = pow ( 10 , x ) NEW_LINE p = ( p * ( rem % MOD ) ) % MOD NEW_LINE ans = ( ans + p ) % MOD NEW_LINE",
        "explain": "Add the contribution by MSB by the remaining numbers"
    },
    {
        "py": "n = rem - 1 NEW_LINE",
        "explain": "The next iteration will be repeated for 2 ^ x - 1"
    },
    {
        "py": "print ( int ( ans ) ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE sumOfBinaryNumbers ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def nearestFibonacci ( num ) : NEW_LINE",
        "explain": "Function to find the Fibonacci number which is nearest to N"
    },
    {
        "py": "if ( num == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "first = 0 NEW_LINE second = 1 NEW_LINE",
        "explain": "Initialize the first & second terms of the Fibonacci series"
    },
    {
        "py": "third = first + second NEW_LINE",
        "explain": "Store the third term"
    },
    {
        "py": "while ( third <= num ) : NEW_LINE",
        "explain": "Iterate until the third term is less than or equal to num"
    },
    {
        "py": "first = second NEW_LINE",
        "explain": "Update the first"
    },
    {
        "py": "second = third NEW_LINE",
        "explain": "Update the second"
    },
    {
        "py": "third = first + second NEW_LINE",
        "explain": "Update the third"
    },
    {
        "py": "if ( abs ( third - num ) >= abs ( second - num ) ) : NEW_LINE INDENT ans = second NEW_LINE DEDENT else : NEW_LINE INDENT ans = third NEW_LINE DEDENT",
        "explain": "Store the Fibonacci number having smaller difference with N"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 17 NEW_LINE nearestFibonacci ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def checkPermutation ( ans , a , n ) : NEW_LINE",
        "explain": "Function to check if the maximum prefix array of ans [ ] is equal to array arr [ ]"
    },
    {
        "py": "Max = - sys . maxsize - 1 NEW_LINE",
        "explain": "Initialize a variable , Max"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array , ans [ ]"
    },
    {
        "py": "Max = max ( Max , ans [ i ] ) NEW_LINE",
        "explain": "Store the maximum value upto index i"
    },
    {
        "py": "if ( Max != a [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If it is not equal to a [ i ] , then return false"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "Otherwise return false"
    },
    {
        "py": "def findPermutation ( a , n ) : NEW_LINE",
        "explain": "Function to find the permutation of the array whose prefix maximum array is same as the given array a [ ]"
    },
    {
        "py": "ans = [ 0 ] * n NEW_LINE",
        "explain": "Stores the required permutation"
    },
    {
        "py": "um = { } NEW_LINE",
        "explain": "Stores the index of first occurrence of elements"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array a [ ]"
    },
    {
        "py": "if ( a [ i ] not in um ) : NEW_LINE",
        "explain": "If a [ i ] is not present in um , then store it in um"
    },
    {
        "py": "ans [ i ] = a [ i ] NEW_LINE um [ a [ i ] ] = i NEW_LINE",
        "explain": "Update the ans [ i ] to a [ i ]"
    },
    {
        "py": "v = [ ] NEW_LINE j = 0 NEW_LINE",
        "explain": "Stores the unvisited numbers"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Fill the array , v [ ]"
    },
    {
        "py": "if ( i not in um ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT",
        "explain": "Store the index"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array , ans [ ]"
    },
    {
        "py": "if ( ans [ i ] == 0 ) : NEW_LINE INDENT ans [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "Fill v [ j ] at places where ans [ i ] is 0"
    },
    {
        "py": "if ( checkPermutation ( ans , a , n ) ) : NEW_LINE",
        "explain": "Check if the current permutation maximum prefix array is same as the given array a [ ]"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If true , the print the permutation"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "Otherwise , print - 1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 5 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "findPermutation ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def countEqualElementPairs ( arr , N ) : NEW_LINE",
        "explain": "Function to count the number of required pairs for every array element"
    },
    {
        "py": "mp = { } NEW_LINE",
        "explain": "Initialize a map"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if arr [ i ] in mp : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Update the frequency of every element"
    },
    {
        "py": "total = 0 NEW_LINE",
        "explain": "Stores the count of pairs"
    },
    {
        "py": "for key , value in mp . items ( ) : NEW_LINE",
        "explain": "Traverse the map"
    },
    {
        "py": "total += ( value * ( value - 1 ) ) / 2 NEW_LINE",
        "explain": "Count the number of ways to select pairs consisting of equal elements only"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "print ( int ( total - ( mp [ arr [ i ] ] - 1 ) ) , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print the count for every array element"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 1 , 1 , 2 , 1 , 2 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE countEqualElementPairs ( arr , N ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "def count ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE DEDENT",
        "explain": "Function to return the count of natural octal numbers upto N digits"
    },
    {
        "py": "for i in range ( N + 1 ) : NEW_LINE INDENT sum += 7 * ( 8 ** ( i - 1 ) ) ; NEW_LINE DEDENT return int ( sum ) ; NEW_LINE",
        "explain": "Loop to iterate from 1 to N and calculating number of octal numbers for every ' i ' th digit ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE print ( count ( N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt ; NEW_LINE",
        "explain": "Python3 program to find all the palindromic divisors of a number"
    },
    {
        "py": "def isPalindrome ( n ) : NEW_LINE",
        "explain": "Function to check is num is palindromic or not"
    },
    {
        "py": "string = str ( n ) ; NEW_LINE",
        "explain": "Convert n to string str"
    },
    {
        "py": "s = 0 ; e = len ( string ) - 1 ; NEW_LINE while ( s < e ) : NEW_LINE",
        "explain": "Starting and ending index of string str"
    },
    {
        "py": "if ( string [ s ] != string [ e ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT s += 1 ; NEW_LINE e -= 1 ; NEW_LINE return True ; NEW_LINE",
        "explain": "If char at s and e are not equals then return false"
    },
    {
        "py": "def palindromicDivisors ( n ) : NEW_LINE",
        "explain": "Function to find palindromic divisors"
    },
    {
        "py": "PalindromDivisors = [ ] ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) ) : NEW_LINE",
        "explain": "To sore the palindromic divisors of number n"
    },
    {
        "py": "if ( n % i == 0 ) : NEW_LINE",
        "explain": "If n is divisible by i"
    },
    {
        "py": "if ( n // i == i ) : NEW_LINE",
        "explain": "Check if number is a perfect square"
    },
    {
        "py": "if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Check divisor is palindromic , then store it"
    },
    {
        "py": "if ( isPalindrome ( i ) ) : NEW_LINE INDENT PalindromDivisors . append ( i ) ; NEW_LINE DEDENT",
        "explain": "Check if divisors are palindrome"
    },
    {
        "py": "if ( isPalindrome ( n // i ) ) : NEW_LINE INDENT PalindromDivisors . append ( n // i ) ; NEW_LINE DEDENT",
        "explain": "Check if n / divisors is palindromic or not"
    },
    {
        "py": "PalindromDivisors . sort ( ) ; NEW_LINE for i in range ( len ( PalindromDivisors ) ) : NEW_LINE INDENT print ( PalindromDivisors [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Print all palindromic divisors in sorted order"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 66 ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "palindromicDivisors ( n ) ; NEW_LINE",
        "explain": "Function call to find all palindromic divisors"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def findMinDel ( arr , n ) : NEW_LINE",
        "explain": "Function to return the minimum deletions to get minimum OR"
    },
    {
        "py": "min_num = sys . maxsize ; NEW_LINE",
        "explain": "To store the minimum element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT min_num = min ( arr [ i ] , min_num ) ; NEW_LINE DEDENT",
        "explain": "Find the minimum element from the array"
    },
    {
        "py": "cnt = 0 ; NEW_LINE",
        "explain": "To store the frequency of the minimum element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == min_num ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Find the frequency of the minimum element"
    },
    {
        "py": "return n - cnt ; NEW_LINE",
        "explain": "Return the final answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findMinDel ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import gcd NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def cntSubArr ( arr , n ) : NEW_LINE",
        "explain": "Function to return the required count"
    },
    {
        "py": "ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store the final answer"
    },
    {
        "py": "' NEW_LINE INDENT curr_gcd = 0 ; NEW_LINE DEDENT",
        "explain": "To store the GCD starting from index 'i"
    },
    {
        "py": "for j in range ( i , n ) : NEW_LINE INDENT curr_gcd = gcd ( curr_gcd , arr [ j ] ) ; NEW_LINE DEDENT",
        "explain": "Loop to find the gcd of each subarray from arr [ i ] to arr [ i ... n - 1 ]"
    },
    {
        "py": "ans += ( curr_gcd == 1 ) ; NEW_LINE",
        "explain": "Increment the count if curr_gcd = 1"
    },
    {
        "py": "return ans ; NEW_LINE",
        "explain": "Return the final answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubArr ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def print_primes_till_N ( N ) : NEW_LINE",
        "explain": "Function to print first N prime numbers"
    },
    {
        "py": "i , j , flag = 0 , 0 , 0 ; NEW_LINE",
        "explain": "Declare the variables"
    },
    {
        "py": "print ( \" Prime \u2581 numbers \u2581 between \u2581 1 \u2581 and \u2581 \" , N , \" \u2581 are : \" ) ; NEW_LINE",
        "explain": "Print display message"
    },
    {
        "py": "for i in range ( 1 , N + 1 , 1 ) : NEW_LINE",
        "explain": "Traverse each number from 1 to N with the help of for loop"
    },
    {
        "py": "if ( i == 1 or i == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT",
        "explain": "Skip 0 and 1 as they are neither prime nor composite"
    },
    {
        "py": "flag = 1 ; NEW_LINE for j in range ( 2 , ( ( i // 2 ) + 1 ) , 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT",
        "explain": "flag variable to tell if i is prime or not"
    },
    {
        "py": "if ( flag == 1 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "flag = 1 means i is prime and flag = 0 means i is not prime"
    },
    {
        "py": "N = 100 ; NEW_LINE print_primes_till_N ( N ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 32 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def findX ( A , B ) : NEW_LINE INDENT X = 0 ; NEW_LINE DEDENT",
        "explain": "Function to find X according to the given conditions"
    },
    {
        "py": "for bit in range ( MAX ) : NEW_LINE",
        "explain": "int can have 32 bits"
    },
    {
        "py": "tempBit = 1 << bit ; NEW_LINE",
        "explain": "Temporary ith bit"
    },
    {
        "py": "bitOfX = A & B & tempBit ; NEW_LINE",
        "explain": "Compute ith bit of X according to given conditions Expression below is the direct conclusion from the illustration we had taken earlier"
    },
    {
        "py": "X += bitOfX ; NEW_LINE return X ; NEW_LINE",
        "explain": "Add the ith bit of X to X"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 11 ; B = 13 ; NEW_LINE print ( findX ( A , B ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def cntSubSets ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count of subsets with the maximum mean"
    },
    {
        "py": "maxVal = max ( arr ) ; NEW_LINE",
        "explain": "Maximum value from the array"
    },
    {
        "py": "cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == maxVal ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "To store the number of times maximum element appears in the array"
    },
    {
        "py": "return ( ( 2 ** cnt ) - 1 ) ; NEW_LINE",
        "explain": "Return the count of valid subsets"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntSubSets ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def findProb ( arr , n ) : NEW_LINE",
        "explain": "Function to return the probability of getting the maximum pair sum when a random pair is chosen from the given array"
    },
    {
        "py": "maxSum = - ( sys . maxsize - 1 ) ; NEW_LINE maxCount = 0 ; NEW_LINE totalPairs = 0 ; NEW_LINE",
        "explain": "Initialize the maximum sum , its count and the count of total pairs"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT",
        "explain": "For every single pair"
    },
    {
        "py": "sum = arr [ i ] + arr [ j ] ; NEW_LINE",
        "explain": "Get the sum of the current pair"
    },
    {
        "py": "if ( sum == maxSum ) : NEW_LINE",
        "explain": "If the sum is equal to the current maximum sum so far"
    },
    {
        "py": "maxCount += 1 ; NEW_LINE",
        "explain": "Increment its count"
    },
    {
        "py": "elif ( sum > maxSum ) : NEW_LINE",
        "explain": "If the sum is greater than the current maximum"
    },
    {
        "py": "maxSum = sum ; NEW_LINE maxCount = 1 ; NEW_LINE totalPairs += 1 ; NEW_LINE",
        "explain": "Update the current maximum and re - initialize the count to 1"
    },
    {
        "py": "prob = maxCount / totalPairs ; NEW_LINE return prob ; NEW_LINE",
        "explain": "Find the required probability"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 2 , 2 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findProb ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def maxCommonFactors ( a , b ) : NEW_LINE",
        "explain": "Function to return the count of common factors of a and b such that all the elements are co - prime to one another"
    },
    {
        "py": "gcd = math . gcd ( a , b ) NEW_LINE",
        "explain": "GCD of a and b"
    },
    {
        "py": "ans = 1 ; NEW_LINE",
        "explain": "Include 1 initially"
    },
    {
        "py": "i = 2 NEW_LINE while ( i * i <= gcd ) : NEW_LINE INDENT if ( gcd % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE while ( gcd % i == 0 ) : NEW_LINE INDENT gcd = gcd // i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT",
        "explain": "Find all the prime factors of the gcd"
    },
    {
        "py": "if ( gcd != 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT",
        "explain": "If gcd is prime"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "a = 12 NEW_LINE b = 18 NEW_LINE print ( maxCommonFactors ( a , b ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "days = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] ; NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def dayOfYear ( date ) : NEW_LINE",
        "explain": "Function to return the day number of the year for the given date"
    },
    {
        "py": "year = ( int ) ( date [ 0 : 4 ] ) ; NEW_LINE month = ( int ) ( date [ 5 : 7 ] ) ; NEW_LINE day = ( int ) ( date [ 8 : ] ) ; NEW_LINE",
        "explain": "Extract the year , month and the day from the date string"
    },
    {
        "py": "if ( month > 2 and year % 4 == 0 and ( year % 100 != 0 or year % 400 == 0 ) ) : NEW_LINE INDENT day += 1 ; NEW_LINE DEDENT",
        "explain": "If current year is a leap year and the date given is after the 28 th of February then it must include the 29 th February"
    },
    {
        "py": "month -= 1 ; NEW_LINE while ( month > 0 ) : NEW_LINE INDENT day = day + days [ month - 1 ] ; NEW_LINE month -= 1 ; NEW_LINE DEDENT return day ; NEW_LINE",
        "explain": "Add the days in the previous months"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT date = \"2019-01-09\" ; NEW_LINE print ( dayOfYear ( date ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Cells ( n , x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x % i == 0 and x / i <= n ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT",
        "explain": "Function to find number of cells in the table contains X"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 ; x = 12 ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( Cells ( n , x ) ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "def nextPowerOfFour ( n ) : NEW_LINE INDENT x = math . floor ( ( n ** ( 1 / 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT",
        "explain": "Function to return the smallest power of 4 greater than or equal to n"
    },
    {
        "py": "if ( ( x ** 4 ) == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT else : NEW_LINE INDENT x = x + 1 ; NEW_LINE return ( x ** 4 ) ; NEW_LINE DEDENT",
        "explain": "If n is itself is a power of 4 then return n"
    },
    {
        "py": "n = 122 ; NEW_LINE print ( nextPowerOfFour ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minOperations ( x , y , p , q ) : NEW_LINE",
        "explain": "Function to return the minimum operations required"
    },
    {
        "py": "if ( y % x != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = y // x NEW_LINE",
        "explain": "Not possible"
    },
    {
        "py": "a = 0 NEW_LINE",
        "explain": "To store the greatest power of p that divides d"
    },
    {
        "py": "while ( d % p == 0 ) : NEW_LINE INDENT d //= p NEW_LINE a += 1 NEW_LINE DEDENT",
        "explain": "While divible by p"
    },
    {
        "py": "b = 0 NEW_LINE",
        "explain": "To store the greatest power of q that divides d"
    },
    {
        "py": "while ( d % q == 0 ) : NEW_LINE INDENT d //= q NEW_LINE b += 1 NEW_LINE DEDENT",
        "explain": "While divible by q"
    },
    {
        "py": "if ( d != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "If d > 1"
    },
    {
        "py": "return ( a + b ) NEW_LINE",
        "explain": "Since , d = p ^ a * q ^ b"
    },
    {
        "py": "x = 12 NEW_LINE y = 2592 NEW_LINE p = 2 NEW_LINE q = 3 NEW_LINE print ( minOperations ( x , y , p , q ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def nCr ( n ) : NEW_LINE",
        "explain": "Function to calculate NC4"
    },
    {
        "py": "if ( n < 4 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; NEW_LINE answer //= 24 ; NEW_LINE return answer ; NEW_LINE",
        "explain": "Base case to calculate NC4"
    },
    {
        "py": "def countQuadruples ( N , K ) : NEW_LINE",
        "explain": "Function to return the count of required quadruples using Inclusion Exclusion"
    },
    {
        "py": "M = N // K ; NEW_LINE answer = nCr ( M ) ; NEW_LINE",
        "explain": "Effective N"
    },
    {
        "py": "for i in range ( 2 , M ) : NEW_LINE INDENT j = i ; NEW_LINE DEDENT",
        "explain": "Iterate over 2 to M"
    },
    {
        "py": "temp2 = M // i ; NEW_LINE",
        "explain": "Number of divisors of i till M"
    },
    {
        "py": "count = 0 ; NEW_LINE",
        "explain": "Count stores the number of prime divisors occurring exactly once"
    },
    {
        "py": "check = 0 ; NEW_LINE temp = j ; NEW_LINE while ( j % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE j //= 2 ; NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( count >= 2 ) : NEW_LINE INDENT check = 1 ; NEW_LINE DEDENT for k in range ( 3 , int ( sqrt ( temp ) ) , 2 ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE while ( j % k == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE j //= k ; NEW_LINE if ( cnt >= 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( cnt >= 2 ) : NEW_LINE INDENT check = 1 ; NEW_LINE break ; NEW_LINE DEDENT elif ( cnt == 1 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT if ( j > 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT",
        "explain": "To prevent repetition of prime divisors"
    },
    {
        "py": "if ( check ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If repetition of prime divisors present ignore this number"
    },
    {
        "py": "if ( count % 2 == 1 ) : NEW_LINE INDENT answer -= nCr ( temp2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT answer += nCr ( temp2 ) ; NEW_LINE DEDENT return answer ; NEW_LINE",
        "explain": "If prime divisor count is odd subtract it from answer else add"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 10 ; K = 2 ; NEW_LINE print ( countQuadruples ( N , K ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def getX ( a , b , c , d ) : NEW_LINE INDENT X = ( b * c - a * d ) // ( d - c ) NEW_LINE return X NEW_LINE DEDENT",
        "explain": "Function to return the required number X"
    },
    {
        "py": "a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE print ( getX ( a , b , c , d ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if a character is vowel or consonent"
    },
    {
        "py": "def fact ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT",
        "explain": "Function to calculate factorial of a number"
    },
    {
        "py": "def only_vowels ( freq ) : NEW_LINE INDENT denom = 1 NEW_LINE cnt_vwl = 0 NEW_LINE DEDENT",
        "explain": "Calculating no of ways for arranging vowels"
    },
    {
        "py": "for itr in freq : NEW_LINE INDENT if ( isVowel ( itr ) ) : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt_vwl += freq [ itr ] NEW_LINE DEDENT DEDENT return fact ( cnt_vwl ) // denom NEW_LINE",
        "explain": "Iterate the map and count the number of vowels and calculate no of ways to arrange vowels"
    },
    {
        "py": "def all_vowels_together ( freq ) : NEW_LINE",
        "explain": "calculating no of ways to arrange the given word such that vowels come together"
    },
    {
        "py": "vow = only_vowels ( freq ) NEW_LINE",
        "explain": "calculate no of ways to arrange vowels"
    },
    {
        "py": "denom = 1 NEW_LINE",
        "explain": "to store denominator of fraction"
    },
    {
        "py": "cnt_cnst = 0 NEW_LINE for itr in freq : NEW_LINE INDENT if ( isVowel ( itr ) == False ) : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt_cnst += freq [ itr ] NEW_LINE DEDENT DEDENT",
        "explain": "count of consonents"
    },
    {
        "py": "ans = fact ( cnt_cnst + 1 ) // denom NEW_LINE return ( ans * vow ) NEW_LINE",
        "explain": "calculate the number of ways to arrange the word such that vowels come together"
    },
    {
        "py": "def total_permutations ( freq ) : NEW_LINE",
        "explain": "To calculate total number of permutations"
    },
    {
        "py": "cnt = 0 NEW_LINE",
        "explain": "To store length of the given word"
    },
    {
        "py": "denom = 1 NEW_LINE for itr in freq : NEW_LINE INDENT denom *= fact ( freq [ itr ] ) NEW_LINE cnt += freq [ itr ] NEW_LINE DEDENT",
        "explain": "denominator of fraction"
    },
    {
        "py": "return fact ( cnt ) // denom NEW_LINE",
        "explain": "return total number of permutations of the given word"
    },
    {
        "py": "def no_vowels_together ( word ) : NEW_LINE",
        "explain": "Function to calculate number of permutations such that no vowels come together"
    },
    {
        "py": "freq = dict ( ) NEW_LINE",
        "explain": "to store frequency of character"
    },
    {
        "py": "for i in word : NEW_LINE INDENT ch = i . lower ( ) NEW_LINE freq [ ch ] = freq . get ( ch , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "count frequency of acharacters"
    },
    {
        "py": "total = total_permutations ( freq ) NEW_LINE",
        "explain": "calculate total number of permutations"
    },
    {
        "py": "vwl_tgthr = all_vowels_together ( freq ) NEW_LINE",
        "explain": "calculate total number of permutations such that vowels come together"
    },
    {
        "py": "res = total - vwl_tgthr NEW_LINE",
        "explain": "substrat vwl_tgthr from total to get the result"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "return the result"
    },
    {
        "py": "word = \" allahabad \" NEW_LINE ans = no_vowels_together ( word ) NEW_LINE print ( ans ) NEW_LINE word = \" geeksforgeeks \" NEW_LINE ans = no_vowels_together ( word ) NEW_LINE print ( ans ) NEW_LINE word = \" abcd \" NEW_LINE ans = no_vowels_together ( word ) NEW_LINE print ( ans ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def numberOfMen ( D , m , d ) : NEW_LINE INDENT Men = ( m * ( D - d ) ) / d ; NEW_LINE return int ( Men ) ; NEW_LINE DEDENT",
        "explain": "Function to return the number of men initially"
    },
    {
        "py": "D = 5 ; m = 4 ; d = 4 ; NEW_LINE print ( numberOfMen ( D , m , d ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def area ( a , b , c ) : NEW_LINE INDENT d = abs ( ( c * c ) / ( 2 * a * b ) ) NEW_LINE return d NEW_LINE DEDENT",
        "explain": "Function to find area"
    },
    {
        "py": "a = - 2 NEW_LINE b = 4 NEW_LINE c = 3 NEW_LINE print ( area ( a , b , c ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def addToArrayForm ( A , K ) : NEW_LINE",
        "explain": "Function to return the vector containing the answer"
    },
    {
        "py": "v , ans = [ ] , [ ] NEW_LINE",
        "explain": "Vector v is to store each digits sum and vector ans is to store the answer"
    },
    {
        "py": "rem , i = 0 , 0 NEW_LINE",
        "explain": "No carry in the beginning"
    },
    {
        "py": "for i in range ( len ( A ) - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Start loop from the end and take element one by one"
    },
    {
        "py": "my = A [ i ] + ( K % 10 ) + rem NEW_LINE if my > 9 : NEW_LINE",
        "explain": "Array index and last digit of number"
    },
    {
        "py": "rem = 1 NEW_LINE",
        "explain": "Maintain carry of summation"
    },
    {
        "py": "v . append ( my % 10 ) NEW_LINE else : NEW_LINE v . append ( my ) NEW_LINE rem = 0 NEW_LINE K = K // 10 NEW_LINE",
        "explain": "Push the digit value into the array"
    },
    {
        "py": "while K > 0 : NEW_LINE",
        "explain": "K value is greater then 0"
    },
    {
        "py": "my = ( K % 10 ) + rem NEW_LINE v . append ( my % 10 ) NEW_LINE",
        "explain": "Push digits of K one by one in the array"
    },
    {
        "py": "if my // 10 > 0 : NEW_LINE INDENT rem = 1 NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE DEDENT K = K // 10 NEW_LINE if rem > 0 : NEW_LINE v . append ( rem ) NEW_LINE",
        "explain": "Also maintain carry with summation"
    },
    {
        "py": "for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT ans . append ( v [ i ] ) NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Reverse the elements of vector v and store it in vector ans"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 7 , 4 ] NEW_LINE K = 181 NEW_LINE ans = addToArrayForm ( A , K ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Print the answer"
    },
    {
        "py": "MAX = 100005 ; NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def kadaneAlgorithm ( ar , n ) : NEW_LINE INDENT sum = 0 ; maxSum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += ar [ i ] ; NEW_LINE if ( sum < 0 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE DEDENT maxSum = max ( maxSum , sum ) ; NEW_LINE DEDENT return maxSum ; NEW_LINE DEDENT",
        "explain": "Function to return maximum sum of a sub - array"
    },
    {
        "py": "def maxFunction ( arr , n ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE c = [ 0 ] * MAX ; NEW_LINE DEDENT",
        "explain": "Function to return maximum value of function F"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; NEW_LINE c [ i ] = - b [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; NEW_LINE b [ i ] = - c [ i ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Compute arrays B [ ] and C [ ]"
    },
    {
        "py": "ans = kadaneAlgorithm ( b , n - 1 ) ; NEW_LINE ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; NEW_LINE return ans ; NEW_LINE",
        "explain": "Find maximum sum sub - array of both of the arrays and take maximum among them"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 4 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( maxFunction ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findThirdDigit ( n ) : NEW_LINE",
        "explain": "Function to find the element"
    },
    {
        "py": "if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "if n < 3"
    },
    {
        "py": "return 1 if n and 1 else 6 NEW_LINE",
        "explain": "If n is even return 6 If n is odd return 1"
    },
    {
        "py": "n = 7 NEW_LINE print ( findThirdDigit ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getProbability ( a , b , c , d ) : NEW_LINE",
        "explain": "Function to return the probability of A winning"
    },
    {
        "py": "p = a / b ; NEW_LINE q = c / d ; NEW_LINE",
        "explain": "p and q store the values of fractions a / b and c / d"
    },
    {
        "py": "ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; NEW_LINE return round ( ans , 5 ) ; NEW_LINE",
        "explain": "To store the winning probability of A"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 ; b = 2 ; c = 10 ; d = 11 ; NEW_LINE print ( getProbability ( a , b , c , d ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isPalindrome ( n ) : NEW_LINE",
        "explain": "Function to check if n is palindrome"
    },
    {
        "py": "divisor = 1 NEW_LINE while ( int ( n / divisor ) >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = int ( n / divisor ) NEW_LINE trailing = n % 10 NEW_LINE DEDENT",
        "explain": "Find the appropriate divisor to extract the leading digit"
    },
    {
        "py": "if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If first and last digits are not same then return false"
    },
    {
        "py": "n = int ( ( n % divisor ) / 10 ) NEW_LINE",
        "explain": "Removing the leading and trailing digits from the number"
    },
    {
        "py": "divisor = int ( divisor / 100 ) NEW_LINE return True NEW_LINE",
        "explain": "Reducing divisor by a factor of 2 as 2 digits are dropped"
    },
    {
        "py": "def largestPalindrome ( A , n ) : NEW_LINE INDENT currentMax = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE DEDENT",
        "explain": "Function to find the largest palindromic number"
    },
    {
        "py": "if ( A [ i ] > currentMax and isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT currentMax = A [ i ] NEW_LINE DEDENT",
        "explain": "If a palindrome larger than the currentMax is found"
    },
    {
        "py": "return currentMax NEW_LINE",
        "explain": "Return the largest palindromic number from the array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( largestPalindrome ( A , n ) ) NEW_LINE",
        "explain": "print required answer"
    },
    {
        "py": "def getFinalElement ( n ) : NEW_LINE INDENT finalNum = 2 NEW_LINE while finalNum * 2 <= n : NEW_LINE INDENT finalNum *= 2 NEW_LINE DEDENT return finalNum NEW_LINE DEDENT",
        "explain": "Function to return the final element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 12 NEW_LINE print ( getFinalElement ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 program to find Sum of elements in an array having prime frequency"
    },
    {
        "py": "def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE",
        "explain": "Function to create Sieve to check primes"
    },
    {
        "py": "prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( p_size + 1 ) ) ) : NEW_LINE",
        "explain": "False here indicates that it is not prime"
    },
    {
        "py": "if ( prime [ p ] ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT",
        "explain": "Update all multiples of p , set them to non - prime"
    },
    {
        "py": "def SumOfElements ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE DEDENT",
        "explain": "Function to return the Sum of elements in an array having prime frequency"
    },
    {
        "py": "m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE",
        "explain": "Map is used to store element frequencies"
    },
    {
        "py": "for i in m : NEW_LINE",
        "explain": "Traverse the map using iterators"
    },
    {
        "py": "if ( prime [ m [ i ] ] ) : NEW_LINE INDENT Sum += ( i ) NEW_LINE DEDENT return Sum NEW_LINE",
        "explain": "Count the number of elements having prime frequencies"
    },
    {
        "py": "arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( SumOfElements ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isPalindrome ( num ) : NEW_LINE INDENT reverse_num = 0 NEW_LINE DEDENT",
        "explain": "Function that returns true if the given number is a palindrome"
    },
    {
        "py": "temp = num NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT remainder = temp % 10 NEW_LINE reverse_num = reverse_num * 10 + remainder NEW_LINE temp = int ( temp / 10 ) NEW_LINE DEDENT",
        "explain": "Here we are generating a new number ( reverse_num ) by reversing the digits of original input number"
    },
    {
        "py": "if ( reverse_num == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If the original input number ( num ) is equal to its reverse ( reverse_num ) then its palindrome else it is not ."
    },
    {
        "py": "def isOddLength ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT num = int ( num / 10 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "Function that returns true if the given number is of odd length"
    },
    {
        "py": "def sumOfAllPalindrome ( L , R ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( L <= R ) : NEW_LINE INDENT for i in range ( L , R + 1 , 1 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the sum of all odd length palindromic numbers within the given range"
    },
    {
        "py": "if ( isPalindrome ( i ) and isOddLength ( i ) ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "if number is palindrome and of odd length"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 110 NEW_LINE R = 1130 NEW_LINE print ( sumOfAllPalindrome ( L , R ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f = f * i NEW_LINE DEDENT return f NEW_LINE DEDENT",
        "explain": "Factorial of a number"
    },
    {
        "py": "def waysOfConsonants ( size1 , freq ) : NEW_LINE INDENT ans = fact ( size1 ) NEW_LINE for i in range ( 26 ) : NEW_LINE DEDENT",
        "explain": "calculating ways for arranging consonants"
    },
    {
        "py": "if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans // fact ( freq [ i ] ) NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Ignore vowels"
    },
    {
        "py": "def waysOfVowels ( size2 , freq ) : NEW_LINE INDENT return ( fact ( size2 ) // ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ) NEW_LINE DEDENT",
        "explain": "calculating ways for arranging vowels"
    },
    {
        "py": "def countWays ( str1 ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to count total no . of ways"
    },
    {
        "py": "vowel = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != ' a ' and str1 [ i ] != ' e ' and str1 [ i ] != ' i ' and str1 [ i ] != ' o ' and str1 [ i ] != ' u ' ) : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT else : NEW_LINE INDENT vowel += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count vowels and consonant"
    },
    {
        "py": "return ( waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ) NEW_LINE",
        "explain": "total no . of ways"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" NEW_LINE print ( countWays ( str1 ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def calculateAlternateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 0 ] = 0 NEW_LINE fibo [ 1 ] = 1 NEW_LINE DEDENT",
        "explain": "Computes value of first fibonacci numbers and stores their alternate sum"
    },
    {
        "py": "sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE DEDENT",
        "explain": "Add remaining terms"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE INDENT sum -= fibo [ i ] NEW_LINE DEDENT",
        "explain": "For even terms"
    },
    {
        "py": "else : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT",
        "explain": "For odd terms"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "Return the alternating sum"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "n = 8 NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "print ( \" Alternating \u2581 Fibonacci \u2581 Sum \u2581 upto \u2581 \" , n , \" \u2581 terms : \u2581 \" , calculateAlternateSum ( n ) ) NEW_LINE",
        "explain": "Find the alternating sum"
    },
    {
        "py": "def getValue ( n ) : NEW_LINE INDENT i = 0 ; NEW_LINE k = 1 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT i = i + k ; NEW_LINE k = k * 2 ; NEW_LINE DEDENT return int ( k / 2 ) ; NEW_LINE DEDENT",
        "explain": "Function that will return nth term"
    },
    {
        "py": "n = 9 ; NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "print ( getValue ( n ) ) ; NEW_LINE",
        "explain": "Get the value"
    },
    {
        "py": "n = 1025 ; NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "print ( getValue ( n ) ) ; NEW_LINE",
        "explain": "Get the value"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python 3 implementation of above approach"
    },
    {
        "py": "def countDigits ( val , arr ) : NEW_LINE INDENT while ( val > 0 ) : NEW_LINE INDENT digit = val % 10 NEW_LINE arr [ int ( digit ) ] += 1 NEW_LINE val = val // 10 NEW_LINE DEDENT return ; NEW_LINE DEDENT def countFrequency ( x , n ) : NEW_LINE",
        "explain": "Function that traverses digits in a number and modifies frequency count array"
    },
    {
        "py": "freq_count = [ 0 ] * 10 NEW_LINE",
        "explain": "Array to keep count of digits"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Traversing through x ^ 1 to x ^ n"
    },
    {
        "py": "val = math . pow ( x , i ) NEW_LINE",
        "explain": "For power function , both its parameters are to be in double"
    },
    {
        "py": "countDigits ( val , freq_count ) NEW_LINE",
        "explain": "calling countDigits function on x ^ i"
    },
    {
        "py": "for i in range ( 10 ) : NEW_LINE INDENT print ( freq_count [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Printing count of digits 0 - 9"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 15 NEW_LINE n = 3 NEW_LINE countFrequency ( x , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countSolutions ( a ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "function to return the number of solutions"
    },
    {
        "py": "for i in range ( a + 1 ) : NEW_LINE INDENT if ( a == ( i + ( a ^ i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE",
        "explain": "check for every possible value"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countSolutions ( a ) : NEW_LINE INDENT count = bin ( a ) . count ( '1' ) NEW_LINE return 2 ** count NEW_LINE DEDENT",
        "explain": "function to return the number of solutions"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 3 NEW_LINE print ( countSolutions ( a ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def calculateAreaSum ( l , b ) : NEW_LINE INDENT size = 1 NEW_LINE DEDENT",
        "explain": "Function to calculate the sum of area of all possible squares that comes inside the rectangle"
    },
    {
        "py": "maxSize = min ( l , b ) NEW_LINE totalArea = 0 NEW_LINE for i in range ( 1 , maxSize + 1 ) : NEW_LINE",
        "explain": "Square with max size possible"
    },
    {
        "py": "totalSquares = ( ( l - size + 1 ) * ( b - size + 1 ) ) NEW_LINE",
        "explain": "calculate total square of a given size"
    },
    {
        "py": "area = ( totalSquares * size * size ) NEW_LINE",
        "explain": "calculate area of squares of a particular size"
    },
    {
        "py": "totalArea += area NEW_LINE",
        "explain": "total area"
    },
    {
        "py": "size += 1 NEW_LINE return totalArea NEW_LINE",
        "explain": "increment size"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT l = 4 NEW_LINE b = 3 NEW_LINE print ( calculateAreaSum ( l , b ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def boost_hyperfactorial ( num ) : NEW_LINE",
        "explain": "function to calculate the value of hyperfactorial"
    },
    {
        "py": "val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT val = val * pow ( i , i ) ; NEW_LINE DEDENT",
        "explain": "initialise the val to 1"
    },
    {
        "py": "return val ; NEW_LINE",
        "explain": "returns the hyperfactorial of a number"
    },
    {
        "py": "num = 5 ; NEW_LINE print ( boost_hyperfactorial ( num ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def boost_hyperfactorial ( num ) : NEW_LINE",
        "explain": "function to calculate the value of hyperfactorial"
    },
    {
        "py": "val = 1 ; NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE DEDENT",
        "explain": "initialise the val to 1"
    },
    {
        "py": "val *= i ; NEW_LINE",
        "explain": "1 ^ 1 * 2 ^ 2 * 3 ^ 3. . . ."
    },
    {
        "py": "return val ; NEW_LINE",
        "explain": "returns the hyperfactorial of a number"
    },
    {
        "py": "num = 5 ; NEW_LINE print ( boost_hyperfactorial ( num ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def subtractOne ( x ) : NEW_LINE INDENT m = 1 NEW_LINE DEDENT",
        "explain": "Python 3 code to subtract one from a given number"
    },
    {
        "py": "while ( ( x & m ) == False ) : NEW_LINE INDENT x = x ^ m NEW_LINE m = m << 1 NEW_LINE DEDENT",
        "explain": "Flip all the set bits until we find a 1"
    },
    {
        "py": "x = x ^ m NEW_LINE return x NEW_LINE",
        "explain": "flip the rightmost 1 bit"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( subtractOne ( 13 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "rows = 3 ; NEW_LINE cols = 3 ; NEW_LINE",
        "explain": "Python3 program to find mean vector of given matrix"
    },
    {
        "py": "def meanVector ( mat ) : NEW_LINE INDENT print ( \" [ \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT",
        "explain": "Function to find mean vector"
    },
    {
        "py": "for i in range ( rows ) : NEW_LINE",
        "explain": "loop to traverse each column"
    },
    {
        "py": "mean = 0.00 ; NEW_LINE",
        "explain": "to calculate mean of each row"
    },
    {
        "py": "sum = 0 ; NEW_LINE for j in range ( cols ) : NEW_LINE INDENT sum = sum + mat [ j ] [ i ] ; mean = int ( sum / rows ) ; print ( mean , end = \" \u2581 \" ) ; print ( \" ] \" ) ; NEW_LINE DEDENT",
        "explain": "to store sum of elements of a column"
    },
    {
        "py": "mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE meanVector ( mat ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 code to check if a number is a hoax number or not ."
    },
    {
        "py": "def primeFactors ( n ) : NEW_LINE INDENT res = [ ] NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT res . append ( 2 ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to find distinct prime factors of given number n"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE",
        "explain": "n is odd at this point , since it is no longer divisible by 2. So we can test only for the odd numbers , whether they are factors of n"
    },
    {
        "py": "if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT res . append ( i ) NEW_LINE DEDENT",
        "explain": "Check if i is prime factor"
    },
    {
        "py": "if ( n > 2 ) : NEW_LINE INDENT res . append ( n ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "This condition is to handle the case when n is a prime number greater than 2"
    },
    {
        "py": "def isHoax ( n ) : NEW_LINE",
        "explain": "Function to calculate sum of digits of distinct prime factors of given number n and sum of digits of number n and compare the sums obtained"
    },
    {
        "py": "pf = primeFactors ( n ) NEW_LINE",
        "explain": "Distinct prime factors of n are being stored in vector pf"
    },
    {
        "py": "if ( pf [ 0 ] == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If n is a prime number , it cannot be a hoax number"
    },
    {
        "py": "all_pf_sum = 0 NEW_LINE for i in range ( 0 , len ( pf ) ) : NEW_LINE",
        "explain": "Finding sum of digits of distinct prime factors of the number n"
    },
    {
        "py": "pf_sum = 0 NEW_LINE while ( pf [ i ] > 0 ) : NEW_LINE INDENT pf_sum += pf [ i ] % 10 NEW_LINE pf [ i ] = int ( pf [ i ] / 10 ) NEW_LINE DEDENT all_pf_sum += pf_sum NEW_LINE",
        "explain": "Finding sum of digits in current prime factor pf [ i ] ."
    },
    {
        "py": "sum_n = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum_n += n % 10 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT",
        "explain": "Finding sum of digits of number n"
    },
    {
        "py": "return sum_n == all_pf_sum NEW_LINE",
        "explain": "Comparing the two calculated sums"
    },
    {
        "py": "n = 84 ; NEW_LINE if ( isHoax ( n ) ) : NEW_LINE INDENT print ( \" A Hoax Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not a Hoax Number \" ) NEW_LINE DEDENT",
        "explain": "Driver Method"
    },
    {
        "py": "def LucasLehmer ( n ) : NEW_LINE",
        "explain": "Function to find out first n terms ( considering 4 as 0 th term ) of Lucas - Lehmer series ."
    },
    {
        "py": "INDENT current_val = 4 ; NEW_LINE DEDENT",
        "explain": "the 0 th term of the series is 4."
    },
    {
        "py": "INDENT series = [ ] NEW_LINE DEDENT",
        "explain": "create an array to store the terms ."
    },
    {
        "py": "INDENT series . append ( current_val ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_val = current_val * current_val - 2 ; NEW_LINE series . append ( current_val ) ; NEW_LINE DEDENT DEDENT",
        "explain": "compute each term and add it to the array ."
    },
    {
        "py": "INDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( \" Term \" , i , \" : \" , series [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "print out the terms one by one ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 ; NEW_LINE LucasLehmer ( n ) ; NEW_LINE DEDENT",
        "explain": "Driver program"
    },
    {
        "py": "' NEW_LINE def modInverse ( a , prime ) : NEW_LINE INDENT a = a % prime NEW_LINE for x in range ( 1 , prime ) : NEW_LINE INDENT if ( ( a * x ) % prime == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printModIverses ( n , prime ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( modInverse ( i , prime ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "A naive method to find modular multiplicative inverse of ' a ' under modulo 'prime"
    },
    {
        "py": "n = 10 NEW_LINE prime = 17 NEW_LINE printModIverses ( n , prime ) NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "def minOp ( num ) : NEW_LINE",
        "explain": "function for minimum operation"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "remainder and operations count"
    },
    {
        "py": "while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE if ( not ( rem == 3 or rem == 8 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT num = num // 10 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "count digits not equal to 3 or 8"
    },
    {
        "py": "num = 234198 NEW_LINE print ( \" Minimum \u2581 Operations \u2581 = \" , minOp ( num ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def sumOfDigits ( a ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT sm = sm + a % 10 NEW_LINE a = a // 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT",
        "explain": "function to calculate the sum of digits of a number ."
    },
    {
        "py": "def findMax ( x ) : NEW_LINE",
        "explain": "Returns the maximum number with maximum sum of digits ."
    },
    {
        "py": "b = 1 NEW_LINE ans = x NEW_LINE",
        "explain": "initializing b as 1 and initial max sum to be of n"
    },
    {
        "py": "while ( x != 0 ) : NEW_LINE",
        "explain": "iterates from right to left in a digit"
    },
    {
        "py": "cur = ( x - 1 ) * b + ( b - 1 ) NEW_LINE",
        "explain": "while iterating this is the number from right to left"
    },
    {
        "py": "if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) or ( sumOfDigits ( cur ) == sumOfDigits ( ans ) and cur > ans ) ) : NEW_LINE INDENT ans = cur NEW_LINE DEDENT",
        "explain": "calls the function to check if sum of cur is more then of ans"
    },
    {
        "py": "x = x // 10 NEW_LINE b = b * 10 NEW_LINE return ans NEW_LINE",
        "explain": "reduces the number to one unit less"
    },
    {
        "py": "n = 521 NEW_LINE print ( findMax ( n ) ) NEW_LINE",
        "explain": "driver program to test the above function"
    },
    {
        "py": "def median ( a , l , r ) : NEW_LINE INDENT n = r - l + 1 NEW_LINE n = ( n + 1 ) // 2 - 1 NEW_LINE return n + l NEW_LINE DEDENT",
        "explain": "Function to give index of the median"
    },
    {
        "py": "def IQR ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE DEDENT",
        "explain": "Function to calculate IQR"
    },
    {
        "py": "mid_index = median ( a , 0 , n ) NEW_LINE",
        "explain": "Index of median of entire data"
    },
    {
        "py": "Q1 = a [ median ( a , 0 , mid_index ) ] NEW_LINE",
        "explain": "Median of first half"
    },
    {
        "py": "Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] NEW_LINE",
        "explain": "Median of second half"
    },
    {
        "py": "return ( Q3 - Q1 ) NEW_LINE",
        "explain": "IQR calculation"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 ] NEW_LINE n = len ( a ) NEW_LINE print ( IQR ( a , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Function"
    },
    {
        "py": "def isPalindrome ( n ) : NEW_LINE",
        "explain": "Function to check if n is palindrome"
    },
    {
        "py": "divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE DEDENT",
        "explain": "Find the appropriate divisor to extract the leading digit"
    },
    {
        "py": "if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If first and last digits are not same then return false"
    },
    {
        "py": "n = ( n % divisor ) // 10 NEW_LINE",
        "explain": "Removing the leading and trailing digits from the number"
    },
    {
        "py": "divisor = divisor // 100 NEW_LINE return True NEW_LINE",
        "explain": "Reducing divisor by a factor of 2 as 2 digits are dropped"
    },
    {
        "py": "def largestPalindrome ( A , n ) : NEW_LINE",
        "explain": "Function to find the largest palindromic number"
    },
    {
        "py": "A . sort ( ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "if ( isPalindrome ( A [ i ] ) ) : NEW_LINE INDENT return A [ i ] NEW_LINE DEDENT",
        "explain": "If number is palindrome"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "If no palindromic number found"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 232 , 54545 , 999991 ] NEW_LINE n = len ( A ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( largestPalindrome ( A , n ) ) NEW_LINE",
        "explain": "print required answer"
    },
    {
        "py": "def findSum ( n , a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE DEDENT",
        "explain": "Function to return the sum of all the integers below N which are multiples of either A or B"
    },
    {
        "py": "if ( i % a == 0 or i % b == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "If i is a multiple of a or b"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE print ( findSum ( n , a , b ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def subtractOne ( x ) : NEW_LINE INDENT return ( ( x << 1 ) + ( ~ x ) ) ; NEW_LINE DEDENT print ( subtractOne ( 13 ) ) ; NEW_LINE",
        "explain": "''Driver code"
    },
    {
        "py": "def pell ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( 2 * pell ( n - 1 ) + pell ( n - 2 ) ) NEW_LINE DEDENT",
        "explain": "Calculate nth pell number"
    },
    {
        "py": "n = 4 ; NEW_LINE print ( pell ( n ) ) NEW_LINE",
        "explain": "Driver function"
    },
    {
        "py": "def LCM ( arr , n ) : NEW_LINE",
        "explain": "Returns LCM of arr [ 0. . n - 1 ]"
    },
    {
        "py": "max_num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_num < arr [ i ] ) : NEW_LINE INDENT max_num = arr [ i ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Find the maximum value in arr [ ]"
    },
    {
        "py": "res = 1 ; NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "while ( x <= max_num ) : NEW_LINE",
        "explain": "Find all factors that are present in two or more array elements . x = 2 ; Current factor ."
    },
    {
        "py": "indexes = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % x == 0 ) : NEW_LINE INDENT indexes . append ( j ) ; NEW_LINE DEDENT DEDENT",
        "explain": "To store indexes of all array elements that are divisible by x ."
    },
    {
        "py": "if ( len ( indexes ) >= 2 ) : NEW_LINE",
        "explain": "If there are 2 or more array elements that are divisible by x ."
    },
    {
        "py": "for j in range ( len ( indexes ) ) : NEW_LINE INDENT arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) ; NEW_LINE DEDENT res = res * x ; NEW_LINE else : NEW_LINE x += 1 ; NEW_LINE",
        "explain": "Reduce all array elements divisible by x ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT res = res * arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE",
        "explain": "Then multiply all reduced array elements"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( LCM ( arr , n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "python program for the above approach"
    },
    {
        "py": "def politness ( n ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Function to find politeness"
    },
    {
        "py": "for i in range ( 2 , int ( math . sqrt ( 2 * n ) ) + 1 ) : NEW_LINE INDENT if ( ( 2 * n ) % i != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a = 2 * n NEW_LINE a = a / i NEW_LINE a = a - ( i - 1 ) NEW_LINE if ( a % 2 != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT a /= 2 NEW_LINE if ( a > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE",
        "explain": "sqrt ( 2 * n ) as max length will be when the sum starts from 1 which follows the equation n ^ 2 - n - ( 2 * sum ) = 0"
    },
    {
        "py": "n = 90 NEW_LINE print \" Politness \u2581 of \u2581 \" , n , \" \u2581 = \u2581 \" , politness ( n ) NEW_LINE n = 15 NEW_LINE print \" Politness \u2581 of \u2581 \" , n , \" \u2581 = \u2581 \" , politness ( n ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "import math NEW_LINE MAX = 10000 ; NEW_LINE",
        "explain": "Python3 program to implement Goldbach 's conjecture"
    },
    {
        "py": "primes = [ ] ; NEW_LINE",
        "explain": "Array to store all prime less than and equal to 10 ^ 6"
    },
    {
        "py": "def sieveSundaram ( ) : NEW_LINE",
        "explain": "Utility function for Sieve of Sundaram"
    },
    {
        "py": "marked = [ False ] * ( int ( MAX / 2 ) + 100 ) ; NEW_LINE",
        "explain": "In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than MAX , we reduce MAX to half . This array is used to separate numbers of the form i + j + 2 * i * j from others where 1 <= i <= j"
    },
    {
        "py": "for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT",
        "explain": "Main logic of Sundaram . Mark all numbers which do not generate prime number by doing 2 * i + 1"
    },
    {
        "py": "primes . append ( 2 ) ; NEW_LINE",
        "explain": "Since 2 is a prime number"
    },
    {
        "py": "for i in range ( 1 , int ( MAX / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."
    },
    {
        "py": "def findPrimes ( n ) : NEW_LINE",
        "explain": "Function to perform Goldbach 's conjecture"
    },
    {
        "py": "if ( n <= 2 or n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "Return if number is not even or less than 3"
    },
    {
        "py": "i = 0 ; NEW_LINE while ( primes [ i ] <= n // 2 ) : NEW_LINE",
        "explain": "Check only upto half of number"
    },
    {
        "py": "diff = n - primes [ i ] ; NEW_LINE",
        "explain": "find difference by subtracting current prime from n"
    },
    {
        "py": "if diff in primes : NEW_LINE",
        "explain": "Search if the difference is also a prime number"
    },
    {
        "py": "print ( primes [ i ] , \" + \" , diff , \" = \" , n ) ; NEW_LINE return ; NEW_LINE i += 1 ; NEW_LINE",
        "explain": "Express as a sum of primes"
    },
    {
        "py": "sieveSundaram ( ) ; NEW_LINE",
        "explain": "Finding all prime numbers before limit"
    },
    {
        "py": "findPrimes ( 4 ) ; NEW_LINE findPrimes ( 38 ) ; NEW_LINE findPrimes ( 100 ) ; NEW_LINE",
        "explain": "Express number as a sum of two primes"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python Program to print kth prime factor"
    },
    {
        "py": "def kPrimeFactor ( n , k ) : NEW_LINE",
        "explain": "A function to generate prime factors of a given number n and return k - th prime factor"
    },
    {
        "py": "while ( n % 2 == 0 ) : NEW_LINE INDENT k = k - 1 NEW_LINE n = n / 2 NEW_LINE if ( k == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT",
        "explain": "Find the number of 2 's that divide k"
    },
    {
        "py": "i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE",
        "explain": "n must be odd at this point . So we can skip one element ( Note i = i + 2 )"
    },
    {
        "py": "while ( n % i == 0 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT k = k - 1 NEW_LINE n = n / i NEW_LINE DEDENT i = i + 2 NEW_LINE",
        "explain": "While i divides n , store i and divide n"
    },
    {
        "py": "if ( n > 2 and k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE",
        "explain": "This condition is to handle the case where n is a prime number greater than 2"
    },
    {
        "py": "n = 12 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k ) ) NEW_LINE n = 14 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k ) ) NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "MAX = 10001 NEW_LINE",
        "explain": "python3 program to find k - th prime factor using Sieve Of Eratosthenes . This program is efficient when we have a range of numbers ."
    },
    {
        "py": "def sieveOfEratosthenes ( s ) : NEW_LINE",
        "explain": "Using SieveOfEratosthenes to find smallest prime factor of all the numbers . For example , if MAX is 10 , s [ 2 ] = s [ 4 ] = s [ 6 ] = s [ 10 ] = 2 s [ 3 ] = s [ 9 ] = 3 s [ 5 ] = 5 s [ 7 ] = 7"
    },
    {
        "py": "prime = [ False for i in range ( MAX + 1 ) ] NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . MAX ] \" and initialize all entries in it as false ."
    },
    {
        "py": "for i in range ( 2 , MAX + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 ; NEW_LINE DEDENT",
        "explain": "Initializing smallest factor equal to 2 for all the even numbers"
    },
    {
        "py": "for i in range ( 3 , MAX , 2 ) : NEW_LINE INDENT if ( prime [ i ] == False ) : NEW_LINE DEDENT",
        "explain": "For odd numbers less then equal to n"
    },
    {
        "py": "s [ i ] = i NEW_LINE",
        "explain": "s ( i ) for a prime is the number itself"
    },
    {
        "py": "for j in range ( i , MAX + 1 , 2 ) : NEW_LINE INDENT if j * j > MAX : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ i * j ] == False ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE DEDENT DEDENT",
        "explain": "For all multiples of current prime number"
    },
    {
        "py": "s [ i * j ] = i NEW_LINE",
        "explain": "i is the smallest prime factor for number \" i * j \" ."
    },
    {
        "py": "def kPrimeFactor ( n , k , s ) : NEW_LINE",
        "explain": "Function to generate prime factors and return its k - th prime factor . s [ i ] stores least prime factor of i ."
    },
    {
        "py": "while ( n > 1 ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return s [ n ] NEW_LINE DEDENT DEDENT",
        "explain": "Keep dividing n by least prime factor while either n is not 1 or count of prime factors is not k ."
    },
    {
        "py": "k -= 1 NEW_LINE",
        "explain": "To keep track of count of prime factors"
    },
    {
        "py": "n //= s [ n ] NEW_LINE return - 1 NEW_LINE",
        "explain": "Divide n to find next prime factor"
    },
    {
        "py": "s = [ - 1 for i in range ( MAX + 1 ) ] NEW_LINE sieveOfEratosthenes ( s ) NEW_LINE n = 12 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k , s ) ) NEW_LINE n = 14 NEW_LINE k = 3 NEW_LINE print ( kPrimeFactor ( n , k , s ) ) NEW_LINE",
        "explain": "s [ i ] is going to store prime factor of i ."
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 program to find sum of divisors of all the divisors of a natural number ."
    },
    {
        "py": "def sumDivisorsOfDivisors ( n ) : NEW_LINE",
        "explain": "Returns sum of divisors of all the divisors of n"
    },
    {
        "py": "mp = dict ( ) NEW_LINE for j in range ( 2 , mt . ceil ( mt . sqrt ( n ) ) ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n % j == 0 ) : NEW_LINE INDENT n //= j NEW_LINE count += 1 NEW_LINE DEDENT if ( count ) : NEW_LINE INDENT mp [ j ] = count NEW_LINE DEDENT DEDENT",
        "explain": "Calculating powers of prime factors and storing them in a map mp [ ] ."
    },
    {
        "py": "if ( n != 1 ) : NEW_LINE INDENT mp [ n ] = 1 NEW_LINE DEDENT",
        "explain": "If n is a prime number"
    },
    {
        "py": "ans = 1 NEW_LINE for it in mp : NEW_LINE INDENT pw = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( mp [ it ] + 1 , 0 , - 1 ) : NEW_LINE INDENT summ += ( i * pw ) NEW_LINE pw *= it NEW_LINE DEDENT ans *= summ NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "For each prime factor , calculating ( p ^ ( a + 1 ) - 1 ) / ( p - 1 ) and adding it to answer ."
    },
    {
        "py": "n = 10 NEW_LINE print ( sumDivisorsOfDivisors ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def fractionToDecimal ( numr , denr ) : NEW_LINE",
        "explain": "This function returns repeating sequence of a fraction . If repeating sequence doesn 't exits, then returns empty string"
    },
    {
        "py": "res = \" \" NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "mp = { } NEW_LINE",
        "explain": "Create a map to store already seen remainders . Remainder is used as key and its position in result is stored as value . Note that we need position for cases like 1 / 6. In this case , the recurring sequence doesn 't start  from first remainder."
    },
    {
        "py": "rem = numr % denr NEW_LINE",
        "explain": "Find first remainder"
    },
    {
        "py": "while ( ( rem != 0 ) and ( rem not in mp ) ) : NEW_LINE",
        "explain": "Keep finding remainder until either remainder becomes 0 or repeats"
    },
    {
        "py": "mp [ rem ] = len ( res ) NEW_LINE",
        "explain": "Store this remainder"
    },
    {
        "py": "rem = rem * 10 NEW_LINE",
        "explain": "Multiply remainder with 10"
    },
    {
        "py": "res_part = rem // denr NEW_LINE res += str ( res_part ) NEW_LINE",
        "explain": "Append rem / denr to result"
    },
    {
        "py": "rem = rem % denr NEW_LINE if ( rem == 0 ) : NEW_LINE return \" \" NEW_LINE else : NEW_LINE return res [ mp [ rem ] : ] NEW_LINE",
        "explain": "Update remainder"
    },
    {
        "py": "numr , denr = 50 , 22 NEW_LINE res = fractionToDecimal ( numr , denr ) NEW_LINE if ( res == \" \" ) : NEW_LINE INDENT print ( \" No \u2581 recurring \u2581 sequence \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Recurring \u2581 sequence \u2581 is \" , res ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def has0 ( x ) : NEW_LINE",
        "explain": "Returns 1 if x has 0 , else 0"
    },
    {
        "py": "while ( x != 0 ) : NEW_LINE",
        "explain": "Traverse through all digits of x to check if it has 0."
    },
    {
        "py": "if ( x % 10 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT x = x // 10 NEW_LINE return 0 NEW_LINE",
        "explain": "If current digit is 0 , return true"
    },
    {
        "py": "def getCount ( n ) : NEW_LINE",
        "explain": "Returns count of numbers from 1 to n with 0 as digit"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Initialize count of numbers having 0 as digit ."
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = count + has0 ( i ) NEW_LINE DEDENT return count NEW_LINE",
        "explain": "Traverse through all numbers and for every number check if it has 0."
    },
    {
        "py": "n = 107 NEW_LINE print ( \" Count \u2581 of \u2581 numbers \u2581 from \u2581 1\" , \" \u2581 to \u2581 \" , n , \" \u2581 is \u2581 \" , getCount ( n ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE DEDENT",
        "explain": "Returns true if square root of n under modulo p exists"
    },
    {
        "py": "for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE",
        "explain": "One by one check all numbers from 2 to p - 1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE n = 2 NEW_LINE if ( squareRootExists ( n , p ) == True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def largestPower ( n , p ) : NEW_LINE",
        "explain": "Returns largest power of p that divides n !"
    },
    {
        "py": "x = 0 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "while n : NEW_LINE INDENT n /= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE",
        "explain": "Calculate x = n / p + n / ( p ^ 2 ) + n / ( p ^ 3 ) + ... ."
    },
    {
        "py": "n = 10 ; p = 3 NEW_LINE print ( \" The largest power of % d that divides % d ! is % d \" % ( p , n , largestPower ( n , p ) ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def factorial ( n ) : NEW_LINE",
        "explain": "Python 3 program to find factorial of given number"
    },
    {
        "py": "return 1 if ( n == 1 or n == 0 ) else n * factorial ( n - 1 ) NEW_LINE",
        "explain": "single line to find factorial"
    },
    {
        "py": "num = 5 NEW_LINE print ( \" Factorial \u2581 of \" , num , \" is \" , factorial ( num ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def getBit ( num , i ) : NEW_LINE",
        "explain": "Function to get the bit at the ith position"
    },
    {
        "py": "return ( ( num & ( 1 << i ) ) != 0 ) NEW_LINE",
        "explain": "Return true if the bit is set . Otherwise return false"
    },
    {
        "py": "def clearBit ( num , i ) : NEW_LINE",
        "explain": "Function to clear the ith bit of the given number N"
    },
    {
        "py": "mask = ~ ( 1 << i ) NEW_LINE",
        "explain": "Create the mask for the ith bit unset"
    },
    {
        "py": "return num & mask NEW_LINE",
        "explain": "Return the update value"
    },
    {
        "py": "def Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) : NEW_LINE",
        "explain": "Function to compute the AND sum for each element of an array"
    },
    {
        "py": "frequency = [ 0 ] * 32 NEW_LINE",
        "explain": "Declaring an array of size 32 for storing the count of each bit"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array arr2 [ ] and store the count of a bit in frequency array"
    },
    {
        "py": "bit_position = 0 NEW_LINE num = arr1 [ i ] NEW_LINE",
        "explain": "Current bit position"
    },
    {
        "py": "while ( num ) : NEW_LINE",
        "explain": "While num is greater than 0"
    },
    {
        "py": "if ( num & 1 ) : NEW_LINE",
        "explain": "Checks if ith bit is set or not"
    },
    {
        "py": "frequency [ bit_position ] += 1 NEW_LINE",
        "explain": "Increment the count of bit by one"
    },
    {
        "py": "bit_position += 1 NEW_LINE",
        "explain": "Increment the bit position by one"
    },
    {
        "py": "num >>= 1 NEW_LINE",
        "explain": "Right shift the num by one"
    },
    {
        "py": "for i in range ( M ) : NEW_LINE INDENT num = arr2 [ i ] NEW_LINE DEDENT",
        "explain": "Traverse in the arr2 [ ]"
    },
    {
        "py": "value_at_that_bit = 1 NEW_LINE",
        "explain": "Store the ith bit value"
    },
    {
        "py": "bitwise_AND_sum = 0 NEW_LINE",
        "explain": "Total required sum"
    },
    {
        "py": "for bit_position in range ( 32 ) : NEW_LINE",
        "explain": "Traverse in the range [ 0 , 31 ]"
    },
    {
        "py": "if ( num & 1 ) : NEW_LINE",
        "explain": "Checks if current bit is set"
    },
    {
        "py": "bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit NEW_LINE",
        "explain": "Increment the bitwise sum by frequency [ bit_position ] * value_at_that_bit"
    },
    {
        "py": "num >>= 1 NEW_LINE",
        "explain": "Right shift num by one"
    },
    {
        "py": "value_at_that_bit <<= 1 NEW_LINE",
        "explain": "Left shift vale_at_that_bit by one"
    },
    {
        "py": "print ( bitwise_AND_sum , end = \" \u2581 \" ) NEW_LINE return NEW_LINE",
        "explain": "Print sum obtained for ith number in arr1 [ ]"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr1 = [ 1 , 2 , 3 ] NEW_LINE",
        "explain": "Given arr1 [ ]"
    },
    {
        "py": "arr2 = [ 1 , 2 , 3 ] NEW_LINE",
        "explain": "Given arr2"
    },
    {
        "py": "N = len ( arr1 ) NEW_LINE",
        "explain": "Size of arr1 [ ]"
    },
    {
        "py": "M = len ( arr2 ) NEW_LINE",
        "explain": "Size of arr2 [ ]"
    },
    {
        "py": "Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def FlipBits ( n ) : NEW_LINE INDENT for bit in range ( 32 ) : NEW_LINE DEDENT",
        "explain": "Unsets the rightmost set bit of n and returns the result"
    },
    {
        "py": "if ( ( n >> bit ) & 1 ) : NEW_LINE",
        "explain": "Checking whether bit position is set or not"
    },
    {
        "py": "n = n ^ ( 1 << bit ) NEW_LINE break NEW_LINE print ( \" The \u2581 number \u2581 after \u2581 unsetting \u2581 the \" , end = \" \u2581 \" ) NEW_LINE print ( \" rightmost \u2581 set \u2581 bit \" , n ) NEW_LINE",
        "explain": "If bit position is found set , we flip this bit by xoring given number and number with bit position set"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 ; NEW_LINE FlipBits ( N ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def bitwiseAndOdd ( n ) : NEW_LINE",
        "explain": "Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]"
    },
    {
        "py": "result = 1 ; NEW_LINE",
        "explain": "Initialize result to 1"
    },
    {
        "py": "for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE",
        "explain": "Starting from 3 , bitwise AND all the odd integers less than or equal to n"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( bitwiseAndOdd ( n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def bitwiseAndOdd ( n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Function to return the bitwise AND of all the odd integers from the range [ 1 , n ]"
    },
    {
        "py": "n = 10 NEW_LINE print ( bitwiseAndOdd ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def reverseBits ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE DEDENT",
        "explain": "function to reverse bits of a number"
    },
    {
        "py": "while ( n > 0 ) : NEW_LINE",
        "explain": "traversing bits of ' n ' from the right"
    },
    {
        "py": "rev = rev << 1 NEW_LINE",
        "explain": "bitwise left shift ' rev ' by 1"
    },
    {
        "py": "' NEW_LINE INDENT if ( n & 1 == 1 ) : NEW_LINE INDENT rev = rev ^ 1 NEW_LINE DEDENT DEDENT",
        "explain": "if current bit is '1"
    },
    {
        "py": "n = n >> 1 NEW_LINE",
        "explain": "bitwise right shift ' n ' by 1"
    },
    {
        "py": "return rev NEW_LINE",
        "explain": "required number"
    },
    {
        "py": "n = 11 NEW_LINE print ( reverseBits ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countgroup ( a , n ) : NEW_LINE INDENT xs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xs = xs ^ a [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Return the count of number of ways to split array into two groups such that each group has equal XOR value ."
    },
    {
        "py": "if xs == 0 : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) - 1 NEW_LINE DEDENT return 0 NEW_LINE",
        "explain": "We can split only if XOR is 0. Since XOR of all is 0 , we can consider all subsets as one group ."
    },
    {
        "py": "a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countgroup ( a , n ) ) NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "def bitExtracted ( number , k , p ) : NEW_LINE INDENT return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; NEW_LINE DEDENT",
        "explain": "Function to extract k bits from p position and returns the extracted value as integer"
    },
    {
        "py": "number = 171 NEW_LINE k = 5 NEW_LINE p = 2 NEW_LINE print \" The \u2581 extracted \u2581 number \u2581 is \u2581 \" , bitExtracted ( number , k , p ) NEW_LINE",
        "explain": "number is from where ' k ' bits are extracted from p position"
    },
    {
        "py": "def findMax ( num ) : NEW_LINE INDENT num_copy = num NEW_LINE DEDENT",
        "explain": "Python 3 program to find maximum number by swapping extreme bits ."
    },
    {
        "py": "j = 4 * 8 - 1 ; NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE",
        "explain": "Traverse bits from both extremes"
    },
    {
        "py": "m = ( num_copy >> i ) & 1 NEW_LINE n = ( num_copy >> j ) & 1 NEW_LINE",
        "explain": "Obtaining i - th and j - th bits"
    },
    {
        "py": "if ( m > n ) : NEW_LINE INDENT x = ( 1 << i 1 << j ) NEW_LINE num = num ^ x NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE return num NEW_LINE",
        "explain": "Swapping the bits if lesser significant is greater than higher significant bit and accordingly modifying the number"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT num = 4 NEW_LINE print ( findMax ( num ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isAMultipleOf4 ( n ) : NEW_LINE",
        "explain": "function to check whether ' n ' is a multiple of 4 or not"
    },
    {
        "py": "if ( ( n & 3 ) == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT",
        "explain": "if true , then ' n ' is a multiple of 4"
    },
    {
        "py": "return \" No \" NEW_LINE",
        "explain": "else ' n ' is not a multiple of 4"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 16 NEW_LINE print ( isAMultipleOf4 ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def square ( n ) : NEW_LINE",
        "explain": "Simple solution to calculate square without using * and pow ( )"
    },
    {
        "py": "if ( n < 0 ) : NEW_LINE INDENT n = - n NEW_LINE DEDENT",
        "explain": "handle negative input"
    },
    {
        "py": "res = n NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT res += n NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Add n to res n - 1 times"
    },
    {
        "py": "for n in range ( 1 , 6 ) : NEW_LINE INDENT print ( \" n \u2581 = \" , n , end = \" , \u2581 \" ) NEW_LINE print ( \" n ^ 2 \u2581 = \" , square ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def PointInKSquares ( n , a , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return a [ n - k ] NEW_LINE DEDENT",
        "explain": "Python 3 implementation of the above approach"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT k = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE x = PointInKSquares ( n , a , k ) NEW_LINE print ( \" ( \" , x , \" , \" , x , \" ) \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def answer ( n ) : NEW_LINE",
        "explain": "function that calculates the answer"
    },
    {
        "py": "dp = [ 0 ] * 10 NEW_LINE",
        "explain": "dp [ j ] stores count of i digit stepping numbers ending with digit j ."
    },
    {
        "py": "prev = [ 0 ] * 10 NEW_LINE",
        "explain": "To store resu1lt of length i - 1 before updating dp [ j ] for length i ."
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT",
        "explain": "if n is 1 then answer will be 10."
    },
    {
        "py": "for j in range ( 0 , 10 ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT",
        "explain": "Initialize values for count of digits equal to 1."
    },
    {
        "py": "for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT prev [ j ] = dp [ j ] NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE DEDENT",
        "explain": "Compute values for count of digits more than 1."
    },
    {
        "py": "if ( j == 0 ) : NEW_LINE INDENT dp [ j ] = prev [ j + 1 ] NEW_LINE DEDENT",
        "explain": "If ending digit is 0"
    },
    {
        "py": "elif ( j == 9 ) : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] NEW_LINE DEDENT",
        "explain": "If ending digit is 9"
    },
    {
        "py": "else : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] NEW_LINE DEDENT",
        "explain": "For other digits ."
    },
    {
        "py": "sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ j ] NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "stores the final answer"
    },
    {
        "py": "n = 2 NEW_LINE print ( answer ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 100000 ; NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "catalan = [ 0 ] * MAX ; NEW_LINE",
        "explain": "To store first N Catalan numbers"
    },
    {
        "py": "def catalanDP ( n ) : NEW_LINE",
        "explain": "Function to find first n Catalan numbers"
    },
    {
        "py": "catalan [ 0 ] = catalan [ 1 ] = 1 ; NEW_LINE",
        "explain": "Initialize first two values in table"
    },
    {
        "py": "for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Fill entries in catalan [ ] using recursive formula"
    },
    {
        "py": "def CatalanSequence ( arr , n ) : NEW_LINE",
        "explain": "Function to return the minimum changes required"
    },
    {
        "py": "catalanDP ( n ) ; NEW_LINE s = set ( ) ; NEW_LINE",
        "explain": "Find first n Catalan Numbers"
    },
    {
        "py": "a = 1 ; b = 1 ; NEW_LINE",
        "explain": "a and b are first two Catalan Sequence numbers"
    },
    {
        "py": "s . add ( a ) ; NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT s . add ( b ) ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT s . add ( catalan [ i ] ) ; NEW_LINE DEDENT temp = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Insert first n catalan elements to set"
    },
    {
        "py": "if arr [ i ] in s : NEW_LINE INDENT temp . add ( arr [ i ] ) NEW_LINE DEDENT s = s - temp ; NEW_LINE",
        "explain": "If catalan element is present in the array then remove it from set"
    },
    {
        "py": "return len ( s ) ; NEW_LINE",
        "explain": "Return the remaining number of elements in the set"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 41 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( CatalanSequence ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def odd_indices ( arr ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT",
        "explain": "Function to print the sum of all composite numbers in the array"
    },
    {
        "py": "for k in range ( 0 , len ( arr ) , 2 ) : NEW_LINE INDENT check = composite ( arr [ k ] ) NEW_LINE DEDENT",
        "explain": "Iterate for odd indices in the array"
    },
    {
        "py": "sum += arr [ k ] if check == 1 else 0 NEW_LINE",
        "explain": "Check if the number is composite then add it to sum"
    },
    {
        "py": "print ( sum ) NEW_LINE",
        "explain": "return the sum"
    },
    {
        "py": "def composite ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE c = 0 NEW_LINE DEDENT",
        "explain": "Function to check for composite numbers"
    },
    {
        "py": "for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % j == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Check if the factors are greater than 2"
    },
    {
        "py": "if ( c >= 3 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT return flag NEW_LINE",
        "explain": "Check if the number is composite or not"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 13 , 5 , 8 , 16 , 25 ] NEW_LINE odd_indices ( arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python 3 program to find number of points lie inside or on the circumference of circle for Q queries ."
    },
    {
        "py": "def preprocess ( p , x , y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT p . sort ( ) NEW_LINE DEDENT",
        "explain": "Computing the x ^ 2 + y ^ 2 for each given points and sorting them ."
    },
    {
        "py": "def query ( p , n , rad ) : NEW_LINE INDENT start = 0 NEW_LINE end = n - 1 NEW_LINE while ( ( end - start ) > 1 ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE tp = math . sqrt ( p [ mid ] ) NEW_LINE if ( tp > ( rad * 1.0 ) ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT tp1 = math . sqrt ( p [ start ] ) NEW_LINE tp2 = math . sqrt ( p [ end ] ) NEW_LINE if ( tp1 > ( rad * 1.0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( tp2 <= ( rad * 1.0 ) ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return start + 1 NEW_LINE DEDENT DEDENT",
        "explain": "Return count of points lie inside or on circumference of circle using binary search on p [ 0. . n - 1 ]"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = [ 1 , 2 , 3 , - 1 , 4 ] NEW_LINE y = [ 1 , 2 , 3 , - 1 , 4 ] NEW_LINE n = len ( x ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "p = [ 0 ] * n NEW_LINE preprocess ( p , x , y , n ) NEW_LINE",
        "explain": "Compute distances of all points and keep the distances sorted so that query can work in O ( logn ) using Binary Search ."
    },
    {
        "py": "print ( query ( p , n , 3 ) ) NEW_LINE",
        "explain": "Print number of points in a circle of radius 3."
    },
    {
        "py": "print ( query ( p , n , 32 ) ) NEW_LINE",
        "explain": "Print number of points in a circle of radius 32."
    },
    {
        "py": "def count ( N ) : NEW_LINE",
        "explain": "python program for above approach"
    },
    {
        "py": "odd_indices = N // 2 NEW_LINE",
        "explain": "No of odd indices in N - digit number"
    },
    {
        "py": "even_indices = N // 2 + N % 2 NEW_LINE",
        "explain": "No of even indices in N - digit number"
    },
    {
        "py": "arrange_odd = 4 ** odd_indices NEW_LINE",
        "explain": "No of ways of arranging prime number digits in odd indices"
    },
    {
        "py": "arrange_even = 5 ** even_indices NEW_LINE",
        "explain": "No of ways of arranging odd number digits in even indices"
    },
    {
        "py": "return arrange_odd * arrange_even NEW_LINE",
        "explain": "returning the total number of ways"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( count ( N ) ) NEW_LINE",
        "explain": "calling the function"
    },
    {
        "py": "def isSpiralSorted ( arr , n ) : NEW_LINE",
        "explain": "Function to check if the array is spirally sorted or not"
    },
    {
        "py": "start = 0 ; NEW_LINE",
        "explain": "Stores start index of the array"
    },
    {
        "py": "end = n - 1 ; NEW_LINE while ( start < end ) : NEW_LINE",
        "explain": "Stores end index of an array"
    },
    {
        "py": "if ( arr [ start ] > arr [ end ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT",
        "explain": "If arr [ start ] greater than arr [ end ]"
    },
    {
        "py": "start += 1 ; NEW_LINE",
        "explain": "Update start"
    },
    {
        "py": "if ( arr [ end ] > arr [ start ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT",
        "explain": "If arr [ end ] greater than arr [ start ]"
    },
    {
        "py": "end -= 1 ; NEW_LINE return True ; NEW_LINE",
        "explain": "Update end"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 10 , 14 , 20 , 18 , 12 , 5 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "if ( isSpiralSorted ( arr , N ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "def findWordsSameRow ( arr ) : NEW_LINE",
        "explain": "Function to print all strings that can be typed using keys of a single row in a QWERTY Keyboard"
    },
    {
        "py": "mp = { ' q ' : 1 , ' w ' : 1 , ' e ' : 1 , ' r ' : 1 , ' t ' : 1 , ' y ' : 1 , ' u ' : 1 , ' o ' : 1 , ' p ' : 1 , ' i ' : 1 , ' a ' : 2 , ' s ' : 2 , ' d ' : 2 , ' f ' : 2 , ' g ' : 2 , ' h ' : 2 , ' j ' : 2 , ' k ' : 2 , ' l ' : 2 , ' z ' : 3 , ' x ' : 3 , ' c ' : 3 , ' v ' : 3 , ' b ' : 3 , ' n ' : 3 , ' m ' : 3 } NEW_LINE",
        "explain": "Stores row number of all possible character of the strings"
    },
    {
        "py": "for word in arr : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( len ( word ) != 0 ) : NEW_LINE",
        "explain": "If current string is not an empty string"
    },
    {
        "py": "flag = True NEW_LINE",
        "explain": "Sets true / false if a string can be typed using keys of a single row or not"
    },
    {
        "py": "rowNum = mp [ word [ 0 ] . lower ( ) ] NEW_LINE",
        "explain": "Stores row number of the first character of current string"
    },
    {
        "py": "M = len ( word ) NEW_LINE",
        "explain": "Stores length of word"
    },
    {
        "py": "for i in range ( 1 , M ) : NEW_LINE",
        "explain": "Traverse current string"
    },
    {
        "py": "if ( mp [ word [ i ] . lower ( ) ] != rowNum ) : NEW_LINE",
        "explain": "If current character can 't be  typed using keys of rowNum only"
    },
    {
        "py": "flag = False NEW_LINE break NEW_LINE",
        "explain": "Update flag"
    },
    {
        "py": "if ( flag ) : NEW_LINE",
        "explain": "If current string can be typed using keys from rowNum only"
    },
    {
        "py": "print ( word , end = ' \u2581 ' ) NEW_LINE",
        "explain": "Print the string"
    },
    {
        "py": "words = [ \" Yeti \" , \" Had \" , \" GFG \" , \" comment \" ] NEW_LINE findWordsSameRow ( words ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "maxN = 2002 NEW_LINE",
        "explain": "Python3 program of the above approach"
    },
    {
        "py": "def countSubsequece ( a , n ) : NEW_LINE",
        "explain": "Function to find the count of the subsequence of given type"
    },
    {
        "py": "answer = 0 NEW_LINE",
        "explain": "Stores the count of quadruples"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Generate all possible combinations of quadruples"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 3 , 2 , 1 , 3 , 2 ] NEW_LINE print ( countSubsequece ( a , 7 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def minDistChar ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to find the character repeats with minimum distance"
    },
    {
        "py": "first = [ ] NEW_LINE last = [ ] NEW_LINE",
        "explain": "Stores the first and last index"
    },
    {
        "py": "for i in range ( 26 ) : NEW_LINE INDENT first . append ( - 1 ) NEW_LINE last . append ( - 1 ) NEW_LINE DEDENT",
        "explain": "Intialize with - 1"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Get the values of last and first occurence"
    },
    {
        "py": "if ( first [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT first [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT",
        "explain": "Update the first index"
    },
    {
        "py": "last [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE",
        "explain": "Update the last index"
    },
    {
        "py": "min = sys . maxsize NEW_LINE ans = '1' NEW_LINE",
        "explain": "Intialize the min"
    },
    {
        "py": "for i in range ( 26 ) : NEW_LINE",
        "explain": "Get the minimum"
    },
    {
        "py": "if ( last [ i ] == first [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Values must not be same"
    },
    {
        "py": "if ( min > last [ i ] - first [ i ] ) : NEW_LINE INDENT min = last [ i ] - first [ i ] NEW_LINE ans = i + ord ( ' a ' ) NEW_LINE DEDENT",
        "explain": "Update the minimum distance"
    },
    {
        "py": "return chr ( ans ) NEW_LINE",
        "explain": "return ans"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( minDistChar ( str ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "n = 3 NEW_LINE",
        "explain": "Python 3 implementation of the approach"
    },
    {
        "py": "def minSteps ( arr ) : NEW_LINE",
        "explain": "Function to return the minimum steps required to reach the end of the matrix"
    },
    {
        "py": "v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE",
        "explain": "Array to determine whether a cell has been visited before"
    },
    {
        "py": "q = [ [ 0 , 0 ] ] NEW_LINE",
        "explain": "Queue for bfs"
    },
    {
        "py": "depth = 0 NEW_LINE",
        "explain": "To store the depth of search"
    },
    {
        "py": "while ( len ( q ) != 0 ) : NEW_LINE",
        "explain": "BFS algorithm"
    },
    {
        "py": "x = len ( q ) NEW_LINE while ( x > 0 ) : NEW_LINE",
        "explain": "Current queue size"
    },
    {
        "py": "y = q [ 0 ] NEW_LINE",
        "explain": "Top - most element of queue"
    },
    {
        "py": "i = y [ 0 ] NEW_LINE j = y [ 1 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE x -= 1 NEW_LINE",
        "explain": "To store index of cell for simplicity"
    },
    {
        "py": "if ( v [ i ] [ j ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return depth NEW_LINE DEDENT",
        "explain": "If we reach ( n - 1 , n - 1 )"
    },
    {
        "py": "v [ i ] [ j ] = 1 NEW_LINE",
        "explain": "Marking the cell visited"
    },
    {
        "py": "if ( i + arr [ i ] [ j ] < n ) : NEW_LINE INDENT q . append ( [ i + arr [ i ] [ j ] , j ] ) NEW_LINE DEDENT if ( j + arr [ i ] [ j ] < n ) : NEW_LINE INDENT q . append ( [ i , j + arr [ i ] [ j ] ] ) NEW_LINE DEDENT depth += 1 NEW_LINE return - 1 NEW_LINE",
        "explain": "Pushing the adjacent cells in the queue that can be visited from the current cell"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( minSteps ( arr ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "A Python 3 program to find largest gap between two elements in an array ."
    },
    {
        "py": "def solve ( a , n ) : NEW_LINE INDENT max1 = - sys . maxsize - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT for j in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( abs ( a [ i ] - a [ j ] ) > max1 ) : NEW_LINE INDENT max1 = abs ( a [ i ] - a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return max1 NEW_LINE DEDENT",
        "explain": "function to solve the given problem"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , - 4 , - 10 , 22 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Largest \u2581 gap \u2581 is \u2581 : \" , solve ( arr , size ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def solve ( a , n ) : NEW_LINE INDENT min1 = a [ 0 ] NEW_LINE max1 = a [ 0 ] NEW_LINE DEDENT",
        "explain": "function to solve the given problem"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max1 ) : NEW_LINE INDENT max1 = a [ i ] NEW_LINE DEDENT if ( a [ i ] < min1 ) : NEW_LINE INDENT min1 = a [ i ] NEW_LINE DEDENT DEDENT return abs ( min1 - max1 ) NEW_LINE",
        "explain": "finding maximum and minimum of an array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , 4 , - 10 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Largest \u2581 gap \u2581 is \u2581 : \u2581 \" , solve ( arr , size ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def replaceOriginal ( s , n ) : NEW_LINE",
        "explain": "Function for replacing the string"
    },
    {
        "py": "r = [ ' \u2581 ' ] * n NEW_LINE",
        "explain": "initialize a string of length n"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse through all characters of string"
    },
    {
        "py": "r [ i ] = s [ n - 1 - i ] NEW_LINE",
        "explain": "assign the value to string r from last index of string s"
    },
    {
        "py": "if ( s [ i ] != ' a ' and s [ i ] != ' e ' and s [ i ] != ' i ' and s [ i ] != ' o ' and s [ i ] != ' u ' ) : NEW_LINE INDENT print ( r [ i ] , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "if s [ i ] is a consonant then print r [ i ]"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE n = len ( s ) NEW_LINE replaceOriginal ( s , n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def sameStrings ( str1 , str2 ) : NEW_LINE INDENT N = len ( str1 ) NEW_LINE M = len ( str2 ) NEW_LINE DEDENT",
        "explain": "Function to find if given strings are same or not"
    },
    {
        "py": "if ( N != M ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Base Condition"
    },
    {
        "py": "a , b = [ 0 ] * 256 , [ 0 ] * 256 NEW_LINE",
        "explain": "Stores frequency of characters of the str1 and str2"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT a [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE b [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Traverse strings str1 & str2 and store frequencies in a [ ] and b [ ]"
    },
    {
        "py": "i = 0 NEW_LINE while ( i < 256 ) : NEW_LINE INDENT if ( ( a [ i ] == 0 and b [ i ] == 0 ) or ( a [ i ] != 0 and b [ i ] != 0 ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Check if both strings have same characters or not"
    },
    {
        "py": "else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If a character is present in one and is not in another string , return false"
    },
    {
        "py": "a = sorted ( a ) NEW_LINE b = sorted ( b ) NEW_LINE",
        "explain": "Sort the array a [ ] and b [ ]"
    },
    {
        "py": "for i in range ( 256 ) : NEW_LINE",
        "explain": "Check arrays a and b contain the same frequency or not"
    },
    {
        "py": "if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If the frequencies are not the same after sorting"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "At this point , str1 can be converted to str2"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 , S2 = \" cabbba \" , \" abbccc \" NEW_LINE if ( sameStrings ( S1 , S2 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def solution ( A , B , C ) : NEW_LINE INDENT arr = [ 0 ] * 3 NEW_LINE DEDENT",
        "explain": "Function to find the minimum number operations"
    },
    {
        "py": "arr [ 0 ] = A NEW_LINE arr [ 1 ] = B NEW_LINE arr [ 2 ] = C NEW_LINE",
        "explain": "Insert the three numbers in array"
    },
    {
        "py": "arr = sorted ( arr ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) : NEW_LINE INDENT return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) // 2 ) NEW_LINE DEDENT",
        "explain": "Case 2"
    },
    {
        "py": "else : NEW_LINE INDENT return ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT",
        "explain": "Case 1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = 8 NEW_LINE B = 1 NEW_LINE C = 5 NEW_LINE",
        "explain": "Given A , B , C"
    },
    {
        "py": "print ( solution ( A , B , C ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def search ( arr , l , h , key ) : NEW_LINE INDENT if ( l > h ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT mid = ( l + h ) // 2 ; NEW_LINE if ( arr [ mid ] == key ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the index of the key in arr [ l . . h ] if the key is present otherwise return - 1"
    },
    {
        "py": "if ( ( arr [ l ] == arr [ mid ] ) and ( arr [ h ] == arr [ mid ] ) ) : NEW_LINE INDENT l += 1 ; NEW_LINE h -= 1 ; NEW_LINE return search ( arr , l , h , key ) NEW_LINE DEDENT",
        "explain": "The tricky case , just update left and right"
    },
    {
        "py": "if ( arr [ l ] <= arr [ mid ] ) : NEW_LINE",
        "explain": "If arr [ l ... mid ] is sorted"
    },
    {
        "py": "if ( key >= arr [ l ] and key <= arr [ mid ] ) : NEW_LINE INDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE DEDENT",
        "explain": "As this subarray is sorted , we can quickly check if key lies in any of the halves"
    },
    {
        "py": "return search ( arr , mid + 1 , h , key ) ; NEW_LINE",
        "explain": "If key does not lie in the first half subarray then divide the other half into two subarrays such that we can quickly check if key lies in the other half"
    },
    {
        "py": "if ( key >= arr [ mid ] and key <= arr [ h ] ) : NEW_LINE INDENT return search ( arr , mid + 1 , h , key ) ; NEW_LINE DEDENT return search ( arr , l , mid - 1 , key ) ; NEW_LINE",
        "explain": "If arr [ l . . mid ] first subarray is not sorted then arr [ mid ... h ] must be sorted subarray"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 3 , 1 , 2 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE key = 3 ; NEW_LINE print ( search ( arr , 0 , n - 1 , key ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def getSortedString ( s , n ) : NEW_LINE",
        "explain": "Function to return the sorted string"
    },
    {
        "py": "v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] >= ' a ' and s [ i ] <= ' z ' ) : NEW_LINE INDENT v1 . append ( s [ i ] ) NEW_LINE DEDENT if ( s [ i ] >= ' A ' and s [ i ] <= ' Z ' ) : NEW_LINE INDENT v2 . append ( s [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Vectors to store the lowercase and uppercase characters"
    },
    {
        "py": "v1 = sorted ( v1 ) NEW_LINE v2 = sorted ( v2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE for k in range ( n ) : NEW_LINE",
        "explain": "Sort both the vectors"
    },
    {
        "py": "if ( s [ k ] >= ' a ' and s [ k ] <= ' z ' ) : NEW_LINE INDENT s [ k ] = v1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "If current character is lowercase then pick the lowercase character from the sorted list"
    },
    {
        "py": "elif ( s [ k ] >= ' A ' and s [ k ] <= ' Z ' ) : NEW_LINE INDENT s [ k ] = v2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "Else pick the uppercase character"
    },
    {
        "py": "return \" \" . join ( s ) NEW_LINE",
        "explain": "Return the sorted string"
    },
    {
        "py": "s = \" gEeksfOrgEEkS \" NEW_LINE ss = [ i for i in s ] NEW_LINE n = len ( ss ) NEW_LINE print ( getSortedString ( ss , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def check ( s ) : NEW_LINE",
        "explain": "Function to check if the condition holds"
    },
    {
        "py": "l = len ( s ) NEW_LINE",
        "explain": "Get the length of the string"
    },
    {
        "py": "s = ' ' . join ( sorted ( s ) ) NEW_LINE",
        "explain": "sort the given string"
    },
    {
        "py": "for i in range ( 1 , l ) : NEW_LINE",
        "explain": "Iterate for every index and check for the condition"
    },
    {
        "py": "if ord ( s [ i ] ) - ord ( s [ i - 1 ] ) != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "If are not consecutive"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "string = \" dcef \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "1 st example"
    },
    {
        "py": "string = \" xyza \" NEW_LINE if check ( string ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "2 nd example"
    },
    {
        "py": "def minElements ( arr , n ) : NEW_LINE",
        "explain": "function to find minimum elements needed ."
    },
    {
        "py": "halfSum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT halfSum = halfSum + arr [ i ] NEW_LINE DEDENT halfSum = int ( halfSum / 2 ) NEW_LINE",
        "explain": "calculating HALF of array sum"
    },
    {
        "py": "arr . sort ( reverse = True ) NEW_LINE res = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE res += 1 NEW_LINE DEDENT",
        "explain": "sort the array in descending order ."
    },
    {
        "py": "if curr_sum > halfSum : NEW_LINE INDENT return res NEW_LINE DEDENT return res NEW_LINE",
        "explain": "current sum greater than sum"
    },
    {
        "py": "arr = [ 3 , 1 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minElements ( arr , n ) ) NEW_LINE",
        "explain": "driver code"
    },
    {
        "py": "def arrayElementEqual ( arr , N ) : NEW_LINE",
        "explain": "Function to check if its possible to make all array elements equal or not"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Stores the sum of the array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( sum % N == 0 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT",
        "explain": "If sum is divisible by N"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Otherwise , not possible to make all array elements equal"
    },
    {
        "py": "arr = [ 1 , 5 , 6 , 4 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE arrayElementEqual ( arr , N ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "def findMaxValByRearrArr ( arr , N ) : NEW_LINE",
        "explain": "Function to find the maximum sum of GCD ( arr [ i ] , i ) by rearranging the array"
    },
    {
        "py": "res = 0 ; NEW_LINE",
        "explain": "Stores maximum sum of GCD ( arr [ i ] , i ) by rearranging the array elements"
    },
    {
        "py": "res = ( N * ( N + 1 ) ) // 2 ; NEW_LINE return res ; NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( findMaxValByRearrArr ( arr , N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MaximumSides ( n ) : NEW_LINE",
        "explain": "Function to find the maximum sided polygon that can be inscribed"
    },
    {
        "py": "if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if n % 2 == 0 : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT return - 1 NEW_LINE",
        "explain": "Return n / 2 if n is even Otherwise , return - 1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 8 NEW_LINE",
        "explain": "Given N"
    },
    {
        "py": "print ( MaximumSides ( N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def pairProductMean ( arr , N ) : NEW_LINE",
        "explain": "Function to find the mean of pair product array of arr [ ]"
    },
    {
        "py": "suffixSumArray = [ 0 ] * N NEW_LINE suffixSumArray [ N - 1 ] = arr [ N - 1 ] NEW_LINE",
        "explain": "Initializing suffix sum array"
    },
    {
        "py": "for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] NEW_LINE DEDENT",
        "explain": "Build suffix sum array"
    },
    {
        "py": "length = ( N * ( N - 1 ) ) // 2 NEW_LINE",
        "explain": "Size of pairProductArray"
    },
    {
        "py": "res = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT res += arr [ i ] * suffixSumArray [ i + 1 ] NEW_LINE DEDENT",
        "explain": "Stores sum of pairProductArray"
    },
    {
        "py": "mean = 0 NEW_LINE",
        "explain": "Store the mean"
    },
    {
        "py": "if ( length != 0 ) : NEW_LINE INDENT mean = res / length NEW_LINE DEDENT else : NEW_LINE INDENT mean = 0 NEW_LINE DEDENT",
        "explain": "Find mean of pairProductArray"
    },
    {
        "py": "return mean NEW_LINE",
        "explain": "Return the resultant mean"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 1 , 2 , 4 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "print ( round ( pairProductMean ( arr , N ) , 2 ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def ncr ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT",
        "explain": "Function to return the value of Binomial Coefficient C ( n , k )"
    },
    {
        "py": "if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT",
        "explain": "Since C ( n , k ) = C ( n , n - k )"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- -- * 1 ]"
    },
    {
        "py": "def countPath ( N , M , K ) : NEW_LINE INDENT answer = 0 NEW_LINE if ( K >= 2 ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT elif ( K == 0 ) : NEW_LINE INDENT answer = ncr ( N + M - 2 , N - 1 ) NEW_LINE DEDENT else : NEW_LINE DEDENT",
        "explain": "Function to find the minimum count of paths from top left to bottom right by placing K 1 s in the matrix"
    },
    {
        "py": "answer = ncr ( N + M - 2 , N - 1 ) NEW_LINE",
        "explain": "Count of ways without 1 s"
    },
    {
        "py": "X = ( N - 1 ) // 2 + ( M - 1 ) // 2 NEW_LINE Y = ( N - 1 ) // 2 NEW_LINE midCount = ncr ( X , Y ) NEW_LINE",
        "explain": "Count of paths from starting poto mid point"
    },
    {
        "py": "X = ( ( N - 1 ) - ( N - 1 ) // 2 ) + NEW_LINE INDENT ( ( M - 1 ) - ( M - 1 ) // 2 ) NEW_LINE DEDENT Y = ( ( N - 1 ) - ( N - 1 ) // 2 ) NEW_LINE midCount *= ncr ( X , Y ) NEW_LINE answer -= midCount NEW_LINE return answer NEW_LINE",
        "explain": "Count of paths from mid poto end point"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 1 NEW_LINE print ( countPath ( N , M , K ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def find_max ( v , n ) : NEW_LINE",
        "explain": "Function to find maximum count of operations"
    },
    {
        "py": "count = 0 NEW_LINE if ( n >= 2 ) : NEW_LINE INDENT count = 2 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT",
        "explain": "Initialize count by 0"
    },
    {
        "py": "for i in range ( 1 , n - 1 ) : NEW_LINE",
        "explain": "Iterate over remaining pairs"
    },
    {
        "py": "if ( v [ i - 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Check if first operation is applicable"
    },
    {
        "py": "elif ( v [ i + 1 ] [ 0 ] > ( v [ i ] [ 0 ] + v [ i ] [ 1 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE v [ i ] [ 0 ] = v [ i ] [ 0 ] + v [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Check if 2 nd operation is applicable"
    },
    {
        "py": "else : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the count of operations"
    },
    {
        "py": "n = 3 NEW_LINE v = [ ] NEW_LINE v . append ( [ 10 , 20 ] ) NEW_LINE v . append ( [ 15 , 10 ] ) NEW_LINE v . append ( [ 20 , 16 ] ) NEW_LINE print ( find_max ( v , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def numberofsubstrings ( str , k , charArray ) : NEW_LINE INDENT N = len ( str ) NEW_LINE DEDENT",
        "explain": "Function to find the number of substrings that can be formed using given characters"
    },
    {
        "py": "available = [ 0 ] * 26 NEW_LINE",
        "explain": "Boolean array for storing the available characters"
    },
    {
        "py": "for i in range ( 0 , k ) : NEW_LINE INDENT available [ ord ( charArray [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT",
        "explain": "Mark indices of all available characters as 1"
    },
    {
        "py": "lastPos = - 1 NEW_LINE",
        "explain": "Initialize lastPos as - 1"
    },
    {
        "py": "ans = ( N * ( N + 1 ) ) / 2 NEW_LINE",
        "explain": "Initialize ans with the total no of possible substrings"
    },
    {
        "py": "for i in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse the string from left to right"
    },
    {
        "py": "if ( available [ ord ( str [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE",
        "explain": "If the current character is not present in B"
    },
    {
        "py": "ans -= ( ( i - lastPos ) * ( N - i ) ) NEW_LINE",
        "explain": "Subtract the total possible substrings"
    },
    {
        "py": "lastPos = i NEW_LINE",
        "explain": "Update the value of lastpos to current index"
    },
    {
        "py": "print ( int ( ans ) ) NEW_LINE",
        "explain": "Print the final answer"
    },
    {
        "py": "str = \" abcb \" NEW_LINE k = 2 NEW_LINE",
        "explain": "Given String"
    },
    {
        "py": "charArray = [ ' a ' , ' b ' ] NEW_LINE",
        "explain": "Given character array"
    },
    {
        "py": "numberofsubstrings ( str , k , charArray ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def minCost ( N , P , Q ) : NEW_LINE",
        "explain": "Function to return minimum cost to reach destination"
    },
    {
        "py": "cost = 0 NEW_LINE",
        "explain": "Initialize cost to 0"
    },
    {
        "py": "while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT cost += P NEW_LINE N -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = N // 2 ; NEW_LINE DEDENT DEDENT",
        "explain": "going backwards until we reach initial position"
    },
    {
        "py": "if ( temp * P > Q ) : NEW_LINE INDENT cost += Q NEW_LINE DEDENT",
        "explain": "if 2 * X jump is better than X + 1"
    },
    {
        "py": "else : NEW_LINE INDENT cost += P * temp NEW_LINE DEDENT N //= 2 NEW_LINE return cost NEW_LINE",
        "explain": "if X + 1 jump is better"
    },
    {
        "py": "N = 9 NEW_LINE P = 5 NEW_LINE Q = 1 NEW_LINE print ( minCost ( N , P , Q ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def numberOfWays ( n , k ) : NEW_LINE",
        "explain": "Function to find number of ways to reach from node 1 to 1 again , after moving exactly K edges"
    },
    {
        "py": "dp = [ 0 for i in range ( 1000 ) ] NEW_LINE",
        "explain": "Initialize a dp [ ] array , where dp [ i ] stores number of ways to reach at a i node"
    },
    {
        "py": "dp [ 0 ] = 1 NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "for i in range ( 1 , k + 1 , 1 ) : NEW_LINE",
        "explain": "Iterate for the number of edges moved"
    },
    {
        "py": "numWays = 0 NEW_LINE",
        "explain": "Sum will store number of ways to reach all the nodes"
    },
    {
        "py": "for j in range ( n ) : NEW_LINE INDENT numWays += dp [ j ] NEW_LINE DEDENT",
        "explain": "Iterate for every possible state for the current step"
    },
    {
        "py": "for j in range ( n ) : NEW_LINE INDENT dp [ j ] = numWays - dp [ j ] NEW_LINE DEDENT",
        "explain": "Update the value of the dp array after travelling each edge"
    },
    {
        "py": "print ( dp [ 0 ] ) NEW_LINE",
        "explain": "Print dp [ 0 ] as the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 5 NEW_LINE K = 3 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "numberOfWays ( N , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findMinCost ( arr , X , n , i = 0 ) : NEW_LINE",
        "explain": "Function to calculate minimum cost of buying least X chocolates"
    },
    {
        "py": "if ( X <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 10 ** 8 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) NEW_LINE if ( inc != 10 ** 8 ) : NEW_LINE INDENT inc += arr [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Include the i - th box"
    },
    {
        "py": "exc = findMinCost ( arr , X , n , i + 1 ) NEW_LINE",
        "explain": "Exclude the i - th box"
    },
    {
        "py": "return min ( inc , exc ) NEW_LINE",
        "explain": "Return the minimum of the above two cases"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ [ 4 , 3 ] , [ 3 , 2 ] , [ 2 , 4 ] , [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE X = 7 NEW_LINE",
        "explain": "Given array and value of X"
    },
    {
        "py": "n = len ( arr ) NEW_LINE ans = findMinCost ( arr , X , n ) NEW_LINE",
        "explain": "Store the size of the array"
    },
    {
        "py": "if ( ans != 10 ** 8 ) : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT",
        "explain": "Print answer"
    },
    {
        "py": "def find ( N , sum ) : NEW_LINE",
        "explain": "Function to calculate the probability for the given sum to be equal to sum in N throws of dice"
    },
    {
        "py": "if ( sum > 6 * N or sum < N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( sum >= 1 and sum <= 6 ) : NEW_LINE INDENT return 1.0 / 6 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT s = 0 NEW_LINE for i in range ( 1 , 7 ) : NEW_LINE INDENT s = s + find ( N - 1 , sum - i ) / 6 NEW_LINE DEDENT return s NEW_LINE",
        "explain": "Base cases"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE a = 13 NEW_LINE b = 17 NEW_LINE probability = 0.0 NEW_LINE for sum in range ( a , b + 1 ) : NEW_LINE INDENT probability = probability + find ( N , sum ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( round ( probability , 6 ) ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "def minDays ( n ) : NEW_LINE",
        "explain": "Function to find the minimum number to steps to reduce N to 0"
    },
    {
        "py": "if n < 1 : NEW_LINE INDENT return n NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "cnt = 1 + min ( n % 2 + minDays ( n // 2 ) , n % 3 + minDays ( n // 3 ) ) NEW_LINE",
        "explain": "Recursive Call to count the minimum steps needed"
    },
    {
        "py": "return cnt NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "N = 6 NEW_LINE",
        "explain": "Given Number N"
    },
    {
        "py": "print ( str ( minDays ( N ) ) ) NEW_LINE",
        "explain": "Function Call"
    }
]