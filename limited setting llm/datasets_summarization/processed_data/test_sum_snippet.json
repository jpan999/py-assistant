[
    {
        "py": "def minSum ( A , N ) : NEW_LINE",
        "explain": "Function to find minimum sum after deletion"
    },
    {
        "py": "mp = { } NEW_LINE sum = 0 NEW_LINE",
        "explain": "Stores frequency of array elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "sum += A [ i ] NEW_LINE",
        "explain": "Calculate sum"
    },
    {
        "py": "if A [ i ] in mp : NEW_LINE INDENT mp [ A [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] ] = 1 NEW_LINE DEDENT",
        "explain": "Update frequency of the current element"
    },
    {
        "py": "minSum = float ( ' inf ' ) NEW_LINE",
        "explain": "Stores the minimum sum required"
    },
    {
        "py": "for it in mp : NEW_LINE",
        "explain": "Traverse map"
    },
    {
        "py": "minSum = min ( minSum , sum - ( it * mp [ it ] ) ) NEW_LINE",
        "explain": "Find the minimum sum obtained"
    },
    {
        "py": "return minSum NEW_LINE",
        "explain": "Return minimum sum"
    },
    {
        "py": "arr = [ 4 , 5 , 6 , 6 ] NEW_LINE",
        "explain": "Input array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE print ( minSum ( arr , N ) ) NEW_LINE",
        "explain": "Size of array"
    },
    {
        "py": "def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE DEDENT",
        "explain": "Function to calculate maximum difference between adjacent elements excluding every array element once"
    },
    {
        "py": "for i in range ( 1 , N - 1 ) : NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "maxi = - 1 * float ( ' inf ' ) NEW_LINE",
        "explain": "Stores the maximum diff"
    },
    {
        "py": "for j in range ( 1 , N ) : NEW_LINE",
        "explain": "Check for maximum adjacent element"
    },
    {
        "py": "if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Exclude current element"
    },
    {
        "py": "maxi = max ( maxi , abs ( arr [ j ] - prev ) ) NEW_LINE",
        "explain": "pdate maximum difference"
    },
    {
        "py": "prev = arr [ j ] NEW_LINE",
        "explain": "Update previous value"
    },
    {
        "py": "res . append ( maxi ) NEW_LINE",
        "explain": "Append the result into a vector"
    },
    {
        "py": "for x in res : NEW_LINE INDENT print ( x , end = ' \u2581 ' ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findSize ( N ) : NEW_LINE",
        "explain": "Function to find the size of the array if the array initially contains a single element"
    },
    {
        "py": "if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT Size = 2 * findSize ( N // 2 ) + 1 NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "return Size NEW_LINE",
        "explain": "P / 2 -> findSize ( N 2 ) P % 2 -> 1 P / 2 -> findSize ( N / 2 )"
    },
    {
        "py": "def CountOnes ( N , L , R ) : NEW_LINE INDENT if ( L > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the count of 1 s in the range [ L , R ]"
    },
    {
        "py": "if ( N <= 1 ) : NEW_LINE INDENT return N NEW_LINE DEDENT ret = 0 NEW_LINE M = N // 2 NEW_LINE Siz_M = findSize ( M ) NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "if ( L <= Siz_M ) : NEW_LINE",
        "explain": "PART 1 -> N / 2 [ 1 , Siz_M ]"
    },
    {
        "py": "ret += CountOnes ( N // 2 , L , min ( Siz_M , R ) ) NEW_LINE",
        "explain": "Update the right end point of the range to min ( Siz_M , R )"
    },
    {
        "py": "if ( L <= Siz_M + 1 and Siz_M + 1 <= R ) : NEW_LINE INDENT ret += N % 2 NEW_LINE DEDENT",
        "explain": "PART 2 -> N % 2 [ SizM + 1 , Siz_M + 1 ]"
    },
    {
        "py": "if ( Siz_M + 1 < R ) : NEW_LINE INDENT ret += CountOnes ( N // 2 , max ( 1 , L - Siz_M - 1 ) , R - Siz_M - 1 ) NEW_LINE DEDENT return ret NEW_LINE",
        "explain": "PART 3 -> N / 2 [ SizM + 2 , 2 * Siz_M - 1 ] Same as PART 1 Property of Symmetricity Shift the coordinates according to PART 1 Subtract ( Siz_M + 1 ) from both L , R"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 7 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE",
        "explain": "Input"
    },
    {
        "py": "print ( CountOnes ( N , L , R ) ) NEW_LINE",
        "explain": "Counts the number of 1 's in  the range [L, R]"
    },
    {
        "py": "def prime ( n ) : NEW_LINE",
        "explain": "Function to check if number is prime or not"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "As 1 is neither prime nor composite return false"
    },
    {
        "py": "for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Check if it is divided by any number then it is not prime , return false"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "Check if n is not divided by any number then it is prime and hence return true"
    },
    {
        "py": "def minDivisior ( n ) : NEW_LINE",
        "explain": "Function to find the pair ( a , b ) such that sum is N & LCM is minimum"
    },
    {
        "py": "if ( prime ( n ) ) : NEW_LINE INDENT print ( 1 , n - 1 ) NEW_LINE DEDENT",
        "explain": "Check if the number is prime"
    },
    {
        "py": "else : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Now , if it is not prime then find the least divisior"
    },
    {
        "py": "if ( n % i == 0 ) : NEW_LINE",
        "explain": "Check if divides n then it is a factor"
    },
    {
        "py": "print ( n // i , n // i * ( i - 1 ) ) NEW_LINE break NEW_LINE",
        "explain": "Required output is a = n / i & b = n / i * ( n - 1 )"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "minDivisior ( N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "Landau = - sys . maxsize - 1 NEW_LINE",
        "explain": "To store Landau 's function of the number"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT",
        "explain": "Function to return gcd of 2 numbers"
    },
    {
        "py": "def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // gcd ( a , b ) NEW_LINE DEDENT",
        "explain": "Function to return LCM of two numbers"
    },
    {
        "py": "def findLCM ( arr ) : NEW_LINE INDENT global Landau NEW_LINE nth_lcm = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT nth_lcm = lcm ( nth_lcm , arr [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to find max lcm value among all representations of n"
    },
    {
        "py": "Landau = max ( Landau , nth_lcm ) NEW_LINE",
        "explain": "Calculate Landau 's value"
    },
    {
        "py": "def findWays ( arr , i , n ) : NEW_LINE",
        "explain": "Recursive function to find different ways in which n can be written as sum of atleast one positive integers"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT findLCM ( arr ) NEW_LINE DEDENT",
        "explain": "Check if sum becomes n , consider this representation"
    },
    {
        "py": "for j in range ( i , n + 1 ) : NEW_LINE",
        "explain": "Start from previous element in the representation till n"
    },
    {
        "py": "arr . append ( j ) NEW_LINE",
        "explain": "Include current element from representation"
    },
    {
        "py": "findWays ( arr , j , n - j ) NEW_LINE",
        "explain": "Call function again with reduced sum"
    },
    {
        "py": "arr . pop ( ) NEW_LINE",
        "explain": "Backtrack - remove current element from representation"
    },
    {
        "py": "def Landau_function ( n ) : NEW_LINE INDENT arr = [ ] NEW_LINE DEDENT",
        "explain": "Function to find the Landau 's function"
    },
    {
        "py": "findWays ( arr , 1 , n ) NEW_LINE",
        "explain": "Using recurrence find different ways in which n can be written as a sum of atleast one + ve integers"
    },
    {
        "py": "print ( Landau ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Given N"
    },
    {
        "py": "Landau_function ( N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Function to check if a number holds the condition ( N - 1 ) ! % N = N - 1"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( ( n % 2 == 0 ) or ( n % 3 == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Number divisible by 2 or 3 are not prime"
    },
    {
        "py": "i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( ( n % i == 0 ) or ( n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False ; NEW_LINE i += 6 NEW_LINE DEDENT DEDENT return true ; NEW_LINE",
        "explain": "Iterate from 5 and keep checking for prime"
    },
    {
        "py": "def checkExpression ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to check the expression for the value N"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE checkExpression ( N ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def checkArray ( n , k , arr ) : NEW_LINE",
        "explain": "Function to check if array can be split in required K subsets"
    },
    {
        "py": "cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Store count of odd numbers"
    },
    {
        "py": "if ( arr [ i ] & 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT",
        "explain": "Check if element is odd"
    },
    {
        "py": "if ( cnt >= k and cnt % 2 == k % 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check if split is possible"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 5 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE if ( checkArray ( n , k , arr ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "Python3 program to compute the sum of division of all the possible pairs for the given array"
    },
    {
        "py": "def func ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxx = 0 NEW_LINE freq = [ 0 ] * 100005 NEW_LINE temp = 0 NEW_LINE DEDENT",
        "explain": "Function to compute the sum"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE freq [ temp ] += 1 NEW_LINE maxx = max ( maxx , temp ) NEW_LINE DEDENT",
        "explain": "Counting frequency of each term and finding maximum among it"
    },
    {
        "py": "for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT freq [ i ] += freq [ i - 1 ] NEW_LINE DEDENT for i in range ( 1 , maxx + 1 ) : NEW_LINE INDENT if ( freq [ i ] ) : NEW_LINE INDENT value = 0 NEW_LINE DEDENT DEDENT",
        "explain": "Making cumulative frequency"
    },
    {
        "py": "cur = ceil ( 0.5 * i ) - 1.0 NEW_LINE j = 1.5 NEW_LINE while ( 1 ) : NEW_LINE INDENT val = min ( maxx , ( ceil ( i * j ) - 1.0 ) ) NEW_LINE times = ( freq [ i ] - freq [ i - 1 ] ) NEW_LINE con = j - 0.5 NEW_LINE DEDENT",
        "explain": "Taking the ceil value"
    },
    {
        "py": "ans += times * con * ( freq [ int ( val ) ] - freq [ int ( cur ) ] ) NEW_LINE cur = val NEW_LINE if ( val == maxx ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE",
        "explain": "nos . in [ ( n - 0.5 ) X , ( n + 0.5 ) X ) range will add n to the ans"
    },
    {
        "py": "return int ( ans ) NEW_LINE",
        "explain": "Return the final result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( func ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def insert_element ( a , n ) : NEW_LINE",
        "explain": "Function to find the minimum number of elements that need to be inserted such that the sum of the elements of the array is twice the XOR of the array"
    },
    {
        "py": "Xor = 0 NEW_LINE",
        "explain": "Variable to store the Xor of all the elements"
    },
    {
        "py": "Sum = 0 NEW_LINE",
        "explain": "Variable to store the sum of all elements"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT Xor ^= a [ i ] NEW_LINE Sum += a [ i ] NEW_LINE DEDENT",
        "explain": "Loop to find the Xor and the sum of the array"
    },
    {
        "py": "if ( Sum == 2 * Xor ) : NEW_LINE",
        "explain": "If sum = 2 * Xor"
    },
    {
        "py": "print ( 0 ) NEW_LINE return NEW_LINE",
        "explain": "No need to insert more elements"
    },
    {
        "py": "if ( Xor == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE print ( Sum ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "We insert one more element which is Sum"
    },
    {
        "py": "num1 = Sum + Xor NEW_LINE num2 = Xor NEW_LINE",
        "explain": "We insert two more elements Sum + Xor and Xor ."
    },
    {
        "py": "print ( 2 ) NEW_LINE",
        "explain": "Print the number of elements inserted in the array"
    },
    {
        "py": "print ( num1 , num2 ) NEW_LINE",
        "explain": "Print the elements that are inserted in the array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE insert_element ( a , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( a == c ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if the roots of a quadratic equation are reciprocal of each other or not"
    },
    {
        "py": "a = 2 ; b = 0 ; c = 2 ; NEW_LINE checkSolution ( a , b , c ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def isPerfectSquare ( x ) : NEW_LINE",
        "explain": "Function check whether x is a perfect square or not"
    },
    {
        "py": "sr = sqrt ( x ) NEW_LINE",
        "explain": "Find floating point value of square root of x ."
    },
    {
        "py": "return ( ( sr - floor ( sr ) ) == 0 ) NEW_LINE",
        "explain": "If square root is an integer"
    },
    {
        "py": "def checkSunnyNumber ( N ) : NEW_LINE",
        "explain": "Function to check Sunny Number"
    },
    {
        "py": "if ( isPerfectSquare ( N + 1 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT",
        "explain": "Check if ( N + 1 ) is a perfect square or not"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "If ( N + 1 ) is not a perfect square"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 8 NEW_LINE",
        "explain": "Given Number"
    },
    {
        "py": "checkSunnyNumber ( N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def countValues ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE DEDENT",
        "explain": "Function to count the numbers which can convert N to 1 using the given operation"
    },
    {
        "py": "for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT k = n NEW_LINE DEDENT",
        "explain": "Iterate through all the integers"
    },
    {
        "py": "while ( k >= i ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT k //= i NEW_LINE DEDENT else : NEW_LINE INDENT k -= i NEW_LINE DEDENT DEDENT",
        "explain": "Check if N can be converted to 1"
    },
    {
        "py": "if ( k == 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT return answer NEW_LINE",
        "explain": "Incrementing the count if it can be converted"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printKNumbers ( N , K ) : NEW_LINE",
        "explain": "Function that prints the required K numbers"
    },
    {
        "py": "for i in range ( K - 1 ) : NEW_LINE INDENT print ( 1 , end = ' \u2581 ' ) NEW_LINE DEDENT",
        "explain": "Print 1 , K - 1 times"
    },
    {
        "py": "print ( N - K + 1 ) NEW_LINE",
        "explain": "Print ( N - K + 1 )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( N , K ) = ( 10 , 3 ) NEW_LINE printKNumbers ( N , K ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def NthSmallest ( K ) : NEW_LINE",
        "explain": "Function to find the Nth stepping natural number"
    },
    {
        "py": "Q = [ ] NEW_LINE",
        "explain": "Declare the queue"
    },
    {
        "py": "for i in range ( 1 , 10 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT",
        "explain": "Enqueue 1 , 2 , ... , 9 in this order"
    },
    {
        "py": "for i in range ( 1 , K + 1 ) : NEW_LINE",
        "explain": "Perform K operation on queue"
    },
    {
        "py": "x = Q [ 0 ] NEW_LINE",
        "explain": "Get the ith Stepping number"
    },
    {
        "py": "Q . remove ( Q [ 0 ] ) NEW_LINE",
        "explain": "Perform Dequeue from the Queue"
    },
    {
        "py": "if ( x % 10 != 0 ) : NEW_LINE",
        "explain": "If x mod 10 is not equal to 0"
    },
    {
        "py": "Q . append ( x * 10 + x % 10 - 1 ) NEW_LINE",
        "explain": "then Enqueue 10 x + ( x mod 10 ) - 1"
    },
    {
        "py": "Q . append ( x * 10 + x % 10 ) NEW_LINE",
        "explain": "Enqueue 10 x + ( x mod 10 )"
    },
    {
        "py": "if ( x % 10 != 9 ) : NEW_LINE",
        "explain": "If x mod 10 is not equal to 9"
    },
    {
        "py": "Q . append ( x * 10 + x % 10 + 1 ) NEW_LINE",
        "explain": "then Enqueue 10 x + ( x mod 10 ) + 1"
    },
    {
        "py": "return x NEW_LINE",
        "explain": "Return the dequeued number of the K - th operation as the Nth stepping number"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 16 NEW_LINE print ( NthSmallest ( N ) ) NEW_LINE",
        "explain": "initialise K"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def nearest ( n ) : NEW_LINE",
        "explain": "Function to return the Least number"
    },
    {
        "py": "prevSquare = int ( sqrt ( n ) ) ; NEW_LINE nextSquare = prevSquare + 1 ; NEW_LINE prevSquare = prevSquare * prevSquare ; NEW_LINE nextSquare = nextSquare * nextSquare ; NEW_LINE",
        "explain": "Get the perfect square before and after N"
    },
    {
        "py": "ans = ( prevSquare - n ) if ( n - prevSquare ) < ( nextSquare - n ) else ( nextSquare - n ) ; NEW_LINE",
        "explain": "Check which is nearest to N"
    },
    {
        "py": "return ans ; NEW_LINE",
        "explain": "return the result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 16 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE n = 18 ; NEW_LINE print ( nearest ( n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import acos NEW_LINE",
        "explain": "Python3 program to calculate the value of pi up to n decimal places"
    },
    {
        "py": "def printValueOfPi ( N ) : NEW_LINE",
        "explain": "Function that prints the value of pi upto N decimal places"
    },
    {
        "py": "b = ' { : . ' + str ( N ) + ' f } ' NEW_LINE pi = b . format ( 2 * acos ( 0.0 ) ) NEW_LINE",
        "explain": "Find value of pi upto using acos ( ) function"
    },
    {
        "py": "print ( pi ) ; NEW_LINE",
        "explain": "Print value of pi upto N decimal places"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 43 ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "printValueOfPi ( N ) ; NEW_LINE",
        "explain": "Function that prints the value of pi"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python implementation of the approach"
    },
    {
        "py": "def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT",
        "explain": "Function to convert decimal number n to its binary representation stored as an array arr [ ]"
    },
    {
        "py": "def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT",
        "explain": "Function to convert the number represented as a binary array arr [ ] its decimal equivalent"
    },
    {
        "py": "def getNum ( n , k ) : NEW_LINE",
        "explain": "Function to concatenate the binary numbers and return the decimal result"
    },
    {
        "py": "l = int ( math . log2 ( n ) ) + 1 NEW_LINE",
        "explain": "Number of bits in both the numbers"
    },
    {
        "py": "a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE",
        "explain": "Convert the bits in both the gers to the arrays a [ ] and b [ ]"
    },
    {
        "py": "if ( k > l ) : NEW_LINE INDENT return n NEW_LINE DEDENT",
        "explain": "The number of bits in n are less than k"
    },
    {
        "py": "if ( a [ k - 1 ] == 0 ) : NEW_LINE INDENT a [ k - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ k - 1 ] = 0 NEW_LINE DEDENT",
        "explain": "Flip the kth bit"
    },
    {
        "py": "return binaryDec ( a , l ) NEW_LINE",
        "explain": "Return the decimal equivalent of the number"
    },
    {
        "py": "n = 56 NEW_LINE k = 2 NEW_LINE print ( getNum ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 1000000 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "result = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE fact = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE",
        "explain": "Declare result array globally"
    },
    {
        "py": "def preCompute ( ) : NEW_LINE",
        "explain": "Function to precompute the product of factorials upto MAX"
    },
    {
        "py": "fact [ 0 ] = 1 NEW_LINE result [ 0 ] = 1 NEW_LINE",
        "explain": "Initialize base condition if n = 0 then factorial of 0 is equal to 1 and answer for n = 0 is 1"
    },
    {
        "py": "for i in range ( 1 , MAX + 1 ) : NEW_LINE",
        "explain": "Iterate loop from 1 to MAX"
    },
    {
        "py": "fact [ i ] = ( ( fact [ i - 1 ] % MOD ) * i ) % MOD NEW_LINE",
        "explain": "factorial ( i ) = factorial ( i - 1 ) * i"
    },
    {
        "py": "result [ i ] = ( ( result [ i - 1 ] % MOD ) * ( fact [ i ] % MOD ) ) % MOD NEW_LINE",
        "explain": "Result for current n is equal to result [ i - 1 ] multiplied by the factorial of i"
    },
    {
        "py": "def performQueries ( q , n ) : NEW_LINE",
        "explain": "Function to perform the queries"
    },
    {
        "py": "preCompute ( ) NEW_LINE",
        "explain": "Precomputing the result tiMAX"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( result [ q [ i ] ] ) NEW_LINE DEDENT",
        "explain": "Perform queries"
    },
    {
        "py": "q = [ 4 , 5 ] NEW_LINE n = len ( q ) NEW_LINE performQueries ( q , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program to find nth term divisible by a , b or c"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT",
        "explain": "Function to return gcd of a and b"
    },
    {
        "py": "def divTermCount ( a , b , c , num ) : NEW_LINE",
        "explain": "Function to return the count of integers from the range [ 1 , num ] which are divisible by either a , b or c"
    },
    {
        "py": "return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; NEW_LINE",
        "explain": "Calculate the number of terms divisible by a , b and c then remove the terms which are divisible by both ( a , b ) or ( b , c ) or ( c , a ) and then add the numbers which are divisible by a , b and c"
    },
    {
        "py": "def findNthTerm ( a , b , c , n ) : NEW_LINE",
        "explain": "Function for binary search to find the nth term divisible by a , b or c"
    },
    {
        "py": "low = 1 ; high = sys . maxsize ; mid = 0 ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 ; NEW_LINE DEDENT",
        "explain": "Set low to 1 and high to LONG_MAX"
    },
    {
        "py": "if ( divTermCount ( a , b , c , mid ) < n ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT",
        "explain": "If the current term is less than n then we need to increase low to mid + 1"
    },
    {
        "py": "else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT return int ( low ) ; NEW_LINE",
        "explain": "If current term is greater than equal to n then high = mid"
    },
    {
        "py": "a = 2 ; b = 3 ; c = 5 ; n = 100 ; NEW_LINE print ( findNthTerm ( a , b , c , n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def calculate_angle ( n , i , j , k ) : NEW_LINE",
        "explain": "Function that checks whether given angle can be created using any 3 sides"
    },
    {
        "py": "x , y = 0 , 0 NEW_LINE",
        "explain": "Initialize x and y"
    },
    {
        "py": "if ( i < j ) : NEW_LINE INDENT x = j - i NEW_LINE DEDENT else : NEW_LINE INDENT x = j + n - i NEW_LINE DEDENT if ( j < k ) : NEW_LINE INDENT y = k - j NEW_LINE DEDENT else : NEW_LINE INDENT y = k + n - j NEW_LINE DEDENT",
        "explain": "Calculate the number of vertices between i and j , j and k"
    },
    {
        "py": "ang1 = ( 180 * x ) // n NEW_LINE ang2 = ( 180 * y ) // n NEW_LINE",
        "explain": "Calculate the angle subtended at the circumference"
    },
    {
        "py": "ans = 180 - ang1 - ang2 NEW_LINE return ans NEW_LINE",
        "explain": "Angle subtended at j can be found using the fact that the sum of angles of a triangle is equal to 180 degrees"
    },
    {
        "py": "n = 5 NEW_LINE a1 = 1 NEW_LINE a2 = 2 NEW_LINE a3 = 5 NEW_LINE print ( calculate_angle ( n , a1 , a2 , a3 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def Loss ( SP , P ) : NEW_LINE INDENT loss = 0 NEW_LINE loss = ( ( 2 * P * P * SP ) / ( 100 * 100 - P * P ) ) NEW_LINE print ( \" Loss \u2581 = \" , round ( loss , 3 ) ) NEW_LINE DEDENT",
        "explain": "Function that will find loss"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT SP , P = 2400 , 30 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "Loss ( SP , P ) NEW_LINE",
        "explain": "Calling Function"
    },
    {
        "py": "MAXN = 1000001 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "spf = [ i for i in range ( MAXN ) ] NEW_LINE",
        "explain": "Stores smallest prime factor for every number"
    },
    {
        "py": "hash1 = [ 0 for i in range ( MAXN ) ] NEW_LINE",
        "explain": "Hash to store prime factors count"
    },
    {
        "py": "def sieve ( ) : NEW_LINE",
        "explain": "Function to calculate SPF ( SmallestPrime Factor ) for every number till MAXN"
    },
    {
        "py": "for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT",
        "explain": "Separately marking spf for every even number as 2"
    },
    {
        "py": "for i in range ( 3 , MAXN ) : NEW_LINE INDENT if i * i >= MAXN : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "Checking if i is prime"
    },
    {
        "py": "if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE DEDENT",
        "explain": "Marking SPF for all numbers divisible by i"
    },
    {
        "py": "if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT",
        "explain": "Marking spf [ j ] if it is not previously marked"
    },
    {
        "py": "def getFactorization ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE if ( x % temp == 0 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to store the prime factors after dividing by the smallest prime factor at every step"
    },
    {
        "py": "hash1 [ spf [ x ] ] += 1 NEW_LINE x = x // spf [ x ] NEW_LINE while ( x % temp == 0 ) : NEW_LINE x = x // temp NEW_LINE",
        "explain": "Storing the count of prime factors in hash"
    },
    {
        "py": "def check ( x ) : NEW_LINE INDENT while ( x != 1 ) : NEW_LINE INDENT temp = spf [ x ] NEW_LINE DEDENT DEDENT",
        "explain": "Function that returns true if there are no common prime factors between x and other numbers of the array"
    },
    {
        "py": "if ( x % temp == 0 and hash1 [ temp ] > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( x % temp == 0 ) : NEW_LINE INDENT x = x // temp NEW_LINE DEDENT return True NEW_LINE",
        "explain": "Checking whether it common prime factor with other numbers"
    },
    {
        "py": "def hasValidNum ( arr , n ) : NEW_LINE",
        "explain": "Function that returns true if there is an element in the array which is coprime with all the other elements of the array"
    },
    {
        "py": "sieve ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT getFactorization ( arr [ i ] ) NEW_LINE DEDENT",
        "explain": "Using sieve for generating prime factors"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( check ( arr [ i ] ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE",
        "explain": "Checking the common prime factors with other numbers"
    },
    {
        "py": "arr = [ 2 , 8 , 4 , 10 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( hasValidNum ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countWays ( N ) : NEW_LINE",
        "explain": "Function to return the number of ways to remove edges from the graph so that odd number of edges are left in the graph"
    },
    {
        "py": "E = ( N * ( N - 1 ) ) / 2 NEW_LINE if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return int ( pow ( 2 , E - 1 ) ) NEW_LINE",
        "explain": "Total number of edges"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( countWays ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "l = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] NEW_LINE def initialize ( ) : NEW_LINE",
        "explain": "Initialize the matrix with 0"
    },
    {
        "py": "l [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1001 ) : NEW_LINE",
        "explain": "0 C0 = 1"
    },
    {
        "py": "l [ i ] [ 0 ] = 1 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE",
        "explain": "Set every nCr = 1 where r = 0"
    },
    {
        "py": "l [ i ] [ j ] = ( l [ i - 1 ] [ j - 1 ] + l [ i - 1 ] [ j ] ) NEW_LINE",
        "explain": "Value for the current cell of Pascal 's triangle"
    },
    {
        "py": "def nCr ( n , r ) : NEW_LINE",
        "explain": "Function to return the value of nCr"
    },
    {
        "py": "return l [ n ] [ r ] NEW_LINE",
        "explain": "Return nCr"
    },
    {
        "py": "initialize ( ) NEW_LINE n = 8 NEW_LINE r = 3 NEW_LINE print ( nCr ( n , r ) ) NEW_LINE",
        "explain": "Build the Pascal 's triangle"
    },
    {
        "py": "def minAbsDiff ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 or mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT",
        "explain": "Function to return the minimum required absolute difference"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def check ( s ) : NEW_LINE",
        "explain": "Python implementation of the above approach"
    },
    {
        "py": "freq = [ 0 ] * 10 NEW_LINE while ( s != 0 ) : NEW_LINE",
        "explain": "creating a frequency array"
    },
    {
        "py": "r = s % 10 NEW_LINE",
        "explain": "Finding the last digit of the number"
    },
    {
        "py": "s = s // 10 NEW_LINE",
        "explain": "Dividing the number by 10 to eliminate last digit"
    },
    {
        "py": "freq [ r ] += 1 NEW_LINE xor = 0 NEW_LINE",
        "explain": "counting frequency of each digit"
    },
    {
        "py": "for i in range ( 10 ) : NEW_LINE INDENT xor = xor ^ freq [ i ] NEW_LINE DEDENT if ( xor == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "checking if the xor of all frequency is zero or not"
    },
    {
        "py": "s = 122233 NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printLines ( n , k ) : NEW_LINE",
        "explain": "Function to print N lines"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( k * ( 6 * i + 1 ) , k * ( 6 * i + 2 ) , k * ( 6 * i + 3 ) , k * ( 6 * i + 5 ) ) NEW_LINE DEDENT",
        "explain": "Iterate N times to print N lines"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n , k = 2 , 2 NEW_LINE printLines ( n , k ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def calculateSum ( n ) : NEW_LINE",
        "explain": "Python program to find sum of n terms of the series"
    },
    {
        "py": "return ( 2 ** ( n + 1 ) + n - 2 ) NEW_LINE",
        "explain": "Sn = n * ( 4 * n * n + 6 * n - 1 ) / 3"
    },
    {
        "py": "n = 4 NEW_LINE",
        "explain": "number of terms for the sum"
    },
    {
        "py": "print ( \" Sum \u2581 = \" , calculateSum ( n ) ) NEW_LINE",
        "explain": "find the Sn"
    },
    {
        "py": "mod = 1000000007 NEW_LINE",
        "explain": "Python3 program to count the number of special strings of a given length N"
    },
    {
        "py": "def count_special ( n ) : NEW_LINE",
        "explain": "Function to return count of special strings"
    },
    {
        "py": "fib = [ 0 for i in range ( n + 1 ) ] NEW_LINE",
        "explain": "Stores the answer for a particular value of n"
    },
    {
        "py": "fib [ 0 ] = 1 NEW_LINE",
        "explain": "For n = 0 we have empty string"
    },
    {
        "py": "fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE",
        "explain": "For n = 1 we have 2 special strings"
    },
    {
        "py": "fib [ i ] = ( fib [ i - 1 ] % mod + fib [ i - 2 ] % mod ) % mod NEW_LINE",
        "explain": "Calculate count of special string of length i"
    },
    {
        "py": "return fib [ n ] NEW_LINE",
        "explain": "fib [ n ] stores the count of special strings of length n"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = 3 NEW_LINE print ( count_special ( n ) ) NEW_LINE",
        "explain": "Initialise n"
    },
    {
        "py": "mod = 1e9 + 7 ; NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def ways ( i , arr , n ) : NEW_LINE",
        "explain": "Find the number of ways to reach the end"
    },
    {
        "py": "if ( i == n - 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "for j in range ( 1 , arr [ i ] + 1 ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT sum += ( ways ( i + j , arr , n ) ) % mod ; NEW_LINE sum %= mod ; NEW_LINE DEDENT DEDENT return int ( sum % mod ) ; NEW_LINE",
        "explain": "Recursive structure"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 1 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ways ( 0 , arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "mod = 10 ** 9 + 7 NEW_LINE",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "def ways ( arr , n ) : NEW_LINE",
        "explain": "find the number of ways to reach the end"
    },
    {
        "py": "dp = [ 0 ] * ( n + 1 ) NEW_LINE",
        "explain": "dp to store value"
    },
    {
        "py": "dp [ n - 1 ] = 1 NEW_LINE",
        "explain": "base case"
    },
    {
        "py": "for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] = 0 NEW_LINE DEDENT",
        "explain": "Bottom up dp structure"
    },
    {
        "py": "j = 1 NEW_LINE while ( ( j + i ) < n and j <= arr [ i ] ) : NEW_LINE INDENT dp [ i ] += dp [ i + j ] NEW_LINE dp [ i ] %= mod NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "F [ i ] is dependent of F [ i + 1 ] to F [ i + k ]"
    },
    {
        "py": "return dp [ 0 ] % mod NEW_LINE",
        "explain": "Return value of dp [ 0 ]"
    },
    {
        "py": "arr = [ 5 , 3 , 1 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ways ( arr , n ) % mod ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT",
        "explain": "Returns the count of odd and even subsequences"
    },
    {
        "py": "count_odd = 0 NEW_LINE count_even = 0 NEW_LINE",
        "explain": "Initialising count_even and count_odd to 0 since as there is no subsequence before the iteration with even or odd count ."
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Find sum of all subsequences with even count and odd count and storing them as we iterate ."
    },
    {
        "py": "if ( arr [ i - 1 ] % 2 == 0 ) : NEW_LINE INDENT count_even = count_even + count_even + 1 NEW_LINE count_odd = count_odd + count_odd NEW_LINE DEDENT",
        "explain": "if the number is even"
    },
    {
        "py": "else : NEW_LINE INDENT temp = count_even NEW_LINE count_even = count_even + count_odd NEW_LINE count_odd = count_odd + temp + 1 NEW_LINE DEDENT return ( count_even , count_odd ) NEW_LINE",
        "explain": "if the number is odd"
    },
    {
        "py": "arr = [ 1 , 2 , 2 , 3 ] ; NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "count_even , count_odd = countSum ( arr , n ) ; NEW_LINE print ( \" EvenSum \u2581 = \u2581 \" , count_even , \" \u2581 OddSum \u2581 = \u2581 \" , count_odd ) NEW_LINE",
        "explain": "Calling the function"
    },
    {
        "py": "MAX = 10 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def numToVec ( N ) : NEW_LINE INDENT digit = [ ] NEW_LINE DEDENT",
        "explain": "Function to convert a number into vector"
    },
    {
        "py": "while ( N != 0 ) : NEW_LINE INDENT digit . append ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT",
        "explain": "Push all the digits of N from the end one by one to the vector"
    },
    {
        "py": "if ( len ( digit ) == 0 ) : NEW_LINE INDENT digit . append ( 0 ) NEW_LINE DEDENT",
        "explain": "If the original number was 0"
    },
    {
        "py": "digit = digit [ : : - 1 ] NEW_LINE",
        "explain": "Reverse the vector elements"
    },
    {
        "py": "return digit NEW_LINE",
        "explain": "Return the required vector"
    },
    {
        "py": "def solve ( A , B , C ) : NEW_LINE INDENT d , d2 = 0 , 0 NEW_LINE DEDENT",
        "explain": "Function to return the count of B length integers which are less than C and they contain digits from set A [ ] only"
    },
    {
        "py": "digit = numToVec ( C ) NEW_LINE d = len ( A ) NEW_LINE",
        "explain": "Convert number to digit array"
    },
    {
        "py": "if ( B > len ( digit ) or d == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Case 1 : No such number possible as the generated numbers will always be greater than C"
    },
    {
        "py": "elif ( B < len ( digit ) ) : NEW_LINE",
        "explain": "Case 2 : All integers of length B are valid as they all are less than C"
    },
    {
        "py": "if ( A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT return ( d - 1 ) * pow ( d , B - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( d , B ) NEW_LINE DEDENT",
        "explain": "contain 0"
    },
    {
        "py": "else : NEW_LINE INDENT dp = [ 0 for i in range ( B + 1 ) ] NEW_LINE lower = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE DEDENT",
        "explain": "Case 3"
    },
    {
        "py": "for i in range ( d ) : NEW_LINE INDENT lower [ A [ i ] + 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT lower [ i ] = lower [ i - 1 ] + lower [ i ] NEW_LINE DEDENT flag = True NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , B + 1 ) : NEW_LINE INDENT d2 = lower [ digit [ i - 1 ] ] NEW_LINE dp [ i ] = dp [ i - 1 ] * d NEW_LINE DEDENT",
        "explain": "Update the lower [ ] array such that lower [ i ] stores the count of elements in A [ ] which are less than i"
    },
    {
        "py": "if ( i == 1 and A [ 0 ] == 0 and B != 1 ) : NEW_LINE INDENT d2 = d2 - 1 NEW_LINE DEDENT",
        "explain": "For first index we can 't use 0"
    },
    {
        "py": "if ( flag ) : NEW_LINE INDENT dp [ i ] += d2 NEW_LINE DEDENT",
        "explain": "Whether ( i - 1 ) digit of generated number can be equal to ( i - 1 ) digit of C"
    },
    {
        "py": "flag = ( flag & ( lower [ digit [ i - 1 ] + 1 ] == lower [ digit [ i - 1 ] ] + 1 ) ) NEW_LINE return dp [ B ] NEW_LINE",
        "explain": "Is digit [ i - 1 ] present in A ?"
    },
    {
        "py": "A = [ 0 , 1 , 2 , 5 ] NEW_LINE N = 2 NEW_LINE k = 21 NEW_LINE print ( solve ( A , N , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import numpy as np NEW_LINE",
        "explain": "Python 3 program to count the number of paths with weight W in a K - ary tree"
    },
    {
        "py": "def solve ( dp , wt , K , M , used ) : NEW_LINE",
        "explain": "Function to return the number of ways having weight as wt in K - ary tree"
    },
    {
        "py": "if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE",
        "explain": "Return 0 if weight becomes less than zero"
    },
    {
        "py": "if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE return dp [ wt ] [ used ] NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE",
        "explain": "Return one only if the current path has included edge weight of atleast M"
    },
    {
        "py": "if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE",
        "explain": "If the current edge weight is greater than or equal to M , set used as true"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE DEDENT",
        "explain": "Function to find the number of partitions of N"
    },
    {
        "py": "p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 20 NEW_LINE",
        "explain": "Python3 program to find longest increasing path in a matrix ."
    },
    {
        "py": "def LIP ( dp , mat , n , m , x , y ) : NEW_LINE",
        "explain": "Return the length of LIP in 2D matrix"
    },
    {
        "py": "if ( dp [ x ] [ y ] < 0 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT",
        "explain": "If value not calculated yet ."
    },
    {
        "py": "if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT dp [ x ] [ y ] = 1 NEW_LINE return dp [ x ] [ y ] NEW_LINE DEDENT",
        "explain": "If reach bottom left cell , return 1."
    },
    {
        "py": "if ( x == n - 1 or y == m - 1 ) : NEW_LINE INDENT result = 1 NEW_LINE DEDENT",
        "explain": "If reach the corner of the matrix ."
    },
    {
        "py": "if ( x + 1 < n and mat [ x ] [ y ] < mat [ x + 1 ] [ y ] ) : NEW_LINE INDENT result = 1 + LIP ( dp , mat , n , m , x + 1 , y ) NEW_LINE DEDENT",
        "explain": "If value greater than below cell ."
    },
    {
        "py": "if ( y + 1 < m and mat [ x ] [ y ] < mat [ x ] [ y + 1 ] ) : NEW_LINE INDENT result = max ( result , 1 + LIP ( dp , mat , n , m , x , y + 1 ) ) NEW_LINE DEDENT dp [ x ] [ y ] = result NEW_LINE return dp [ x ] [ y ] NEW_LINE",
        "explain": "If value greater than left cell ."
    },
    {
        "py": "def wrapper ( mat , n , m ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return LIP ( dp , mat , n , m , 0 , 0 ) NEW_LINE DEDENT",
        "explain": "Wrapper function"
    },
    {
        "py": "mat = [ [ 1 , 2 , 3 , 4 ] , [ 2 , 2 , 3 , 4 ] , [ 3 , 2 , 3 , 4 ] , [ 4 , 5 , 6 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE print ( wrapper ( mat , n , m ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def countPaths ( n , m ) : NEW_LINE",
        "explain": "Recursive function to count number of paths"
    },
    {
        "py": "if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If we reach bottom or top left , we are have only one way to reach ( 0 , 0 )"
    },
    {
        "py": "return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE",
        "explain": "Else count sum of both ways"
    },
    {
        "py": "n = 3 NEW_LINE m = 2 NEW_LINE print ( \" \u2581 Number \u2581 of \u2581 Paths \u2581 \" , countPaths ( n , m ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 100 NEW_LINE",
        "explain": "Python program to solve Gold Mine problem"
    },
    {
        "py": "def getMaxGold ( gold , m , n ) : NEW_LINE",
        "explain": "Returns maximum amount of gold that can be collected when journey started from first column and moves allowed are right , right - up and right - down"
    },
    {
        "py": "goldTable = [ [ 0 for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for col in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for row in range ( m ) : NEW_LINE DEDENT",
        "explain": "Create a table for storing intermediate results and initialize all cells to 0. The first row of goldMineTable gives the maximum gold that the miner can collect when starts that row"
    },
    {
        "py": "if ( col == n - 1 ) : NEW_LINE INDENT right = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right = goldTable [ row ] [ col + 1 ] NEW_LINE DEDENT",
        "explain": "Gold collected on going to the cell on the right ( -> )"
    },
    {
        "py": "if ( row == 0 or col == n - 1 ) : NEW_LINE INDENT right_up = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_up = goldTable [ row - 1 ] [ col + 1 ] NEW_LINE DEDENT",
        "explain": "Gold collected on going to the cell to right up ( / )"
    },
    {
        "py": "if ( row == m - 1 or col == n - 1 ) : NEW_LINE INDENT right_down = 0 NEW_LINE DEDENT else : NEW_LINE INDENT right_down = goldTable [ row + 1 ] [ col + 1 ] NEW_LINE DEDENT",
        "explain": "Gold collected on going to the cell to right down ( \\ )"
    },
    {
        "py": "goldTable [ row ] [ col ] = gold [ row ] [ col ] + max ( right , right_up , right_down ) NEW_LINE",
        "explain": "Max gold collected from taking either of the above 3 paths"
    },
    {
        "py": "res = goldTable [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT res = max ( res , goldTable [ i ] [ 0 ] ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "The max amount of gold collected will be the max value in first column of all rows"
    },
    {
        "py": "gold = [ [ 1 , 3 , 1 , 5 ] , [ 2 , 2 , 4 , 1 ] , [ 5 , 0 , 2 , 3 ] , [ 0 , 6 , 1 , 2 ] ] NEW_LINE m = 4 NEW_LINE n = 4 NEW_LINE print ( getMaxGold ( gold , m , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "M = 100 NEW_LINE",
        "explain": "Python3 program to find minimum adjustment cost of an array"
    },
    {
        "py": "def minAdjustmentCost ( A , n , target ) : NEW_LINE",
        "explain": "Function to find minimum adjustment cost of an array"
    },
    {
        "py": "dp = [ [ 0 for i in range ( M + 1 ) ] for i in range ( n ) ] NEW_LINE",
        "explain": "dp [ i ] [ j ] stores minimal adjustment cost on changing A [ i ] to j"
    },
    {
        "py": "for j in range ( M + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = abs ( j - A [ 0 ] ) NEW_LINE DEDENT",
        "explain": "handle first element of array separately"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE",
        "explain": "do for rest elements of the array"
    },
    {
        "py": "for j in range ( M + 1 ) : NEW_LINE",
        "explain": "replace A [ i ] to j and calculate minimal adjustment cost dp [ i ] [ j ]"
    },
    {
        "py": "dp [ i ] [ j ] = 100000000 NEW_LINE",
        "explain": "initialize minimal adjustment cost to INT_MAX"
    },
    {
        "py": "for k in range ( max ( j - target , 0 ) , min ( M , j + target ) + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ k ] + abs ( A [ i ] - j ) ) NEW_LINE DEDENT",
        "explain": "consider all k such that k >= max ( j - target , 0 ) and k <= min ( M , j + target ) and take minimum"
    },
    {
        "py": "res = 10000000 NEW_LINE for j in range ( M + 1 ) : NEW_LINE INDENT res = min ( res , dp [ n - 1 ] [ j ] ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "return minimum value from last row of dp table"
    },
    {
        "py": "arr = [ 55 , 77 , 52 , 61 , 39 , 6 , 25 , 60 , 49 , 47 ] NEW_LINE n = len ( arr ) NEW_LINE target = 10 NEW_LINE print ( \" Minimum \u2581 adjustment \u2581 cost \u2581 is \" , minAdjustmentCost ( arr , n , target ) , sep = ' \u2581 ' ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def totalCombination ( L , R ) : NEW_LINE",
        "explain": "Function to find the number of triplets from the range [ L , R ] having sum of two numbers from the triplet equal to the third number"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the total number of triplets"
    },
    {
        "py": "K = R - L NEW_LINE",
        "explain": "Find the difference of the range"
    },
    {
        "py": "if ( K < L ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Case 1 : If triplets can 't  be formed, then return 0"
    },
    {
        "py": "ans = K - L NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "count = ( ( ans + 1 ) * ( ans + 2 ) ) // 2 NEW_LINE",
        "explain": "Update the total number of triplets"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 2 , 6 NEW_LINE print ( totalCombination ( L , R ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def printArrays ( n ) : NEW_LINE",
        "explain": "Function to generate two arrays satisfying the given conditions"
    },
    {
        "py": "A , B = [ ] , [ ] ; NEW_LINE",
        "explain": "Declare the two arrays A and B"
    },
    {
        "py": "for i in range ( 1 , 2 * n + 1 ) : NEW_LINE",
        "explain": "Iterate from range [ 1 , 2 * n ]"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE INDENT A . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT B . append ( i ) ; NEW_LINE DEDENT",
        "explain": "Assign consecutive numbers to same indices of the two arrays"
    },
    {
        "py": "print ( \" { \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \u2581 \" , end = \" \" ) ; NEW_LINE DEDENT DEDENT print ( \" } \" ) ; NEW_LINE",
        "explain": "Print the first array"
    },
    {
        "py": "print ( \" { \u2581 \" , end = \" \" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = \" \" ) ; NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( \" , \" , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT print ( \" \u2581 } \" , end = \" \" ) ; NEW_LINE",
        "explain": "Print the second array , B"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 5 ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "printArrays ( N ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def flipBitsOfAandB ( A , B ) : NEW_LINE",
        "explain": "Function to flip bits of A and B which are set in both of them"
    },
    {
        "py": "for i in range ( 0 , 32 ) : NEW_LINE",
        "explain": "Iterate all possible bits of A and B"
    },
    {
        "py": "if ( ( A & ( 1 << i ) ) and ( B & ( 1 << i ) ) ) : NEW_LINE",
        "explain": "If ith bit is set in both A and B"
    },
    {
        "py": "A = A ^ ( 1 << i ) NEW_LINE",
        "explain": "Clear i - th bit of A"
    },
    {
        "py": "B = B ^ ( 1 << i ) NEW_LINE",
        "explain": "Clear i - th bit of B"
    },
    {
        "py": "print ( A , B ) NEW_LINE",
        "explain": "Print A and B"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 7 NEW_LINE B = 4 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findDistinctSums ( N ) : NEW_LINE INDENT return ( 2 * N - 1 ) NEW_LINE DEDENT",
        "explain": "Function to find the distinct sums"
    },
    {
        "py": "N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countSubstrings ( str ) : NEW_LINE",
        "explain": "Function to count the number of substrings consists of 0 , 1 , and 2"
    },
    {
        "py": "freq = [ 0 ] * 3 NEW_LINE",
        "explain": "Initialize frequency array of size 3"
    },
    {
        "py": "count = 0 NEW_LINE i = 0 NEW_LINE",
        "explain": "Stores the resultant count"
    },
    {
        "py": "for j in range ( 0 , len ( str ) ) : NEW_LINE",
        "explain": "Traversing string str"
    },
    {
        "py": "freq [ ord ( str [ j ] ) - ord ( '0' ) ] += 1 NEW_LINE",
        "explain": "Update frequency array"
    },
    {
        "py": "while ( freq [ 0 ] > 0 and freq [ 1 ] > 0 and freq [ 2 ] > 0 ) : NEW_LINE INDENT i += 1 NEW_LINE freq [ ord ( str [ i ] ) - ord ( '0' ) ] -= 1 NEW_LINE DEDENT",
        "explain": "If all the characters are present counting number of substrings possible"
    },
    {
        "py": "count += i NEW_LINE",
        "explain": "Update number of substrings"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the number of substrings"
    },
    {
        "py": "str = \"00021\" NEW_LINE count = countSubstrings ( str ) NEW_LINE print ( count ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def minFlips ( st ) : NEW_LINE",
        "explain": "Function to find the minimum number of flips to make all three pairs of consecutive characters different"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores resultant count of pairs"
    },
    {
        "py": "if ( len ( st ) <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "for i in range ( len ( st ) - 2 ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , N - 2 ]"
    },
    {
        "py": "if ( st [ i ] == st [ i + 1 ] and st [ i + 2 ] == st [ i + 1 ] ) : NEW_LINE INDENT i = i + 3 NEW_LINE count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "If the consecutive 3 numbers are the same then increment the count and the counter"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"0011101\" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def convertToHex ( num ) : NEW_LINE INDENT temp = \" \" NEW_LINE while ( num != 0 ) : NEW_LINE INDENT rem = num % 16 NEW_LINE c = 0 NEW_LINE if ( rem < 10 ) : NEW_LINE INDENT c = rem + 48 NEW_LINE DEDENT else : NEW_LINE INDENT c = rem + 87 NEW_LINE DEDENT temp += chr ( c ) NEW_LINE num = num // 16 NEW_LINE DEDENT return temp NEW_LINE DEDENT",
        "explain": "Function to convert Decimal to Hex"
    },
    {
        "py": "def encryptString ( S , N ) : NEW_LINE INDENT ans = \" \" NEW_LINE DEDENT",
        "explain": "Function to encrypt the string"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT ch = S [ i ] NEW_LINE count = 0 NEW_LINE DEDENT",
        "explain": "Iterate the characters of the string"
    },
    {
        "py": "while ( i < N and S [ i ] == ch ) : NEW_LINE",
        "explain": "Iterate until S [ i ] is equal to ch"
    },
    {
        "py": "count += 1 NEW_LINE i += 1 NEW_LINE",
        "explain": "Update count and i"
    },
    {
        "py": "i -= 1 NEW_LINE",
        "explain": "Decrement i by 1"
    },
    {
        "py": "hex = convertToHex ( count ) NEW_LINE",
        "explain": "Convert count to hexadecimal representation"
    },
    {
        "py": "ans += ch NEW_LINE",
        "explain": "Append the character"
    },
    {
        "py": "ans += hex NEW_LINE",
        "explain": "Append the characters frequency in hexadecimal representation"
    },
    {
        "py": "ans = ans [ : : - 1 ] NEW_LINE",
        "explain": "Reverse the obtained answer"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return required answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "S = \" abc \" NEW_LINE N = len ( S ) NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( encryptString ( S , N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT",
        "explain": "Function to calculate and return the value of Binomial Coefficient C ( n , k )"
    },
    {
        "py": "if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT",
        "explain": "Since C ( n , k ) = C ( n , n - k )"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Calculate the value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ]"
    },
    {
        "py": "def countOfString ( N ) : NEW_LINE",
        "explain": "Function to return the count of binary strings of length N such that frequency of 1 ' s \u2581 exceed \u2581 that \u2581 of \u2581 0' s"
    },
    {
        "py": "Stotal = pow ( 2 , N ) NEW_LINE",
        "explain": "Count of N - length binary strings"
    },
    {
        "py": "Sequal = 0 NEW_LINE",
        "explain": "Count of N - length binary strings having equal count of 0 ' s \u2581 and \u2581 1' s"
    },
    {
        "py": "if ( N % 2 == 0 ) : NEW_LINE INDENT Sequal = binomialCoeff ( N , N // 2 ) NEW_LINE DEDENT S1 = ( Stotal - Sequal ) // 2 NEW_LINE return S1 NEW_LINE",
        "explain": "For even length strings"
    },
    {
        "py": "N = 3 NEW_LINE print ( countOfString ( N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def removeCharRecursive ( str , X ) : NEW_LINE",
        "explain": "Function to remove all occurrences of a character in the string"
    },
    {
        "py": "if ( len ( str ) == 0 ) : NEW_LINE INDENT return \" \" NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if ( str [ 0 ] == X ) : NEW_LINE",
        "explain": "Check the first character of the given string"
    },
    {
        "py": "return removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE",
        "explain": "Pass the rest of the string to recursion Function call"
    },
    {
        "py": "return str [ 0 ] + removeCharRecursive ( str [ 1 : ] , X ) NEW_LINE",
        "explain": "Add the first character of str and string from recursion"
    },
    {
        "py": "str = \" geeksforgeeks \" NEW_LINE",
        "explain": "Given String"
    },
    {
        "py": "X = ' e ' NEW_LINE",
        "explain": "Given character"
    },
    {
        "py": "str = removeCharRecursive ( str , X ) NEW_LINE print ( str ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def isValid ( a1 , a2 , strr , flag ) : NEW_LINE INDENT v1 , v2 = 0 , 0 NEW_LINE DEDENT",
        "explain": "Function checks whether given time is correct"
    },
    {
        "py": "if ( flag == 0 ) : NEW_LINE INDENT v1 = strr [ 4 ] NEW_LINE v2 = strr [ 3 ] NEW_LINE DEDENT else : NEW_LINE",
        "explain": "To check minute value of time"
    },
    {
        "py": "v1 = strr [ 1 ] NEW_LINE v2 = strr [ 0 ] NEW_LINE",
        "explain": "To check hour value of time"
    },
    {
        "py": "if ( v1 != a1 and v1 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( v2 != a2 and v2 != ' ? ' ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "Changes in value is not allowed at position where ' ? ' is not present"
    },
    {
        "py": "def inRange ( hh , mm , L , R ) : NEW_LINE INDENT a = abs ( hh - mm ) NEW_LINE DEDENT",
        "explain": "Function checks whether the absolute difference between hour and minute value is within [ L , R ]"
    },
    {
        "py": "if ( a < L or a > R ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "Checks if the difference is outside the give range"
    },
    {
        "py": "def displayTime ( hh , mm ) : NEW_LINE INDENT if ( hh > 10 ) : NEW_LINE INDENT print ( hh , end = \" : \" ) NEW_LINE DEDENT elif ( hh < 10 ) : NEW_LINE INDENT print ( \"0\" , hh , end = \" : \" ) NEW_LINE DEDENT if ( mm > 10 ) : NEW_LINE INDENT print ( mm ) NEW_LINE DEDENT elif ( mm < 10 ) : NEW_LINE INDENT print ( \"0\" , mm ) NEW_LINE DEDENT DEDENT",
        "explain": "Displays time in proper 24 - hour format"
    },
    {
        "py": "def maximumTimeWithDifferenceInRange ( strr , L , R ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE h1 , h2 , m1 , m2 = 0 , 0 , 0 , 0 NEW_LINE DEDENT",
        "explain": "Function find the desired value of time whose difference lies in the range [ L , R ]"
    },
    {
        "py": "for i in range ( 23 , - 1 , - 1 ) : NEW_LINE INDENT h1 = i % 10 NEW_LINE h2 = i // 10 NEW_LINE DEDENT",
        "explain": "Decrease hour value from 23 to 0"
    },
    {
        "py": "if ( not isValid ( chr ( h1 ) , chr ( h2 ) , strr , 1 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Check if the hour value is valid if not valid then no need to change minute value , since time will still remain in valid , to check hour value flag is set to 1."
    },
    {
        "py": "for j in range ( 59 , - 1 , - 1 ) : NEW_LINE INDENT m1 = j % 10 NEW_LINE m2 = j // 10 NEW_LINE DEDENT",
        "explain": "Decrease minute value from 59 to 0"
    },
    {
        "py": "if ( not isValid ( chr ( m1 ) , chr ( m2 ) , strr , 0 ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE INDENT displayTime ( i , j ) NEW_LINE return NEW_LINE DEDENT if ( inRange ( i , j , L , R ) ) : NEW_LINE displayTime ( i , j ) NEW_LINE else : NEW_LINE print ( - 1 ) NEW_LINE",
        "explain": "Check if the minute value is valid , if not valid then skip the current iteration , to check ' minute ' value flag is set to 0."
    },
    {
        "py": "timeValue = \" ? ? : ? ? \" NEW_LINE",
        "explain": "Input time"
    },
    {
        "py": "L = 20 NEW_LINE R = 39 NEW_LINE maximumTimeWithDifferenceInRange ( timeValue , L , R ) NEW_LINE",
        "explain": "Difference range"
    },
    {
        "py": "def check ( s , n ) : NEW_LINE",
        "explain": "Function to check string str can be split a string into even length palindromic substrings"
    },
    {
        "py": "st = [ ] NEW_LINE",
        "explain": "Initialize a stack"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate the string"
    },
    {
        "py": "if ( len ( st ) != 0 and st [ len ( st ) - 1 ] == s [ i ] ) : NEW_LINE INDENT st . pop ( ) ; NEW_LINE DEDENT",
        "explain": "If the i - th character is same as that at the top of the stack then pop the top element"
    },
    {
        "py": "else : NEW_LINE INDENT st . append ( s [ i ] ) ; NEW_LINE DEDENT",
        "explain": "Else push the current charactor into the stack"
    },
    {
        "py": "if ( len ( st ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT",
        "explain": "If the stack is empty , then even palindromic substrings are possible"
    },
    {
        "py": "else : NEW_LINE INDENT return False ; NEW_LINE DEDENT",
        "explain": "Else not - possible"
    },
    {
        "py": "str = \" aanncddc \" ; NEW_LINE n = len ( str ) NEW_LINE",
        "explain": "Given string"
    },
    {
        "py": "if ( check ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "from collections import defaultdict NEW_LINE def findNumOfValidWords ( w , p ) : NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "m = defaultdict ( int ) NEW_LINE",
        "explain": "To store the frequency of string after bitmasking"
    },
    {
        "py": "res = [ ] NEW_LINE",
        "explain": "To store result for each string in arr2 [ ]"
    },
    {
        "py": "for s in w : NEW_LINE INDENT val = 0 NEW_LINE DEDENT",
        "explain": "Traverse the arr1 [ ] and bitmask each string in it"
    },
    {
        "py": "for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT",
        "explain": "Bitmasking for each string s"
    },
    {
        "py": "m [ val ] += 1 NEW_LINE",
        "explain": "Update the frequency of string with it 's bitmasking value"
    },
    {
        "py": "for s in p : NEW_LINE INDENT val = 0 NEW_LINE DEDENT",
        "explain": "Traverse the arr2 [ ]"
    },
    {
        "py": "for c in s : NEW_LINE INDENT val = val | ( 1 << ( ord ( c ) - ord ( ' a ' ) ) ) NEW_LINE DEDENT temp = val NEW_LINE first = ord ( s [ 0 ] ) - ord ( ' a ' ) NEW_LINE count = 0 NEW_LINE while ( temp != 0 ) : NEW_LINE",
        "explain": "Bitmasking for each string s"
    },
    {
        "py": "if ( ( ( temp >> first ) & 1 ) == 1 ) : NEW_LINE INDENT if ( temp in m ) : NEW_LINE INDENT count += m [ temp ] NEW_LINE DEDENT DEDENT",
        "explain": "Check if temp is present in an unordered_map or not"
    },
    {
        "py": "temp = ( temp - 1 ) & val NEW_LINE",
        "explain": "Check for next set bit"
    },
    {
        "py": "res . append ( count ) NEW_LINE",
        "explain": "Push the count for current string in resultant array"
    },
    {
        "py": "for it in res : NEW_LINE INDENT print ( it ) NEW_LINE DEDENT",
        "explain": "Print the count for each string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ \" aaaa \" , \" asas \" , \" able \" , \" ability \" , \" actt \" , \" actor \" , \" access \" ] NEW_LINE arr2 = [ \" aboveyz \" , \" abrodyz \" , \" absolute \" , \" absoryz \" , \" actresz \" , \" gaswxyz \" ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "findNumOfValidWords ( arr1 , arr2 ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def flip ( s ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE DEDENT",
        "explain": "Function to print the binary number"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE",
        "explain": "Check if the current number is 0"
    },
    {
        "py": "while ( s [ i ] == '0' ) : NEW_LINE",
        "explain": "Find the continuous 0 s"
    },
    {
        "py": "s [ i ] = '1' NEW_LINE i += 1 NEW_LINE s = ' ' . join ( map ( str , s ) ) NEW_LINE",
        "explain": "Replace initially occurring 0 with 1"
    },
    {
        "py": "return s NEW_LINE",
        "explain": "return the string and break the loop"
    },
    {
        "py": "s = \"100010001\" NEW_LINE print ( flip ( s ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getOrgString ( s ) : NEW_LINE",
        "explain": "Function to return the original string after converting it back from camelCase"
    },
    {
        "py": "print ( s [ 0 ] , end = \" \" ) NEW_LINE",
        "explain": "Print the first character as it is"
    },
    {
        "py": "i = 1 NEW_LINE while ( i < len ( s ) ) : NEW_LINE",
        "explain": "Traverse the rest of the characters one by one"
    },
    {
        "py": "if ( ord ( s [ i ] ) >= ord ( ' A ' ) and ord ( s [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT print ( \" \u2581 \" , s [ i ] . lower ( ) , end = \" \" ) NEW_LINE DEDENT",
        "explain": "If current character is uppercase prspace followed by the current character in lowercase"
    },
    {
        "py": "else : NEW_LINE INDENT print ( s [ i ] , end = \" \" ) NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "Else print the current character"
    },
    {
        "py": "s = \" ILoveGeeksForGeeks \" NEW_LINE getOrgString ( s ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "' NEW_LINE def countChar ( str , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE DEDENT",
        "explain": "Function to count the character 'a"
    },
    {
        "py": "repetitions = n // len ( str ) NEW_LINE count = count * repetitions NEW_LINE",
        "explain": "atleast k repetition are required"
    },
    {
        "py": "l = n % len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE",
        "explain": "if n is not the multiple of the string size check for the remaining repeating character ."
    },
    {
        "py": "str = \" abcac \" NEW_LINE print ( countChar ( str , ' a ' ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countFreq ( arr , n , limit ) : NEW_LINE",
        "explain": "Python3 program to count frequencies of array items having small values ."
    },
    {
        "py": "count = [ 0 for i in range ( limit + 1 ) ] NEW_LINE",
        "explain": "Create an array to store counts . The size of array is limit + 1 and all values are initially 0"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE INDENT if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( i , count [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Traverse through array elements and count frequencies ( assuming that elements are limited by limit )"
    },
    {
        "py": "arr = [ 5 , 5 , 6 , 6 , 5 , 6 , 1 , 2 , 3 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE limit = 10 NEW_LINE countFreq ( arr , n , limit ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def check ( s , m ) : NEW_LINE",
        "explain": "Function that checks if the binary string contains m consecutive 1 ' s \u2581 or \u2581 0' s"
    },
    {
        "py": "l = len ( s ) ; NEW_LINE",
        "explain": "length of binary string"
    },
    {
        "py": "c1 = 0 ; NEW_LINE",
        "explain": "counts zeros"
    },
    {
        "py": "c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE DEDENT DEDENT",
        "explain": "counts 1 's"
    },
    {
        "py": "c1 = c1 + 1 ; NEW_LINE else : NEW_LINE c1 = 0 ; NEW_LINE",
        "explain": "count consecutive 0 's"
    },
    {
        "py": "c2 = c2 + 1 ; NEW_LINE if ( c1 == m or c2 == m ) : NEW_LINE return True ; NEW_LINE return False ; NEW_LINE",
        "explain": "count consecutive 1 's"
    },
    {
        "py": "s = \"001001\" ; NEW_LINE m = 2 ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "if ( check ( s , m ) ) : NEW_LINE INDENT print ( \" YES \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) ; NEW_LINE DEDENT",
        "explain": "function call"
    },
    {
        "py": "def productAtKthLevel ( tree , k ) : NEW_LINE INDENT level = - 1 NEW_LINE DEDENT",
        "explain": "Function to find product of digits of elements at k - th level"
    },
    {
        "py": "product = 1 NEW_LINE n = len ( tree ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "if ( tree [ i ] == ' ( ' ) : NEW_LINE INDENT level += 1 NEW_LINE DEDENT",
        "explain": "increasing level number"
    },
    {
        "py": "elif ( tree [ i ] == ' ) ' ) : NEW_LINE INDENT level -= 1 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "decreasing level number"
    },
    {
        "py": "if ( level == k ) : NEW_LINE INDENT product *= ( int ( tree [ i ] ) - int ( '0' ) ) NEW_LINE DEDENT",
        "explain": "check if current level is the desired level or not"
    },
    {
        "py": "return product NEW_LINE",
        "explain": "required product"
    },
    {
        "py": "tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE print ( productAtKthLevel ( tree , k ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def findDuplicates ( a , n , m ) : NEW_LINE",
        "explain": "Function to check duplicates in row and column"
    },
    {
        "py": "isPresent = [ [ False for i in range ( n ) ] for j in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT",
        "explain": "Create an array isPresent and initialize all entries of it as false . The value of isPresent [ i ] [ j ] is going to be true if s [ i ] [ j ] is present in its row or column ."
    },
    {
        "py": "for k in range ( n ) : NEW_LINE INDENT if i != k and a [ i ] [ j ] == a [ k ] [ j ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ k ] [ j ] = True NEW_LINE DEDENT DEDENT",
        "explain": "Checking every row for duplicates of a [ i ] [ j ]"
    },
    {
        "py": "for k in range ( m ) : NEW_LINE INDENT if j != k and a [ i ] [ j ] == a [ i ] [ k ] : NEW_LINE INDENT isPresent [ i ] [ j ] = True NEW_LINE isPresent [ i ] [ k ] = True NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE for j in range ( m ) : NEW_LINE",
        "explain": "Checking every row for duplicates of a [ i ] [ j ]"
    },
    {
        "py": "if not isPresent [ i ] [ j ] : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT",
        "explain": "If the character is unique in its row and column"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE m = 2 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "a = [ \" zx \" , \" xz \" ] NEW_LINE",
        "explain": "character array"
    },
    {
        "py": "findDuplicates ( a , n , m ) NEW_LINE",
        "explain": "Calling function"
    },
    {
        "py": "def isValidISBN ( isbn ) : NEW_LINE",
        "explain": "Python code to check if a given ISBN is valid or not ."
    },
    {
        "py": "if len ( isbn ) != 10 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "check for length"
    },
    {
        "py": "_sum = 0 NEW_LINE for i in range ( 9 ) : NEW_LINE INDENT if 0 <= int ( isbn [ i ] ) <= 9 : NEW_LINE INDENT _sum += int ( isbn [ i ] ) * ( 10 - i ) NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Computing weighted sum of first 9 digits"
    },
    {
        "py": "if ( isbn [ 9 ] != ' X ' and 0 <= int ( isbn [ 9 ] ) <= 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Checking last digit"
    },
    {
        "py": "_sum += 10 if isbn [ 9 ] == ' X ' else int ( isbn [ 9 ] ) NEW_LINE",
        "explain": "If last digit is ' X ' , add 10 to sum , else add its value ."
    },
    {
        "py": "return ( _sum % 11 == 0 ) NEW_LINE",
        "explain": "Return true if weighted sum of digits is divisible by 11"
    },
    {
        "py": "isbn = \"007462542X \" NEW_LINE if isValidISBN ( isbn ) : NEW_LINE INDENT print ( ' Valid ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Invalid \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "utility function to check for vowel"
    },
    {
        "py": "def reverserVowel ( string ) : NEW_LINE INDENT j = 0 NEW_LINE vowel = [ 0 ] * len ( string ) NEW_LINE string = list ( string ) NEW_LINE DEDENT",
        "explain": "Function to reverse order of vowels"
    },
    {
        "py": "for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT vowel [ j ] = string [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Storing the vowels separately"
    },
    {
        "py": "for i in range ( len ( string ) ) : NEW_LINE INDENT if isVowel ( string [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE string [ i ] = vowel [ j ] NEW_LINE DEDENT DEDENT return ' ' . join ( string ) NEW_LINE",
        "explain": "Placing the vowels in the reverse order in the string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" hello \u2581 world \" NEW_LINE print ( reverserVowel ( string ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def firstLetterWord ( str ) : NEW_LINE INDENT result = \" \" NEW_LINE DEDENT",
        "explain": "Function to find string which has first character of each word ."
    },
    {
        "py": "v = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE",
        "explain": "Traverse the string ."
    },
    {
        "py": "if ( str [ i ] == ' \u2581 ' ) : NEW_LINE INDENT v = True NEW_LINE DEDENT",
        "explain": "If it is space , set v as true ."
    },
    {
        "py": "elif ( str [ i ] != ' \u2581 ' and v == True ) : NEW_LINE INDENT result += ( str [ i ] ) NEW_LINE v = False NEW_LINE DEDENT return result NEW_LINE",
        "explain": "Else check if v is true or not . If true , copy character in output string and set v as false ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeks \u2581 for \u2581 geeks \" NEW_LINE print ( firstLetterWord ( str ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def dfs ( i , j , grid , vis , ans , z , z_count ) : NEW_LINE INDENT n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE DEDENT",
        "explain": "Function for dfs . i , j == > Current cell indexes vis == > To mark visited cells ans == > Result z == > Current count 0 s visited z_count == > Total 0 s present"
    },
    {
        "py": "vis [ i ] [ j ] = 1 NEW_LINE if ( grid [ i ] [ j ] == 0 ) : NEW_LINE",
        "explain": "Mark the block as visited"
    },
    {
        "py": "z += 1 NEW_LINE",
        "explain": "Update the count"
    },
    {
        "py": "if ( grid [ i ] [ j ] == 2 ) : NEW_LINE",
        "explain": "If end block reached"
    },
    {
        "py": "if ( z == z_count ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE",
        "explain": "If path covered all the non - obstacle blocks"
    },
    {
        "py": "if ( i >= 1 and not vis [ i - 1 ] [ j ] and grid [ i - 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i - 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT",
        "explain": "Up"
    },
    {
        "py": "if ( i < n - 1 and not vis [ i + 1 ] [ j ] and grid [ i + 1 ] [ j ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i + 1 , j , grid , vis , ans , z , z_count ) NEW_LINE DEDENT",
        "explain": "Down"
    },
    {
        "py": "if ( j >= 1 and not vis [ i ] [ j - 1 ] and grid [ i ] [ j - 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j - 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT",
        "explain": "Left"
    },
    {
        "py": "if ( j < m - 1 and not vis [ i ] [ j + 1 ] and grid [ i ] [ j + 1 ] != - 1 ) : NEW_LINE INDENT grid , vis , ans = dfs ( i , j + 1 , grid , vis , ans , z , z_count ) NEW_LINE DEDENT",
        "explain": "Right"
    },
    {
        "py": "vis [ i ] [ j ] = 0 NEW_LINE return grid , vis , ans NEW_LINE",
        "explain": "Unmark the block ( unvisited )"
    },
    {
        "py": "def uniquePaths ( grid ) : NEW_LINE",
        "explain": "Function to return the count of the unique paths"
    },
    {
        "py": "z_count = 0 NEW_LINE n = len ( grid ) NEW_LINE m = len ( grid [ 0 ] ) NEW_LINE ans = 0 NEW_LINE vis = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT",
        "explain": "Total 0 s present"
    },
    {
        "py": "if grid [ i ] [ j ] == 0 : NEW_LINE INDENT z_count += 1 NEW_LINE DEDENT elif ( grid [ i ] [ j ] == 1 ) : NEW_LINE",
        "explain": "Count non - obstacle blocks"
    },
    {
        "py": "x = i NEW_LINE y = j NEW_LINE grid , vis , ans = dfs ( x , y , grid , vis , ans , 0 , z_count ) NEW_LINE return ans NEW_LINE",
        "explain": "Starting position"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT grid = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 2 , - 1 ] ] NEW_LINE print ( uniquePaths ( grid ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def numPairs ( a , n ) : NEW_LINE",
        "explain": "Return the number of unordered pairs satisfying the conditions"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "ans stores the number of unordered pairs"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT",
        "explain": "Making each value of array to positive"
    },
    {
        "py": "a . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT index = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( 2 * a [ i ] >= a [ j - 1 ] and 2 * a [ i ] < a [ j ] ) : NEW_LINE INDENT index = j NEW_LINE DEDENT DEDENT if index == 0 : NEW_LINE INDENT index = n NEW_LINE DEDENT ans += index - i - 1 NEW_LINE DEDENT",
        "explain": "For each index calculating the right boundary for the unordered pairs"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the final result"
    },
    {
        "py": "a = [ 3 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( numPairs ( a , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def areaOfSquare ( S ) : NEW_LINE",
        "explain": "Function to find the area of a square"
    },
    {
        "py": "area = S * S NEW_LINE return area NEW_LINE",
        "explain": "Use above formula"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "S = 5 NEW_LINE",
        "explain": "Given Side of square"
    },
    {
        "py": "print ( areaOfSquare ( S ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def maxPointOfIntersection ( x , y ) : NEW_LINE INDENT k = y * ( y - 1 ) // 2 NEW_LINE k = k + x * ( 2 * y + x - 1 ) NEW_LINE return k NEW_LINE DEDENT",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "x = 3 NEW_LINE",
        "explain": "Number of circles"
    },
    {
        "py": "y = 4 NEW_LINE",
        "explain": "Number of straight lines"
    },
    {
        "py": "print ( maxPointOfIntersection ( x , y ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def Icosihenagonal_num ( n ) : NEW_LINE",
        "explain": "Function to find icosihenagonal number"
    },
    {
        "py": "return ( 19 * n * n - 17 * n ) / 2 NEW_LINE",
        "explain": "Formula to calculate nth icosihenagonal number"
    },
    {
        "py": "n = 3 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icosihenagonal_num ( n ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def find_Centroid ( v ) : NEW_LINE INDENT ans = [ 0 , 0 ] NEW_LINE n = len ( v ) NEW_LINE signedArea = 0 NEW_LINE DEDENT",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "for i in range ( len ( v ) ) : NEW_LINE INDENT x0 = v [ i ] [ 0 ] NEW_LINE y0 = v [ i ] [ 1 ] NEW_LINE x1 = v [ ( i + 1 ) % n ] [ 0 ] NEW_LINE y1 = v [ ( i + 1 ) % n ] [ 1 ] NEW_LINE DEDENT",
        "explain": "For all vertices"
    },
    {
        "py": "A = ( x0 * y1 ) - ( x1 * y0 ) NEW_LINE signedArea += A NEW_LINE",
        "explain": "Calculate value of A using shoelace formula"
    },
    {
        "py": "ans [ 0 ] += ( x0 + x1 ) * A NEW_LINE ans [ 1 ] += ( y0 + y1 ) * A NEW_LINE signedArea *= 0.5 NEW_LINE ans [ 0 ] = ( ans [ 0 ] ) / ( 6 * signedArea ) NEW_LINE ans [ 1 ] = ( ans [ 1 ] ) / ( 6 * signedArea ) NEW_LINE return ans NEW_LINE",
        "explain": "Calculating coordinates of centroid of polygon"
    },
    {
        "py": "vp = [ [ 1 , 2 ] , [ 3 , - 4 ] , [ 6 , - 7 ] ] NEW_LINE ans = find_Centroid ( vp ) NEW_LINE print ( round ( ans [ 0 ] , 12 ) , ans [ 1 ] ) NEW_LINE",
        "explain": "Coordinate of the vertices"
    },
    {
        "py": "d = 10 NEW_LINE a = 0.0 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "a = ( 360 - ( 6 * d ) ) / 4 NEW_LINE",
        "explain": "according to formula derived above"
    },
    {
        "py": "print ( a , \" , \" , a + d , \" , \" , a + 2 * d , \" , \" , a + 3 * d , sep = ' \u2581 ' ) NEW_LINE",
        "explain": "print all the angles"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program to find the Distance between two parallel Planes in 3 D ."
    },
    {
        "py": "def distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) : NEW_LINE INDENT if ( a1 / a2 == b1 / b2 and b1 / b2 == c1 / c2 ) : NEW_LINE INDENT x1 = y1 = 0 NEW_LINE z1 = - d1 / c1 NEW_LINE d = abs ( ( c2 * z1 + d2 ) ) / ( math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ) NEW_LINE print ( \" Perpendicular \u2581 distance \u2581 is \" ) , d NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Planes \u2581 are \u2581 not \u2581 parallel \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to find distance"
    },
    {
        "py": "a1 = 1 NEW_LINE b1 = 2 NEW_LINE c1 = - 1 NEW_LINE d1 = 1 NEW_LINE a2 = 3 NEW_LINE b2 = 6 NEW_LINE c2 = - 3 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , d1 , a2 , b2 , c2 , d2 ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT",
        "explain": "Function to calculate factorial"
    },
    {
        "py": "def numOfNecklace ( N ) : NEW_LINE",
        "explain": "Function to count number of ways to make 2 necklace having exactly N / 2 beads if each bead is considered different"
    },
    {
        "py": "ans = factorial ( N ) // ( factorial ( N // 2 ) * factorial ( N // 2 ) ) NEW_LINE",
        "explain": "Number of ways to choose N / 2 beads from N beads"
    },
    {
        "py": "ans = ans * factorial ( N // 2 - 1 ) NEW_LINE ans = ans * factorial ( N // 2 - 1 ) NEW_LINE",
        "explain": "Number of ways to permute N / 2 beads"
    },
    {
        "py": "ans //= 2 NEW_LINE",
        "explain": "Divide ans by 2 to remove repetitions"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return ans"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( numOfNecklace ( N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def isDivisibleByDivisor ( S , D ) : NEW_LINE",
        "explain": "Function to check if S is divisible by D while changing S to ( S + S % D )"
    },
    {
        "py": "S %= D NEW_LINE",
        "explain": "V ( 0 ) = S % D"
    },
    {
        "py": "hashMap = set ( ) NEW_LINE hashMap . add ( S ) NEW_LINE for i in range ( D + 1 ) : NEW_LINE",
        "explain": "Stores the encountered values"
    },
    {
        "py": "S += ( S % D ) NEW_LINE S %= D NEW_LINE",
        "explain": "V ( i ) = ( V ( i - 1 ) + V ( i - 1 ) % D ) % D"
    },
    {
        "py": "if ( S in hashMap ) : NEW_LINE",
        "explain": "Check if the value has already been encountered"
    },
    {
        "py": "if ( S == 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT return \" No \" NEW_LINE",
        "explain": "Edge Case"
    },
    {
        "py": "else : NEW_LINE INDENT hashMap . add ( S ) NEW_LINE DEDENT return \" Yes \" NEW_LINE",
        "explain": "Otherwise , insert it into the hashmap"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = 3 NEW_LINE D = 6 NEW_LINE print ( isDivisibleByDivisor ( S , D ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minimumSteps ( x , y ) : NEW_LINE",
        "explain": "Function to count the number of steps required to convert ( x , y ) to ( 1 , 1 )"
    },
    {
        "py": "cnt = 0 NEW_LINE",
        "explain": "Store the required result"
    },
    {
        "py": "while ( x != 0 and y != 0 ) : NEW_LINE",
        "explain": "Iterate while both x and y are not equal to 0"
    },
    {
        "py": "if ( x > y ) : NEW_LINE",
        "explain": "If x is greater than y"
    },
    {
        "py": "cnt += x / y NEW_LINE x %= y NEW_LINE",
        "explain": "Update count and value of x"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "cnt += y / x NEW_LINE y %= x NEW_LINE cnt -= 1 NEW_LINE",
        "explain": "Update count and value of y"
    },
    {
        "py": "if ( x > 1 or y > 1 ) : NEW_LINE INDENT cnt = - 1 NEW_LINE DEDENT",
        "explain": "If both x and y > 1"
    },
    {
        "py": "print ( int ( cnt ) ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "x = 3 NEW_LINE y = 1 NEW_LINE minimumSteps ( x , y ) NEW_LINE",
        "explain": "Given X and Y"
    },
    {
        "py": "def countMinReversals ( expr ) : NEW_LINE INDENT lenn = len ( expr ) NEW_LINE DEDENT",
        "explain": "Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced ."
    },
    {
        "py": "if ( lenn % 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "length of expression must be even to make it balanced by using reversals ."
    },
    {
        "py": "s = [ ] NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( expr [ i ] == ' ' and len ( s ) ) : NEW_LINE INDENT if ( s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT s . insert ( 0 , expr [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "After this loop , stack contains unbalanced part of expression , i . e . , expression of the form \" . . . . \""
    },
    {
        "py": "red_len = len ( s ) NEW_LINE",
        "explain": "Length of the reduced expression red_len = ( m + n )"
    },
    {
        "py": "n = 0 NEW_LINE while ( len ( s ) and s [ 0 ] == ' ' ) : NEW_LINE INDENT s . pop ( 0 ) NEW_LINE n += 1 NEW_LINE DEDENT",
        "explain": "count opening brackets at the end of stack"
    },
    {
        "py": "return ( red_len // 2 + n % 2 ) NEW_LINE",
        "explain": "return ceil ( m / 2 ) + ceil ( n / 2 ) which is actually equal to ( m + n ) / 2 + n % 2 when m + n is even ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr = \" } } { { \" NEW_LINE print ( countMinReversals ( expr . strip ( ) ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def PrintMinNumberForPattern ( arr ) : NEW_LINE",
        "explain": "Prints the minimum number that can be formed from input sequence of I ' s \u2581 and \u2581 D ' s"
    },
    {
        "py": "curr_max = 0 NEW_LINE",
        "explain": "Initialize current_max ( to make sure that we don 't use repeated character"
    },
    {
        "py": "last_entry = 0 NEW_LINE i = 0 NEW_LINE",
        "explain": "Initialize last_entry ( Keeps track for last printed digit )"
    },
    {
        "py": "while i < len ( arr ) : NEW_LINE",
        "explain": "Iterate over input array"
    },
    {
        "py": "noOfNextD = 0 NEW_LINE if arr [ i ] == \" I \" : NEW_LINE",
        "explain": "Initialize ' noOfNextD ' to get count of next D 's available"
    },
    {
        "py": "j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT if i == 0 : NEW_LINE INDENT curr_max = noOfNextD + 2 NEW_LINE last_entry += 1 NEW_LINE DEDENT",
        "explain": "If letter is ' I ' Calculate number of next consecutive D 's  available"
    },
    {
        "py": "print ( \" \" , last_entry , end = \" \" ) NEW_LINE print ( \" \" , curr_max , end = \" \" ) NEW_LINE",
        "explain": "If ' I ' is first letter , print incremented sequence from 1"
    },
    {
        "py": "last_entry = curr_max NEW_LINE else : NEW_LINE",
        "explain": "Set max digit reached"
    },
    {
        "py": "curr_max += noOfNextD + 1 NEW_LINE",
        "explain": "If not first letter Get next digit to print"
    },
    {
        "py": "last_entry = curr_max NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE",
        "explain": "Print digit for I"
    },
    {
        "py": "for k in range ( noOfNextD ) : NEW_LINE INDENT last_entry -= 1 NEW_LINE print ( \" \" , last_entry , end = \" \" ) NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "For all next consecutive ' D ' print decremented sequence"
    },
    {
        "py": "elif arr [ i ] == \" D \" : NEW_LINE INDENT if i == 0 : NEW_LINE DEDENT",
        "explain": "If letter is 'D"
    },
    {
        "py": "j = i + 1 NEW_LINE while j < len ( arr ) and arr [ j ] == \" D \" : NEW_LINE INDENT noOfNextD += 1 NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "If ' D ' is first letter in sequence Find number of Next D 's available"
    },
    {
        "py": "curr_max = noOfNextD + 2 NEW_LINE",
        "explain": "Calculate first digit to print based on number of consecutive D 's"
    },
    {
        "py": "print ( \" \" , curr_max , curr_max - 1 , end = \" \" ) NEW_LINE",
        "explain": "Print twice for the first time"
    },
    {
        "py": "last_entry = curr_max - 1 NEW_LINE else : NEW_LINE",
        "explain": "Store last entry"
    },
    {
        "py": "print ( \" \" , last_entry - 1 , end = \" \" ) NEW_LINE last_entry -= 1 NEW_LINE i += 1 NEW_LINE print ( ) NEW_LINE",
        "explain": "If current ' D ' is not first letter Decrement last_entry"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printLeast ( arr ) : NEW_LINE",
        "explain": "Python3 program to print minimum number that can be formed from a given sequence of Is and Ds"
    },
    {
        "py": "min_avail = 1 NEW_LINE pos_of_I = 0 NEW_LINE",
        "explain": "min_avail represents the minimum number which is still available for inserting in the output vector . pos_of_I keeps track of the most recent index where ' I ' was encountered w . r . t the output vector"
    },
    {
        "py": "v = [ ] NEW_LINE",
        "explain": "Vector to store the output"
    },
    {
        "py": "if ( arr [ 0 ] == ' I ' ) : NEW_LINE INDENT v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( 2 ) NEW_LINE v . append ( 1 ) NEW_LINE min_avail = 3 NEW_LINE pos_of_I = 0 NEW_LINE DEDENT",
        "explain": "Cover the base cases"
    },
    {
        "py": "for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] == ' I ' ) : NEW_LINE INDENT v . append ( min_avail ) NEW_LINE min_avail += 1 NEW_LINE pos_of_I = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT v . append ( v [ i ] ) NEW_LINE for j in range ( pos_of_I , i + 1 ) : NEW_LINE INDENT v [ j ] += 1 NEW_LINE DEDENT min_avail += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse rest of the input"
    },
    {
        "py": "print ( * v , sep = ' \u2581 ' ) NEW_LINE",
        "explain": "Print the number"
    },
    {
        "py": "printLeast ( \" IDID \" ) NEW_LINE printLeast ( \" I \" ) NEW_LINE printLeast ( \" DD \" ) NEW_LINE printLeast ( \" II \" ) NEW_LINE printLeast ( \" DIDI \" ) NEW_LINE printLeast ( \" IIDDD \" ) NEW_LINE printLeast ( \" DDIDDIID \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def PrintMinNumberForPattern ( Strr ) : NEW_LINE",
        "explain": "Function to decode the given sequence to construct minimum number without repeated digits"
    },
    {
        "py": "res = ' ' NEW_LINE",
        "explain": "String for storing result"
    },
    {
        "py": "stack = [ ] NEW_LINE",
        "explain": "Take a List to work as Stack"
    },
    {
        "py": "for i in range ( len ( Strr ) + 1 ) : NEW_LINE",
        "explain": "run n + 1 times where n is length of input sequence , As length of result string is always 1 greater"
    },
    {
        "py": "stack . append ( i + 1 ) NEW_LINE",
        "explain": "Push number i + 1 into the stack"
    },
    {
        "py": "if ( i == len ( Strr ) or Strr [ i ] == ' I ' ) : NEW_LINE",
        "explain": "If all characters of the input sequence are processed or current character is 'I"
    },
    {
        "py": "while len ( stack ) > 0 : NEW_LINE",
        "explain": "Run While Loop Untill stack is empty"
    },
    {
        "py": "res += str ( stack . pop ( ) ) NEW_LINE res += ' \u2581 ' NEW_LINE print ( res ) NEW_LINE",
        "explain": "pop the element on top of stack And store it in result String"
    },
    {
        "py": "PrintMinNumberForPattern ( \" IDID \" ) NEW_LINE PrintMinNumberForPattern ( \" I \" ) NEW_LINE PrintMinNumberForPattern ( \" DD \" ) NEW_LINE PrintMinNumberForPattern ( \" II \" ) NEW_LINE PrintMinNumberForPattern ( \" DIDI \" ) NEW_LINE PrintMinNumberForPattern ( \" IIDDD \" ) NEW_LINE PrintMinNumberForPattern ( \" DDIDDIID \" ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def getMinNumberForPattern ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE if ( n >= 9 ) : NEW_LINE INDENT return \" - 1\" NEW_LINE DEDENT result = [ None ] * ( n + 1 ) NEW_LINE count = 1 NEW_LINE DEDENT",
        "explain": "Returns minimum number made from given sequence without repeating digits"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT if ( i == n or seq [ i ] == ' I ' ) : NEW_LINE INDENT for j in range ( i - 1 , - 2 , - 1 ) : NEW_LINE INDENT result [ j + 1 ] = int ( '0' + str ( count ) ) NEW_LINE count += 1 NEW_LINE if ( j >= 0 and seq [ j ] == ' I ' ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE",
        "explain": "The loop runs for each input character as well as one additional time for assigning rank to remaining characters"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inputs = [ \" IDID \" , \" I \" , \" DD \" , \" II \" , \" DIDI \" , \" IIDDD \" , \" DDIDDIID \" ] NEW_LINE for Input in inputs : NEW_LINE INDENT print ( * ( getMinNumberForPattern ( Input ) ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE INDENT i , c = 0 , 0 NEW_LINE for i in range ( 1 , n // 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "function to check prime"
    },
    {
        "py": "def findMinNum ( arr , n ) : NEW_LINE",
        "explain": "Function to generate smallest possible number with given digits"
    },
    {
        "py": "first , last = 0 , 0 NEW_LINE Hash = [ 0 for i in range ( 10 ) ] NEW_LINE",
        "explain": "Declare a Hash array of size 10 and initialize all the elements to zero"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT Hash [ arr [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "store the number of occurrences of the digits in the given array into the Hash table"
    },
    {
        "py": "print ( \" Minimum \u2581 number : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE",
        "explain": "Traverse the Hash in ascending order to print the required number"
    },
    {
        "py": "for j in range ( Hash [ i ] ) : NEW_LINE INDENT print ( i , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the number of times a digits occurs"
    },
    {
        "py": "for i in range ( 10 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "extracting the first digit"
    },
    {
        "py": "for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT if ( Hash [ i ] != 0 ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT num = first * 10 + last NEW_LINE rev = last * 10 + first NEW_LINE",
        "explain": "extracting the last digit"
    },
    {
        "py": "print ( \" Prime \u2581 combinations : \u2581 \" , end = \" \" ) NEW_LINE if ( isPrime ( num ) and isPrime ( rev ) ) : NEW_LINE INDENT print ( num , \" \u2581 \" , rev ) NEW_LINE DEDENT elif ( isPrime ( num ) ) : NEW_LINE INDENT print ( num ) NEW_LINE DEDENT elif ( isPrime ( rev ) ) : NEW_LINE INDENT print ( rev ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 combinations \u2581 exist \" ) NEW_LINE DEDENT",
        "explain": "printing the prime combinations"
    },
    {
        "py": "arr = [ 1 , 2 , 4 , 7 , 8 ] NEW_LINE findMinNum ( arr , 5 ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT",
        "explain": "Function to return gcd of a and b"
    },
    {
        "py": "def coprime ( a , b ) : NEW_LINE",
        "explain": "function to check for gcd"
    },
    {
        "py": "return ( gcd ( a , b ) == 1 ) ; NEW_LINE",
        "explain": "a and b are coprime if their gcd is 1."
    },
    {
        "py": "def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE DEDENT",
        "explain": "Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt"
    },
    {
        "py": "for a in range ( L , R + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , R + 1 ) : NEW_LINE INDENT for c in range ( b + 1 , R + 1 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Generate and check for all possible triplets between L and R"
    },
    {
        "py": "if ( coprime ( a , b ) and coprime ( b , c ) and coprime ( a , c ) == False ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = a ; NEW_LINE possibleB = b ; NEW_LINE possibleC = c ; NEW_LINE break ; NEW_LINE DEDENT",
        "explain": "if we find any such triplets set flag to true"
    },
    {
        "py": "if ( flag == True ) : NEW_LINE INDENT print ( \" ( \" , possibleA , \" , \" , possibleB , \" , \" , possibleC , \" ) \u2581 is \u2581 one \u2581 such \" , \" possible \u2581 triplet \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Such \u2581 Triplet \u2581 exists \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT",
        "explain": "flag = True indicates that a pair exists between L and R"
    },
    {
        "py": "L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE",
        "explain": "finding possible Triplet between 2 and 10"
    },
    {
        "py": "L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE",
        "explain": "finding possible Triplet between 23 and 46"
    },
    {
        "py": "import numpy as np NEW_LINE",
        "explain": "Python 3 program to determine if A and B can be reached starting from 1 , 1 following the given steps ."
    },
    {
        "py": "def possibleToReach ( a , b ) : NEW_LINE",
        "explain": "function to check is it is possible to reach A and B starting from 1 and 1"
    },
    {
        "py": "c = np . cbrt ( a * b ) NEW_LINE",
        "explain": "find the cuberoot of the number"
    },
    {
        "py": "re1 = a // c NEW_LINE re2 = b // c NEW_LINE",
        "explain": "divide the number by cuberoot"
    },
    {
        "py": "if ( ( re1 * re1 * re2 == a ) and ( re2 * re2 * re1 == b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "if it is a perfect cuberoot and divides a and b"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 60 NEW_LINE B = 450 NEW_LINE if ( possibleToReach ( A , B ) ) : NEW_LINE INDENT print ( \" yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" no \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def isUndulating ( n ) : NEW_LINE",
        "explain": "Python3 program to check whether a number is undulating or not"
    },
    {
        "py": "if ( len ( n ) <= 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Considering the definition with restriction that there should be at least 3 digits"
    },
    {
        "py": "for i in range ( 2 , len ( n ) ) : NEW_LINE INDENT if ( n [ i - 2 ] != n [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "Check if all alternate digits are same or not ."
    },
    {
        "py": "n = \"1212121\" NEW_LINE if ( isUndulating ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def Series ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sums += ( i * i ) ; NEW_LINE DEDENT return sums NEW_LINE DEDENT",
        "explain": "Function to calculate the following series"
    },
    {
        "py": "n = 3 NEW_LINE res = Series ( n ) NEW_LINE print ( res ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Efficient python program to count numbers with last digit as k in given range ."
    },
    {
        "py": "def counLastDigitK ( low , high , k ) : NEW_LINE INDENT mlow = 10 * math . ceil ( low / 10.0 ) NEW_LINE mhigh = 10 * int ( high / 10.0 ) NEW_LINE count = ( mhigh - mlow ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 <= k and ( low % 10 ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT",
        "explain": "Returns count of numbers with k as last digit ."
    },
    {
        "py": "low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "sdef sumDivisible ( L , R ) : NEW_LINE",
        "explain": "function to calculate the sum of all numbers divisible by 6 in range L - R . ."
    },
    {
        "py": "p = int ( R / 6 ) NEW_LINE",
        "explain": "no of multiples of 6 upto r"
    },
    {
        "py": "q = int ( ( L - 1 ) / 6 ) NEW_LINE",
        "explain": "no of multiples of 6 upto l - 1"
    },
    {
        "py": "sumR = 3 * ( p * ( p + 1 ) ) NEW_LINE",
        "explain": "summation of all multiples of 6 upto r"
    },
    {
        "py": "sumL = ( q * ( q + 1 ) ) * 3 NEW_LINE",
        "explain": "summation of all multiples of 6 upto l - 1"
    },
    {
        "py": "return sumR - sumL NEW_LINE",
        "explain": "returns the answer"
    },
    {
        "py": "L = 1 NEW_LINE R = 20 NEW_LINE print ( sumDivisible ( L , R ) ) NEW_LINE",
        "explain": "driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program to find the largest smaller number by swapping one digit ."
    },
    {
        "py": "def prevNum ( string , n ) : NEW_LINE INDENT index = - 1 NEW_LINE DEDENT",
        "explain": "Returns largest possible number with one swap such that the number is smaller than str . It is assumed that there are leading 0 s ."
    },
    {
        "py": "for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if int ( string [ i ] ) > int ( string [ i + 1 ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Traverse from right until we find a digit which is greater than its next digit . For example , in 34125 , our index is 4."
    },
    {
        "py": "smallGreatDgt = - 1 NEW_LINE for i in range ( n - 1 , index , - 1 ) : NEW_LINE INDENT if ( smallGreatDgt == - 1 and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT elif ( index > - 1 and int ( string [ i ] ) >= int ( string [ smallGreatDgt ] ) and int ( string [ i ] ) < int ( string [ index ] ) ) : NEW_LINE INDENT smallGreatDgt = i NEW_LINE DEDENT DEDENT",
        "explain": "We can also use binary search here as digits after index are sorted in increasing order . Find the biggest digit in the right of arr [ index ] which is smaller than arr [ index ]"
    },
    {
        "py": "if index == - 1 : NEW_LINE INDENT return \" \" . join ( \" - 1\" ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If index is - 1 i . e . digits are in increasing order ."
    },
    {
        "py": "( string [ index ] , string [ smallGreatDgt ] ) = ( string [ smallGreatDgt ] , string [ index ] ) NEW_LINE return \" \" . join ( string ) NEW_LINE",
        "explain": "Swap both values"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n_str = \"34125\" NEW_LINE ans = prevNum ( list ( n_str ) , len ( n_str ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def horner ( poly , n , x ) : NEW_LINE",
        "explain": "returns value of poly [ 0 ] x ( n - 1 ) + poly [ 1 ] x ( n - 2 ) + . . + poly [ n - 1 ]"
    },
    {
        "py": "result = poly [ 0 ] ; NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT result = ( result * x + poly [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE",
        "explain": "Evaluate value of polynomial using Horner 's method"
    },
    {
        "py": "def findSign ( poly , n , x ) : NEW_LINE INDENT result = horner ( poly , n , x ) ; NEW_LINE if ( result > 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( result < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Returns sign value of polynomial"
    },
    {
        "py": "poly = [ 2 , - 6 , 2 , - 1 ] ; NEW_LINE x = 3 ; NEW_LINE n = len ( poly ) ; NEW_LINE print ( \" Sign \u2581 of \u2581 polynomial \u2581 is \u2581 \" , findSign ( poly , n , x ) ) ; NEW_LINE",
        "explain": "Let us evaluate value of 2 x3 - 6 x2 + 2 x - 1 for x = 3"
    },
    {
        "py": "isPrime = [ 1 ] * 100005 NEW_LINE",
        "explain": "Python3 program to find minimum number to insert in array so their sum is prime"
    },
    {
        "py": "def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT",
        "explain": "function to calculate prime using sieve of eratosthenes"
    },
    {
        "py": "def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE DEDENT",
        "explain": "Find prime number greater than a number"
    },
    {
        "py": "while ( num ) : NEW_LINE",
        "explain": "find prime greater than n"
    },
    {
        "py": "if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT",
        "explain": "check if num is prime"
    },
    {
        "py": "num += 1 NEW_LINE return 0 NEW_LINE",
        "explain": "Increment num"
    },
    {
        "py": "def minNumber ( arr ) : NEW_LINE",
        "explain": "To find number to be added so sum of array is prime"
    },
    {
        "py": "sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE",
        "explain": "call sieveOfEratostheneses to calculate primes"
    },
    {
        "py": "for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT",
        "explain": "To find sum of array elements"
    },
    {
        "py": "if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If sum is already prime return 0"
    },
    {
        "py": "num = findPrime ( s ) NEW_LINE",
        "explain": "To find prime number greater than sum"
    },
    {
        "py": "return num - s NEW_LINE",
        "explain": "Return difference of sum and num"
    },
    {
        "py": "arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def SubArraySum ( arr , n ) : NEW_LINE INDENT temp , result = 0 , 0 NEW_LINE DEDENT",
        "explain": "Computes sum all sub - array"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Pick starting point"
    },
    {
        "py": "temp = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE",
        "explain": "Pick ending point"
    },
    {
        "py": "temp += arr [ j ] NEW_LINE result += temp NEW_LINE return result NEW_LINE",
        "explain": "sum subarray between current starting and ending points"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum \u2581 of \u2581 SubArray \u2581 : \" , SubArraySum ( arr , n ) ) NEW_LINE",
        "explain": "driver program"
    },
    {
        "py": "import math NEW_LINE def highestPowerof2 ( n ) : NEW_LINE INDENT p = int ( math . log ( n , 2 ) ) ; NEW_LINE return int ( pow ( 2 , p ) ) ; NEW_LINE DEDENT",
        "explain": "Python3 program to find highest power of 2 smaller than or equal to n ."
    },
    {
        "py": "n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "' NEW_LINE",
        "explain": "Python program to find ( a ^ b ) mod m for a large 'a"
    },
    {
        "py": "def aModM ( s , mod ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE DEDENT",
        "explain": "utility function to calculate a % m"
    },
    {
        "py": "number = ( number * 10 + int ( s [ i ] ) ) NEW_LINE number = number % m NEW_LINE return number NEW_LINE",
        "explain": "convert string s [ i ] to integer which gives the digit value and form the number"
    },
    {
        "py": "def ApowBmodM ( a , b , m ) : NEW_LINE",
        "explain": "Returns find ( a ^ b ) % m"
    },
    {
        "py": "ans = aModM ( a , m ) NEW_LINE mul = ans NEW_LINE",
        "explain": "Find a % m"
    },
    {
        "py": "for i in range ( 1 , b ) : NEW_LINE INDENT ans = ( ans * mul ) % m NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "now multiply ans by b - 1 times and take mod with m"
    },
    {
        "py": "a = \"987584345091051645734583954832576\" NEW_LINE b , m = 3 , 11 NEW_LINE print ApowBmodM ( a , b , m ) NEW_LINE",
        "explain": "Driver program to run the case"
    },
    {
        "py": "class Data : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT",
        "explain": "To represent a data point corresponding to x and y = f ( x )"
    },
    {
        "py": "def interpolate ( f : list , xi : int , n : int ) -> float : NEW_LINE",
        "explain": "function to interpolate the given data points using Lagrange 's formula xi -> corresponds to the new data point whose value is to be obtained n -> represents the number of known data points"
    },
    {
        "py": "result = 0.0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "term = f [ i ] . y NEW_LINE for j in range ( n ) : NEW_LINE INDENT if j != i : NEW_LINE INDENT term = term * ( xi - f [ j ] . x ) / ( f [ i ] . x - f [ j ] . x ) NEW_LINE DEDENT DEDENT",
        "explain": "Compute individual terms of above formula"
    },
    {
        "py": "result += term NEW_LINE return result NEW_LINE",
        "explain": "Add current term to result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "f = [ Data ( 0 , 2 ) , Data ( 1 , 3 ) , Data ( 2 , 12 ) , Data ( 5 , 147 ) ] NEW_LINE",
        "explain": "creating an array of 4 known data points"
    },
    {
        "py": "print ( \" Value \u2581 of \u2581 f ( 3 ) \u2581 is \u2581 : \" , interpolate ( f , 3 , 4 ) ) NEW_LINE",
        "explain": "Using the interpolate function to obtain a data point corresponding to x = 3"
    },
    {
        "py": "def SieveOfSundaram ( n ) : NEW_LINE",
        "explain": "Prints all prime numbers smaller"
    },
    {
        "py": "nNew = int ( ( n - 1 ) / 2 ) ; NEW_LINE",
        "explain": "In general Sieve of Sundaram , produces primes smaller than ( 2 * x + 2 ) for a number given number x . Since we want primes smaller than n , we reduce n to half"
    },
    {
        "py": "marked = [ 0 ] * ( nNew + 1 ) ; NEW_LINE",
        "explain": "This array is used to separate numbers of the form i + j + 2 ij from others where 1 <= i <= j Initialize all elements as not marked"
    },
    {
        "py": "for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT j = i ; NEW_LINE while ( ( i + j + 2 * i * j ) <= nNew ) : NEW_LINE INDENT marked [ i + j + 2 * i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Main logic of Sundaram . Mark all numbers of the form i + j + 2 ij as true where 1 <= i <= j"
    },
    {
        "py": "if ( n > 2 ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Since 2 is a prime number"
    },
    {
        "py": "for i in range ( 1 , nNew + 1 ) : NEW_LINE INDENT if ( marked [ i ] == 0 ) : NEW_LINE INDENT print ( ( 2 * i + 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Print other primes . Remaining primes are of the form 2 * i + 1 such that marked [ i ] is false ."
    },
    {
        "py": "n = 20 ; NEW_LINE SieveOfSundaram ( n ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def constructArray ( A , N , K ) : NEW_LINE",
        "explain": "Function to construct an array with each element equal to XOR of all array elements except the element at the same index"
    },
    {
        "py": "B = [ 0 ] * N ; NEW_LINE",
        "explain": "Original array"
    },
    {
        "py": "totalXOR = A [ 0 ] ^ K ; NEW_LINE",
        "explain": "Stores Bitwise XOR of array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT B [ i ] = totalXOR ^ A [ i ] ; NEW_LINE DEDENT",
        "explain": "Calculate XOR of all array elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Print the original array B"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 13 , 14 , 10 , 6 ] ; NEW_LINE K = 2 ; NEW_LINE N = len ( A ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "constructArray ( A , N , K ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def extraElement ( A , B , n ) : NEW_LINE",
        "explain": "Function to return the extra element in B [ ]"
    },
    {
        "py": "ans = 0 ; NEW_LINE",
        "explain": "To store the result"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT ans ^= A [ i ] ; NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT ans ^= B [ i ] ; NEW_LINE DEDENT return ans ; NEW_LINE",
        "explain": "Find the XOR of all the element of array A [ ] and array B [ ]"
    },
    {
        "py": "A = [ 10 , 15 , 5 ] ; NEW_LINE B = [ 10 , 100 , 15 , 5 ] ; NEW_LINE n = len ( A ) ; NEW_LINE print ( extraElement ( A , B , n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def hammingDistance ( n1 , n2 ) : NEW_LINE INDENT x = n1 ^ n2 NEW_LINE setBits = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT setBits += x & 1 NEW_LINE x >>= 1 NEW_LINE DEDENT return setBits NEW_LINE DEDENT",
        "explain": "Function to calculate hamming distance"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 9 NEW_LINE n2 = 14 NEW_LINE print ( hammingDistance ( 9 , 14 ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printSubsets ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n & i ) == i ) : NEW_LINE INDENT print ( i , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "function to find bitwise subsets Naive approach"
    },
    {
        "py": "n = 9 NEW_LINE printSubsets ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE def setBitNumber ( n ) : NEW_LINE",
        "explain": "Python program to find MSB number for given n ."
    },
    {
        "py": "k = int ( math . log ( n , 2 ) ) NEW_LINE",
        "explain": "To find the position of the most significant set bit"
    },
    {
        "py": "return 1 << k NEW_LINE",
        "explain": "To return the value of the number with set bit at k - th position"
    },
    {
        "py": "n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def subset ( ar , n ) : NEW_LINE",
        "explain": "function to count subsets such that all subsets have distinct elements ."
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "take input and initialize res = 0"
    },
    {
        "py": "ar . sort ( ) NEW_LINE",
        "explain": "sort the array"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT",
        "explain": "traverse the input array and find maximum frequency"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "for each number find its repetition / frequency"
    },
    {
        "py": "res = max ( res , count ) NEW_LINE return res NEW_LINE",
        "explain": "update res"
    },
    {
        "py": "ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def subset ( arr , n ) : NEW_LINE",
        "explain": "Function to count subsets such that all subsets have distinct elements ."
    },
    {
        "py": "mp = { i : 0 for i in range ( 10 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "Traverse the input array and store frequencies of elements"
    },
    {
        "py": "res = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT res = max ( res , value ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Find the maximum value in map ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( subset ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "psquare = [ ] NEW_LINE",
        "explain": "''Store perfect squares less than or equal to N"
    },
    {
        "py": "def calcPsquare ( N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT psquare . append ( i * i ) NEW_LINE DEDENT DEDENT",
        "explain": "''Utility function to calculate perfect squares less than or equal to N"
    },
    {
        "py": "def countWays ( index , target ) : NEW_LINE",
        "explain": "''Function to find the number of ways to represent a number as sum of perfect squares"
    },
    {
        "py": "if ( target == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( index < 0 or target < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "'' Handle the base cases"
    },
    {
        "py": "inc = countWays ( index , target - psquare [ index ] ) NEW_LINE",
        "explain": "'' Include the i-th index element"
    },
    {
        "py": "exc = countWays ( index - 1 , target ) NEW_LINE",
        "explain": "'' Exclude the i-th index element"
    },
    {
        "py": "return inc + exc NEW_LINE",
        "explain": "'' Return the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "''Driver Code"
    },
    {
        "py": "N = 9 NEW_LINE",
        "explain": "'' Given Input"
    },
    {
        "py": "calcPsquare ( N ) NEW_LINE",
        "explain": "'' Precalculate perfect  squares <= N"
    },
    {
        "py": "print ( countWays ( len ( psquare ) - 1 , N ) ) NEW_LINE",
        "explain": "'' Function Call"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "''Stores the sum of distances of all nodes from the given node"
    },
    {
        "py": "class TreeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . size = 0 NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT",
        "explain": "''Structure of a binary tree node"
    },
    {
        "py": "def sumofsubtree ( root ) : NEW_LINE",
        "explain": "''Function to count the number of nodes in the left and right subtrees"
    },
    {
        "py": "p = [ 1 , 0 ] NEW_LINE",
        "explain": "'' Initialize a pair that stores  the pair {number of nodes, depth}"
    },
    {
        "py": "if ( root . left ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . left ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT",
        "explain": "'' Finding the number of nodes  in the left subtree"
    },
    {
        "py": "if ( root . right ) : NEW_LINE INDENT ptemp = sumofsubtree ( root . right ) NEW_LINE p [ 1 ] += ptemp [ 0 ] + ptemp [ 1 ] NEW_LINE p [ 0 ] += ptemp [ 0 ] NEW_LINE DEDENT",
        "explain": "'' Find the number of nodes  in the right subtree"
    },
    {
        "py": "root . size = p [ 0 ] NEW_LINE return p NEW_LINE",
        "explain": "'' Filling up size field"
    },
    {
        "py": "def distance ( root , target , distancesum , n ) : NEW_LINE INDENT global sum NEW_LINE DEDENT",
        "explain": "''Function to find the total distance"
    },
    {
        "py": "if ( root . data == target ) : NEW_LINE INDENT sum = distancesum NEW_LINE DEDENT",
        "explain": "'' If target node matches with  the current node"
    },
    {
        "py": "if ( root . left ) : NEW_LINE",
        "explain": "'' If root.left is not null"
    },
    {
        "py": "tempsum = ( distancesum - root . left . size + ( n - root . left . size ) ) NEW_LINE",
        "explain": "'' Update sum"
    },
    {
        "py": "distance ( root . left , target , tempsum , n ) NEW_LINE",
        "explain": "'' Recur for the left subtree"
    },
    {
        "py": "if ( root . right ) : NEW_LINE",
        "explain": "'' If root.right is not null"
    },
    {
        "py": "tempsum = ( distancesum - root . right . size + ( n - root . right . size ) ) NEW_LINE",
        "explain": "'' Apply the formula given  in the approach"
    },
    {
        "py": "distance ( root . right , target , tempsum , n ) NEW_LINE",
        "explain": "'' Recur for the right subtree"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "''Driver Code"
    },
    {
        "py": "root = TreeNode ( 1 ) NEW_LINE root . left = TreeNode ( 2 ) NEW_LINE root . right = TreeNode ( 3 ) NEW_LINE root . left . left = TreeNode ( 4 ) NEW_LINE root . left . right = TreeNode ( 5 ) NEW_LINE root . right . left = TreeNode ( 6 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE root . left . left . left = TreeNode ( 8 ) NEW_LINE root . left . left . right = TreeNode ( 9 ) NEW_LINE target = 3 NEW_LINE p = sumofsubtree ( root ) NEW_LINE",
        "explain": "'' Input tree"
    },
    {
        "py": "totalnodes = p [ 0 ] NEW_LINE distance ( root , target , p [ 1 ] , totalnodes ) NEW_LINE",
        "explain": "'' Total number of nodes"
    },
    {
        "py": "print ( sum ) NEW_LINE",
        "explain": "'' Print the sum of distances"
    },
    {
        "py": "def rearrangeArray ( A , B , N , K ) : NEW_LINE",
        "explain": "''Function to rearrange array such that sum of similar indexed elements does not exceed K"
    },
    {
        "py": "B . sort ( reverse = True ) NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "'' Sort the array B[]  in descending order"
    },
    {
        "py": "if ( A [ i ] + B [ i ] > K ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if ( flag == False ) : NEW_LINE print ( \" - 1\" ) NEW_LINE else : NEW_LINE",
        "explain": "'' If condition fails"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( B [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "'' Print the array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "''Driver Code"
    },
    {
        "py": "A = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE K = 5 ; NEW_LINE rearrangeArray ( A , B , N , K ) NEW_LINE",
        "explain": "'' Given arrays"
    },
    {
        "py": "def countRows ( mat ) : NEW_LINE",
        "explain": "''Function to count the number of rows whose sum exceeds the sum of elements of the remaining matrix"
    },
    {
        "py": "n = len ( mat ) NEW_LINE m = len ( mat [ 0 ] ) NEW_LINE",
        "explain": "'' Stores the matrix dimensions"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "'' To store the result"
    },
    {
        "py": "totalSum = 0 NEW_LINE",
        "explain": "'' Stores the total sum of  the matrix elements"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT totalSum += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT",
        "explain": "'' Calculate the total sum"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "'' Traverse to check for each row"
    },
    {
        "py": "currSum = 0 NEW_LINE",
        "explain": "'' Stores the sum of elements  of the current row"
    },
    {
        "py": "for j in range ( m ) : NEW_LINE INDENT currSum += mat [ i ] [ j ] NEW_LINE DEDENT",
        "explain": "'' Calculate the sum of elements  of the current row"
    },
    {
        "py": "if ( currSum > totalSum - currSum ) : NEW_LINE",
        "explain": "'' If sum of current row exceeds  the sum of rest of the matrix"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "'' Increase count"
    },
    {
        "py": "print ( count ) NEW_LINE",
        "explain": "'' Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "''Driver Code"
    },
    {
        "py": "mat = [ [ 2 , - 1 , 5 ] , [ - 3 , 0 , - 2 ] , [ 5 , 1 , 2 ] ] NEW_LINE",
        "explain": "'' Given matrix"
    },
    {
        "py": "countRows ( mat ) NEW_LINE",
        "explain": "'' Function call"
    },
    {
        "py": "def areElementsContiguous ( arr , n ) : NEW_LINE",
        "explain": "function to check whether the array contains a set of contiguous integers"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE",
        "explain": "After sorting , check if current element is either same as previous or is one more ."
    },
    {
        "py": "arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def areElementsContiguous ( arr , n ) : NEW_LINE",
        "explain": "function to check whether the array contains a set of contiguous integers"
    },
    {
        "py": "max1 = max ( arr ) NEW_LINE min1 = min ( arr ) NEW_LINE m = max1 - min1 + 1 NEW_LINE",
        "explain": "Find maximum and minimum elements ."
    },
    {
        "py": "if ( m > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "There should be at least m elements in array to make them contiguous ."
    },
    {
        "py": "visited = [ 0 ] * m NEW_LINE",
        "explain": "Create a visited array and initialize fals"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT visited [ arr [ i ] - min1 ] = True NEW_LINE DEDENT",
        "explain": "Mark elements as true ."
    },
    {
        "py": "for i in range ( 0 , m ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "If any element is not marked , all elements are not contiguous ."
    },
    {
        "py": "arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areElementsContiguous ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver program"
    },
    {
        "py": "def areElementsContiguous ( arr ) : NEW_LINE",
        "explain": "Function to check whether the array contains a set of contiguous integers"
    },
    {
        "py": "us = set ( ) NEW_LINE for i in arr : us . add ( i ) NEW_LINE",
        "explain": "Storing elements of ' arr [ ] ' in a hash table 'us"
    },
    {
        "py": "count = 1 NEW_LINE",
        "explain": "As arr [ 0 ] is present in 'us"
    },
    {
        "py": "curr_ele = arr [ 0 ] - 1 NEW_LINE",
        "explain": "Starting with previous smaller element of arr [ 0 ]"
    },
    {
        "py": "while curr_ele in us : NEW_LINE",
        "explain": "If ' curr _ ele ' is present in 'us"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "curr_ele -= 1 NEW_LINE",
        "explain": "Update 'curr_ele\""
    },
    {
        "py": "curr_ele = arr [ 0 ] + 1 NEW_LINE",
        "explain": "Starting with next greater element of arr [ 0 ]"
    },
    {
        "py": "while curr_ele in us : NEW_LINE",
        "explain": "If ' curr _ ele ' is present in 'us"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "curr_ele += 1 NEW_LINE",
        "explain": "Update 'curr_ele\""
    },
    {
        "py": "return ( count == len ( us ) ) NEW_LINE",
        "explain": "Returns true if array contains a set of contiguous integers else returns false"
    },
    {
        "py": "arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE if areElementsContiguous ( arr ) : print ( \" Yes \" ) NEW_LINE else : print ( \" No \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import collections NEW_LINE def longest ( a , n , k ) : NEW_LINE INDENT freq = collections . defaultdict ( int ) NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE now = 0 NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "function to print the longest sub - array"
    },
    {
        "py": "freq [ a [ i ] ] += 1 NEW_LINE",
        "explain": "mark the element visited"
    },
    {
        "py": "if ( freq [ a [ i ] ] == 1 ) : NEW_LINE INDENT now += 1 NEW_LINE DEDENT",
        "explain": "if its visited first time , then increase the counter of distinct elements by 1"
    },
    {
        "py": "while ( now > k ) : NEW_LINE",
        "explain": "When the counter of distinct elements increases from k , then reduce it to k"
    },
    {
        "py": "freq [ a [ l ] ] -= 1 NEW_LINE",
        "explain": "from the left , reduce the number of time of visit"
    },
    {
        "py": "if ( freq [ a [ l ] ] == 0 ) : NEW_LINE INDENT now -= 1 NEW_LINE DEDENT",
        "explain": "if the reduced visited time element is not present in further segment then decrease the count of distinct elements"
    },
    {
        "py": "l += 1 NEW_LINE",
        "explain": "increase the subsegment mark"
    },
    {
        "py": "if ( i - l + 1 >= end - start + 1 ) : NEW_LINE INDENT end = i NEW_LINE start = l NEW_LINE DEDENT",
        "explain": "check length of longest sub - segment when greater then previous best then change it"
    },
    {
        "py": "for i in range ( start , end + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "print the longest sub - segment"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE longest ( a , n , k ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def kOverlap ( pairs : list , k ) : NEW_LINE",
        "explain": "Function that returns true if any k segments overlap at any point"
    },
    {
        "py": "vec = list ( ) NEW_LINE for i in range ( len ( pairs ) ) : NEW_LINE",
        "explain": "Vector to store the starting point and the ending point"
    },
    {
        "py": "vec . append ( ( pairs [ 0 ] , - 1 ) ) NEW_LINE vec . append ( ( pairs [ 1 ] , 1 ) ) NEW_LINE",
        "explain": "Starting points are marked by - 1 and ending points by + 1"
    },
    {
        "py": "vec . sort ( key = lambda a : a [ 0 ] ) NEW_LINE",
        "explain": "Sort the vector by first element"
    },
    {
        "py": "st = list ( ) NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE",
        "explain": "Stack to store the overlaps"
    },
    {
        "py": "cur = vec [ i ] NEW_LINE",
        "explain": "Get the current element"
    },
    {
        "py": "if cur [ 1 ] == - 1 : NEW_LINE",
        "explain": "If it is the starting point"
    },
    {
        "py": "st . append ( cur ) NEW_LINE",
        "explain": "Push it in the stack"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "It is the ending point"
    },
    {
        "py": "st . pop ( ) NEW_LINE",
        "explain": "Pop an element from stack"
    },
    {
        "py": "if len ( st ) >= k : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If more than k ranges overlap"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT pairs = list ( ) NEW_LINE pairs . append ( ( 1 , 3 ) ) NEW_LINE pairs . append ( ( 2 , 4 ) ) NEW_LINE pairs . append ( ( 3 , 5 ) ) NEW_LINE pairs . append ( ( 7 , 10 ) ) NEW_LINE n = len ( pairs ) NEW_LINE k = 3 NEW_LINE if kOverlap ( pairs , k ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "N = 5 NEW_LINE",
        "explain": "Python3 program to finds out smallest range that includes elements from each of the given sorted lists ."
    },
    {
        "py": "ptr = [ 0 for i in range ( 501 ) ] NEW_LINE",
        "explain": "array for storing the current index of list i"
    },
    {
        "py": "def findSmallestRange ( arr , n , k ) : NEW_LINE INDENT i , minval , maxval , minrange , minel , maxel , flag , minind = 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 NEW_LINE DEDENT",
        "explain": "This function takes an k sorted lists in the form of 2D array as an argument . It finds out smallest range that includes elements from each of the k lists ."
    },
    {
        "py": "for i in range ( k + 1 ) : NEW_LINE INDENT ptr [ i ] = 0 NEW_LINE DEDENT minrange = 10 ** 9 NEW_LINE while ( 1 ) : NEW_LINE",
        "explain": "initializing to 0 index"
    },
    {
        "py": "minind = - 1 NEW_LINE minval = 10 ** 9 NEW_LINE maxval = - 10 ** 9 NEW_LINE flag = 0 NEW_LINE",
        "explain": "for maintaining the index of list containing the minimum element"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE",
        "explain": "iterating over all the list"
    },
    {
        "py": "if ( ptr [ i ] == n ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT",
        "explain": "if every element of list [ i ] is traversed then break the loop"
    },
    {
        "py": "if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] < minval ) : NEW_LINE",
        "explain": "find minimum value among all the list elements pointing by the ptr [ ] array"
    },
    {
        "py": "minind = i NEW_LINE minval = arr [ i ] [ ptr [ i ] ] NEW_LINE",
        "explain": "update the index of the list"
    },
    {
        "py": "if ( ptr [ i ] < n and arr [ i ] [ ptr [ i ] ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] [ ptr [ i ] ] NEW_LINE DEDENT",
        "explain": "find maximum value among all the list elements pointing by the ptr [ ] array"
    },
    {
        "py": "if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT ptr [ minind ] += 1 NEW_LINE",
        "explain": "if any list exhaust we will not get any better answer , so break the while loop"
    },
    {
        "py": "if ( ( maxval - minval ) < minrange ) : NEW_LINE INDENT minel = minval NEW_LINE maxel = maxval NEW_LINE minrange = maxel - minel NEW_LINE DEDENT print ( \" The \u2581 smallest \u2581 range \u2581 is \u2581 [ \" , minel , maxel , \" ] \" ) NEW_LINE",
        "explain": "updating the minrange"
    },
    {
        "py": "arr = [ [ 4 , 7 , 9 , 12 , 15 ] , [ 0 , 8 , 10 , 14 , 20 ] , [ 6 , 12 , 16 , 30 , 50 ] ] NEW_LINE k = len ( arr ) NEW_LINE findSmallestRange ( arr , N , k ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findLargestd ( S , n ) : NEW_LINE INDENT found = False NEW_LINE DEDENT",
        "explain": "function to find largest d"
    },
    {
        "py": "S . sort ( ) NEW_LINE",
        "explain": "sort the array in ascending order"
    },
    {
        "py": "for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE DEDENT",
        "explain": "iterating from backwards to find the required largest d"
    },
    {
        "py": "if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE INDENT continue NEW_LINE DEDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( i == l ) : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "since all four a , b , c , d should be distinct"
    },
    {
        "py": "if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) : NEW_LINE INDENT found = True NEW_LINE return S [ i ] NEW_LINE DEDENT if ( found == False ) : NEW_LINE return - 1 NEW_LINE",
        "explain": "if the current combination of j , k , l in the set is equal to S [ i ] return this value as this would be the largest d since we are iterating in descending order"
    },
    {
        "py": "S = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( S ) NEW_LINE ans = findLargestd ( S , n ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( \" No \u2581 Solution \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Largest \u2581 d \u2581 such \u2581 that \u2581 a \u2581 + \u2581 b \u2581 + \" , \" c \u2581 = \u2581 d \u2581 is \" , ans ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findFourElements ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE DEDENT",
        "explain": "The function finds four elements with given sum X"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT mp [ arr [ i ] + arr [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT",
        "explain": "Store sums ( a + b ) of all pairs ( a , b ) in a hash table"
    },
    {
        "py": "d = - 10 ** 9 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT abs_diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Traverse through all pairs and find ( d - c ) is present in hash table"
    },
    {
        "py": "if abs_diff in mp . keys ( ) : NEW_LINE",
        "explain": "If d - c is present in hash table ,"
    },
    {
        "py": "p = mp [ abs_diff ] NEW_LINE if ( p [ 0 ] != i and p [ 0 ] != j and p [ 1 ] != i and p [ 1 ] != j ) : NEW_LINE INDENT d = max ( d , max ( arr [ i ] , arr [ j ] ) ) NEW_LINE DEDENT return d NEW_LINE",
        "explain": "Making sure that all elements are distinct array elements and an element is not considered more than once ."
    },
    {
        "py": "arr = [ 2 , 3 , 5 , 7 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE res = findFourElements ( arr , n ) NEW_LINE if ( res == - 10 ** 9 ) : NEW_LINE INDENT print ( \" No \u2581 Solution . \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def CountMaximum ( arr , n , k ) : NEW_LINE",
        "explain": "Function to count maximum number of elements that can be selected"
    },
    {
        "py": "arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE",
        "explain": "Sort he array"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "Sum += arr [ i ] NEW_LINE",
        "explain": "Add current element to the sum"
    },
    {
        "py": "if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "IF sum exceeds k"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the count"
    },
    {
        "py": "arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( CountMaximum ( arr , n , k ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def leftRotatebyOne ( arr , n ) : NEW_LINE INDENT temp = arr [ 0 ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = temp NEW_LINE DEDENT",
        "explain": "Function to left Rotate arr [ ] of size n by 1"
    },
    {
        "py": "def leftRotate ( arr , d , n ) : NEW_LINE INDENT for i in range ( d ) : NEW_LINE INDENT leftRotatebyOne ( arr , n ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to left rotate arr [ ] of size n by d"
    },
    {
        "py": "def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( \" % \u2581 d \" % arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "utility function to print an array"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE leftRotate ( arr , 2 , 7 ) NEW_LINE printArray ( arr , 7 ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "def partSort ( arr , N , a , b ) : NEW_LINE",
        "explain": "Function to sort the elements of the array from index a to index b"
    },
    {
        "py": "l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE",
        "explain": "Variables to store start and end of the index range"
    },
    {
        "py": "temp = [ 0 for i in range ( r - l + 1 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "Temporary array"
    },
    {
        "py": "temp . sort ( reverse = False ) NEW_LINE",
        "explain": "Sort the temporary array"
    },
    {
        "py": "j = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT",
        "explain": "Modifying original array with temporary array elements"
    },
    {
        "py": "for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the modified array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE",
        "explain": "length of the array"
    },
    {
        "py": "MAX_SIZE = 10 NEW_LINE",
        "explain": "Python 3 implementation to sort the rows of matrix in descending order followed by sorting the columns in ascending order"
    },
    {
        "py": "def sortByRow ( mat , n , descending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( descending == True ) : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "function to sort each row of the matrix according to the order specified by descending ."
    },
    {
        "py": "def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT DEDENT",
        "explain": "function to find transpose of the matrix"
    },
    {
        "py": "mat [ i ] [ j ] , mat [ j ] [ i ] = mat [ j ] [ i ] , mat [ i ] [ j ] NEW_LINE",
        "explain": "swapping element at index ( i , j ) by element at index ( j , i )"
    },
    {
        "py": "def sortMatRowAndColWise ( mat , n ) : NEW_LINE",
        "explain": "function to sort the matrix row - wise and column - wise"
    },
    {
        "py": "sortByRow ( mat , n , True ) NEW_LINE",
        "explain": "sort rows of mat [ ] [ ] in descending order"
    },
    {
        "py": "transpose ( mat , n ) NEW_LINE",
        "explain": "get transpose of mat [ ] [ ]"
    },
    {
        "py": "sortByRow ( mat , n , False ) NEW_LINE",
        "explain": "again sort rows of mat [ ] [ ] in ascending order ."
    },
    {
        "py": "transpose ( mat , n ) ; NEW_LINE",
        "explain": "again get transpose of mat [ ] [ ]"
    },
    {
        "py": "def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT",
        "explain": "function to print the matrix"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original \u2581 Matrix : \u2581 \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix \u2581 After \u2581 Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def pushZerosToEnd ( arr , n ) : NEW_LINE",
        "explain": "Function which pushes all zeros to end of an array ."
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Count of non - zero elements"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE DEDENT",
        "explain": "Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element"
    },
    {
        "py": "arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE",
        "explain": "here count is incremented"
    },
    {
        "py": "while count < n : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end ."
    },
    {
        "py": "arr = [ 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE pushZerosToEnd ( arr , n ) NEW_LINE print ( \" Array \u2581 after \u2581 pushing \u2581 all \u2581 zeros \u2581 to \u2581 end \u2581 of \u2581 array : \" ) NEW_LINE print ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def moveZerosToEnd ( arr , n ) : NEW_LINE",
        "explain": "function to move all zeroes at the end of array"
    },
    {
        "py": "count = 0 ; NEW_LINE",
        "explain": "Count of non - zero elements"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ count ] , arr [ i ] = arr [ i ] , arr [ count ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the array . If arr [ i ] is non - zero , then swap the element at index ' count ' with the element at index 'i"
    },
    {
        "py": "def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "function to print the array elements"
    },
    {
        "py": "arr = [ 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original \u2581 array : \" , end = \" \u2581 \" ) NEW_LINE printArray ( arr , n ) NEW_LINE moveZerosToEnd ( arr , n ) NEW_LINE print ( \" Modified array : \" , \u2581 end = \"   \" ) NEW_LINE printArray ( arr , n ) NEW_LINE",
        "explain": "Driver program to test above"
    },
    {
        "py": "def pushZerosToEnd ( arr , n ) : NEW_LINE",
        "explain": "function which pushes all zeros to end of an array ."
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Count of non - zero elements"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] != 0 : NEW_LINE DEDENT",
        "explain": "Traverse the array . If element encountered is non - zero , then replace the element at index ' count ' with this element"
    },
    {
        "py": "arr [ count ] = arr [ i ] NEW_LINE count += 1 NEW_LINE",
        "explain": "here count is incremented"
    },
    {
        "py": "while ( count < n ) : NEW_LINE INDENT arr [ count ] = 0 NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "Now all non - zero elements have been shifted to front and ' count ' is set as index of first 0. Make all elements 0 from count to end ."
    },
    {
        "py": "def modifyAndRearrangeArr ( ar , n ) : NEW_LINE",
        "explain": "function to rearrange the array elements after modification"
    },
    {
        "py": "if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "if ' arr [ ] ' contains a single element only"
    },
    {
        "py": "for i in range ( 0 , n - 1 ) : NEW_LINE",
        "explain": "traverse the array"
    },
    {
        "py": "if ( arr [ i ] != 0 ) and ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE",
        "explain": "if true , perform the required modification"
    },
    {
        "py": "arr [ i ] = 2 * arr [ i ] NEW_LINE",
        "explain": "double current index value"
    },
    {
        "py": "arr [ i + 1 ] = 0 NEW_LINE",
        "explain": "put 0 in the next index"
    },
    {
        "py": "i += 1 NEW_LINE",
        "explain": "increment by 1 so as to move two indexes ahead during loop iteration"
    },
    {
        "py": "pushZerosToEnd ( arr , n ) NEW_LINE",
        "explain": "push all the zeros at the end of 'arr[]"
    },
    {
        "py": "def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "function to print the array elements"
    },
    {
        "py": "arr = [ 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Original \u2581 array : \" , end = \" \u2581 \" ) NEW_LINE printArray ( arr , n ) NEW_LINE modifyAndRearrangeArr ( arr , n ) NEW_LINE print ( \" Modified array : \" , end = \"   \" ) NEW_LINE printArray ( arr , n ) NEW_LINE",
        "explain": "Driver program to test above"
    },
    {
        "py": "def shiftAllZeroToLeft ( arr , n ) : NEW_LINE",
        "explain": "shift all zero to left side of an array"
    },
    {
        "py": "lastSeenNonZero = 0 NEW_LINE for index in range ( 0 , n ) : NEW_LINE",
        "explain": "Maintain last index with positive value"
    },
    {
        "py": "if ( array [ index ] != 0 ) : NEW_LINE",
        "explain": "If Element is non - zero"
    },
    {
        "py": "array [ index ] , array [ lastSeenNonZero ] = array [ lastSeenNonZero ] , array [ index ] NEW_LINE",
        "explain": "swap current index , with lastSeen non - zero"
    },
    {
        "py": "lastSeenNonZero += 1 NEW_LINE",
        "explain": "next element will be last seen non - zero"
    },
    {
        "py": "def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "A utility function to print an array of size n"
    },
    {
        "py": "def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Function to Rearrange positive and negative numbers in a array"
    },
    {
        "py": "if ( key > 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "if current element is positive do nothing"
    },
    {
        "py": "j = i - 1 NEW_LINE while ( j >= 0 and arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT",
        "explain": "if current element is negative , shift positive elements of arr [ 0. . i - 1 ] , to one position to their right"
    },
    {
        "py": "arr [ j + 1 ] = key NEW_LINE",
        "explain": "Put negative element at its right position"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def printArray ( A , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( A [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Function to print an array"
    },
    {
        "py": "def reverse ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE INDENT arr [ l ] , arr [ r ] = arr [ r ] , arr [ l ] NEW_LINE l , r = l + 1 , r - 1 NEW_LINE reverse ( arr , l , r ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to reverse an array . An array can be reversed in O ( n ) time and O ( 1 ) space ."
    },
    {
        "py": "def merge ( arr , l , m , r ) : NEW_LINE",
        "explain": "Merges two subarrays of arr [ ] . First subarray is arr [ l . . m ] Second subarray is arr [ m + 1. . r ]"
    },
    {
        "py": "i = l NEW_LINE",
        "explain": "Initial index of 1 st subarray"
    },
    {
        "py": "j = m + 1 NEW_LINE while i <= m and arr [ i ] < 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "Initial index of IInd"
    },
    {
        "py": "while j <= r and arr [ j ] < 0 : NEW_LINE INDENT j += 1 NEW_LINE DEDENT",
        "explain": "arr [ i . . m ] is positive"
    },
    {
        "py": "reverse ( arr , i , m ) NEW_LINE",
        "explain": "arr [ j . . r ] is positive reverse positive part of left sub - array ( arr [ i . . m ] )"
    },
    {
        "py": "reverse ( arr , m + 1 , j - 1 ) NEW_LINE",
        "explain": "reverse negative part of right sub - array ( arr [ m + 1. . j - 1 ] )"
    },
    {
        "py": "reverse ( arr , i , j - 1 ) NEW_LINE",
        "explain": "reverse arr [ i . . j - 1 ]"
    },
    {
        "py": "def RearrangePosNeg ( arr , l , r ) : NEW_LINE INDENT if l < r : NEW_LINE DEDENT",
        "explain": "Function to Rearrange positive and negative numbers in a array"
    },
    {
        "py": "m = l + ( r - l ) // 2 NEW_LINE",
        "explain": "Same as ( l + r ) / 2 , but avoids overflow for large l and h"
    },
    {
        "py": "RearrangePosNeg ( arr , l , m ) NEW_LINE RearrangePosNeg ( arr , m + 1 , r ) NEW_LINE merge ( arr , l , m , r ) NEW_LINE",
        "explain": "Sort first and second halves"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE RearrangePosNeg ( arr , 0 , arr_size - 1 ) NEW_LINE printArray ( arr , arr_size ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def RearrangePosNeg ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( True ) : NEW_LINE DEDENT",
        "explain": "Python implementation of the above approach"
    },
    {
        "py": "while ( arr [ i ] < 0 and i < n ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "Loop until arr [ i ] < 0 and still inside the array"
    },
    {
        "py": "while ( arr [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT",
        "explain": "Loop until arr [ j ] > 0 and still inside the array"
    },
    {
        "py": "if ( i < j ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "if i is less than j"
    },
    {
        "py": "arr = [ - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE RearrangePosNeg ( arr , n ) NEW_LINE print ( * arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def winner ( arr , N ) : NEW_LINE",
        "explain": "Function to find the winner of the game played based on given conditions"
    },
    {
        "py": "if ( N % 2 == 1 ) : NEW_LINE INDENT print ( \" A \" ) NEW_LINE DEDENT",
        "explain": "A wins if size of array is odd"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" B \" ) NEW_LINE DEDENT",
        "explain": "Otherwise , B wins"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 24 , 45 , 45 , 24 ] NEW_LINE",
        "explain": "Input array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE winner ( arr , N ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "import math NEW_LINE sz = 20 NEW_LINE sqr = int ( math . sqrt ( sz ) ) + 1 NEW_LINE",
        "explain": "python program for the above approach"
    },
    {
        "py": "def precomputeExpressionForAllVal ( arr , N , dp ) : NEW_LINE",
        "explain": "Function to sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all possible values of X and Y , where Y is less than or equal to sqrt ( N ) ."
    },
    {
        "py": "for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Iterate over all possible values of X"
    },
    {
        "py": "for j in range ( 1 , int ( math . sqrt ( N ) ) + 1 ) : NEW_LINE",
        "explain": "Precompute for all possible values of an expression such that y <= sqrt ( N )"
    },
    {
        "py": "if ( i + j < N ) : NEW_LINE",
        "explain": "If i + j less than N"
    },
    {
        "py": "dp [ i ] [ j ] = arr [ i ] + dp [ i + j ] [ j ] NEW_LINE else : NEW_LINE",
        "explain": "Update dp [ i ] [ j ]"
    },
    {
        "py": "dp [ i ] [ j ] = arr [ i ] NEW_LINE",
        "explain": "Update dp [ i ] [ j ]"
    },
    {
        "py": "def querySum ( arr , N , Q , M ) : NEW_LINE",
        "explain": "Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries"
    },
    {
        "py": "dp = [ [ 0 for x in range ( sz ) ] for x in range ( sqr ) ] NEW_LINE precomputeExpressionForAllVal ( arr , N , dp ) NEW_LINE",
        "explain": "dp [ x ] [ y ] : Stores sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ..."
    },
    {
        "py": "for i in range ( 0 , M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Traverse the query array , Q [ ] [ ]"
    },
    {
        "py": "if ( y <= math . sqrt ( N ) ) : NEW_LINE INDENT print ( dp [ x ] [ y ] ) NEW_LINE continue NEW_LINE DEDENT",
        "explain": "If y is less than or equal to sqrt ( N )"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ..."
    },
    {
        "py": "while ( x < N ) : NEW_LINE",
        "explain": "Traverse the array , arr [ ]"
    },
    {
        "py": "sum += arr [ x ] NEW_LINE",
        "explain": "Update sum"
    },
    {
        "py": "x += y NEW_LINE print ( sum ) NEW_LINE",
        "explain": "Update x"
    },
    {
        "py": "arr = [ 1 , 2 , 7 , 5 , 4 ] NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q [ 0 ] ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findElements ( arr , n ) : NEW_LINE",
        "explain": "Python3 program to find all elements in array which have at - least two greater elements itself ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ i ] : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if count >= 2 : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Pick elements one by one and count greater elements . If count is more than 2 , print that element ."
    },
    {
        "py": "arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findElements ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Sorting based Python 3 program to find all elements in array which have atleast two greater elements itself ."
    },
    {
        "py": "arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE",
        "explain": "Driven source"
    },
    {
        "py": "import sys NEW_LINE def findElements ( arr , n ) : NEW_LINE INDENT first = - sys . maxsize NEW_LINE second = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE DEDENT",
        "explain": "Python3 program to find all elements in array which have atleast two greater elements itself ."
    },
    {
        "py": "if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT",
        "explain": "If current element is smaller than first then update both first and second"
    },
    {
        "py": "elif ( arr [ i ] > second ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE if ( arr [ i ] < second ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If arr [ i ] is in between first and second then update second"
    },
    {
        "py": "arr = [ 2 , - 6 , 3 , 5 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findElements ( arr , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getMinOps ( arr ) : NEW_LINE",
        "explain": "Function to find the minimum number of operations required to make the array non - increasing"
    },
    {
        "py": "res = 0 NEW_LINE for i in range ( len ( arr ) - 1 ) : NEW_LINE",
        "explain": "Stores the count of required operations"
    },
    {
        "py": "res += max ( arr [ i + 1 ] - arr [ i ] , 0 ) NEW_LINE",
        "explain": "If arr [ i ] > arr [ i + 1 ] , no increments required . Otherwise , add their difference to the answer"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the result res"
    },
    {
        "py": "arr = [ 1 , 3 , 4 , 1 , 2 ] NEW_LINE print ( getMinOps ( arr ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findFirstMissing ( array , start , end ) : NEW_LINE INDENT if ( start > end ) : NEW_LINE INDENT return end + 1 NEW_LINE DEDENT if ( start != array [ start ] ) : NEW_LINE INDENT return start ; NEW_LINE DEDENT mid = int ( ( start + end ) / 2 ) NEW_LINE DEDENT",
        "explain": "function that returns smallest elements missing in a sorted array ."
    },
    {
        "py": "if ( array [ mid ] == mid ) : NEW_LINE INDENT return findFirstMissing ( array , mid + 1 , end ) NEW_LINE DEDENT return findFirstMissing ( array , start , mid ) NEW_LINE",
        "explain": "Left half has all elements from 0 to mid"
    },
    {
        "py": "arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Smallest \u2581 missing \u2581 element \u2581 is \" , findFirstMissing ( arr , 0 , n - 1 ) ) NEW_LINE",
        "explain": "driver program to test above function"
    },
    {
        "py": "def findFirstMissing ( arr , start , end , first ) : NEW_LINE INDENT if ( start < end ) : NEW_LINE INDENT mid = int ( ( start + end ) / 2 ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to find missing element"
    },
    {
        "py": "if ( arr [ mid ] != mid + first ) : NEW_LINE INDENT return findFirstMissing ( arr , start , mid , first ) NEW_LINE DEDENT else : NEW_LINE INDENT return findFirstMissing ( arr , mid + 1 , end , first ) NEW_LINE DEDENT return start + first NEW_LINE",
        "explain": "Index matches with value at that index , means missing element cannot be upto that point"
    },
    {
        "py": "def findSmallestMissinginSortedArray ( arr ) : NEW_LINE",
        "explain": "Function to find Smallest Missing in Sorted Array"
    },
    {
        "py": "if ( arr [ 0 ] != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Check if 0 is missing in the array"
    },
    {
        "py": "if ( arr [ - 1 ] == len ( arr ) - 1 ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE return findFirstMissing ( arr , 0 , len ( arr ) - 1 , first ) NEW_LINE",
        "explain": "Check is all numbers 0 to n - 1 are prsent in array"
    },
    {
        "py": "arr = [ 0 , 1 , 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( \" First \u2581 Missing \u2581 element \u2581 is \u2581 : \" , findSmallestMissinginSortedArray ( arr ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def find_max_sum ( arr ) : NEW_LINE INDENT incl = 0 NEW_LINE excl = 0 NEW_LINE for i in arr : NEW_LINE DEDENT",
        "explain": "Function to return max sum such that no two elements are adjacent"
    },
    {
        "py": "new_excl = excl if excl > incl else incl NEW_LINE",
        "explain": "Current max excluding i ( No ternary in Python )"
    },
    {
        "py": "incl = excl + i NEW_LINE excl = new_excl NEW_LINE",
        "explain": "Current max including i"
    },
    {
        "py": "return ( excl if excl > incl else incl ) NEW_LINE",
        "explain": "return max of incl and excl"
    },
    {
        "py": "arr = [ 5 , 5 , 10 , 100 , 10 , 5 ] NEW_LINE print find_max_sum ( arr ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def countChanges ( matrix , n , m ) : NEW_LINE",
        "explain": "Function for counting minimum number of changes"
    },
    {
        "py": "dist = n + m - 1 NEW_LINE",
        "explain": "Distance of elements from ( 0 , 0 ) will is i range [ 0 , n + m - 2 ]"
    },
    {
        "py": "freq = [ [ 0 ] * 10 for i in range ( dist ) ] NEW_LINE",
        "explain": "Store frequencies of [ 0 , 9 ] at distance i Initialize all with zero"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT",
        "explain": "Count frequencies of [ 0 , 9 ]"
    },
    {
        "py": "freq [ i + j ] [ matrix [ i ] [ j ] ] += 1 NEW_LINE min_changes_sum = 0 NEW_LINE for i in range ( dist // 2 ) : NEW_LINE maximum = 0 NEW_LINE total_values = 0 NEW_LINE",
        "explain": "Increment frequency of value matrix [ i ] [ j ] at distance i + j"
    },
    {
        "py": "for j in range ( 10 ) : NEW_LINE INDENT maximum = max ( maximum , freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE total_values += ( freq [ i ] [ j ] + freq [ n + m - 2 - i ] [ j ] ) NEW_LINE DEDENT",
        "explain": "Find value with max frequency and count total cells at distance i from front end and rear end"
    },
    {
        "py": "min_changes_sum += ( total_values - maximum ) NEW_LINE",
        "explain": "Change all values to the value with max frequency"
    },
    {
        "py": "return min_changes_sum NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "mat = [ [ 1 , 2 ] , [ 3 , 5 ] ] NEW_LINE",
        "explain": "Given matrix"
    },
    {
        "py": "print ( countChanges ( mat , 2 , 2 ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to do range minimum query using sparse table"
    },
    {
        "py": "def buildSparseTable ( arr , n ) : NEW_LINE",
        "explain": "Fills lookup array lookup [ ] [ ] in bottom up manner ."
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT j = 1 NEW_LINE",
        "explain": "Initialize M for the intervals with length 1"
    },
    {
        "py": "while ( 1 << j ) <= n : NEW_LINE",
        "explain": "Compute values from smaller to bigger intervals"
    },
    {
        "py": "i = 0 NEW_LINE while ( i + ( 1 << j ) - 1 ) < n : NEW_LINE",
        "explain": "Compute minimum value for all intervals with size 2 ^ j"
    },
    {
        "py": "if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE",
        "explain": "For arr [ 2 ] [ 10 ] , we compare arr [ lookup [ 0 ] [ 7 ] ] and arr [ lookup [ 3 ] [ 10 ] ]"
    },
    {
        "py": "def query ( L , R ) : NEW_LINE",
        "explain": "Returns minimum of arr [ L . . R ]"
    },
    {
        "py": "j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE",
        "explain": "Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3"
    },
    {
        "py": "if lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] : NEW_LINE INDENT return lookup [ L ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return lookup [ R - ( 1 << j ) + 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "Compute minimum of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we compare arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE lookup = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 4 ) ) NEW_LINE print ( query ( 4 , 7 ) ) NEW_LINE print ( query ( 7 , 8 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to do range minimum query using sparse table"
    },
    {
        "py": "def buildSparseTable ( arr , n ) : NEW_LINE",
        "explain": "Fills lookup array lookup [ ] [ ] in bottom up manner ."
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT table [ i ] [ 0 ] = arr [ i ] NEW_LINE DEDENT",
        "explain": "GCD of single element is element itself"
    },
    {
        "py": "j = 1 NEW_LINE while ( 1 << j ) <= n : NEW_LINE INDENT i = 0 NEW_LINE while i <= n - ( 1 << j ) : NEW_LINE INDENT table [ i ] [ j ] = math . gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) NEW_LINE i += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT",
        "explain": "Build sparse table"
    },
    {
        "py": "def query ( L , R ) : NEW_LINE",
        "explain": "Returns minimum of arr [ L . . R ]"
    },
    {
        "py": "j = int ( math . log2 ( R - L + 1 ) ) NEW_LINE",
        "explain": "Find highest power of 2 that is smaller than or equal to count of elements in given range . For [ 2 , 10 ] , j = 3"
    },
    {
        "py": "return math . gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) NEW_LINE",
        "explain": "Compute GCD of last 2 ^ j elements with first 2 ^ j elements in range . For [ 2 , 10 ] , we find GCD of arr [ lookup [ 0 ] [ 3 ] ] and arr [ lookup [ 3 ] [ 3 ] ] ,"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE MAX = 500 NEW_LINE table = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE buildSparseTable ( a , n ) NEW_LINE print ( query ( 0 , 2 ) ) NEW_LINE print ( query ( 1 , 3 ) ) NEW_LINE print ( query ( 4 , 5 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minimizeWithKSwaps ( arr , n , k ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE DEDENT",
        "explain": "Modifies arr [ 0. . n - 1 ] to lexicographically smallest with k swaps ."
    },
    {
        "py": "pos = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE",
        "explain": "Set the position where we we want to put the smallest integer"
    },
    {
        "py": "if ( j - i > k ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If we exceed the Max swaps then terminate the loop"
    },
    {
        "py": "if ( arr [ j ] < arr [ pos ] ) : NEW_LINE INDENT pos = j NEW_LINE DEDENT",
        "explain": "Find the minimum value from i + 1 to max ( k or n )"
    },
    {
        "py": "for j in range ( pos , i , - 1 ) : NEW_LINE INDENT arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] NEW_LINE DEDENT",
        "explain": "Swap the elements from Minimum position we found till now to the i index"
    },
    {
        "py": "k -= pos - i NEW_LINE",
        "explain": "Set the final value after swapping pos - i elements"
    },
    {
        "py": "n , k = 5 , 3 NEW_LINE arr = [ 7 , 6 , 9 , 2 , 1 ] NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the final Array"
    },
    {
        "py": "def findMaxAverage ( arr , n , k ) : NEW_LINE",
        "explain": "Returns beginning index of maximum average subarray of length k"
    },
    {
        "py": "if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Check if ' k ' is valid"
    },
    {
        "py": "csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT",
        "explain": "Create and fill array to store cumulative sum . csum [ i ] stores sum of arr [ 0 ] to arr [ i ]"
    },
    {
        "py": "max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE",
        "explain": "Initialize max_sm as sum of first subarray"
    },
    {
        "py": "for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT",
        "explain": "Find sum of other subarrays and update max_sum if required ."
    },
    {
        "py": "return max_end - k + 1 NEW_LINE",
        "explain": "Return starting index"
    },
    {
        "py": "arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( \" The \u2581 maximum \u2581 average \u2581 subarray \u2581 of \u2581 length \" , k , \" begins \u2581 at \u2581 index \" , findMaxAverage ( arr , n , k ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def findMaxAverage ( arr , n , k ) : NEW_LINE",
        "explain": "Returns beginning index of maximum average subarray of length k"
    },
    {
        "py": "if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Check if ' k ' is valid"
    },
    {
        "py": "sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE",
        "explain": "Compute sum of first ' k ' elements"
    },
    {
        "py": "for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT",
        "explain": "Compute sum of remaining subarrays"
    },
    {
        "py": "return max_end - k + 1 NEW_LINE",
        "explain": "Return starting index"
    },
    {
        "py": "arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( \" The \u2581 maximum \u2581 average \u2581 subarray \u2581 of \u2581 length \" , k , \" begins \u2581 at \u2581 index \" , findMaxAverage ( arr , n , k ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "m = dict ( ) NEW_LINE",
        "explain": "Stores the minimum score for each states as map < pair < pos , myturn > , ans >"
    },
    {
        "py": "def findMinimum ( a , n , pos , myturn ) : NEW_LINE",
        "explain": "Function to find the minimum score after choosing element from array"
    },
    {
        "py": "if ( pos , myturn ) in m : NEW_LINE INDENT return m [ ( pos , myturn ) ] ; NEW_LINE DEDENT",
        "explain": "Return the stored state"
    },
    {
        "py": "if ( pos >= n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if ( not myturn ) : NEW_LINE",
        "explain": "Player A 's turn"
    },
    {
        "py": "ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) + a [ pos ] , findMinimum ( a , n , pos + 2 , not myturn ) + a [ pos ] + a [ pos + 1 ] ) ; NEW_LINE",
        "explain": "Find the minimum score"
    },
    {
        "py": "m [ ( pos , myturn ) ] = ans ; NEW_LINE",
        "explain": "Store the current state"
    },
    {
        "py": "return ans ; NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if ( myturn ) : NEW_LINE",
        "explain": "Player B 's turn"
    },
    {
        "py": "ans = min ( findMinimum ( a , n , pos + 1 , not myturn ) , findMinimum ( a , n , pos + 2 , not myturn ) ) ; NEW_LINE",
        "explain": "Find minimum score"
    },
    {
        "py": "m [ ( pos , myturn ) ] = ans ; NEW_LINE",
        "explain": "Store the current state"
    },
    {
        "py": "return ans ; NEW_LINE return 0 ; NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "def countPenality ( arr , N ) : NEW_LINE",
        "explain": "Function that finds the minimum penality after choosing element from the given binary array"
    },
    {
        "py": "pos = 0 ; NEW_LINE",
        "explain": "Starting position of choosing element from array"
    },
    {
        "py": "turn = False ; NEW_LINE",
        "explain": "0 denotes player A turn 1 denotes player B turn"
    },
    {
        "py": "return findMinimum ( arr , N , pos , turn ) + 1 ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def printAnswer ( arr , N ) : NEW_LINE",
        "explain": "Print the answer for player A and B"
    },
    {
        "py": "a = countPenality ( arr , N ) ; NEW_LINE",
        "explain": "Minimum penalty"
    },
    {
        "py": "sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT",
        "explain": "Calculate sum of all arr elements"
    },
    {
        "py": "print ( a ) NEW_LINE",
        "explain": "Print the minimum score"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printAnswer ( arr , N ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE MAX = 1000001 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "prime = [ True ] * MAX NEW_LINE",
        "explain": "Create a boolean array prime [ ] and initialize all entires it as true A value in prime [ i ] will finally be false if i is Not a prime"
    },
    {
        "py": "def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= MAX : NEW_LINE DEDENT",
        "explain": "Function to find prime numbers"
    },
    {
        "py": "if prime [ p ] == True : NEW_LINE",
        "explain": "Check if prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * p , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p greater than or equal to the square of it numbers which are multiple of p and are less than p ^ 2 are already been marked"
    },
    {
        "py": "def getMid ( s , e ) : NEW_LINE INDENT return s + ( e - s ) // 2 NEW_LINE DEDENT",
        "explain": "Function to get the middle index from corner indexes"
    },
    {
        "py": "def getSumUtil ( st , ss , se , qs , qe , si ) : NEW_LINE",
        "explain": "Function to get the sum of values in the given range of the array"
    },
    {
        "py": "if qs <= ss and qe >= se : NEW_LINE INDENT return st [ si ] NEW_LINE DEDENT",
        "explain": "If segment of this node is a part of given range , then return the sum of the segment"
    },
    {
        "py": "if se < qs or ss > qe : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If segment of this node is outside the given range"
    },
    {
        "py": "mid = getMid ( ss , se ) NEW_LINE return ( getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ) NEW_LINE",
        "explain": "If a part of this segment overlaps with the given range"
    },
    {
        "py": "def updateValueUtil ( st , ss , se , i , diff , si ) : NEW_LINE",
        "explain": "Function to update the nodes which have the given index in their range"
    },
    {
        "py": "if i < ss or i > se : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "If the input index lies outside the range of this segment"
    },
    {
        "py": "st [ si ] = st [ si ] + diff NEW_LINE if se != ss : NEW_LINE INDENT mid = getMid ( ss , se ) NEW_LINE updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) NEW_LINE updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) NEW_LINE DEDENT",
        "explain": "If the input index is in range of this node , then update the value of the node and its children"
    },
    {
        "py": "def updateValue ( arr , st , n , i , new_val ) : NEW_LINE",
        "explain": "Function to update a value in input array and segment tree"
    },
    {
        "py": "if i < 0 or i > n - 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Check for errorneous imput index"
    },
    {
        "py": "diff = new_val - arr [ i ] NEW_LINE prev_val = arr [ i ] NEW_LINE",
        "explain": "Get the difference between new value and old value"
    },
    {
        "py": "arr [ i ] = new_val NEW_LINE",
        "explain": "Update the value in array"
    },
    {
        "py": "if prime [ new_val ] or prime [ prev_val ] : NEW_LINE",
        "explain": "Update the values of nodes in segment tree only if either previous value or new value or both are prime"
    },
    {
        "py": "if not prime [ prev_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , new_val , 0 ) NEW_LINE DEDENT",
        "explain": "If only new value is prime"
    },
    {
        "py": "elif not prime [ new_val ] : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , - prev_val , 0 ) NEW_LINE DEDENT",
        "explain": "If only old value is prime"
    },
    {
        "py": "else : NEW_LINE INDENT updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) NEW_LINE DEDENT",
        "explain": "If both are prime"
    },
    {
        "py": "def getSum ( st , n , qs , qe ) : NEW_LINE",
        "explain": "Return sum of elements in range from index qs ( query start ) to qe ( query end ) . It mainly uses getSumUtil ( )"
    },
    {
        "py": "if qs < 0 or qe > n - 1 or qs > qe : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) NEW_LINE",
        "explain": "Check for erroneous input values"
    },
    {
        "py": "def constructSTUtil ( arr , ss , se , st , si ) : NEW_LINE",
        "explain": "Function that constructs the Segment Tree"
    },
    {
        "py": "if ss == se : NEW_LINE",
        "explain": "If there is one element in array , store it in current node of segment tree and return"
    },
    {
        "py": "if prime [ arr [ ss ] ] : NEW_LINE INDENT st [ si ] = arr [ ss ] NEW_LINE DEDENT else : NEW_LINE INDENT st [ si ] = 0 NEW_LINE DEDENT return st [ si ] NEW_LINE",
        "explain": "Only add those elements in segment tree which are prime"
    },
    {
        "py": "mid = getMid ( ss , se ) NEW_LINE st [ si ] = ( constructSTUtil ( arr , ss , mid , st , 2 * si + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , 2 * si + 2 ) ) NEW_LINE return st [ si ] NEW_LINE",
        "explain": "If there are more than one elements , then recur for left and right subtrees and store the sum of values in this node"
    },
    {
        "py": "def constructST ( arr , n ) : NEW_LINE",
        "explain": "Function to construct segment tree from given array"
    },
    {
        "py": "x = int ( math . ceil ( math . log2 ( n ) ) ) NEW_LINE",
        "explain": "Height of segment tree"
    },
    {
        "py": "max_size = 2 * int ( pow ( 2 , x ) ) - 1 NEW_LINE",
        "explain": "Maximum size of segment tree"
    },
    {
        "py": "st = [ 0 ] * max_size NEW_LINE",
        "explain": "Allocate memory"
    },
    {
        "py": "constructSTUtil ( arr , 0 , n - 1 , st , 0 ) NEW_LINE",
        "explain": "Fill the allocated memory st"
    },
    {
        "py": "return st NEW_LINE",
        "explain": "Return the constructed segment tree"
    },
    {
        "py": "arr = [ 1 , 3 , 5 , 7 , 9 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE Q = [ [ 1 , 1 , 3 ] , [ 2 , 1 , 10 ] , [ 1 , 1 , 3 ] ] NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "SieveOfEratosthenes ( ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "st = constructST ( arr , n ) NEW_LINE",
        "explain": "Build segment tree from given array"
    },
    {
        "py": "print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE",
        "explain": "Print sum of values in array from index 1 to 3"
    },
    {
        "py": "updateValue ( arr , st , n , 1 , 10 ) NEW_LINE",
        "explain": "Update : set arr [ 1 ] = 10 and update corresponding segment tree nodes"
    },
    {
        "py": "print ( getSum ( st , n , 1 , 3 ) ) NEW_LINE",
        "explain": "Find sum after value is updated"
    },
    {
        "py": "mod = 1000000007 NEW_LINE dp = [ [ - 1 for i in range ( 1000 ) ] for j in range ( 1000 ) ] ; NEW_LINE def calculate ( pos , prev , s , index ) : NEW_LINE",
        "explain": "Python 3 Program to Count the number of ways to construct the target string"
    },
    {
        "py": "if ( pos == len ( s ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "if ( dp [ pos ] [ prev ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ prev ] NEW_LINE DEDENT",
        "explain": "If current subproblem has been solved , use the value"
    },
    {
        "py": "c = ord ( s [ pos ] ) - ord ( ' a ' ) ; NEW_LINE",
        "explain": "current character"
    },
    {
        "py": "answer = 0 NEW_LINE for i in range ( len ( index ) ) : NEW_LINE INDENT if ( index [ i ] > prev ) : NEW_LINE INDENT answer = ( answer % mod + calculate ( pos + 1 , index [ i ] , s , index ) % mod ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ prev ] = 4 NEW_LINE",
        "explain": "search through all the indiced at which the current character occurs . For each index greater than prev , take the index and move to the next position , and add to the answer ."
    },
    {
        "py": "return dp [ pos ] [ prev ] NEW_LINE def countWays ( a , s ) : NEW_LINE n = len ( a ) NEW_LINE",
        "explain": "Store and return the solution for this subproblem"
    },
    {
        "py": "index = [ [ ] for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE DEDENT",
        "explain": "preprocess the strings by storing for each character of every string , the index of their occurrence we will use a common list for all because of only the index matter in the string from which the character was picked"
    },
    {
        "py": "index [ ord ( a [ i ] [ j ] ) - ord ( ' a ' ) ] . append ( j + 1 ) ; NEW_LINE",
        "explain": "we are storing j + 1 because the initial picked index in the recursive step will ne 0. This is just for ease of implementation"
    },
    {
        "py": "return calculate ( 0 , 0 , s , index [ 0 ] ) NEW_LINE",
        "explain": "initialise dp table . - 1 represents that the subproblem hasn 't been solve"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ] NEW_LINE A . append ( \" adc \" ) NEW_LINE A . append ( \" aec \" ) NEW_LINE A . append ( \" erg \" ) NEW_LINE S = \" ac \" NEW_LINE print ( countWays ( A , S ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 10005 NEW_LINE MOD = 1000000007 NEW_LINE",
        "explain": "Python 3 implementation of the approach"
    },
    {
        "py": "def countNum ( idx , sum , tight , num , len1 , k ) : NEW_LINE INDENT if ( len1 == idx ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ idx ] [ sum ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ sum ] [ tight ] NEW_LINE DEDENT res = 0 NEW_LINE DEDENT",
        "explain": "Function to return the count of numbers from the range [ 0 , n ] whose digit sum is a multiple of k using bottom - up dp"
    },
    {
        "py": "if ( tight == 0 ) : NEW_LINE INDENT limit = num [ idx ] NEW_LINE DEDENT",
        "explain": "The digit in this index can only be from [ 0 , num [ idx ] ]"
    },
    {
        "py": "else : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE",
        "explain": "The digit in this index can be anything from [ 0 , 9 ]"
    },
    {
        "py": "new_tight = tight NEW_LINE if ( tight == 0 and i < limit ) : NEW_LINE INDENT new_tight = 1 NEW_LINE DEDENT res += countNum ( idx + 1 , ( sum + i ) % k , new_tight , num , len1 , k ) NEW_LINE res %= MOD NEW_LINE",
        "explain": "new_tight is the flag value for the next position"
    },
    {
        "py": "if ( res < 0 ) : NEW_LINE INDENT res += MOD NEW_LINE DEDENT dp [ idx ] [ sum ] [ tight ] = res NEW_LINE return dp [ idx ] [ sum ] [ tight ] NEW_LINE",
        "explain": "res can 't be negative"
    },
    {
        "py": "def process ( s ) : NEW_LINE INDENT num = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT num . append ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return num NEW_LINE DEDENT",
        "explain": "Function to process the string to a vector of digits from MSD to LSD"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = \"98765432109876543210\" NEW_LINE",
        "explain": "For large input number n"
    },
    {
        "py": "len1 = len ( n ) NEW_LINE k = 58 NEW_LINE",
        "explain": "Total number of digits in n"
    },
    {
        "py": "dp = [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 101 ) ] for k in range ( MAX ) ] NEW_LINE",
        "explain": "To store the states of the dp"
    },
    {
        "py": "num = process ( n ) NEW_LINE print ( countNum ( 0 , 0 , 0 , num , len1 , k ) ) NEW_LINE",
        "explain": "Process the string to a vector of digits from MSD to LSD"
    },
    {
        "py": "def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE",
        "explain": "w1_r represents remaining capacity of 1 st knapsack w2_r represents remaining capacity of 2 nd knapsack i represents index of the array arr we are working on"
    },
    {
        "py": "if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE",
        "explain": "Variables to store the result of three parts of recurrence relation"
    },
    {
        "py": "dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE",
        "explain": "Store the state in the 3D array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE",
        "explain": "Input array"
    },
    {
        "py": "dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE",
        "explain": "3D array to store states of DP"
    },
    {
        "py": "n = len ( arr ) NEW_LINE",
        "explain": "Number of elements in the array"
    },
    {
        "py": "w1 , w2 = 10 , 3 NEW_LINE",
        "explain": "Capacity of knapsacks"
    },
    {
        "py": "print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE",
        "explain": "Function to be called"
    },
    {
        "py": "def CountWays ( n ) : NEW_LINE",
        "explain": "Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed"
    },
    {
        "py": "noOfWays = [ 0 ] * ( n + 1 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE",
        "explain": "noOfWays [ i ] will store count for last 3 values before i ."
    },
    {
        "py": "for i in range ( 3 , n + 1 ) : NEW_LINE",
        "explain": "Loop till \" n + 1\" to compute value for \" n \""
    },
    {
        "py": "noOfWays [ i ] = noOfWays [ 3 - 1 ] NEW_LINE",
        "explain": "number of ways if first run is 1"
    },
    {
        "py": "+ noOfWays [ 3 - 3 ] NEW_LINE",
        "explain": "number of ways if first run is 2 and second run is 1"
    },
    {
        "py": "noOfWays [ 0 ] = noOfWays [ 1 ] NEW_LINE noOfWays [ 1 ] = noOfWays [ 2 ] NEW_LINE noOfWays [ 2 ] = noOfWays [ i ] NEW_LINE return noOfWays [ n ] NEW_LINE",
        "explain": "Remember last 3 values"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 105 NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = 1 ; NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "def dfs ( i , j , k , q , n , m ) : NEW_LINE",
        "explain": "Depth First Search"
    },
    {
        "py": "if ( mappedMatrix [ i ] [ j ] == 0 or i > n or j > m or mark [ i ] [ j ] or q != 0 ) : NEW_LINE INDENT return q ; NEW_LINE DEDENT",
        "explain": "Return if cell contain non prime number or obstacle , or going out of matrix or already visited the cell or already found the lexicographical largest path"
    },
    {
        "py": "mark [ i ] [ j ] = 1 ; NEW_LINE",
        "explain": "marking cell is already visited"
    },
    {
        "py": "ans [ k ] = [ i , j ] NEW_LINE",
        "explain": "storing the lexicographical largest path index"
    },
    {
        "py": "if ( i == n and j == m ) : NEW_LINE",
        "explain": "if reached the end of the matrix"
    },
    {
        "py": "q = k ; NEW_LINE return q ; NEW_LINE",
        "explain": "updating the final number of steps in lexicographical largest path"
    },
    {
        "py": "q = dfs ( i + 1 , j + 1 , k + 1 , q , n , m ) ; NEW_LINE",
        "explain": "moving diagonal ( trying lexicographical largest path )"
    },
    {
        "py": "q = dfs ( i + 1 , j , k + 1 , q , n , m ) ; NEW_LINE",
        "explain": "moving cell right to current cell"
    },
    {
        "py": "q = dfs ( i , j + 1 , k + 1 , q , n , m ) ; NEW_LINE return q NEW_LINE",
        "explain": "moving cell down to current cell ."
    },
    {
        "py": "def lexicographicalPath ( n , m ) : NEW_LINE",
        "explain": "Print lexicographical largest prime path"
    },
    {
        "py": "q = 0 ; NEW_LINE global ans , mark NEW_LINE",
        "explain": "To count the number of step in lexicographical largest prime path"
    },
    {
        "py": "ans = [ [ 0 , 0 ] for i in range ( MAX ) ] NEW_LINE",
        "explain": "To store the lexicographical largest prime path index"
    },
    {
        "py": "mark = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE",
        "explain": "To mark if the cell is already traversed or not"
    },
    {
        "py": "q = dfs ( 1 , 1 , 1 , q , n , m ) ; NEW_LINE",
        "explain": "traversing by DFS"
    },
    {
        "py": "for i in range ( 1 , q + 1 ) : NEW_LINE INDENT print ( str ( ans [ i ] [ 0 ] ) + ' \u2581 ' + str ( ans [ i ] [ 1 ] ) ) NEW_LINE DEDENT",
        "explain": "printing the lexicographical largest prime path"
    },
    {
        "py": "def countPrimePath ( n , m ) : NEW_LINE INDENT global dp NEW_LINE dp = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE dp [ 1 ] [ 1 ] = 1 ; NEW_LINE DEDENT",
        "explain": "Return the number of prime path in ther matrix ."
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE DEDENT",
        "explain": "for each cell"
    },
    {
        "py": "if ( i == 1 and j == 1 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ) ; NEW_LINE",
        "explain": "If on the top row or leftmost column , there is no path there ."
    },
    {
        "py": "if ( mappedMatrix [ i ] [ j ] == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 ; NEW_LINE DEDENT print ( dp [ n ] [ m ] ) NEW_LINE",
        "explain": "If non prime number"
    },
    {
        "py": "def preprocessMatrix ( a , n , m ) : NEW_LINE INDENT global prime NEW_LINE prime = [ 0 for i in range ( MAX ) ] NEW_LINE DEDENT",
        "explain": "Finding the matrix mapping by considering non prime number as obstacle and prime number be valid path ."
    },
    {
        "py": "sieve ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE DEDENT",
        "explain": "Sieve"
    },
    {
        "py": "if ( prime [ a [ i ] [ j ] ] == 0 ) : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 1 ; NEW_LINE DEDENT",
        "explain": "If prime"
    },
    {
        "py": "else : NEW_LINE INDENT mappedMatrix [ i + 1 ] [ j + 1 ] = 0 ; NEW_LINE DEDENT",
        "explain": "if non prime"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE m = 3 ; NEW_LINE a = [ [ 2 , 3 , 7 ] , [ 5 , 4 , 2 ] , [ 3 , 7 , 11 ] ] ; NEW_LINE mappedMatrix = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE preprocessMatrix ( a , n , m ) ; NEW_LINE countPrimePath ( n , m ) ; NEW_LINE lexicographicalPath ( n , m ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isSubsetSum ( arr , n , sum ) : NEW_LINE",
        "explain": "A Dynamic Programming solution for subset sum problem + maximal subset value . Returns size of maximum sized subset if there is a subset of set [ ] with sun equal to given sum . It returns - 1 if there is no subset with given sum ."
    },
    {
        "py": "subset = [ [ False for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE count = [ [ 0 for x in range ( n + 1 ) ] for y in range ( sum + 1 ) ] NEW_LINE",
        "explain": "The value of subset [ i ] [ j ] will be true if there is a subset of set [ 0. . j - 1 ] with sum equal to i"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = True NEW_LINE count [ 0 ] [ i ] = 0 NEW_LINE DEDENT",
        "explain": "If sum is 0 , then answer is true"
    },
    {
        "py": "for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = False NEW_LINE count [ i ] [ 0 ] = - 1 NEW_LINE DEDENT",
        "explain": "If sum is not 0 and set is empty , then answer is false"
    },
    {
        "py": "for i in range ( 1 , sum + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i ] [ j - 1 ] NEW_LINE count [ i ] [ j ] = count [ i ] [ j - 1 ] NEW_LINE if ( i >= arr [ j - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i ] [ j ] or subset [ i - arr [ j - 1 ] ] [ j - 1 ] ) NEW_LINE if ( subset [ i ] [ j ] ) : NEW_LINE INDENT count [ i ] [ j ] = ( max ( count [ i ] [ j - 1 ] , count [ i - arr [ j - 1 ] ] [ j - 1 ] + 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return count [ sum ] [ n ] NEW_LINE",
        "explain": "Fill the subset table in bottom up manner"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 10 ] NEW_LINE sum = 20 NEW_LINE n = 4 NEW_LINE print ( isSubsetSum ( arr , n , sum ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 100 NEW_LINE lcslen = 0 NEW_LINE",
        "explain": "Python3 program to find all LCS of two strings in sorted order ."
    },
    {
        "py": "dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE",
        "explain": "dp matrix to store result of sub calls for lcs"
    },
    {
        "py": "def lcs ( str1 , str2 , len1 , len2 , i , j ) : NEW_LINE",
        "explain": "A memoization based function that returns LCS of str1 [ i . . len1 - 1 ] and str2 [ j . . len2 - 1 ]"
    },
    {
        "py": "if ( i == len1 or j == len2 ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT",
        "explain": "base condition"
    },
    {
        "py": "if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ret = 0 NEW_LINE",
        "explain": "if lcs has been computed"
    },
    {
        "py": "if ( str1 [ i ] == str2 [ j ] ) : NEW_LINE INDENT ret = 1 + lcs ( str1 , str2 , len1 , len2 , i + 1 , j + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ret = max ( lcs ( str1 , str2 , len1 , len2 , i + 1 , j ) , lcs ( str1 , str2 , len1 , len2 , i , j + 1 ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ret NEW_LINE return ret NEW_LINE",
        "explain": "if characters are same return previous + 1 else max of two sequences after removing i ' th \u2581 and \u2581 j ' th char one by one"
    },
    {
        "py": "def printAll ( str1 , str2 , len1 , len2 , data , indx1 , indx2 , currlcs ) : NEW_LINE",
        "explain": "Function to prall routes common sub - sequences of length lcslen"
    },
    {
        "py": "if ( currlcs == lcslen ) : NEW_LINE INDENT print ( \" \" . join ( data [ : currlcs ] ) ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "if currlcs is equal to lcslen then prit"
    },
    {
        "py": "if ( indx1 == len1 or indx2 == len2 ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "if we are done with all the characters of both string"
    },
    {
        "py": "for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE",
        "explain": "here we have to prall sub - sequences lexicographically , that ' s \u2581 why \u2581 we \u2581 start \u2581 from \u2581 ' a ' to ' z ' if this character is  present in both of them then append it in data[] and same  remaining part"
    },
    {
        "py": "done = False NEW_LINE for i in range ( indx1 , len1 ) : NEW_LINE",
        "explain": "done is a flag to tell that we have printed all the subsequences corresponding to current character"
    },
    {
        "py": "if ( chr ( ch ) == str1 [ i ] ) : NEW_LINE for j in range ( indx2 , len2 ) : NEW_LINE",
        "explain": "if character ch is present in str1 then check if it is present in str2"
    },
    {
        "py": "if ( chr ( ch ) == str2 [ j ] and dp [ i ] [ j ] == lcslen - currlcs ) : NEW_LINE data [ currlcs ] = chr ( ch ) NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , i + 1 , j + 1 , currlcs + 1 ) NEW_LINE done = True NEW_LINE break NEW_LINE",
        "explain": "if ch is present in both of them and remaining length is equal to remaining lcs length then add ch in sub - sequenece"
    },
    {
        "py": "if ( done ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If we found LCS beginning with current character ."
    },
    {
        "py": "def prinlAllLCSSorted ( str1 , str2 ) : NEW_LINE INDENT global lcslen NEW_LINE DEDENT",
        "explain": "This function prints all LCS of str1 and str2 in lexicographic order ."
    },
    {
        "py": "len1 , len2 = len ( str1 ) , len ( str2 ) NEW_LINE",
        "explain": "Find lengths of both strings"
    },
    {
        "py": "lcslen = lcs ( str1 , str2 , len1 , len2 , 0 , 0 ) NEW_LINE",
        "explain": "Find length of LCS"
    },
    {
        "py": "data = [ ' a ' for i in range ( MAX ) ] NEW_LINE printAll ( str1 , str2 , len1 , len2 , data , 0 , 0 , 0 ) NEW_LINE",
        "explain": "Prall LCS using recursive backtracking data [ ] is used to store individual LCS ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abcabcaa \" NEW_LINE str2 = \" acbacba \" NEW_LINE prinlAllLCSSorted ( str1 , str2 ) NEW_LINE DEDENT",
        "explain": "Driver program to run the case"
    },
    {
        "py": "def isMajority ( arr , n , x ) : NEW_LINE",
        "explain": "Python3 Program to check for majority element in a sorted array"
    },
    {
        "py": "last_index = ( n // 2 + 1 ) if n % 2 == 0 else ( n // 2 ) NEW_LINE",
        "explain": "get last index according to n ( even or odd )"
    },
    {
        "py": "for i in range ( last_index ) : NEW_LINE",
        "explain": "search for first occurrence of x in arr [ ]"
    },
    {
        "py": "if arr [ i ] == x and arr [ i + n // 2 ] == x : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "check if x is present and is present more than n / 2 times"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE if ( isMajority ( arr , n , x ) ) : NEW_LINE INDENT print ( \" % \u2581 d \u2581 appears \u2581 more \u2581 than \u2581 % \u2581 d \u2581 times \u2581 in \u2581 arr [ ] \" % ( x , n // 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" % \u2581 d \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \u2581 % \u2581 d \u2581 times \u2581 in \u2581 arr [ ] \" % ( x , n // 2 ) ) NEW_LINE DEDENT",
        "explain": "Driver program to check above function"
    },
    {
        "py": "def _binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT DEDENT",
        "explain": "If x is present in arr [ low ... high ] then returns the index of first occurrence of x , otherwise returns - 1"
    },
    {
        "py": "if ( mid == 0 or x > arr [ mid - 1 ] ) and ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif x > arr [ mid ] : NEW_LINE INDENT return _binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return _binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT return - 1 NEW_LINE",
        "explain": "Check if arr [ mid ] is the first occurrence of x . arr [ mid ] is first occurrence if x is one of the following is true : ( i ) mid == 0 and arr [ mid ] = = x ( ii ) arr [ mid - 1 ] < x and arr [ mid ] == x"
    },
    {
        "py": "def isMajority ( arr , n , x ) : NEW_LINE",
        "explain": "This function returns true if the x is present more than n / 2 times in arr [ ] of size n"
    },
    {
        "py": "i = _binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE",
        "explain": "Find the index of first occurrence of x in arr [ ]"
    },
    {
        "py": "if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If element is not present at all , return false"
    },
    {
        "py": "if ( ( i + n // 2 ) <= ( n - 1 ) ) and arr [ i + n // 2 ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "check if the element is present more than n / 2 times"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 3 , 3 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE if ( isMajorityElement ( arr , n , x ) ) : NEW_LINE INDENT print ( x , \" \u2581 appears \u2581 more \u2581 than \u2581 \" , n // 2 , \" \u2581 times \u2581 in \u2581 arr [ ] \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , \" \u2581 does \u2581 not \u2581 appear \u2581 more \u2581 than \" , n // 2 , \" \u2581 times \u2581 in \u2581 arr [ ] \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "INT_MIN = - 32767 NEW_LINE",
        "explain": "A Dynamic Programming solution for Rod cutting problem"
    },
    {
        "py": "def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE DEDENT",
        "explain": "Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE",
        "explain": "Build the table val [ ] in bottom up manner and return the last entry from the table"
    },
    {
        "py": "arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + str ( cutRod ( arr , size ) ) ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "def isPossible ( target ) : NEW_LINE",
        "explain": "Function to check if the arr [ ] can be converted to target [ ] by replacing any element in arr [ ] by the sum of arr [ ]"
    },
    {
        "py": "INDENT max = 0 NEW_LINE DEDENT",
        "explain": "Store the maximum element"
    },
    {
        "py": "INDENT index = 0 NEW_LINE DEDENT",
        "explain": "Store the index of the maximum element"
    },
    {
        "py": "INDENT for i in range ( len ( target ) ) : NEW_LINE DEDENT",
        "explain": "Traverse the array target [ ]"
    },
    {
        "py": "if ( max < target [ i ] ) : NEW_LINE max = target [ i ] NEW_LINE index = i NEW_LINE",
        "explain": "If current element is greater than max"
    },
    {
        "py": "INDENT if ( max == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT",
        "explain": "If max element is 1"
    },
    {
        "py": "INDENT for i in range ( len ( target ) ) : NEW_LINE DEDENT",
        "explain": "Traverse the array , target [ ]"
    },
    {
        "py": "if ( i != index ) : NEW_LINE",
        "explain": "If current index is not equal to maximum element index"
    },
    {
        "py": "max -= target [ i ] NEW_LINE",
        "explain": "Update max"
    },
    {
        "py": "if ( max <= 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If max is less than or equal to 0 ,"
    },
    {
        "py": "INDENT target [ index ] = max NEW_LINE DEDENT",
        "explain": "Update the maximum element"
    },
    {
        "py": "INDENT return isPossible ( target ) NEW_LINE DEDENT",
        "explain": "Recursively call the function"
    },
    {
        "py": "target = [ 9 , 3 , 5 ] NEW_LINE res = isPossible ( target ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def nCr ( n , r ) : NEW_LINE",
        "explain": "Function returns nCr i . e . Binomial Coefficient"
    },
    {
        "py": "res = 1 NEW_LINE",
        "explain": "Initialize res with 1"
    },
    {
        "py": "if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT",
        "explain": "Since C ( n , r ) = C ( n , n - r )"
    },
    {
        "py": "for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Evaluating expression"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 NEW_LINE print ( nCr ( n + m , k ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python Program to check if N can be obtained from 1 by repetitive multiplication by 10 or 20"
    },
    {
        "py": "def Is_possible ( N ) : NEW_LINE INDENT C = 0 NEW_LINE D = 0 NEW_LINE DEDENT",
        "explain": "Function to check if N can be obtained or not"
    },
    {
        "py": "while ( N % 10 == 0 ) : NEW_LINE INDENT N = N / 10 NEW_LINE C += 1 NEW_LINE DEDENT",
        "explain": "Count and remove trailing zeroes"
    },
    {
        "py": "if ( math . log ( N , 2 ) - int ( math . log ( N , 2 ) ) == 0 ) : NEW_LINE INDENT D = int ( math . log ( N , 2 ) ) NEW_LINE DEDENT",
        "explain": "Check if remaining N is a power of 2"
    },
    {
        "py": "if ( C >= D ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT else : NEW_LINE print ( \" NO \" ) NEW_LINE",
        "explain": "To check the condition to print YES or NO"
    },
    {
        "py": "N = 2000000000000 NEW_LINE Is_possible ( N ) NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "def findNthTerm ( n ) : NEW_LINE INDENT print ( n * n - n + 1 ) NEW_LINE DEDENT",
        "explain": "Function to find N - th term in the series"
    },
    {
        "py": "N = 4 NEW_LINE findNthTerm ( N ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def rev ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT DEDENT",
        "explain": "Iterative function to reverse digits of num"
    },
    {
        "py": "return rev_num NEW_LINE",
        "explain": "Return the reversed num"
    },
    {
        "py": "def divSum ( num ) : NEW_LINE",
        "explain": "Function to calculate sum of reverse all proper divisors"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Final result of summation of divisors"
    },
    {
        "py": "for i in range ( 2 , int ( num ** 0.5 ) ) : NEW_LINE",
        "explain": "Find all divisors of num"
    },
    {
        "py": "' NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE DEDENT",
        "explain": "If ' i ' is divisor of 'num"
    },
    {
        "py": "if ( i == ( num / i ) ) : NEW_LINE INDENT result += rev ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT result += ( rev ( i ) + rev ( num / i ) ) NEW_LINE DEDENT",
        "explain": "If both divisors are same then add it only once else add both"
    },
    {
        "py": "return ( result + 1 ) NEW_LINE",
        "explain": "Add 1 to the result as 1 is also a divisor"
    },
    {
        "py": "def isAntiPerfect ( n ) : NEW_LINE INDENT return divSum ( n ) == n NEW_LINE DEDENT",
        "explain": "Function to check if N is anti - perfect or not"
    },
    {
        "py": "N = 244 NEW_LINE",
        "explain": "Given Number N"
    },
    {
        "py": "if ( isAntiPerfect ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "def printSeries ( n , a , b , c ) : NEW_LINE",
        "explain": "Function to print the series"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) ; NEW_LINE return ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT print ( a , b , end = \" \u2581 \" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( a , b , c , end = \" \u2581 \" ) ; NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT d = a + b + c ; NEW_LINE print ( d , end = \" \u2581 \" ) ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE c = d ; NEW_LINE DEDENT",
        "explain": "Generate the ith term and print it"
    },
    {
        "py": "N = 7 ; a = 1 ; b = 3 ; NEW_LINE c = 4 ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "printSeries ( N , a , b , c ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def diameter ( n ) : NEW_LINE",
        "explain": "Function to find diameter of BIT with N + 1 nodes"
    },
    {
        "py": "L , H , templen = 0 , 0 , 0 ; NEW_LINE L = 1 ; NEW_LINE",
        "explain": "L is size of subtree just before subtree in which N lies"
    },
    {
        "py": "H = 0 ; NEW_LINE",
        "explain": "H is the height of subtree just before subtree in which N lies"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT",
        "explain": "Base Cases"
    },
    {
        "py": "while ( L * 2 <= n ) : NEW_LINE INDENT L *= 2 ; NEW_LINE H += 1 ; NEW_LINE DEDENT",
        "explain": "Size of subtree are power of 2"
    },
    {
        "py": "if ( n >= L * 2 - 1 ) : NEW_LINE INDENT return 2 * H + 1 ; NEW_LINE DEDENT elif ( n >= L + ( L / 2 ) - 1 ) : NEW_LINE INDENT return 2 * H ; NEW_LINE DEDENT return 2 * H - 1 ; NEW_LINE",
        "explain": "3 Cases as explained in Approach"
    },
    {
        "py": "n = 15 ; NEW_LINE print ( diameter ( n ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def compareValues ( a , b , c , d ) : NEW_LINE",
        "explain": "Function to find whether a ^ b is greater or c ^ d"
    },
    {
        "py": "log1 = math . log10 ( a ) NEW_LINE num1 = log1 * b NEW_LINE",
        "explain": "Find b * log ( a )"
    },
    {
        "py": "log2 = math . log10 ( c ) NEW_LINE num2 = log2 * d NEW_LINE",
        "explain": "Find d * log ( c )"
    },
    {
        "py": "if num1 > num2 : NEW_LINE INDENT print ( a , ' ^ ' , b ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , ' ^ ' , d ) NEW_LINE DEDENT",
        "explain": "Compare both values"
    },
    {
        "py": "a = 8 NEW_LINE b = 29 NEW_LINE c = 60 NEW_LINE d = 59 NEW_LINE compareValues ( a , b , c , d ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 100005 NEW_LINE",
        "explain": "Python3 program for above approach"
    },
    {
        "py": "def addPrimes ( ) : NEW_LINE INDENT n = MAX NEW_LINE prime = [ True for i in range ( n + 1 ) ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT ans = [ ] NEW_LINE DEDENT",
        "explain": "Find all prime numbers"
    },
    {
        "py": "for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT ans . append ( p ) NEW_LINE DEDENT DEDENT return ans NEW_LINE",
        "explain": "Store all prime numbers"
    },
    {
        "py": "def is_prime ( n ) : NEW_LINE INDENT if n in [ 3 , 5 , 7 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "Function to check if a digit is odd prime or not"
    },
    {
        "py": "def find_Sum ( n ) : NEW_LINE",
        "explain": "Function to find sum"
    },
    {
        "py": "Sum = 0 NEW_LINE",
        "explain": "To store required answer"
    },
    {
        "py": "v = addPrimes ( ) NEW_LINE",
        "explain": "Get all prime numbers"
    },
    {
        "py": "for i in range ( len ( v ) ) : NEW_LINE",
        "explain": "Traverse through all the prime numbers"
    },
    {
        "py": "flag = 1 NEW_LINE a = v [ i ] NEW_LINE",
        "explain": "Flag stores 1 if a number does not contain any odd primes"
    },
    {
        "py": "while ( a != 0 ) : NEW_LINE INDENT d = a % 10 ; NEW_LINE a = a // 10 ; NEW_LINE if ( is_prime ( d ) ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Find all digits of a number"
    },
    {
        "py": "if ( flag == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE Sum = Sum + v [ i ] NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If number does not contain any odd primes"
    },
    {
        "py": "return Sum NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "n = 7 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( find_Sum ( n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def primeCount ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count of primes in the given array"
    },
    {
        "py": "max_val = max ( arr ) NEW_LINE",
        "explain": "Find maximum value in the array"
    },
    {
        "py": "prime = [ True ] * ( max_val + 1 ) NEW_LINE",
        "explain": "USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array \" prime [ 0 . . n ] \" . A value in prime [ i ] will finally be False if i is Not a prime , else True ."
    },
    {
        "py": "prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE",
        "explain": "Remaining part of SIEVE"
    },
    {
        "py": "if prime [ p ] == True : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE",
        "explain": "Find all primes in arr [ ]"
    },
    {
        "py": "def getPrefixArray ( arr , n , pre ) : NEW_LINE",
        "explain": "Function to generate the prefix array"
    },
    {
        "py": "pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT",
        "explain": "Fill the prefix array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE",
        "explain": "Prefix array of arr [ ]"
    },
    {
        "py": "print ( primeCount ( pre , n ) ) NEW_LINE",
        "explain": "Count of primes in the prefix array"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python implementation of the approach"
    },
    {
        "py": "def minValue ( n , x , y ) : NEW_LINE",
        "explain": "Function to return the required value that must be added to x so that it is at least y percent of n"
    },
    {
        "py": "val = ( y * n ) / 100 NEW_LINE",
        "explain": "Required value"
    },
    {
        "py": "if x >= val : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return math . ceil ( val ) - x NEW_LINE DEDENT",
        "explain": "If x is already >= y percent of n"
    },
    {
        "py": "n = 10 ; x = 2 ; y = 40 NEW_LINE print ( minValue ( n , x , y ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program to check if given number is a factorial prime"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Utility function to check if a number is prime or not"
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "This is checked so that we can skip middle five numbers in below loop"
    },
    {
        "py": "def isFactorialPrime ( n ) : NEW_LINE",
        "explain": "Function that returns true if n is a factorial prime"
    },
    {
        "py": "if ( not isPrime ( n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT fact = 1 NEW_LINE i = 1 NEW_LINE while ( fact <= n + 1 ) : NEW_LINE",
        "explain": "If n is not prime then return false"
    },
    {
        "py": "fact = fact * i NEW_LINE",
        "explain": "Calculate factorial"
    },
    {
        "py": "if ( n + 1 == fact or n - 1 == fact ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "If n is a factorial prime"
    },
    {
        "py": "return False NEW_LINE",
        "explain": "n is not a factorial prime"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 23 NEW_LINE if ( isFactorialPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "n = 5 NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "fac1 = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fac1 = fac1 * i NEW_LINE DEDENT",
        "explain": "find fac1 = ( n - 1 ) !"
    },
    {
        "py": "fac2 = fac1 * n NEW_LINE",
        "explain": "Find fac2 = n !"
    },
    {
        "py": "totalWays = fac1 * fac2 NEW_LINE",
        "explain": "Find total number of ways"
    },
    {
        "py": "print ( totalWays ) NEW_LINE",
        "explain": "Print the total number of ways"
    },
    {
        "py": "MAX = 10000 NEW_LINE arr = [ ] NEW_LINE",
        "explain": "Python 3 program to check Euclid Number"
    },
    {
        "py": "def SieveOfEratosthenes ( ) : NEW_LINE",
        "explain": "Function to generate prime numbers"
    },
    {
        "py": "prime = [ True ] * MAX NEW_LINE p = 2 NEW_LINE while p * p < MAX : NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."
    },
    {
        "py": "if ( prime [ p ] == True ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "' NEW_LINE INDENT for p in range ( 2 , MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT arr . append ( p ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "store all prime numbers to vector 'arr"
    },
    {
        "py": "def isEuclid ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while ( product < n ) : NEW_LINE DEDENT",
        "explain": "Function to check the number for Euclid Number"
    },
    {
        "py": "product = product * arr [ i ] NEW_LINE if ( product + 1 == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE return False NEW_LINE",
        "explain": "Multiply next prime number and check if product + 1 = n holds or not"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "SieveOfEratosthenes ( ) NEW_LINE",
        "explain": "Get the prime numbers"
    },
    {
        "py": "n = 31 NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Check if n is Euclid Number"
    },
    {
        "py": "n = 42 NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "if ( isEuclid ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Check if n is Euclid Number"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "Python 3 implementation of above approach"
    },
    {
        "py": "def nextPerfectCube ( N ) : NEW_LINE INDENT nextN = floor ( N ** ( 1 / 3 ) ) + 1 NEW_LINE return nextN ** 3 NEW_LINE DEDENT",
        "explain": "Function to find the next perfect cube"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 35 NEW_LINE print ( nextPerfectCube ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find sum of prime divisors of N"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Function to check if the number is prime or not ."
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE",
        "explain": "This is checked so that we can skip middle five numbers in below loop"
    },
    {
        "py": "def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE DEDENT",
        "explain": "function to find sum of prime divisors of N"
    },
    {
        "py": "root_n = ( int ) ( math . sqrt ( n ) ) NEW_LINE for i in range ( 1 , root_n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT",
        "explain": "return type of sqrt function if float"
    },
    {
        "py": "if ( i == ( int ) ( n / i ) and isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT else : NEW_LINE",
        "explain": "both factors are same"
    },
    {
        "py": "if ( isPrime ( i ) ) : NEW_LINE INDENT Sum += i NEW_LINE DEDENT if ( isPrime ( ( int ) ( n / i ) ) ) : NEW_LINE INDENT Sum += ( int ) ( n / i ) NEW_LINE DEDENT return Sum NEW_LINE",
        "explain": "both factors are not same ( i and n / i )"
    },
    {
        "py": "n = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \" , SumOfPrimeDivisors ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findpos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in n : NEW_LINE DEDENT",
        "explain": "Program position of n among the numbers made of 2 , 3 , 5 & 7"
    },
    {
        "py": "if i == '2' : NEW_LINE INDENT pos = pos * 4 + 1 NEW_LINE DEDENT",
        "explain": "If number is 2 then it is on the position pos * 2 + 1"
    },
    {
        "py": "elif i == '3' : NEW_LINE INDENT pos = pos * 4 + 2 NEW_LINE DEDENT",
        "explain": "If number is 3 then it is on the position pos * 2 + 2"
    },
    {
        "py": "elif i == '5' : NEW_LINE INDENT pos = pos * 4 + 3 NEW_LINE DEDENT",
        "explain": "If number is 5 then it is on the position pos * 2 + 3"
    },
    {
        "py": "elif i == '7' : NEW_LINE INDENT pos = pos * 4 + 4 NEW_LINE DEDENT return pos NEW_LINE",
        "explain": "If number is 7 then it is on the position pos * 2 + 4"
    },
    {
        "py": "n = \"777\" NEW_LINE print ( findpos ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def possibleTripletInRange ( L , R ) : NEW_LINE INDENT flag = False ; NEW_LINE possibleA = 0 ; NEW_LINE possibleB = 0 ; NEW_LINE possibleC = 0 ; NEW_LINE numbersInRange = ( R - L + 1 ) ; NEW_LINE DEDENT",
        "explain": "Checks if any possible triplet ( a , b , c ) satifying the condition that ( a , b ) is coprime , ( b , c ) is coprime but ( a , c ) isnt"
    },
    {
        "py": "if ( numbersInRange < 3 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT",
        "explain": "Case 1 : Less than 3 numbers between L and R"
    },
    {
        "py": "elif ( numbersInRange > 3 ) : NEW_LINE INDENT flag = True ; NEW_LINE DEDENT",
        "explain": "Case 2 : More than 3 numbers between L and R"
    },
    {
        "py": "if ( ( L % 2 ) > 0 ) : NEW_LINE INDENT L += 1 ; NEW_LINE DEDENT possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE else : NEW_LINE",
        "explain": "triplets should always be of form ( 2 k , 2 k + 1 , 2 k + 2 )"
    },
    {
        "py": "if ( ( L % 2 ) == 0 ) : NEW_LINE INDENT flag = True ; NEW_LINE possibleA = L ; NEW_LINE possibleB = L + 1 ; NEW_LINE possibleC = L + 2 ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Case 3.1 : Exactly 3 numbers in range of form ( 2 k , 2 k + 1 , 2 k + 2 )"
    },
    {
        "py": "flag = False ; NEW_LINE",
        "explain": "Case 3.2 : Exactly 3 numbers in range of form ( 2 k - 1 , 2 k , 2 k + 1 )"
    },
    {
        "py": "if ( flag == True ) : NEW_LINE INDENT print ( \" ( \" , possibleA , \" , \" , possibleB , \" , \" , possibleC , \" ) \u2581 is \u2581 one \u2581 such \" , \" possible \u2581 triplet \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \u2581 Such \u2581 Triplet \u2581 exists \u2581 between \" , L , \" and \" , R ) ; NEW_LINE DEDENT",
        "explain": "flag = True indicates that a pair exists between L and R"
    },
    {
        "py": "L = 2 ; NEW_LINE R = 10 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE",
        "explain": "finding possible Triplet between 2 and 10"
    },
    {
        "py": "L = 23 ; NEW_LINE R = 46 ; NEW_LINE possibleTripletInRange ( L , R ) ; NEW_LINE",
        "explain": "finding possible Triplet between 23 and 46"
    },
    {
        "py": "mod = 1000000007 NEW_LINE",
        "explain": "Python Implementation of above method"
    },
    {
        "py": "def digitNumber ( n ) : NEW_LINE",
        "explain": "Finding number of possible number with n digits excluding a particular digit"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Checking if number of digits is zero"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT",
        "explain": "Checking if number of digits is one"
    },
    {
        "py": "if ( n % 2 != 0 ) : NEW_LINE",
        "explain": "Checking if number of digits is odd"
    },
    {
        "py": "temp = digitNumber ( ( n - 1 ) // 2 ) % mod NEW_LINE return ( 9 * ( temp * temp ) % mod ) % mod NEW_LINE else : NEW_LINE",
        "explain": "Calling digitNumber function with ( digit - 1 ) / 2 digits"
    },
    {
        "py": "temp = digitNumber ( n // 2 ) % mod NEW_LINE return ( temp * temp ) % mod NEW_LINE def countExcluding ( n , d ) : NEW_LINE",
        "explain": "Calling digitNumber function with n / 2 digits"
    },
    {
        "py": "if ( d == 0 ) : NEW_LINE INDENT return ( 9 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return ( 8 * digitNumber ( n - 1 ) ) % mod NEW_LINE DEDENT",
        "explain": "Calling digitNumber function Checking if excluding digit is zero or non - zero"
    },
    {
        "py": "d = 9 NEW_LINE n = 3 NEW_LINE print ( countExcluding ( n , d ) ) NEW_LINE",
        "explain": "Initializing variables"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Returns true if n is prime . Else false ."
    },
    {
        "py": "if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Corner case"
    },
    {
        "py": "for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "Check from 2 to n - 1"
    },
    {
        "py": "def isEmirp ( n ) : NEW_LINE",
        "explain": "Function will check whether number is Emirp or not"
    },
    {
        "py": "n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check if n is prime"
    },
    {
        "py": "rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT",
        "explain": "Find reverse of n"
    },
    {
        "py": "return isPrime ( rev ) NEW_LINE",
        "explain": "If both Original and Reverse are Prime , then it is an Emirp number"
    },
    {
        "py": "n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Input number"
    },
    {
        "py": "def Convert ( radian ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE degree = radian * ( 180 / pi ) NEW_LINE return degree NEW_LINE DEDENT",
        "explain": "Function for convertion"
    },
    {
        "py": "radian = 5 NEW_LINE print ( \" degree \u2581 = \" , ( Convert ( radian ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT",
        "explain": "Return sum of first n integers of an AP"
    },
    {
        "py": "def trace ( n , m ) : NEW_LINE",
        "explain": "Return the trace of sum of row - major matrix and column - major matrix"
    },
    {
        "py": "an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE",
        "explain": "Finding nth element in AP in case of Row major matrix ."
    },
    {
        "py": "rowmajorSum = sn ( n , an ) ; NEW_LINE",
        "explain": "Finding sum of first n integers of AP in case of Row major matrix"
    },
    {
        "py": "an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE",
        "explain": "Finding nth element in AP in case of Row major matrix"
    },
    {
        "py": "colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE",
        "explain": "Finding sum of first n integers of AP in case of Column major matrix"
    },
    {
        "py": "N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def max_area ( n , m , k ) : NEW_LINE INDENT if ( k > ( n + m - 2 ) ) : NEW_LINE INDENT print ( \" Not \u2581 possible \" ) NEW_LINE DEDENT else : NEW_LINE DEDENT",
        "explain": "Utility Function"
    },
    {
        "py": "if ( k < max ( m , n ) - 1 ) : NEW_LINE INDENT result = max ( m * ( n / ( k + 1 ) ) , n * ( m / ( k + 1 ) ) ) ; NEW_LINE DEDENT",
        "explain": "for the 1 st case"
    },
    {
        "py": "else : NEW_LINE INDENT result = max ( m / ( k - n + 2 ) , n / ( k - m + 2 ) ) ; NEW_LINE DEDENT",
        "explain": "for the second case"
    },
    {
        "py": "print ( result ) NEW_LINE",
        "explain": "print final result"
    },
    {
        "py": "n = 3 NEW_LINE m = 4 NEW_LINE k = 1 NEW_LINE max_area ( n , m , k ) NEW_LINE",
        "explain": "driver code"
    },
    {
        "py": "def area_fun ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT",
        "explain": "function to find the area"
    },
    {
        "py": "side = 4 NEW_LINE area = area_fun ( side ) NEW_LINE print ( area ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def countConsecutive ( N ) : NEW_LINE",
        "explain": "Utility method to compute number of ways in which N can be represented as sum of consecutive number"
    },
    {
        "py": "count = 0 NEW_LINE L = 1 NEW_LINE while ( L * ( L + 1 ) < 2 * N ) : NEW_LINE INDENT a = ( 1.0 * N - ( L * ( L + 1 ) ) / 2 ) / ( L + 1 ) NEW_LINE if ( a - int ( a ) == 0.0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT L += 1 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "constraint on values of L gives us the time Complexity as O ( N ^ 0.5 )"
    },
    {
        "py": "N = 15 NEW_LINE print countConsecutive ( N ) NEW_LINE N = 10 NEW_LINE print countConsecutive ( N ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isAutomorphic ( N ) : NEW_LINE",
        "explain": "Function to check Automorphic number"
    },
    {
        "py": "sq = N * N NEW_LINE",
        "explain": "Store the square"
    },
    {
        "py": "while ( N > 0 ) : NEW_LINE",
        "explain": "Start Comparing digits"
    },
    {
        "py": "if ( N % 10 != sq % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Return false , if any digit of N doesn ' t \u2581 \u2581 match \u2581 with \u2581 its \u2581 square ' s digits from last"
    },
    {
        "py": "N /= 10 NEW_LINE sq /= 10 NEW_LINE return True NEW_LINE",
        "explain": "Reduce N and square"
    },
    {
        "py": "N = 5 NEW_LINE if isAutomorphic ( N ) : NEW_LINE INDENT print \" Automorphic \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" Not \u2581 Automorphic \" NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxPrimefactorNum ( N ) : NEW_LINE",
        "explain": "Return smallest number having maximum prime factors ."
    },
    {
        "py": "arr = [ True ] * ( N + 5 ) ; NEW_LINE",
        "explain": "default value of boolean is false"
    },
    {
        "py": "i = 3 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] = False ; NEW_LINE DEDENT DEDENT i += 2 ; NEW_LINE DEDENT",
        "explain": "Sieve of eratosthenes"
    },
    {
        "py": "prime = [ ] ; NEW_LINE prime . append ( 2 ) ; NEW_LINE for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT prime . append ( i ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Storing prime numbers ."
    },
    {
        "py": "i = 0 ; NEW_LINE ans = 1 ; NEW_LINE while ( ans * prime [ i ] <= N and i < len ( prime ) ) : NEW_LINE INDENT ans *= prime [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE",
        "explain": "Generating number having maximum prime factors ."
    },
    {
        "py": "N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "PYTHON program to find sum of all divisors of a natural number"
    },
    {
        "py": "def divSum ( num ) : NEW_LINE",
        "explain": "Function to calculate sum of all proper divisors num -- > given natural number"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Final result of summation of divisors"
    },
    {
        "py": "' NEW_LINE INDENT i = 2 NEW_LINE while i <= ( math . sqrt ( num ) ) : NEW_LINE DEDENT",
        "explain": "find all divisors which divides 'num"
    },
    {
        "py": "' NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE DEDENT",
        "explain": "if ' i ' is divisor of 'num"
    },
    {
        "py": "if ( i == ( num / i ) ) : NEW_LINE INDENT result = result + i ; NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + num / i ) ; NEW_LINE DEDENT i = i + 1 NEW_LINE",
        "explain": "if both divisors are same then add it only once else add both"
    },
    {
        "py": "return ( result + 1 ) ; NEW_LINE",
        "explain": "Add 1 to the result as 1 is also a divisor"
    },
    {
        "py": "num = 36 NEW_LINE print ( divSum ( num ) ) NEW_LINE",
        "explain": "Driver program to run the case"
    },
    {
        "py": "def power ( x , y , p ) : NEW_LINE",
        "explain": "Utility function to do modular exponentiation . It returns ( x ^ y ) % p ."
    },
    {
        "py": "while ( y > 0 ) : NEW_LINE",
        "explain": "res = 1 Initialize result x = x % p Update x if it is more than or equal to p"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT",
        "explain": "If y is odd , multiply x with result"
    },
    {
        "py": "x = ( x * x ) % p NEW_LINE return res NEW_LINE",
        "explain": "y must be even now y = y >> 1 y = y / 2"
    },
    {
        "py": "def squareRoot ( n , p ) : NEW_LINE INDENT if ( p % 4 != 3 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return NEW_LINE DEDENT DEDENT",
        "explain": "Returns true if square root of n under modulo p exists . Assumption : p is of the form 3 * i + 4 where i >= 1"
    },
    {
        "py": "n = n % p NEW_LINE x = power ( n , ( p + 1 ) // 4 , p ) NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( \" Square \u2581 root \u2581 is \u2581 \" , x ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Try \" + ( n ^ ( ( p \u2581 + \u2581 1 ) / 4 ) ) \""
    },
    {
        "py": "x = p - x NEW_LINE if ( ( x * x ) % p == n ) : NEW_LINE INDENT print ( \" Square \u2581 root \u2581 is \u2581 \" , x ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Try \" - ( n \u2581 ^ \u2581 ( ( p \u2581 + \u2581 1 ) / 4 ) ) \""
    },
    {
        "py": "print ( \" Square \u2581 root \u2581 doesn ' t \u2581 exist \u2581 \" ) NEW_LINE",
        "explain": "If none of the above two work , then square root doesn 't exist"
    },
    {
        "py": "p = 7 NEW_LINE n = 2 NEW_LINE squareRoot ( n , p ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import random NEW_LINE",
        "explain": "Python3 program Miller - Rabin primality test"
    },
    {
        "py": "def power ( x , y , p ) : NEW_LINE",
        "explain": "Utility function to do modular exponentiation . It returns ( x ^ y ) % p"
    },
    {
        "py": "res = 1 ; NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE",
        "explain": "Update x if it is more than or equal to p"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT",
        "explain": "If y is odd , multiply x with result"
    },
    {
        "py": "x = ( x * x ) % p ; NEW_LINE return res ; NEW_LINE",
        "explain": "y must be even now y = y >> 1 ; y = y / 2"
    },
    {
        "py": "def miillerTest ( d , n ) : NEW_LINE",
        "explain": "This function is called for all k trials . It returns false if n is composite and returns false if n is probably prime . d is an odd number such that d * 2 < sup > r < / sup > = n - 1 for some r >= 1"
    },
    {
        "py": "a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE",
        "explain": "Pick a random number in [ 2. . n - 2 ] Corner cases make sure that n > 4"
    },
    {
        "py": "x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT",
        "explain": "Compute a ^ d % n"
    },
    {
        "py": "while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT",
        "explain": "Keep squaring x while one of the following doesn 't  happen  (i) d does not reach n-1  (ii) (x^2) % n is not 1  (iii) (x^2) % n is not n-1"
    },
    {
        "py": "return False ; NEW_LINE",
        "explain": "Return composite"
    },
    {
        "py": "def isPrime ( n , k ) : NEW_LINE",
        "explain": "It returns false if n is composite and returns true if n is probably prime . k is an input parameter that determines accuracy level . Higher value of k indicates more accuracy ."
    },
    {
        "py": "if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT",
        "explain": "Find r such that n = 2 ^ d * r + 1 for some r >= 1"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE",
        "explain": "Iterate given nber of ' k ' times"
    },
    {
        "py": "k = 4 ; NEW_LINE print ( \" All \u2581 primes \u2581 smaller \u2581 than \u2581 100 : \u2581 \" ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code Number of iterations"
    },
    {
        "py": "def maxConsecutiveOnes ( x ) : NEW_LINE",
        "explain": "Function to find length of the longest consecutive 1 s in binary representation of a number"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "while ( x != 0 ) : NEW_LINE",
        "explain": "Count the number of iterations to reach x = 0."
    },
    {
        "py": "x = ( x & ( x << 1 ) ) NEW_LINE count = count + 1 NEW_LINE return count NEW_LINE",
        "explain": "This operation reduces length of every sequence of 1 s by one ."
    },
    {
        "py": "print ( maxConsecutiveOnes ( 14 ) ) NEW_LINE print ( maxConsecutiveOnes ( 222 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def subtract ( x , y ) : NEW_LINE",
        "explain": "Python program to Subtract two numbers without using arithmetic operators"
    },
    {
        "py": "while ( y != 0 ) : NEW_LINE",
        "explain": "Iterate till there is no carry"
    },
    {
        "py": "borrow = ( ~ x ) & y NEW_LINE",
        "explain": "borrow contains common set bits of y and unset bits of x"
    },
    {
        "py": "x = x ^ y NEW_LINE",
        "explain": "Subtraction of bits of x and y where at least one of the bits is not set"
    },
    {
        "py": "y = borrow << 1 NEW_LINE return x NEW_LINE",
        "explain": "Borrow is shifted by one so that subtracting it from x gives the required sum"
    },
    {
        "py": "x = 29 NEW_LINE y = 13 NEW_LINE print ( \" x \u2581 - \u2581 y \u2581 is \" , subtract ( x , y ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def subtract ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return x NEW_LINE DEDENT return subtract ( x ^ y , ( ~ x & y ) << 1 ) NEW_LINE DEDENT",
        "explain": "Python Program to subtract two Number without using arithmetic operator Recursive implementation ."
    },
    {
        "py": "x = 29 NEW_LINE y = 13 NEW_LINE print ( \" x \u2581 - \u2581 y \u2581 is \" , subtract ( x , y ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def addEdge ( v , x , y ) : NEW_LINE INDENT v [ x ] . append ( y ) NEW_LINE v [ y ] . append ( x ) NEW_LINE DEDENT",
        "explain": "Function to add an edge in the tree"
    },
    {
        "py": "def dfs ( tree , temp , ancestor , u , parent , k ) : NEW_LINE",
        "explain": "DFS to find the Kth ancestor of every node"
    },
    {
        "py": "temp . append ( u ) NEW_LINE",
        "explain": "Pushing current node in the vector"
    },
    {
        "py": "for i in tree [ u ] : NEW_LINE INDENT if ( i == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( tree , temp , ancestor , i , u , k ) NEW_LINE DEDENT temp . pop ( ) NEW_LINE",
        "explain": "Traverse its neighbors"
    },
    {
        "py": "if ( len ( temp ) < k ) : NEW_LINE INDENT ancestor [ u ] = - 1 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If K ancestors are not found for current node"
    },
    {
        "py": "ancestor [ u ] = temp [ len ( temp ) - k ] NEW_LINE",
        "explain": "Add the Kth ancestor for the node"
    },
    {
        "py": "def KthAncestor ( N , K , E , edges ) : NEW_LINE",
        "explain": "Function to find Kth ancestor of each node"
    },
    {
        "py": "tree = [ [ ] for i in range ( N + 1 ) ] NEW_LINE for i in range ( E ) : NEW_LINE INDENT addEdge ( tree , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) NEW_LINE DEDENT",
        "explain": "Building the tree"
    },
    {
        "py": "temp = [ ] NEW_LINE",
        "explain": "Stores all parents of a node"
    },
    {
        "py": "ancestor = [ 0 ] * ( N + 1 ) NEW_LINE dfs ( tree , temp , ancestor , 1 , 0 , K ) NEW_LINE",
        "explain": "Store Kth ancestor of all nodes"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( ancestor [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the ancestors"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "N = 9 NEW_LINE K = 2 NEW_LINE",
        "explain": "Given N and K"
    },
    {
        "py": "E = 8 NEW_LINE edges = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 7 ] , [ 3 , 8 ] , [ 3 , 9 ] ] NEW_LINE",
        "explain": "Given edges of n - ary tree"
    },
    {
        "py": "KthAncestor ( N , K , E , edges ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def build ( sum , a , l , r , rt ) : NEW_LINE",
        "explain": "Function to build a segment tree"
    },
    {
        "py": "if ( l == r ) : NEW_LINE INDENT sum [ rt ] = a [ l - 1 ] NEW_LINE return NEW_LINE DEDENT",
        "explain": "Check for base case"
    },
    {
        "py": "m = ( l + r ) >> 1 NEW_LINE",
        "explain": "Find mid point"
    },
    {
        "py": "build ( sum , a , l , m , rt << 1 ) NEW_LINE build ( sum , a , m + 1 , r , rt << 1 1 ) NEW_LINE",
        "explain": "Recursively build the segment tree"
    },
    {
        "py": "def pushDown ( sum , add , rt , ln , rn ) : NEW_LINE INDENT if ( add [ rt ] ) : NEW_LINE INDENT add [ rt << 1 ] += add [ rt ] NEW_LINE add [ rt << 1 1 ] += add [ rt ] NEW_LINE sum [ rt << 1 ] += add [ rt ] * ln NEW_LINE sum [ rt << 1 1 ] += add [ rt ] * rn NEW_LINE add [ rt ] = 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function for push down operation on the segment tree"
    },
    {
        "py": "def update ( sum , add , L , R , C , l , r , rt ) : NEW_LINE",
        "explain": "Function to update the segment tree"
    },
    {
        "py": "if ( L <= l and r <= R ) : NEW_LINE INDENT sum [ rt ] += C * ( r - l + 1 ) NEW_LINE add [ rt ] += C NEW_LINE return NEW_LINE DEDENT",
        "explain": "Complete overlap"
    },
    {
        "py": "m = ( l + r ) >> 1 NEW_LINE",
        "explain": "Find mid"
    },
    {
        "py": "pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE",
        "explain": "Perform push down operation on segment tree"
    },
    {
        "py": "if ( L <= m ) : NEW_LINE INDENT update ( sum , add , L , R , C , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT update ( sum , add , L , R , C , m + 1 , r , rt << 1 1 ) NEW_LINE DEDENT",
        "explain": "Recursively update the segment tree"
    },
    {
        "py": "def queryy ( sum , add , L , R , l , r , rt ) : NEW_LINE",
        "explain": "Function to process the queryy"
    },
    {
        "py": "if ( L <= l and r <= R ) : NEW_LINE INDENT return sum [ rt ] NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "m = ( l + r ) >> 1 NEW_LINE",
        "explain": "Find mid"
    },
    {
        "py": "pushDown ( sum , add , rt , m - l + 1 , r - m ) NEW_LINE ans = 0 NEW_LINE",
        "explain": "Perform push down operation on segment tree"
    },
    {
        "py": "if ( L <= m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , l , m , rt << 1 ) NEW_LINE DEDENT if ( R > m ) : NEW_LINE INDENT ans += queryy ( sum , add , L , R , m + 1 , r , ( rt << 1 1 ) ) NEW_LINE DEDENT",
        "explain": "Recursively calculate the result of the queryy"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "def sequenceMaintenance ( n , q , a , b , m ) : NEW_LINE",
        "explain": "Function to count the numbers which are greater than the given queryy"
    },
    {
        "py": "a = sorted ( a ) NEW_LINE",
        "explain": "Sort the input array"
    },
    {
        "py": "sum = [ 0 ] * ( 4 * n ) NEW_LINE add = [ 0 ] * ( 4 * n ) NEW_LINE ans = [ ] NEW_LINE",
        "explain": "Create segment tree of size 4 * n vector < int > sum , add , ans"
    },
    {
        "py": "build ( sum , a , 1 , n , 1 ) NEW_LINE",
        "explain": "Build the segment tree"
    },
    {
        "py": "for i in range ( q ) : NEW_LINE INDENT l = 1 NEW_LINE r = n NEW_LINE pos = - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) >> 1 NEW_LINE if ( queryy ( sum , add , m , m , 1 , n , 1 ) >= b [ i ] ) : NEW_LINE INDENT r = m - 1 NEW_LINE pos = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( pos == - 1 ) : NEW_LINE INDENT ans . append ( 0 ) NEW_LINE DEDENT else : NEW_LINE DEDENT",
        "explain": "Iterate over the queries"
    },
    {
        "py": "ans . append ( n - pos + 1 ) NEW_LINE",
        "explain": "Store result in array"
    },
    {
        "py": "update ( sum , add , pos , n , - m , 1 , n , 1 ) NEW_LINE",
        "explain": "Update the elements in the given range"
    },
    {
        "py": "for i in ans : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the result of queries"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE Q = 3 NEW_LINE M = 1 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE query = [ 4 , 3 , 1 ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "sequenceMaintenance ( N , Q , arr , query , M ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def hasCoprimePair ( arr , n ) : NEW_LINE",
        "explain": "Function to find the final array length by replacing coprime pair with 1"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT",
        "explain": "Iterate over all pairs of element"
    },
    {
        "py": "if ( math . gcd ( arr [ i ] , arr [ j ] ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Check if gcd is 1"
    },
    {
        "py": "return False NEW_LINE",
        "explain": "If no coprime pair found return false"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE arr = [ 6 , 9 , 15 ] NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "if ( hasCoprimePair ( arr , n ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT",
        "explain": "Check if atleast one coprime pair exists in the array"
    },
    {
        "py": "else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT",
        "explain": "If no such pair exists"
    },
    {
        "py": "def Numberofways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for a in range ( 1 , n ) : NEW_LINE INDENT for b in range ( 1 , n ) : NEW_LINE INDENT c = n - ( a + b ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to return the required number of ways"
    },
    {
        "py": "if ( a < b + c and b < a + c and c < a + b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Check if a , b , c can form a triangle"
    },
    {
        "py": "return count ; NEW_LINE",
        "explain": "Return number of ways"
    },
    {
        "py": "n = 15 NEW_LINE print ( Numberofways ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countPairs ( N , arr ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Function to print the count of pair"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( i == arr [ arr [ i ] - 1 ] - 1 ) : NEW_LINE DEDENT",
        "explain": "Iterate over all the elements of the array"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment the count"
    },
    {
        "py": "print ( count // 2 ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 1 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( N , arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def LongestFibSubseq ( A , n ) : NEW_LINE",
        "explain": "Function to return the max Length of Fibonacci subsequence"
    },
    {
        "py": "S = set ( A ) NEW_LINE maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = A [ j ] NEW_LINE y = A [ i ] + A [ j ] NEW_LINE length = 2 NEW_LINE DEDENT DEDENT",
        "explain": "Store all array elements in a hash table"
    },
    {
        "py": "while y in S : NEW_LINE",
        "explain": "check until next fib element is found"
    },
    {
        "py": "z = x + y NEW_LINE x = y NEW_LINE y = z NEW_LINE length += 1 NEW_LINE maxLen = max ( maxLen , length ) NEW_LINE return maxLen if maxLen >= 3 else 0 NEW_LINE",
        "explain": "next element of fib subseq"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE print ( LongestFibSubseq ( A , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def CountMaximum ( arr , n , k ) : NEW_LINE",
        "explain": "Function to count maximum number of elements that can be selected"
    },
    {
        "py": "arr . sort ( ) NEW_LINE Sum , count = 0 , 0 NEW_LINE",
        "explain": "Sort he array"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "Sum += arr [ i ] NEW_LINE",
        "explain": "Add current element to the sum"
    },
    {
        "py": "if ( Sum > k ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "IF sum exceeds k"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the count"
    },
    {
        "py": "arr = [ 30 , 30 , 10 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( CountMaximum ( arr , n , k ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def num_candyTypes ( candies ) : NEW_LINE",
        "explain": "Function to find number of candy types"
    },
    {
        "py": "s = set ( ) NEW_LINE",
        "explain": "Declare a hashset to store candies"
    },
    {
        "py": "for i in range ( len ( candies ) ) : NEW_LINE INDENT s . add ( candies [ i ] ) NEW_LINE DEDENT",
        "explain": "Traverse the given array and inserts element into set"
    },
    {
        "py": "return len ( s ) NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "def distribute_candies ( candies ) : NEW_LINE",
        "explain": "Function to find maximum number of types of candies a person can eat"
    },
    {
        "py": "allowed = len ( candies ) / 2 NEW_LINE",
        "explain": "Store the number of candies allowed to eat"
    },
    {
        "py": "types = num_candyTypes ( candies ) NEW_LINE",
        "explain": "Store the number of candy types"
    },
    {
        "py": "if ( types < allowed ) : NEW_LINE INDENT print ( int ( types ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( allowed ) ) NEW_LINE DEDENT",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "candies = [ 4 , 4 , 5 , 5 , 3 , 3 ] NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "distribute_candies ( candies ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python Program to implement the above approach"
    },
    {
        "py": "def Length_Diagonals ( a , theta ) : NEW_LINE INDENT p = a * math . sqrt ( 2 + ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE q = a * math . sqrt ( 2 - ( 2 * math . cos ( math . radians ( theta ) ) ) ) NEW_LINE return [ p , q ] NEW_LINE DEDENT",
        "explain": "Function to calculate the length of diagonals of a rhombus using length of sides and vertex angle"
    },
    {
        "py": "A = 6 NEW_LINE theta = 45 NEW_LINE ans = Length_Diagonals ( A , theta ) NEW_LINE print ( round ( ans [ 0 ] , 2 ) , round ( ans [ 1 ] , 2 ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE DEDENT",
        "explain": "Function to store EVEN and odd variable"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Store the count of even and odd set bit"
    },
    {
        "py": "x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT",
        "explain": "Count the set bit using in built function"
    },
    {
        "py": "y = bin ( K ) . count ( '1' ) ; NEW_LINE",
        "explain": "Count of set - bit of K"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT print ( \" Even \u2581 = \" , odd , \" , \u2581 Odd \u2581 = \" , even ) ; NEW_LINE DEDENT",
        "explain": "If y is odd then , count of even and odd set bit will be interchanged"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Even \u2581 = \" , even , \" , \u2581 Odd \u2581 = \" , odd ) ; NEW_LINE DEDENT",
        "explain": "Else it will remain same as the original array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver 's Code"
    },
    {
        "py": "countEvenOdd ( arr , n , K ) ; NEW_LINE",
        "explain": "Function call to count even and odd"
    },
    {
        "py": "N = 6 NEW_LINE Even = N // 2 NEW_LINE Odd = N - Even NEW_LINE print ( Even * Odd ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python 3 program for the above approach"
    },
    {
        "py": "def longestSubSequence ( A , N , ind = 0 , lastf = - sys . maxsize - 1 , lasts = sys . maxsize ) : NEW_LINE",
        "explain": "Recursive function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing"
    },
    {
        "py": "if ( ind == N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "ans = longestSubSequence ( A , N , ind + 1 , lastf , lasts ) NEW_LINE",
        "explain": "Not include the current pair in the longest subsequence"
    },
    {
        "py": "if ( A [ ind ] [ 0 ] > lastf and A [ ind ] [ 1 ] < lasts ) : NEW_LINE INDENT ans = max ( ans , longestSubSequence ( A , N , ind + 1 , A [ ind ] [ 0 ] , A [ ind ] [ 1 ] ) + 1 ) NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Including the current pair in the longest subsequence"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( longestSubSequence ( A , N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def countTriplets ( A ) : NEW_LINE",
        "explain": "Function to find the number of triplets whose Bitwise AND is 0."
    },
    {
        "py": "cnt = 0 ; NEW_LINE",
        "explain": "Stores the count of triplets having bitwise AND equal to 0"
    },
    {
        "py": "tuples = { } ; NEW_LINE",
        "explain": "Stores frequencies of all possible A [ i ] & A [ j ]"
    },
    {
        "py": "for a in A : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Update frequency of Bitwise AND of all array elements with a"
    },
    {
        "py": "for a in A : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "for t in tuples : NEW_LINE",
        "explain": "Iterate the map"
    },
    {
        "py": "if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT",
        "explain": "If bitwise AND of triplet is zero , increment cnt"
    },
    {
        "py": "return cnt ; NEW_LINE",
        "explain": "Return the number of triplets whose Bitwise AND is 0."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = [ 2 , 1 , 3 ] ; NEW_LINE",
        "explain": "Input Array"
    },
    {
        "py": "print ( countTriplets ( A ) ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def CountWays ( n ) : NEW_LINE",
        "explain": "Bottom up approach for counting ways to reach a score using 1 and 2 with consecutive 2 allowed"
    },
    {
        "py": "noOfWays = [ 0 ] * ( n + 3 ) NEW_LINE noOfWays [ 0 ] = 1 NEW_LINE noOfWays [ 1 ] = 1 NEW_LINE noOfWays [ 2 ] = 1 + 1 NEW_LINE",
        "explain": "noOfWays [ i ] will store count for value i . 3 extra values are to take care of corner case n = 0"
    },
    {
        "py": "for i in range ( 3 , n + 1 ) : NEW_LINE",
        "explain": "Loop till \" n + 1\" to compute value for \" n \""
    },
    {
        "py": "noOfWays [ i ] = noOfWays [ i - 1 ] + noOfWays [ i - 3 ] NEW_LINE return noOfWays [ n ] NEW_LINE",
        "explain": "number of ways if first run is 1 + number of ways if first run is 2 and second run is 1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def findWinner ( a , n ) : NEW_LINE",
        "explain": "Function to check if player A wins the game or not"
    },
    {
        "py": "v = [ ] NEW_LINE",
        "explain": "Stores size of the groups of 0 s"
    },
    {
        "py": "c = 0 NEW_LINE",
        "explain": "Stores size of the group of 0 s"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( a [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT",
        "explain": "Increment c by 1 if a [ i ] is 0"
    },
    {
        "py": "else : NEW_LINE INDENT if ( c != 0 ) : NEW_LINE INDENT v . append ( c ) NEW_LINE DEDENT c = 0 NEW_LINE DEDENT if ( c != 0 ) : NEW_LINE v . append ( c ) NEW_LINE",
        "explain": "Otherwise , push the size in array and reset c to 0"
    },
    {
        "py": "if ( len ( v ) == 0 ) : NEW_LINE INDENT print ( \" Player \u2581 B \" , end = \" \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If there is no substring of odd length consisting only of 0 s"
    },
    {
        "py": "if ( len ( v ) == 1 ) : NEW_LINE INDENT if ( ( v [ 0 ] & 1 ) != 0 ) : NEW_LINE INDENT print ( \" Player \u2581 A \" , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "explain": "If there is only 1 substring of odd length consisting only of 0 s"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Player \u2581 B \" , end = \" \" ) NEW_LINE DEDENT return NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "first = sys . minsize NEW_LINE second = sys . minsize NEW_LINE",
        "explain": "Stores the size of the largest and second largest substrings of 0 s"
    },
    {
        "py": "for i in range ( len ( v ) ) : NEW_LINE",
        "explain": "Traverse the array v [ ]"
    },
    {
        "py": "if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT",
        "explain": "If current element is greater than first , then update both first and second"
    },
    {
        "py": "elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT",
        "explain": "If arr [ i ] is in between first and second , then update second"
    },
    {
        "py": "if ( ( ( first & 1 ) != 0 ) and ( first + 1 ) // 2 > second ) : NEW_LINE INDENT print ( \" Player \u2581 A \" , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Player \u2581 B \" , end = \" \" ) NEW_LINE DEDENT",
        "explain": "If the condition is satisfied"
    },
    {
        "py": "S = \"1100011\" NEW_LINE N = len ( S ) NEW_LINE findWinner ( S , N ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def can_Construct ( S , K ) : NEW_LINE",
        "explain": "Function to check whether the is K palindrome or not"
    },
    {
        "py": "m = dict ( ) NEW_LINE p = 0 NEW_LINE",
        "explain": "map to frequency of character"
    },
    {
        "py": "if ( len ( S ) == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Check when k is given as same as length of string"
    },
    {
        "py": "for i in S : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Storing the frequency of every character in map"
    },
    {
        "py": "if ( K > len ( S ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If K is greater than size of then return false"
    },
    {
        "py": "for h in m : NEW_LINE INDENT if ( m [ h ] % 2 != 0 ) : NEW_LINE INDENT p = p + 1 NEW_LINE DEDENT DEDENT",
        "explain": "Check that number of character having the odd frequency"
    },
    {
        "py": "if ( K < p ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "If k is less than number of odd frequency character then it is again false otherwise true"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" annabelle \" NEW_LINE K = 4 NEW_LINE if ( can_Construct ( S , K ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def equalIgnoreCase ( str1 , str2 ) : NEW_LINE",
        "explain": "Function to compare two strings ignoring their cases"
    },
    {
        "py": "str1 = str1 . lower ( ) ; NEW_LINE str2 = str2 . lower ( ) ; NEW_LINE",
        "explain": "Convert to lower case"
    },
    {
        "py": "x = str1 == str2 ; NEW_LINE",
        "explain": "Comparing both"
    },
    {
        "py": "return x ; NEW_LINE",
        "explain": "if strings are equal , return true otherwise false"
    },
    {
        "py": "def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Same \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the same or not same if strings are equal or not equal"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" Geeks \" ; NEW_LINE str2 = \" geeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = \" Geek \" ; NEW_LINE str2 = \" geeksforgeeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 program to print Step Pattern"
    },
    {
        "py": "def steps ( string , n ) : NEW_LINE",
        "explain": "function to print the steps"
    },
    {
        "py": "flag = False NEW_LINE x = 0 NEW_LINE",
        "explain": "declare a flag"
    },
    {
        "py": "for i in range ( len ( string ) ) : NEW_LINE",
        "explain": "traverse through all the characters in the string"
    },
    {
        "py": "if ( x == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT",
        "explain": "if the x value is 0. . then we must increment till n ... set flag to true"
    },
    {
        "py": "if ( x == n - 1 ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT",
        "explain": "if the x value is n - 1 then we must decrement till 0 ... set flag as false"
    },
    {
        "py": "for j in range ( x ) : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT print ( string [ i ] ) NEW_LINE",
        "explain": "print x * s"
    },
    {
        "py": "if ( flag == True ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT",
        "explain": "checking whether to increment or decrement x"
    },
    {
        "py": "n = 4 NEW_LINE string = \" GeeksForGeeks \" NEW_LINE print ( \" String : \u2581 \" , string ) NEW_LINE print ( \" Max \u2581 Length \u2581 of \u2581 Steps : \u2581 \" , n ) NEW_LINE",
        "explain": "Get the String and the number n"
    },
    {
        "py": "steps ( string , n ) NEW_LINE",
        "explain": "calling the function"
    },
    {
        "py": "def countFreq ( arr , n ) : NEW_LINE",
        "explain": "Python program to count frequencies of array items"
    },
    {
        "py": "visited = [ False for i in range ( n ) ] NEW_LINE",
        "explain": "mark all array elements as not visited"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse through array elements and count frequencies"
    },
    {
        "py": "if visited [ i ] == True : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Skip this element if already processed"
    },
    {
        "py": "count = 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT visited [ j ] = True NEW_LINE count += 1 NEW_LINE DEDENT DEDENT print ( arr [ i ] , count ) NEW_LINE",
        "explain": "count frequency"
    },
    {
        "py": "a = [ 10 , 20 , 20 , 10 , 10 , 20 , 5 , 20 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isDivisible ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE c = 0 NEW_LINE DEDENT",
        "explain": "function to check whether given binary number is evenly divisible by 2 ^ k or not"
    },
    {
        "py": "for i in range ( 0 , k ) : NEW_LINE INDENT if ( str [ n - i - 1 ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT",
        "explain": "count of number of 0 from last"
    },
    {
        "py": "return ( c == k ) NEW_LINE",
        "explain": "if count = k , number is evenly divisible , so returns true else false"
    },
    {
        "py": "str1 = \"10101100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str1 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "first example"
    },
    {
        "py": "str2 = \"111010100\" NEW_LINE k = 2 NEW_LINE if ( isDivisible ( str2 , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Second example"
    },
    {
        "py": "NO_OF_CHARS = 256 NEW_LINE",
        "explain": "Python program to Check if any anagram of a string is palindrome or not"
    },
    {
        "py": "def canFormPalindrome ( string ) : NEW_LINE",
        "explain": "function to check whether characters of a string can form a palindrome"
    },
    {
        "py": "count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE",
        "explain": "Create a count array and initialize all values as 0"
    },
    {
        "py": "for i in string : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT",
        "explain": "For each character in input strings , increment count in the corresponding count array"
    },
    {
        "py": "odd = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Count odd occurring characters"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "Return true if odd count is 0 or 1 ,"
    },
    {
        "py": "if ( canFormPalindrome ( \" geeksforgeeks \" ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT if ( canFormPalindrome ( \" geeksogeeks \" ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" NO \" NEW_LINE DEDENT",
        "explain": "Driver program to test to print printDups"
    },
    {
        "py": "def isNumber ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] . isdigit ( ) != True : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "This function Returns true if s is a number else false"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "str = \"6790\" NEW_LINE",
        "explain": "Store the input in a str variable"
    },
    {
        "py": "if isNumber ( str ) : NEW_LINE INDENT print ( \" Integer \" ) NEW_LINE DEDENT",
        "explain": "Function returns 1 if all elements are in range '0 \u2581 - \u2581 9'"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" String \" ) NEW_LINE DEDENT",
        "explain": "Function returns 0 if the input is not an integer"
    },
    {
        "py": "def reverse ( string ) : NEW_LINE INDENT if len ( string ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT temp = string [ 0 ] NEW_LINE reverse ( string [ 1 : ] ) NEW_LINE print ( temp , end = ' ' ) NEW_LINE DEDENT",
        "explain": "Function to print reverse of the passed string"
    },
    {
        "py": "string = \" Geeks \u2581 for \u2581 Geeks \" NEW_LINE reverse ( string ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "box1 = 0 NEW_LINE",
        "explain": "Stores the count of distinct colors in box1"
    },
    {
        "py": "box2 = 0 NEW_LINE fact = [ 0 for i in range ( 11 ) ] NEW_LINE",
        "explain": "Stores the count of distinct colors in box2"
    },
    {
        "py": "def getProbability ( balls ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE DEDENT",
        "explain": "Function to calculate the required probability"
    },
    {
        "py": "factorial ( 10 ) NEW_LINE",
        "explain": "Calculate factorial from [ 1 , 10 ]"
    },
    {
        "py": "box2 = len ( balls ) NEW_LINE",
        "explain": "Assign all distinct balls to second box"
    },
    {
        "py": "K = 0 NEW_LINE",
        "explain": "Total number of balls"
    },
    {
        "py": "for i in range ( len ( balls ) ) : NEW_LINE INDENT K += balls [ i ] NEW_LINE DEDENT",
        "explain": "Calculate total number of balls"
    },
    {
        "py": "if ( K % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If K is an odd number"
    },
    {
        "py": "all = comb ( K , K // 2 ) NEW_LINE",
        "explain": "Total ways of distributing the balls in two equal halves"
    },
    {
        "py": "validPermutation = validPermutations ( K // 2 , balls , 0 , 0 ) NEW_LINE",
        "explain": "Required number of ways"
    },
    {
        "py": "return validPermutation / all NEW_LINE",
        "explain": "Return the required probability"
    },
    {
        "py": "def validPermutations ( n , balls , usedBalls , i ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE DEDENT",
        "explain": "Function to calculate total number of possible distributions which satisfies the given conditions"
    },
    {
        "py": "if ( usedBalls == n ) : NEW_LINE",
        "explain": "If used balls is equal to K / 2"
    },
    {
        "py": "if ( box1 == box2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If box1 is equal to box2"
    },
    {
        "py": "if ( i >= len ( balls ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base condition"
    },
    {
        "py": "res = validPermutations ( n , balls , usedBalls , i + 1 ) NEW_LINE",
        "explain": "Stores the number of ways of distributing remaining balls without including the current balls in box1"
    },
    {
        "py": "box1 += 1 NEW_LINE",
        "explain": "Increment box1 by one"
    },
    {
        "py": "for j in range ( 1 , balls [ i ] + 1 ) : NEW_LINE",
        "explain": "Iterate over the range [ 1 , balls [ i ] ]"
    },
    {
        "py": "if ( j == balls [ i ] ) : NEW_LINE INDENT box2 -= 1 NEW_LINE DEDENT",
        "explain": "If all the balls goes to box1 , then decrease box2 by one"
    },
    {
        "py": "combinations = comb ( balls [ i ] , j ) NEW_LINE",
        "explain": "Total number of ways of selecting j balls"
    },
    {
        "py": "res += combinations * validPermutations ( n , balls , usedBalls + j , i + 1 ) NEW_LINE",
        "explain": "Increment res by total number of valid ways of distributing the remaining balls"
    },
    {
        "py": "box1 -= 1 NEW_LINE",
        "explain": "Decrement box1 by one"
    },
    {
        "py": "box2 += 1 NEW_LINE return res NEW_LINE",
        "explain": "Increment box2 by 1"
    },
    {
        "py": "def factorial ( N ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE DEDENT",
        "explain": "Function to calculate factorial of N"
    },
    {
        "py": "fact [ 0 ] = 1 NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT",
        "explain": "Iterate over the range [ 1 , N ]"
    },
    {
        "py": "def comb ( n , r ) : NEW_LINE INDENT global box1 , box2 , fact NEW_LINE res = fact [ n ] // fact [ r ] NEW_LINE res //= fact [ n - r ] NEW_LINE return res NEW_LINE DEDENT",
        "explain": "Function to calculate NcR"
    },
    {
        "py": "arr = [ 2 , 1 , 1 ] NEW_LINE N = 4 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( getProbability ( arr ) ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "from math import sin NEW_LINE",
        "explain": "Python3 Program to find the area of a regular polygon with given radius"
    },
    {
        "py": "def polyarea ( n , r ) : NEW_LINE",
        "explain": "Function to find the area of a regular polygon"
    },
    {
        "py": "if ( r < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Side and radius cannot be negative"
    },
    {
        "py": "A = ( ( ( r * r * n ) * sin ( ( 360 / n ) * 3.14159 / 180 ) ) / 2 ) ; NEW_LINE return round ( A , 3 ) NEW_LINE",
        "explain": "Area degree converted to radians"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , n = 9 , 6 NEW_LINE print ( polyarea ( n , r ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def is_partition_possible ( n , x , y , w ) : NEW_LINE INDENT weight_at_x = defaultdict ( int ) NEW_LINE max_x = - 2e3 NEW_LINE min_x = 2e3 NEW_LINE DEDENT",
        "explain": "Checking if a plane can be divide by a line at 45 degrees such that weight sum is equal"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT new_x = x [ i ] - y [ i ] NEW_LINE max_x = max ( max_x , new_x ) NEW_LINE min_x = min ( min_x , new_x ) NEW_LINE DEDENT",
        "explain": "Rotating each point by 45 degrees and calculating prefix sum . Also , finding maximum and minimum x coordinates"
    },
    {
        "py": "weight_at_x [ new_x ] += w [ i ] NEW_LINE sum_till = [ ] NEW_LINE sum_till . append ( 0 ) NEW_LINE",
        "explain": "storing weight sum upto x - y point"
    },
    {
        "py": "for x in range ( min_x , max_x + 1 ) : NEW_LINE INDENT sum_till . append ( sum_till [ - 1 ] + weight_at_x [ x ] ) NEW_LINE DEDENT total_sum = sum_till [ - 1 ] NEW_LINE partition_possible = False NEW_LINE for i in range ( 1 , len ( sum_till ) ) : NEW_LINE INDENT if ( sum_till [ i ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT DEDENT",
        "explain": "Finding prefix sum"
    },
    {
        "py": "if ( sum_till [ i - 1 ] == total_sum - sum_till [ i ] ) : NEW_LINE INDENT partition_possible = True NEW_LINE DEDENT if partition_possible : NEW_LINE print ( \" YES \" ) NEW_LINE else : NEW_LINE print ( \" NO \" ) NEW_LINE",
        "explain": "Line passes through i , so it neither falls left nor right ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE x = [ - 1 , - 2 , 1 ] NEW_LINE y = [ 1 , 1 , - 1 ] NEW_LINE w = [ 3 , 1 , 4 ] NEW_LINE is_partition_possible ( n , x , y , w ) NEW_LINE DEDENT",
        "explain": "Driven Program"
    },
    {
        "py": "def findPCSlope ( m ) : NEW_LINE INDENT return - 1.0 / m NEW_LINE DEDENT",
        "explain": "Function to find the Slope of other line"
    },
    {
        "py": "m = 2.0 NEW_LINE print ( findPCSlope ( m ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE pi = 3.14159 NEW_LINE",
        "explain": "Python3 Program to find area of segment of a circle"
    },
    {
        "py": "def area_of_segment ( radius , angle ) : NEW_LINE",
        "explain": "Function to find area of segment"
    },
    {
        "py": "area_of_sector = pi * NEW_LINE INDENT ( radius * radius ) NEW_LINE * ( angle / 360 ) NEW_LINE DEDENT",
        "explain": "Calculating area of sector"
    },
    {
        "py": "area_of_triangle = 1 / 2 * NEW_LINE INDENT ( radius * radius ) * NEW_LINE math . sin ( ( angle * pi ) / 180 ) NEW_LINE DEDENT return area_of_sector - area_of_triangle ; NEW_LINE",
        "explain": "Calculating area of triangle"
    },
    {
        "py": "radius = 10.0 NEW_LINE angle = 90.0 NEW_LINE print ( \" Area \u2581 of \u2581 minor \u2581 segment \u2581 = \" , area_of_segment ( radius , angle ) ) NEW_LINE print ( \" Area \u2581 of \u2581 major \u2581 segment \u2581 = \" , area_of_segment ( radius , ( 360 - angle ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def SectorArea ( radius , angle ) : NEW_LINE INDENT pi = 22 / 7 NEW_LINE if angle >= 360 : NEW_LINE INDENT print ( \" Angle \u2581 not \u2581 possible \" ) NEW_LINE return NEW_LINE DEDENT DEDENT",
        "explain": "Python program to find Area of a Sector"
    },
    {
        "py": "else : NEW_LINE INDENT sector = ( pi * radius ** 2 ) * ( angle / 360 ) NEW_LINE print ( sector ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Calculating area of the sector"
    },
    {
        "py": "radius = 9 NEW_LINE angle = 60 NEW_LINE SectorArea ( radius , angle ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program for the above approach"
    },
    {
        "py": "def PrimeFactor ( N ) : NEW_LINE INDENT ANS = dict ( ) NEW_LINE DEDENT",
        "explain": "Function to calculate total number of prime factor with their prime factor"
    },
    {
        "py": "while N % 2 == 0 : NEW_LINE INDENT if 2 in ANS : NEW_LINE INDENT ANS [ 2 ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ 2 ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Iterate while the number is even"
    },
    {
        "py": "N = N // 2 NEW_LINE",
        "explain": "Reduce to half"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( N ) ) + 1 , 2 ) : NEW_LINE",
        "explain": "Iterate up to sqrt ( N )"
    },
    {
        "py": "while N % i == 0 : NEW_LINE INDENT if i in ANS : NEW_LINE INDENT ANS [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ANS [ i ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Iterate while N has factors of i"
    },
    {
        "py": "N = N // i NEW_LINE if 2 < N : NEW_LINE ANS [ N ] = 1 NEW_LINE return ANS NEW_LINE",
        "explain": "Removing one factor of i"
    },
    {
        "py": "def CountToMakeEqual ( X , Y ) : NEW_LINE",
        "explain": "Function to count the number of factors"
    },
    {
        "py": "GCD = math . gcd ( X , Y ) NEW_LINE",
        "explain": "Find the GCD"
    },
    {
        "py": "newY = X // GCD NEW_LINE newX = Y // GCD NEW_LINE",
        "explain": "Find multiples left in X and Y"
    },
    {
        "py": "primeX = PrimeFactor ( newX ) NEW_LINE primeY = PrimeFactor ( newY ) NEW_LINE",
        "explain": "Find prime factor of multiple left in X and Y"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Initialize ans"
    },
    {
        "py": "for factor in primeX : NEW_LINE INDENT if X % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeX [ factor ] NEW_LINE DEDENT",
        "explain": "Check if it possible to obtain X or not"
    },
    {
        "py": "for factor in primeY : NEW_LINE INDENT if Y % factor != 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans += primeY [ factor ] NEW_LINE DEDENT",
        "explain": "Check if it possible to obtain Y or not"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "return main ans"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "X = 36 NEW_LINE Y = 48 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "ans = CountToMakeEqual ( X , Y ) NEW_LINE print ( ans ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "from collections import deque NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def check ( Adj , Src , N , visited ) : NEW_LINE INDENT color = [ 0 ] * N NEW_LINE DEDENT",
        "explain": "Function to check whether the graph is bipartite or not"
    },
    {
        "py": "visited = [ True ] * Src NEW_LINE q = deque ( ) NEW_LINE",
        "explain": "Mark source node as visited"
    },
    {
        "py": "q . append ( Src ) NEW_LINE while ( len ( q ) > 0 ) : NEW_LINE",
        "explain": "Push the source vertex in queue"
    },
    {
        "py": "u = q . popleft ( ) NEW_LINE",
        "explain": "Get the front of the queue"
    },
    {
        "py": "Col = color [ u ] NEW_LINE",
        "explain": "Assign the color to the popped node"
    },
    {
        "py": "for x in Adj [ u ] : NEW_LINE",
        "explain": "Traverse the adjacency list of the node u"
    },
    {
        "py": "if ( visited [ x ] == True and color [ x ] == Col ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( visited [ x ] == False ) : NEW_LINE",
        "explain": "If any node is visited & a different colors has been assigned , then return false"
    },
    {
        "py": "visited [ x ] = True NEW_LINE",
        "explain": "Set visited [ x ]"
    },
    {
        "py": "q . append ( x ) NEW_LINE",
        "explain": "Push the node x into the queue"
    },
    {
        "py": "color [ x ] = 1 - Col NEW_LINE",
        "explain": "Update color of node"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "If the graph is bipartite"
    },
    {
        "py": "def addEdge ( Adj , u , v ) : NEW_LINE INDENT Adj [ u ] . append ( v ) NEW_LINE Adj [ v ] . append ( u ) NEW_LINE return Adj NEW_LINE DEDENT",
        "explain": "Function to add an edge between the nodes u and v"
    },
    {
        "py": "def isPossible ( Arr , N ) : NEW_LINE",
        "explain": "Function to check if the assignment of direction can be possible to all the segments , such that they do not intersect after a long period of time"
    },
    {
        "py": "Adj = [ [ ] for i in range ( N ) ] NEW_LINE",
        "explain": "Stores the adjacency list of the created graph"
    },
    {
        "py": "for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE DEDENT",
        "explain": "Generate all possible pairs"
    },
    {
        "py": "if ( Arr [ i ] [ 0 ] < Arr [ j ] [ 1 ] or Arr [ i ] [ 1 ] > Arr [ j ] [ 0 ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If segments do not overlap"
    },
    {
        "py": "else : NEW_LINE INDENT if ( Arr [ i ] [ 2 ] == Arr [ j ] [ 2 ] ) : NEW_LINE DEDENT",
        "explain": "Otherwise , the segments overlap"
    },
    {
        "py": "Adj = addEdge ( Adj , i , j ) NEW_LINE",
        "explain": "If both segments have same speed , then add an edge"
    },
    {
        "py": "visited = [ False ] * N NEW_LINE",
        "explain": "Keep the track of visited nodes"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( visited [ i ] == False and len ( Adj [ i ] ) > 0 ) : NEW_LINE DEDENT",
        "explain": "Iterate for all possible nodes"
    },
    {
        "py": "if ( check ( Adj , i , N , visited ) == False ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Check whether graph is bipartite or not"
    },
    {
        "py": "print ( \" Yes \" ) NEW_LINE",
        "explain": "If the graph is bipartite"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 5 , 7 , 2 ] , [ 4 , 6 , 1 ] , [ 1 , 5 , 2 ] , [ 6 , 5 , 1 ] ] NEW_LINE N = len ( arr ) NEW_LINE isPossible ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def lexNumbers ( n ) : NEW_LINE INDENT sol = [ ] NEW_LINE dfs ( 1 , n , sol ) NEW_LINE print ( \" [ \" , sol [ 0 ] , end = \" \" , sep = \" \" ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT print ( \" , \u2581 \" , sol [ i ] , end = \" \" , sep = \" \" ) print ( \" ] \" ) NEW_LINE DEDENT DEDENT def dfs ( temp , n , sol ) : NEW_LINE INDENT if ( temp > n ) : NEW_LINE INDENT return NEW_LINE DEDENT sol . append ( temp ) NEW_LINE dfs ( temp * 10 , n , sol ) NEW_LINE if ( temp % 10 != 9 ) : NEW_LINE INDENT dfs ( temp + 1 , n , sol ) NEW_LINE DEDENT DEDENT",
        "explain": "Python program for the above approach"
    },
    {
        "py": "n = 15 NEW_LINE lexNumbers ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minimumSwaps ( arr ) : NEW_LINE",
        "explain": "Function to find minimum swaps"
    },
    {
        "py": "count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( arr ) ) : NEW_LINE",
        "explain": "Initialise count variable"
    },
    {
        "py": "if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT while ( arr [ i ] != i + 1 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE DEDENT DEDENT",
        "explain": "If current element is not at the right position"
    },
    {
        "py": "temp = arr [ arr [ i ] - 1 ] ; NEW_LINE arr [ arr [ i ] - 1 ] = arr [ i ] ; NEW_LINE arr [ i ] = temp ; NEW_LINE count += 1 ; NEW_LINE",
        "explain": "Swap current element with correct position of that element"
    },
    {
        "py": "i += 1 ; NEW_LINE return count ; NEW_LINE",
        "explain": "Increment for next index when current element is at correct position"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 1 , 5 ] ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( minimumSwaps ( arr ) ) ; NEW_LINE",
        "explain": "Function to find minimum swaps"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE self . prev = None NEW_LINE DEDENT DEDENT",
        "explain": "A linked list node"
    },
    {
        "py": "def append ( head_ref , new_data ) : NEW_LINE",
        "explain": "Given a reference ( pointer to pointer ) to the head Of a DLL and an int , appends a new node at the end"
    },
    {
        "py": "new_node = Node ( 0 ) NEW_LINE last = head_ref NEW_LINE",
        "explain": "Allocate node"
    },
    {
        "py": "new_node . data = new_data NEW_LINE",
        "explain": "Put in the data"
    },
    {
        "py": "new_node . next = None NEW_LINE",
        "explain": "This new node is going to be the last node , so make next of it as None"
    },
    {
        "py": "if ( head_ref == None ) : NEW_LINE INDENT new_node . prev = None NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT",
        "explain": "If the Linked List is empty , then make the new node as head"
    },
    {
        "py": "while ( last . next != None ) : NEW_LINE INDENT last = last . next NEW_LINE DEDENT",
        "explain": "Else traverse till the last node"
    },
    {
        "py": "last . next = new_node NEW_LINE",
        "explain": "Change the next of last node"
    },
    {
        "py": "new_node . prev = last NEW_LINE return head_ref NEW_LINE",
        "explain": "Make last node as previous of new node"
    },
    {
        "py": "def printList ( node ) : NEW_LINE INDENT last = None NEW_LINE DEDENT",
        "explain": "Function to print the list"
    },
    {
        "py": "while ( node != None ) : NEW_LINE INDENT print ( node . data , end = \" \u2581 \" ) NEW_LINE last = node NEW_LINE node = node . next NEW_LINE DEDENT",
        "explain": "Run while loop unless node becomes None"
    },
    {
        "py": "def mergeList ( p , q ) : NEW_LINE INDENT s = None NEW_LINE DEDENT",
        "explain": "Function to merge two sorted doubly linked lists"
    },
    {
        "py": "if ( p == None or q == None ) : NEW_LINE INDENT if ( p == None ) : NEW_LINE INDENT return q NEW_LINE DEDENT else : NEW_LINE INDENT return p NEW_LINE DEDENT DEDENT",
        "explain": "If any of the list is empty"
    },
    {
        "py": "if ( p . data < q . data ) : NEW_LINE INDENT p . prev = s NEW_LINE s = p NEW_LINE p = p . next NEW_LINE DEDENT else : NEW_LINE INDENT q . prev = s NEW_LINE s = q NEW_LINE q = q . next NEW_LINE DEDENT",
        "explain": "Comparison the data of two linked list"
    },
    {
        "py": "head = s NEW_LINE while ( p != None and q != None ) : NEW_LINE INDENT if ( p . data < q . data ) : NEW_LINE DEDENT",
        "explain": "Store head pointer before merge the list"
    },
    {
        "py": "s . next = p NEW_LINE p . prev = s NEW_LINE s = s . next NEW_LINE p = p . next NEW_LINE else : NEW_LINE",
        "explain": "Changing of pointer between Two list for merging"
    },
    {
        "py": "s . next = q NEW_LINE q . prev = s NEW_LINE s = s . next NEW_LINE q = q . next NEW_LINE",
        "explain": "Changing of pointer between Two list for merging"
    },
    {
        "py": "if ( p == None ) : NEW_LINE INDENT s . next = q NEW_LINE q . prev = s NEW_LINE DEDENT if ( q == None ) : NEW_LINE INDENT s . next = p NEW_LINE p . prev = s NEW_LINE DEDENT",
        "explain": "Condition to check if any anyone list not end"
    },
    {
        "py": "return head NEW_LINE",
        "explain": "Return head pointer of merged list"
    },
    {
        "py": "def mergeAllList ( head , k ) : NEW_LINE INDENT finalList = None NEW_LINE i = 0 NEW_LINE while ( i < k ) : NEW_LINE DEDENT",
        "explain": "Function to merge all sorted linked list in sorted order"
    },
    {
        "py": "finalList = mergeList ( finalList , head [ i ] ) NEW_LINE i = i + 1 NEW_LINE",
        "explain": "Function call to merge two sorted doubly linked list at a time"
    },
    {
        "py": "return finalList NEW_LINE",
        "explain": "Return final sorted doubly linked list"
    },
    {
        "py": "k = 3 NEW_LINE head = [ 0 ] * k NEW_LINE i = 0 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "while ( i < k ) : NEW_LINE INDENT head [ i ] = None NEW_LINE i = i + 1 NEW_LINE DEDENT",
        "explain": "Loop to initialize all the lists to empty"
    },
    {
        "py": "head [ 0 ] = append ( head [ 0 ] , 1 ) NEW_LINE head [ 0 ] = append ( head [ 0 ] , 5 ) NEW_LINE head [ 0 ] = append ( head [ 0 ] , 9 ) NEW_LINE",
        "explain": "Create first doubly linked List List1 . 1 <= > 5 <= > 9"
    },
    {
        "py": "head [ 1 ] = append ( head [ 1 ] , 2 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 3 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 7 ) NEW_LINE head [ 1 ] = append ( head [ 1 ] , 12 ) NEW_LINE",
        "explain": "Create second doubly linked List List2 . 2 <= > 3 <= > 7 <= > 12"
    },
    {
        "py": "head [ 2 ] = append ( head [ 2 ] , 8 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 11 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 13 ) NEW_LINE head [ 2 ] = append ( head [ 2 ] , 18 ) NEW_LINE",
        "explain": "Create third doubly linked List List3 . 8 <= > 11 <= > 13 <= > 18"
    },
    {
        "py": "finalList = mergeAllList ( head , k ) NEW_LINE",
        "explain": "Function call to merge all sorted doubly linked lists in sorted order"
    },
    {
        "py": "printList ( finalList ) NEW_LINE",
        "explain": "Print final sorted list"
    },
    {
        "py": "def minIndex ( a , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT",
        "explain": "Return minimum index"
    },
    {
        "py": "k = minIndex ( a , i + 1 , j ) NEW_LINE",
        "explain": "Find minimum of remaining elements"
    },
    {
        "py": "return ( i if a [ i ] < a [ k ] else k ) NEW_LINE",
        "explain": "Return minimum of current and remaining ."
    },
    {
        "py": "def recurSelectionSort ( a , n , index = 0 ) : NEW_LINE",
        "explain": "Recursive selection sort . n is size of a [ ] and index is index of starting element ."
    },
    {
        "py": "if index == n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Return when starting and size are same"
    },
    {
        "py": "k = minIndex ( a , index , n - 1 ) NEW_LINE",
        "explain": "calling minimum index function for minimum index"
    },
    {
        "py": "if k != index : NEW_LINE INDENT a [ k ] , a [ index ] = a [ index ] , a [ k ] NEW_LINE DEDENT",
        "explain": "Swapping when index and minimum index are not same"
    },
    {
        "py": "a [ k ] , a [ index ] = a [ index ] , a [ k ] NEW_LINE",
        "explain": "swap"
    },
    {
        "py": "recurSelectionSort ( a , n , index + 1 ) NEW_LINE",
        "explain": "Recursively calling selection sort function"
    },
    {
        "py": "arr = [ 3 , 1 , 5 , 2 , 7 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "recurSelectionSort ( arr , n ) NEW_LINE",
        "explain": "Calling function"
    },
    {
        "py": "for i in arr : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT",
        "explain": "printing sorted array"
    },
    {
        "py": "def insertionSortRecursive ( arr , n ) : NEW_LINE",
        "explain": "Recursive function to sort an array using insertion sort"
    },
    {
        "py": "if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "insertionSortRecursive ( arr , n - 1 ) NEW_LINE",
        "explain": "Sort first n - 1 elements"
    },
    {
        "py": "last = arr [ n - 1 ] NEW_LINE j = n - 2 NEW_LINE",
        "explain": "Insert last element at its correct position in sorted array ."
    },
    {
        "py": "while ( j >= 0 and arr [ j ] > last ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = last NEW_LINE",
        "explain": "Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position"
    },
    {
        "py": "def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT",
        "explain": "A utility function to print an array of size n"
    },
    {
        "py": "arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE insertionSortRecursive ( arr , n ) NEW_LINE printArray ( arr , n ) NEW_LINE",
        "explain": "Driver program to test insertion sort"
    },
    {
        "py": "class bubbleSort : NEW_LINE",
        "explain": "Python Program for implementation of Recursive Bubble sort"
    },
    {
        "py": "def __init__ ( self , array ) : NEW_LINE INDENT self . array = array NEW_LINE self . length = len ( array ) NEW_LINE DEDENT def __str__ ( self ) : NEW_LINE INDENT return \" \u2581 \" . join ( [ str ( x ) for x in self . array ] ) NEW_LINE DEDENT def bubbleSortRecursive ( self , n = None ) : NEW_LINE INDENT if n is None : NEW_LINE INDENT n = self . length NEW_LINE DEDENT DEDENT",
        "explain": "A function to implement bubble sort"
    },
    {
        "py": "if n == 1 : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT if self . array [ i ] > self . array [ i + 1 ] : NEW_LINE DEDENT",
        "explain": "One pass of bubble sort . After this pass , the largest element is moved ( or bubbled ) to end ."
    },
    {
        "py": "self . array [ i ] , self . array [ i + 1 ] = self . array [ i + 1 ] , self . array [ i ] NEW_LINE",
        "explain": "swap arr [ i ] , arr [ i + 1 ]"
    },
    {
        "py": "self . bubbleSortRecursive ( n - 1 ) NEW_LINE",
        "explain": "Largest element is fixed , recur for remaining array"
    },
    {
        "py": "def maxSumAfterPartition ( arr , n ) : NEW_LINE",
        "explain": "Python 3 Program for the above approach"
    },
    {
        "py": "pos = [ ] NEW_LINE",
        "explain": "Stores the positive elements"
    },
    {
        "py": "neg = [ ] NEW_LINE",
        "explain": "Stores the negative elements"
    },
    {
        "py": "zero = 0 NEW_LINE",
        "explain": "Stores the count of 0 s"
    },
    {
        "py": "pos_sum = 0 NEW_LINE",
        "explain": "Sum of all positive numbers"
    },
    {
        "py": "neg_sum = 0 NEW_LINE",
        "explain": "Sum of all negative numbers"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT pos . append ( arr [ i ] ) NEW_LINE pos_sum += arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < 0 ) : NEW_LINE INDENT neg . append ( arr [ i ] ) NEW_LINE neg_sum += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Iterate over the array"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the difference"
    },
    {
        "py": "pos . sort ( ) NEW_LINE",
        "explain": "Sort the positive numbers in ascending order"
    },
    {
        "py": "neg . sort ( reverse = True ) NEW_LINE",
        "explain": "Sort the negative numbers in decreasing order"
    },
    {
        "py": "if ( len ( pos ) > 0 and len ( neg ) > 0 ) : NEW_LINE INDENT ans = ( pos_sum - neg_sum ) NEW_LINE DEDENT elif ( len ( pos ) > 0 ) : NEW_LINE INDENT if ( zero > 0 ) : NEW_LINE DEDENT",
        "explain": "Case 1 : Include both positive and negative numbers"
    },
    {
        "py": "ans = ( pos_sum ) NEW_LINE else : NEW_LINE",
        "explain": "Put all numbers in subset A and one 0 in subset B"
    },
    {
        "py": "ans = ( pos_sum - 2 * pos [ 0 ] ) NEW_LINE else : NEW_LINE if ( zero > 0 ) : NEW_LINE",
        "explain": "Put all numbers in subset A except the smallest positive number which is put in B"
    },
    {
        "py": "ans = ( - 1 * neg_sum ) NEW_LINE else : NEW_LINE",
        "explain": "Put all numbers in subset B and one 0 in subset A"
    },
    {
        "py": "ans = ( neg [ 0 ] - ( neg_sum - neg [ 0 ] ) ) NEW_LINE return ans NEW_LINE",
        "explain": "Place the largest negative number in subset A and remaining in B"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , - 5 , - 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumAfterPartition ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def MaxXOR ( arr , N ) : NEW_LINE",
        "explain": "Function to find the bitwise OR of array elements"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores the resultant maximum value of Bitwise XOR"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT res |= arr [ i ] NEW_LINE DEDENT",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the maximum value res"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MaxXOR ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countEqual ( A , B , N ) : NEW_LINE",
        "explain": "Function to count the number of elements common in both the arrays"
    },
    {
        "py": "first = 0 NEW_LINE second = N - 1 NEW_LINE",
        "explain": "Used to traverse array A [ ] and B [ ] from the front and the back"
    },
    {
        "py": "count = 0 NEW_LINE while ( first < N and second >= 0 ) : NEW_LINE",
        "explain": "Stores the count of numbers common in both array"
    },
    {
        "py": "if ( A [ first ] < B [ second ] ) : NEW_LINE",
        "explain": "If A [ first ] is less than B [ second ]"
    },
    {
        "py": "first += 1 NEW_LINE",
        "explain": "Increment the value of first"
    },
    {
        "py": "elif ( B [ second ] < A [ first ] ) : NEW_LINE",
        "explain": "IF B [ second ] is less than A [ first ]"
    },
    {
        "py": "second -= 1 NEW_LINE",
        "explain": "Decrement the value of second"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "A [ first ] is equal to B [ second ]"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment the value of count"
    },
    {
        "py": "first += 1 NEW_LINE",
        "explain": "Increment the value of first"
    },
    {
        "py": "second -= 1 NEW_LINE",
        "explain": "Decrement the value of second"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the value of count"
    },
    {
        "py": "A = [ 2 , 4 , 5 , 8 , 12 , 13 , 17 , 18 , 20 , 22 , 309 , 999 ] NEW_LINE B = [ 109 , 99 , 68 , 54 , 22 , 19 , 17 , 13 , 11 , 5 , 3 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( countEqual ( A , B , N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 0 for i in range ( 100005 ) ] NEW_LINE",
        "explain": "Python 3 program for the above approach"
    },
    {
        "py": "def isPalindrome ( N ) : NEW_LINE",
        "explain": "Function to check if the number N is palindrome or not"
    },
    {
        "py": "temp = N NEW_LINE",
        "explain": "Store the value of N"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Store the reverse of number N"
    },
    {
        "py": "while ( temp != 0 ) : NEW_LINE INDENT rem = temp % 10 NEW_LINE res = res * 10 + rem NEW_LINE temp //= 10 NEW_LINE DEDENT",
        "explain": "Reverse temp and store in res"
    },
    {
        "py": "if ( res == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If N is the same as res , then return true"
    },
    {
        "py": "def sumOfDigits ( N ) : NEW_LINE",
        "explain": "Function to find the sum of the digits of the number N"
    },
    {
        "py": "sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE",
        "explain": "Stores the sum of the digits"
    },
    {
        "py": "sum += N % 10 NEW_LINE",
        "explain": "Add the last digit of the number N to the sum"
    },
    {
        "py": "N //= 10 NEW_LINE",
        "explain": "Remove the last digit from N"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "Return the resultant sum"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Function to check if N is prime or not"
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If i is 1 or 0 , then return false"
    },
    {
        "py": "for i in range ( 2 , ( n // 2 ) + 1 , 1 ) : NEW_LINE",
        "explain": "Check if i is divisible by any number in the range [ 2 , n / 2 ]"
    },
    {
        "py": "if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "If n is divisible by i"
    },
    {
        "py": "def precompute ( ) : NEW_LINE",
        "explain": "Function to precompute all the numbers till 10 ^ 5 that are palindromic and whose sum of digits is prime numbers"
    },
    {
        "py": "for i in range ( 1 , 100001 , 1 ) : NEW_LINE",
        "explain": "Iterate over the range 1 to 10 ^ 5"
    },
    {
        "py": "if ( isPalindrome ( i ) ) : NEW_LINE",
        "explain": "If i is a palindrome number"
    },
    {
        "py": "sum = sumOfDigits ( i ) NEW_LINE",
        "explain": "Stores the sum of the digits in i"
    },
    {
        "py": "if ( isPrime ( sum ) ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT else : NEW_LINE arr [ i ] = 0 NEW_LINE",
        "explain": "If the sum of digits in i is a prime number"
    },
    {
        "py": "for i in range ( 1 , 100001 , 1 ) : NEW_LINE INDENT arr [ i ] = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Find the prefix sum of arr [ ]"
    },
    {
        "py": "def countNumbers ( Q , N ) : NEW_LINE",
        "explain": "Function to count all the numbers in the given ranges that are palindromic and the sum of digits is prime numbers"
    },
    {
        "py": "precompute ( ) NEW_LINE",
        "explain": "Function Call to precompute all the numbers till 10 ^ 5"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the given queries Q [ ]"
    },
    {
        "py": "print ( arr [ Q [ i ] [ 1 ] ] - arr [ Q [ i ] [ 0 ] - 1 ] ) NEW_LINE",
        "explain": "Print the result for each query"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Q = [ [ 5 , 9 ] , [ 1 , 101 ] ] NEW_LINE N = len ( Q ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "countNumbers ( Q , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def sum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sm += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return sm NEW_LINE DEDENT",
        "explain": "Function to calculate sum of digits of n"
    },
    {
        "py": "def smallestNumber ( n , s ) : NEW_LINE",
        "explain": "Function to find the smallest possible integer satisfying the given condition"
    },
    {
        "py": "if ( sum ( n ) <= s ) : NEW_LINE INDENT return n NEW_LINE DEDENT",
        "explain": "If sum of digits is already smaller than s"
    },
    {
        "py": "ans , k = n , 1 NEW_LINE for i in range ( 9 ) : NEW_LINE",
        "explain": "Initialize variables"
    },
    {
        "py": "digit = ( ans // k ) % 10 NEW_LINE",
        "explain": "Find the k - th digit"
    },
    {
        "py": "add = k * ( ( 10 - digit ) % 10 ) NEW_LINE ans += add NEW_LINE",
        "explain": "Add remaining"
    },
    {
        "py": "if ( sum ( ans ) <= s ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If sum of digits does not exceed s"
    },
    {
        "py": "k *= 10 NEW_LINE return ans NEW_LINE",
        "explain": "Update K"
    },
    {
        "py": "n , s = 3 , 2 NEW_LINE",
        "explain": "Given N and S"
    },
    {
        "py": "print ( smallestNumber ( n , s ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python program to implement the above approach"
    },
    {
        "py": "def maxSubsequences ( arr , n ) -> int : NEW_LINE",
        "explain": "Function to find the maximum number number of required subsequences"
    },
    {
        "py": "m = defaultdict ( int ) NEW_LINE",
        "explain": "Dictionary to store number of arrows available with height of arrow as key"
    },
    {
        "py": "maxCount = 0 NEW_LINE",
        "explain": "Stores the maximum count of possible subsequences"
    },
    {
        "py": "count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Stores the count of possible subsequences"
    },
    {
        "py": "if arr [ i ] in m . keys ( ) : NEW_LINE",
        "explain": "Check if i - th element can be part of any of the previous subsequence"
    },
    {
        "py": "count = m [ arr [ i ] ] NEW_LINE",
        "explain": "Count of subsequences possible with arr [ i ] as the next element"
    },
    {
        "py": "if count > 1 : NEW_LINE",
        "explain": "If more than one such subsequence exists"
    },
    {
        "py": "m [ arr [ i ] ] = count - 1 NEW_LINE",
        "explain": "Include arr [ i ] in a subsequence"
    },
    {
        "py": "else : NEW_LINE INDENT m . pop ( arr [ i ] ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT else : NEW_LINE maxCount += 1 NEW_LINE",
        "explain": "Increase count of subsequence possible with arr [ i ] - 1 as the next element"
    },
    {
        "py": "maxCount += 1 NEW_LINE",
        "explain": "Start a new subsequence"
    },
    {
        "py": "if arr [ i ] - 1 > 0 : NEW_LINE INDENT m [ arr [ i ] - 1 ] += 1 NEW_LINE DEDENT",
        "explain": "Increase count of subsequence possible with arr [ i ] - 1 as the next element"
    },
    {
        "py": "return maxCount NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 4 , 5 , 2 , 1 , 4 ] NEW_LINE print ( maxSubsequences ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def removeOcc ( s , ch ) : NEW_LINE",
        "explain": "Function to remove first and last occurrence of a given character from the given string"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "Traverse the given string from the beginning"
    },
    {
        "py": "if ( s [ i ] == ch ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT",
        "explain": "If ch is found"
    },
    {
        "py": "for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Traverse the given string from the end"
    },
    {
        "py": "if ( s [ i ] == ch ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT return s NEW_LINE",
        "explain": "If ch is found"
    },
    {
        "py": "s = \" hello \u2581 world \" NEW_LINE ch = ' l ' NEW_LINE print ( removeOcc ( s , ch ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def minSteps ( N , increasing , decreasing ) : NEW_LINE",
        "explain": "Function that finds the minimum steps to reach either 0 or N for given increasing and decreasing arrays"
    },
    {
        "py": "Min = sys . maxsize ; NEW_LINE",
        "explain": "Initialize variable to find the minimum element"
    },
    {
        "py": "for i in increasing : NEW_LINE INDENT if ( Min > i ) : NEW_LINE INDENT Min = i ; NEW_LINE DEDENT DEDENT",
        "explain": "Find minimum element in increasing array"
    },
    {
        "py": "Max = - sys . maxsize ; NEW_LINE",
        "explain": "Initialize variable to find the maximum element"
    },
    {
        "py": "for i in decreasing : NEW_LINE INDENT if ( Max < i ) : NEW_LINE INDENT Max = i ; NEW_LINE DEDENT DEDENT",
        "explain": "Find maximum element in decreasing array"
    },
    {
        "py": "minSteps = max ( Max , N - Min ) ; NEW_LINE",
        "explain": "Find the minimum steps"
    },
    {
        "py": "print ( minSteps ) ; NEW_LINE",
        "explain": "Prthe minimum steps"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 7 ; NEW_LINE",
        "explain": "Given N"
    },
    {
        "py": "increasing = [ 3 , 5 ] ; NEW_LINE decreasing = [ 6 ] ; NEW_LINE",
        "explain": "Given increasing and decreasing array"
    },
    {
        "py": "minSteps ( N , increasing , decreasing ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def solve ( P , n ) : NEW_LINE",
        "explain": "Function to find the minimum number of swaps"
    },
    {
        "py": "arr = [ ] NEW_LINE arr . append ( 0 ) NEW_LINE for x in P : NEW_LINE INDENT arr . append ( x ) NEW_LINE DEDENT",
        "explain": "New array to convert to 1 - based indexing"
    },
    {
        "py": "cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE",
        "explain": "Keeps count of swaps"
    },
    {
        "py": "if ( arr [ i ] == i ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE cnt += 1 NEW_LINE DEDENT",
        "explain": "Check if it is an ' X ' position"
    },
    {
        "py": "if ( arr [ n ] == n ) : NEW_LINE",
        "explain": "Corner Case"
    },
    {
        "py": "arr [ n - 1 ] , arr [ n ] = arr [ n ] , arr [ n - 1 ] NEW_LINE cnt += 1 NEW_LINE",
        "explain": "Swap"
    },
    {
        "py": "print ( cnt ) NEW_LINE",
        "explain": "Print the minimum swaps"
    },
    {
        "py": "N = 9 NEW_LINE",
        "explain": "Given number N"
    },
    {
        "py": "P = [ 1 , 2 , 4 , 9 , 5 , 8 , 7 , 3 , 6 ] NEW_LINE",
        "explain": "Given permutation of N numbers"
    },
    {
        "py": "solve ( P , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def SieveOfEratosthenes ( n , allPrimes ) : NEW_LINE",
        "explain": "Function to find all prime numbers"
    },
    {
        "py": "prime = [ True ] * ( n + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries as true . A value in prime [ i ] will finally be false if i is Not a prime ."
    },
    {
        "py": "if prime [ p ] == True : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p greater than or equal to the square of it"
    },
    {
        "py": "for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT allPrimes . add ( p ) NEW_LINE DEDENT DEDENT",
        "explain": "Store all prime numbers"
    },
    {
        "py": "def countInterestingPrimes ( n ) : NEW_LINE",
        "explain": "Function to check if a number is perfect square or not"
    },
    {
        "py": "allPrimes = set ( ) NEW_LINE",
        "explain": "To store all primes"
    },
    {
        "py": "SieveOfEratosthenes ( n , allPrimes ) NEW_LINE interestingPrimes = set ( ) NEW_LINE squares , quadruples = [ ] , [ ] NEW_LINE",
        "explain": "To store all interseting primes"
    },
    {
        "py": "i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT squares . append ( i * i ) NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "Store all perfect squares"
    },
    {
        "py": "i = 1 NEW_LINE while i * i * i * i <= n : NEW_LINE INDENT quadruples . append ( i * i * i * i ) NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "Store all perfect quadruples"
    },
    {
        "py": "for a in squares : NEW_LINE INDENT for b in quadruples : NEW_LINE INDENT if a + b in allPrimes : NEW_LINE INDENT interestingPrimes . add ( a + b ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Store all interseting primes"
    },
    {
        "py": "return len ( interestingPrimes ) NEW_LINE",
        "explain": "Return count of interseting primes"
    },
    {
        "py": "N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isWaveArray ( arr , n ) : NEW_LINE INDENT result = True NEW_LINE DEDENT",
        "explain": "Function to check if array is wave array arr : input array n : size of array"
    },
    {
        "py": "if ( arr [ 1 ] > arr [ 0 ] and arr [ 1 ] > arr [ 2 ] ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Check the wave form If arr [ 1 ] is greater than left and right . Same pattern will be followed by whole elements , else reverse pattern will be followed by array elements"
    },
    {
        "py": "if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] <= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT elif ( arr [ 1 ] < arr [ 0 ] and arr [ 1 ] < arr [ 2 ] ) : NEW_LINE for i in range ( 1 , n - 1 , 2 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT result = True NEW_LINE DEDENT else : NEW_LINE INDENT result = False NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Check for last element"
    },
    {
        "py": "if ( result == True and n % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] >= arr [ n - 2 ] ) : NEW_LINE INDENT result = False NEW_LINE DEDENT DEDENT return result NEW_LINE",
        "explain": "Check for last element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 1 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isWaveArray ( arr , n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Array"
    },
    {
        "py": "def countPossiblities ( arr , n ) : NEW_LINE",
        "explain": "Function to count number of sequences satisfying the given criteria"
    },
    {
        "py": "lastOccur = [ - 1 ] * 100000 NEW_LINE",
        "explain": "Stores the index of the last occurrence of the element"
    },
    {
        "py": "dp = [ 0 ] * ( n + 1 ) NEW_LINE",
        "explain": "Initialize an array to store the number of different sequences that are possible of length i"
    },
    {
        "py": "dp [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curEle = arr [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "dp [ i ] = dp [ i - 1 ] NEW_LINE",
        "explain": "If no operation is applied on ith element"
    },
    {
        "py": "if ( lastOccur [ curEle ] != - 1 and lastOccur [ curEle ] < i - 1 ) : NEW_LINE INDENT dp [ i ] += dp [ lastOccur [ curEle ] ] NEW_LINE DEDENT",
        "explain": "If operation is applied on ith element"
    },
    {
        "py": "lastOccur [ curEle ] = i NEW_LINE",
        "explain": "Update the last occurrence of curEle"
    },
    {
        "py": "print ( dp [ n ] ) NEW_LINE",
        "explain": "Finally , prthe answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE countPossiblities ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxSum ( arr , n , m ) : NEW_LINE",
        "explain": "Function to prthe maximum sum"
    },
    {
        "py": "dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( 2 ) ] NEW_LINE",
        "explain": "Dp table"
    },
    {
        "py": "dp [ 0 ] [ m - 1 ] = arr [ 0 ] [ m - 1 ] NEW_LINE dp [ 1 ] [ m - 1 ] = arr [ 1 ] [ m - 1 ] NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "for j in range ( m - 2 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Traverse each column"
    },
    {
        "py": "for i in range ( 2 ) : NEW_LINE INDENT if ( i == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 0 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 0 ] [ j + 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( arr [ i ] [ j ] + dp [ 1 ] [ j + 1 ] , arr [ i ] [ j ] + dp [ 1 ] [ j + 2 ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Update answer for both rows"
    },
    {
        "py": "print ( max ( dp [ 0 ] [ 0 ] , dp [ 1 ] [ 0 ] ) ) NEW_LINE",
        "explain": "Print the maximum sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr [ 0 ] ) NEW_LINE",
        "explain": "Number of Columns"
    },
    {
        "py": "maxSum ( arr , 2 , N ) NEW_LINE",
        "explain": "Function calls"
    },
    {
        "py": "def maxSum ( arr , n ) : NEW_LINE",
        "explain": "Function to print the maximum sum possible by selecting at most one element from each column such that no consecutive pairs are selected from a single row"
    },
    {
        "py": "r1 = r2 = 0 NEW_LINE",
        "explain": "Initialize variables"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT r1 , r2 = max ( r1 , r2 + arr [ 0 ] [ i ] ) , max ( r2 , r1 + arr [ 1 ] [ i ] ) NEW_LINE DEDENT",
        "explain": "Traverse each column"
    },
    {
        "py": "print ( max ( r1 , r2 ) ) NEW_LINE",
        "explain": "Print answer"
    },
    {
        "py": "arr = [ [ 1 , 50 , 21 , 5 ] , [ 2 , 10 , 10 , 5 ] ] NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = len ( arr [ 0 ] ) NEW_LINE maxSum ( arr , n ) NEW_LINE",
        "explain": "Numberof columns"
    },
    {
        "py": "mod = 1e9 + 7 NEW_LINE mx = 1000000 NEW_LINE fact = [ 0 ] * ( mx + 1 ) NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def Calculate_factorial ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE DEDENT",
        "explain": "Function to calculate the factorials up to a number"
    },
    {
        "py": "for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT fact [ i ] = i * fact [ i - 1 ] NEW_LINE fact [ i ] %= mod NEW_LINE DEDENT",
        "explain": "Calculate the factorial"
    },
    {
        "py": "def UniModal_per ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE DEDENT",
        "explain": "Function to find power ( a , b )"
    },
    {
        "py": "while ( b != 0 ) : NEW_LINE",
        "explain": "Iterate until b exists"
    },
    {
        "py": "if ( b % 2 != 0 ) : NEW_LINE INDENT res = res * a NEW_LINE DEDENT res %= mod NEW_LINE a = a * a NEW_LINE a %= mod NEW_LINE",
        "explain": "If b is divisible by 2"
    },
    {
        "py": "b //= 2 NEW_LINE",
        "explain": "Decrease the value of b"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "def countPermutations ( n ) : NEW_LINE",
        "explain": "Function that counts the unimodal and non - unimodal permutations of a given integer N"
    },
    {
        "py": "Calculate_factorial ( ) NEW_LINE",
        "explain": "Function Call for finding factorials up to N"
    },
    {
        "py": "uni_modal = UniModal_per ( 2 , n - 1 ) NEW_LINE",
        "explain": "Function to count unimodal permutations"
    },
    {
        "py": "nonuni_modal = fact [ n ] - uni_modal NEW_LINE print ( int ( uni_modal ) , \" \" , int ( nonuni_modal ) ) NEW_LINE return NEW_LINE",
        "explain": "Non - unimodal permutation is N ! - unimodal permutations"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Driver Code Given number N"
    },
    {
        "py": "countPermutations ( N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import sys NEW_LINE def longestSubseq ( s , length ) : NEW_LINE",
        "explain": "Python3 program to find the longest subsequence possible that starts and ends with 1 and filled with 0 in the middle"
    },
    {
        "py": "ones = [ 0 for i in range ( length + 1 ) ] NEW_LINE zeroes = [ 0 for i in range ( length + 1 ) ] NEW_LINE",
        "explain": "Prefix array to store the occurences of '1' and '0' Initialise prefix arrays with 0"
    },
    {
        "py": "for i in range ( length ) : NEW_LINE",
        "explain": "Iterate over the length of the string"
    },
    {
        "py": "' NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT ones [ i + 1 ] = ones [ i ] + 1 NEW_LINE zeroes [ i + 1 ] = zeroes [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "If current character is '1"
    },
    {
        "py": "x += ones [ i ] NEW_LINE",
        "explain": "Add '1' available for the first string"
    },
    {
        "py": "x += ( zeroes [ j ] - zeroes [ i ] ) NEW_LINE",
        "explain": "Add '0' available for the second string"
    },
    {
        "py": "x += ( ones [ length ] - ones [ j ] ) NEW_LINE",
        "explain": "Add '1' available for the third string"
    },
    {
        "py": "answer = max ( answer , x ) NEW_LINE x = 0 NEW_LINE",
        "explain": "Update answer"
    },
    {
        "py": "print ( answer ) NEW_LINE",
        "explain": "Print the final result"
    },
    {
        "py": "S = \"10010010111100101\" NEW_LINE length = len ( S ) NEW_LINE longestSubseq ( S , length ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 100 NEW_LINE",
        "explain": "Python3 implementation to find the largest square in the matrix such that it contains at most K 1 's"
    },
    {
        "py": "def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE",
        "explain": "Function to calculate the largest square with atmost K 1 s for Q queries"
    },
    {
        "py": "for q in range ( Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) NEW_LINE ans = - 1 NEW_LINE for k in range ( min_dist + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT DEDENT",
        "explain": "Loop to solve for each query"
    },
    {
        "py": "for row in range ( i - k , i + k + 1 ) : NEW_LINE INDENT for col in range ( j - k , j + k + 1 ) : NEW_LINE INDENT count += matrix [ row ] [ col ] NEW_LINE DEDENT DEDENT",
        "explain": "Traversing the each sub square and counting total"
    },
    {
        "py": "if count > K : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE print ( ans ) NEW_LINE",
        "explain": "Breaks when exceeds the maximum count"
    },
    {
        "py": "matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE DEDENT",
        "explain": "Function to find the largest square in the matrix such that it contains atmost K 1 's"
    },
    {
        "py": "countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Precomputing the countDP prefix sum of the matrix"
    },
    {
        "py": "for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE DEDENT",
        "explain": "Loop to solve Queries"
    },
    {
        "py": "min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE for k in range ( 0 , min_dist + 1 ) : NEW_LINE INDENT x1 = i - k NEW_LINE x2 = i + k NEW_LINE y1 = j - k NEW_LINE y2 = j + k NEW_LINE DEDENT",
        "explain": "Calculating the maximum possible distance of the centre from edge"
    },
    {
        "py": "count = countDP [ x2 ] [ y2 ] ; NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT if ( count > K ) : NEW_LINE INDENT break NEW_LINE DEDENT ans = 2 * k + 1 NEW_LINE print ( ans ) NEW_LINE",
        "explain": "Calculating the number of 1 s in the submatrix"
    },
    {
        "py": "matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def MinCost ( arr , n ) : NEW_LINE",
        "explain": "Function to return the minimum cost to connect the given ropes"
    },
    {
        "py": "dp = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE sum = [ [ 0 for i in range ( n + 5 ) ] for i in range ( n + 5 ) ] NEW_LINE",
        "explain": "dp [ i ] [ j ] = minimum cost in range ( i , j ) sum [ i ] [ j ] = sum of range ( i , j )"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT sum [ i ] [ j ] = k NEW_LINE DEDENT else : NEW_LINE INDENT k += arr [ j ] NEW_LINE sum [ i ] [ j ] = k NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Initializing the sum table memset ( sum , 0 , sizeof ( 0 ) ) ;"
    },
    {
        "py": "for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Computing minimum cost for all the possible interval ( i , j ) Left range"
    },
    {
        "py": "for j in range ( i , n ) : NEW_LINE INDENT dp [ i ] [ j ] = 10 ** 9 NEW_LINE DEDENT",
        "explain": "Right range"
    },
    {
        "py": "if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + sum [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE",
        "explain": "No cost for a single rope"
    },
    {
        "py": "arr = [ 7 , 6 , 8 , 6 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( MinCost ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def f ( i , state , A , dp , N ) : NEW_LINE INDENT if i >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function to recursively fill the dp array"
    },
    {
        "py": "elif dp [ i ] [ state ] != - 1 : NEW_LINE INDENT return dp [ i ] [ state ] NEW_LINE DEDENT",
        "explain": "If f ( i , state ) is already calculated then return the value"
    },
    {
        "py": "else : NEW_LINE INDENT if i == N - 1 : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] > A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 2 and A [ i ] < A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 NEW_LINE DEDENT elif state == 1 and A [ i ] <= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 2 , A , dp , N ) NEW_LINE DEDENT elif state == 2 and A [ i ] >= A [ i + 1 ] : NEW_LINE INDENT dp [ i ] [ state ] = 1 + f ( i + 1 , 1 , A , dp , N ) NEW_LINE DEDENT return dp [ i ] [ state ] NEW_LINE DEDENT",
        "explain": "Calculate f ( i , state ) according to the recurrence relation and store in dp [ ] [ ]"
    },
    {
        "py": "def maxLenSeq ( A , N ) : NEW_LINE",
        "explain": "Function that calls the resucrsive function to fill the dp array and then returns the result"
    },
    {
        "py": "dp = [ [ - 1 , - 1 , - 1 ] for i in range ( 1000 ) ] NEW_LINE",
        "explain": "dp [ ] [ ] array for storing result of f ( i , 1 ) and f ( 1 , 2 ) Populating the array dp [ ] with - 1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT tmp = f ( i , 1 , A , dp , N ) NEW_LINE tmp = f ( i , 2 , A , dp , N ) NEW_LINE DEDENT",
        "explain": "Make sure that longest UD and DU sequence starting at each index is calculated"
    },
    {
        "py": "ans = - 1 NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "Assume the answer to be - 1 This value will only increase"
    },
    {
        "py": "y = dp [ i ] [ 1 ] NEW_LINE if ( i + y ) >= N : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 ) NEW_LINE DEDENT",
        "explain": "y is the length of the longest UD sequence starting at i"
    },
    {
        "py": "elif y % 2 == 0 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 2 ] ) NEW_LINE DEDENT",
        "explain": "If length is even then add an integer and then a DU sequence starting at i + y"
    },
    {
        "py": "elif y % 2 == 1 : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ 1 ] + 1 + dp [ i + y ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "If length is odd then add an integer and then a UD sequence starting at i + y"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 10 , 3 , 20 , 25 , 24 ] NEW_LINE n = len ( A ) NEW_LINE print ( maxLenSeq ( A , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def MaxGCD ( a , n ) : NEW_LINE",
        "explain": "Function to return the maximized gcd after removing a single element from the given array"
    },
    {
        "py": "Prefix = [ 0 for i in range ( n + 2 ) ] NEW_LINE Suffix = [ 0 for i in range ( n + 2 ) ] NEW_LINE",
        "explain": "Prefix and Suffix arrays"
    },
    {
        "py": "Prefix [ 1 ] = a [ 0 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = mt . gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT",
        "explain": "Single state dynamic programming relation for storing gcd of first i elements from the left in Prefix [ i ]"
    },
    {
        "py": "Suffix [ n ] = a [ n - 1 ] NEW_LINE",
        "explain": "Initializing Suffix array"
    },
    {
        "py": "for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = mt . gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT",
        "explain": "Single state dynamic programming relation for storing gcd of all the elements having greater than or equal to i in Suffix [ i ]"
    },
    {
        "py": "ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) NEW_LINE",
        "explain": "If first or last element of the array has to be removed"
    },
    {
        "py": "for i in range ( 2 , n ) : NEW_LINE INDENT ans = max ( ans , mt . gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) NEW_LINE DEDENT",
        "explain": "If any other element is replaced"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the maximized gcd"
    },
    {
        "py": "a = [ 14 , 17 , 28 , 70 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxGCD ( a , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import numpy as np NEW_LINE right = 3 ; NEW_LINE left = 6 ; NEW_LINE dp = np . ones ( ( left , right ) ) NEW_LINE dp = - 1 * dp NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def findSubarraySum ( ind , flips , n , a , k ) : NEW_LINE",
        "explain": "Function to find the maximum subarray sum with flips starting from index i"
    },
    {
        "py": "if ( flips > k ) : NEW_LINE INDENT return - 1e9 ; NEW_LINE DEDENT",
        "explain": "If the number of flips have exceeded"
    },
    {
        "py": "if ( ind == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Complete traversal"
    },
    {
        "py": "if ( dp [ ind ] [ flips ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] [ flips ] ; NEW_LINE DEDENT",
        "explain": "If the state has previously been visited"
    },
    {
        "py": "ans = 0 ; NEW_LINE",
        "explain": "Initially"
    },
    {
        "py": "ans = max ( 0 , a [ ind ] + findSubarraySum ( ind + 1 , flips , n , a , k ) ) ; NEW_LINE ans = max ( ans , - a [ ind ] + findSubarraySum ( ind + 1 , flips + 1 , n , a , k ) ) ; NEW_LINE",
        "explain": "Use Kadane 's algorithm and  call two states"
    },
    {
        "py": "dp [ ind ] [ flips ] = ans ; NEW_LINE return dp [ ind ] [ flips ] ; NEW_LINE",
        "explain": "Memoize the answer and return it"
    },
    {
        "py": "def findMaxSubarraySum ( a , n , k ) : NEW_LINE",
        "explain": "Utility function to call flips from index and return the answer"
    },
    {
        "py": "ans = - 1e9 ; NEW_LINE",
        "explain": "Create DP array int dp [ n , k + 1 ]"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , findSubarraySum ( i , 0 , n , a , k ) ) ; NEW_LINE DEDENT",
        "explain": "Iterate and call recursive function from every index to get the maximum subarray sum"
    },
    {
        "py": "if ans == 0 and k == 0 : NEW_LINE return max ( a ) ; NEW_LINE return ans ; NEW_LINE",
        "explain": "corner casae"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ - 1 , - 2 , - 100 , - 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE k = 1 ; NEW_LINE print ( findMaxSubarraySum ( a , n , k ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "mod = 1000000007 ; NEW_LINE",
        "explain": "Python3 program to Find the sum of first N odd Fibonacci numbers"
    },
    {
        "py": "def sumOddFibonacci ( n ) : NEW_LINE INDENT Sum = [ 0 ] * ( n + 1 ) ; NEW_LINE DEDENT",
        "explain": "Function to calculate sum of first N odd Fibonacci numbers"
    },
    {
        "py": "Sum [ 0 ] = 0 ; NEW_LINE Sum [ 1 ] = 1 ; NEW_LINE Sum [ 2 ] = 2 ; NEW_LINE Sum [ 3 ] = 5 ; NEW_LINE Sum [ 4 ] = 10 ; NEW_LINE Sum [ 5 ] = 23 ; NEW_LINE for i in range ( 6 , n + 1 ) : NEW_LINE INDENT Sum [ i ] = ( ( Sum [ i - 1 ] + ( 4 * Sum [ i - 2 ] ) % mod - ( 4 * Sum [ i - 3 ] ) % mod + mod ) % mod + ( Sum [ i - 4 ] - Sum [ i - 5 ] + mod ) % mod ) % mod ; NEW_LINE DEDENT return Sum [ n ] ; NEW_LINE",
        "explain": "base values"
    },
    {
        "py": "n = 6 ; NEW_LINE print ( sumOddFibonacci ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def fun ( marks , n ) : NEW_LINE",
        "explain": "Python implementation of the above approach"
    },
    {
        "py": "dp = [ 1 for i in range ( 0 , n ) ] NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE",
        "explain": "Initializing one tablet for each student"
    },
    {
        "py": "if marks [ i ] > marks [ i + 1 ] : NEW_LINE INDENT temp = i NEW_LINE while True : NEW_LINE INDENT if marks [ temp ] > marks [ temp + 1 ] and temp >= 0 : NEW_LINE INDENT if dp [ temp ] > dp [ temp + 1 ] : NEW_LINE INDENT temp -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ temp ] = dp [ temp + 1 ] + 1 NEW_LINE temp -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "if left adjacent is having higher marks review and change all the dp values assigned before until assigned dp values are found wrong according to given constrains"
    },
    {
        "py": "elif marks [ i ] < marks [ i + 1 ] : NEW_LINE INDENT dp [ i + 1 ] = dp [ i ] + 1 NEW_LINE DEDENT return ( sum ( dp ) ) NEW_LINE",
        "explain": "if right adjacent is having higher marks add one in dp of left adjacent and assign to right one"
    },
    {
        "py": "n = 6 NEW_LINE",
        "explain": "n number of students"
    },
    {
        "py": "marks = [ 1 , 4 , 5 , 2 , 2 , 1 ] NEW_LINE",
        "explain": "marks of students"
    },
    {
        "py": "print ( fun ( marks , n ) ) NEW_LINE",
        "explain": "solution of problem"
    },
    {
        "py": "def solve ( N , K ) : NEW_LINE",
        "explain": "Python3 program to reach N - th stair by taking a maximum of K leap"
    },
    {
        "py": "combo = [ 0 ] * ( N + 1 ) NEW_LINE",
        "explain": "elements of combo [ ] stores the no of possible ways to reach it by all combinations of k leaps or less"
    },
    {
        "py": "combo [ 0 ] = 1 NEW_LINE",
        "explain": "assuming leap 0 exist and assigning its value to 1 for calculation"
    },
    {
        "py": "for i in range ( 1 , K + 1 ) : NEW_LINE",
        "explain": "loop to iterate over all possible leaps upto k ;"
    },
    {
        "py": "for j in range ( 0 , N + 1 ) : NEW_LINE",
        "explain": "in this loop we count all possible leaps to reach the jth stair with the help of ith leap or less"
    },
    {
        "py": "if j >= i : NEW_LINE",
        "explain": "if the leap is not more than the i - j"
    },
    {
        "py": "combo [ j ] += combo [ j - i ] NEW_LINE",
        "explain": "calculate the value and store in combo [ j ] to reuse it for next leap calculation for the jth stair"
    },
    {
        "py": "return combo [ N ] NEW_LINE",
        "explain": "returns the no of possible number of leaps to reach the top of building of n stairs"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N , K = 29 , 5 NEW_LINE print ( solve ( N , K ) ) NEW_LINE",
        "explain": "N i the no of total stairs K is the value of the greatest leap"
    },
    {
        "py": "def computeLIS ( circBuff , start , end , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( end ) ] NEW_LINE DEDENT",
        "explain": "Utility method to find LIS using Dynamic programming"
    },
    {
        "py": "for i in range ( start , end ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT",
        "explain": "Initialize LIS values for all indexes"
    },
    {
        "py": "for i in range ( start + 1 , end ) : NEW_LINE",
        "explain": "Compute optimized LIS values in bottom up manner"
    },
    {
        "py": "for j in range ( start , i ) : NEW_LINE INDENT if ( circBuff [ i ] > circBuff [ j ] and LIS [ i ] < LIS [ j ] + 1 ) : NEW_LINE INDENT LIS [ i ] = LIS [ j ] + 1 NEW_LINE DEDENT DEDENT",
        "explain": "Set j on the basis of current window i . e . first element of the current window"
    },
    {
        "py": "res = - 100000 NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT res = max ( res , LIS [ i ] ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Pick maximum of all LIS values"
    },
    {
        "py": "def LICS ( arr , n ) : NEW_LINE",
        "explain": "Function to find Longest Increasing subsequence in Circular manner"
    },
    {
        "py": "circBuff = [ 0 for i in range ( 2 * n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n , 2 * n ) : NEW_LINE INDENT circBuff [ i ] = arr [ i - n ] NEW_LINE DEDENT",
        "explain": "Make a copy of given array by appending same array elements to itself"
    },
    {
        "py": "res = - 100000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( computeLIS ( circBuff , i , i + n , n ) , res ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Perform LIS for each window of size n"
    },
    {
        "py": "arr = [ 1 , 4 , 6 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Length \u2581 of \u2581 LICS \u2581 is \" , LICS ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE C [ 0 ] = 1 NEW_LINE DEDENT",
        "explain": "Function to find binomial Coefficient"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE",
        "explain": "Constructing Pascal 's Triangle"
    },
    {
        "py": "n = 3 NEW_LINE m = 2 NEW_LINE print ( \" Number \u2581 of \u2581 Paths : \" , binomialCoeff ( n + m , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def LCIS ( arr1 , n , arr2 , m ) : NEW_LINE",
        "explain": "Returns the length and the LCIS of two arrays arr1 [ 0. . n - 1 ] and arr2 [ 0. . m - 1 ]"
    },
    {
        "py": "table = [ 0 ] * m NEW_LINE for j in range ( m ) : NEW_LINE INDENT table [ j ] = 0 NEW_LINE DEDENT",
        "explain": "table [ j ] is going to store length of LCIS ending with arr2 [ j ] . We initialize it as 0 ,"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse all elements of arr1 [ ]"
    },
    {
        "py": "current = 0 NEW_LINE",
        "explain": "Initialize current length of LCIS"
    },
    {
        "py": "for j in range ( m ) : NEW_LINE",
        "explain": "For each element of arr1 [ ] , traverse all elements of arr2 [ ] ."
    },
    {
        "py": "if ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT if ( current + 1 > table [ j ] ) : NEW_LINE INDENT table [ j ] = current + 1 NEW_LINE DEDENT DEDENT",
        "explain": "If both the array have same elements . Note that we don 't break the loop here."
    },
    {
        "py": "if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT if ( table [ j ] > current ) : NEW_LINE INDENT current = table [ j ] NEW_LINE DEDENT DEDENT",
        "explain": "Now seek for previous smaller common element for current element of arr1"
    },
    {
        "py": "result = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( table [ i ] > result ) : NEW_LINE INDENT result = table [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE",
        "explain": "The maximum value in table [ ] is out result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 3 , 4 , 9 , 1 ] NEW_LINE arr2 = [ 5 , 3 , 8 , 9 , 10 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE print ( \" Length \u2581 of \u2581 LCIS \u2581 is \" , LCIS ( arr1 , n , arr2 , m ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def longComPre ( arr , N ) : NEW_LINE",
        "explain": "Function to get the length of the longest common prefix by rearranging the strings"
    },
    {
        "py": "freq = [ [ 0 for i in range ( 256 ) ] for i in range ( N ) ] NEW_LINE",
        "explain": "freq [ i ] [ j ] : stores the frequency of a character ( = j ) in a arr [ i ]"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the given array"
    },
    {
        "py": "M = len ( arr [ i ] ) NEW_LINE",
        "explain": "Stores length of current string"
    },
    {
        "py": "for j in range ( M ) : NEW_LINE",
        "explain": "Traverse current string of the given array"
    },
    {
        "py": "freq [ i ] [ ord ( arr [ i ] [ j ] ) ] += 1 NEW_LINE",
        "explain": "Update the value of freq [ i ] [ arr [ i ] [ j ] ]"
    },
    {
        "py": "maxLen = 0 NEW_LINE",
        "explain": "Stores the length of longest common prefix"
    },
    {
        "py": "for j in range ( 256 ) : NEW_LINE",
        "explain": "Count the minimum frequency of each character in in all the strings of arr [ ]"
    },
    {
        "py": "minRowVal = sys . maxsize NEW_LINE",
        "explain": "Stores minimum value in each row of freq [ ] [ ]"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Calculate minimum frequency of current character in all the strings ."
    },
    {
        "py": "minRowVal = min ( minRowVal , freq [ i ] [ j ] ) NEW_LINE",
        "explain": "Update minRowVal"
    },
    {
        "py": "maxLen += minRowVal NEW_LINE return maxLen NEW_LINE",
        "explain": "Update maxLen"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" aabdc \" , \" abcd \" , \" aacd \" ] NEW_LINE N = 3 NEW_LINE print ( longComPre ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAX_CHAR = 26 NEW_LINE",
        "explain": "Python 3 program to remove characters from a String that appears exactly K times"
    },
    {
        "py": "def removeChars ( arr , k ) : NEW_LINE",
        "explain": "Function to reduce the string by removing the characters which appears exactly k times"
    },
    {
        "py": "hash = [ 0 ] * MAX_CHAR NEW_LINE",
        "explain": "Hash table initialised to 0"
    },
    {
        "py": "n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Increment the frequency of the character"
    },
    {
        "py": "ans = \" \" NEW_LINE",
        "explain": "To store answer"
    },
    {
        "py": "index = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Next index in reduced string"
    },
    {
        "py": "if ( hash [ ord ( arr [ i ] ) - ord ( ' a ' ) ] != k ) : NEW_LINE INDENT ans += arr [ i ] NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Append the characters which appears exactly k times"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE k = 2 NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( removeChars ( str , k ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def sub_segments ( string , n ) : NEW_LINE INDENT l = len ( string ) NEW_LINE for x in range ( 0 , l , n ) : NEW_LINE INDENT newlist = string [ x : x + n ] NEW_LINE DEDENT DEDENT",
        "explain": "Function that prints the segments"
    },
    {
        "py": "arr = [ ] NEW_LINE for y in newlist : NEW_LINE",
        "explain": "New array for every iteration"
    },
    {
        "py": "if y not in arr : NEW_LINE INDENT arr . append ( y ) NEW_LINE DEDENT print ( ' ' . join ( arr ) ) NEW_LINE",
        "explain": "Check if the character is in the array"
    },
    {
        "py": "string = \" geeksforgeeksgfg \" NEW_LINE n = 4 NEW_LINE sub_segments ( string , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findWord ( c , n ) : NEW_LINE INDENT co = 0 NEW_LINE DEDENT",
        "explain": "Function to find the encrypted string"
    },
    {
        "py": "s = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n / 2 ) : NEW_LINE INDENT co += 1 NEW_LINE DEDENT else : NEW_LINE INDENT co = n - i NEW_LINE DEDENT DEDENT",
        "explain": "to store the encrypted string"
    },
    {
        "py": "if ( ord ( c [ i ] ) + co <= 122 ) : NEW_LINE INDENT s [ i ] = chr ( ord ( c [ i ] ) + co ) NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = chr ( ord ( c [ i ] ) + co - 26 ) NEW_LINE DEDENT print ( * s , sep = \" \" ) NEW_LINE",
        "explain": "after ' z ' , it should go to a ."
    },
    {
        "py": "s = \" abcd \" NEW_LINE findWord ( s , len ( s ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def equalIgnoreCase ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT",
        "explain": "Function to compare two strings ignoring their cases"
    },
    {
        "py": "len1 = len ( str1 ) NEW_LINE",
        "explain": "length of first string"
    },
    {
        "py": "len2 = len ( str2 ) NEW_LINE",
        "explain": "length of second string"
    },
    {
        "py": "if ( len1 != len2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "if length is not same simply return false since both string can not be same if length is not equal"
    },
    {
        "py": "while ( i < len1 ) : NEW_LINE",
        "explain": "loop to match one by one all characters of both string"
    },
    {
        "py": "if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT",
        "explain": "if current characters of both string are same , increase value of i to compare next character"
    },
    {
        "py": "elif ( ( ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) or ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "if any character of first string is some special character or numeric character and not same as corresponding character of second string then return false"
    },
    {
        "py": "elif ( ( ( str2 [ i ] >= ' a ' and str2 [ i ] <= ' z ' ) or ( str2 [ i ] >= ' A ' and str2 [ i ] <= ' Z ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "do the same for second string"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "this block of code will be executed if characters of both strings are of different cases"
    },
    {
        "py": "if ( str1 [ i ] >= ' a ' and str1 [ i ] <= ' z ' ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) - 32 != ord ( str2 [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( str1 [ i ] >= ' A ' and str1 [ i ] <= ' Z ' ) : NEW_LINE INDENT if ( ord ( str1 [ i ] ) + 32 != ord ( str2 [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "compare characters by ASCII value"
    },
    {
        "py": "i += 1 NEW_LINE",
        "explain": "if characters matched , increase the value of i to compare next char"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "if all characters of the first string are matched with corresponding characters of the second string , then return true"
    },
    {
        "py": "def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Same \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the same or not same if strings are equal or not equal"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" Geeks \" NEW_LINE str2 = \" geeks \" NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) NEW_LINE str1 = \" Geek \" NEW_LINE str2 = \" geeksforgeeks \" NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxValue ( a , b ) : NEW_LINE",
        "explain": "Function to return the maximized value of A"
    },
    {
        "py": "b = sorted ( b ) NEW_LINE bi = [ i for i in b ] NEW_LINE ai = [ i for i in a ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE",
        "explain": "Sort digits in ascending order"
    },
    {
        "py": "j = m - 1 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "j points to largest digit in B"
    },
    {
        "py": "if ( j < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( bi [ j ] > ai [ i ] ) : NEW_LINE INDENT ai [ i ] = bi [ j ] NEW_LINE DEDENT",
        "explain": "If all the digits of b have been used"
    },
    {
        "py": "j -= 1 NEW_LINE",
        "explain": "Current digit has been used"
    },
    {
        "py": "x = \" \" . join ( ai ) NEW_LINE return x NEW_LINE",
        "explain": "Return the maximized value"
    },
    {
        "py": "a = \"1234\" NEW_LINE b = \"4321\" NEW_LINE print ( maxValue ( a , b ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def checkIfUnequal ( n , q ) : NEW_LINE",
        "explain": "Function to check if all of the digits in a number and it 's product with q are unequal or not"
    },
    {
        "py": "s1 = str ( n ) NEW_LINE a = [ 0 for i in range ( 26 ) ] NEW_LINE",
        "explain": "convert first number into string"
    },
    {
        "py": "for i in range ( 0 , len ( s1 ) , 1 ) : NEW_LINE INDENT a [ ord ( s1 [ i ] ) - ord ( '0' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Insert elements from 1 st number to hash"
    },
    {
        "py": "prod = n * q NEW_LINE",
        "explain": "Calculate corresponding product"
    },
    {
        "py": "s2 = str ( prod ) NEW_LINE",
        "explain": "Convert the product to string"
    },
    {
        "py": "for i in range ( 0 , len ( s2 ) , 1 ) : NEW_LINE",
        "explain": "Using the hash check if any digit of product matches with the digits of input number"
    },
    {
        "py": "if ( a [ ord ( s2 [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If yes , return false"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "Return true"
    },
    {
        "py": "def countInRange ( l , r , q ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE DEDENT",
        "explain": "Function to count numbers in the range [ l , r ] such that all of the digits of the number and it 's product with q are unequal"
    },
    {
        "py": "if ( checkIfUnequal ( i , q ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "check for every number between l and r"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 10 NEW_LINE r = 12 NEW_LINE q = 2 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( countInRange ( l , r , q ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def is_possible ( s ) : NEW_LINE",
        "explain": "function to check the binary string"
    },
    {
        "py": "l = len ( s ) NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE",
        "explain": "length of string"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT",
        "explain": "count zero 's"
    },
    {
        "py": "else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT",
        "explain": "count one 's"
    },
    {
        "py": "if ( l % 2 == 0 ) : NEW_LINE INDENT return ( one == zero ) NEW_LINE DEDENT",
        "explain": "if length is even"
    },
    {
        "py": "else : NEW_LINE INDENT return ( abs ( one - zero ) == 1 ) NEW_LINE DEDENT",
        "explain": "if length is odd"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"100110\" NEW_LINE if ( is_possible ( s ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "limit = 255 NEW_LINE def countFreq ( Str ) : NEW_LINE",
        "explain": "Python3 program to count frequencies of array items"
    },
    {
        "py": "count = [ 0 ] * ( limit + 1 ) NEW_LINE",
        "explain": "Create an array to store counts . The size of array is limit + 1 and all values are initially 0"
    },
    {
        "py": "for i in range ( len ( Str ) ) : NEW_LINE INDENT count [ ord ( Str [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( limit + 1 ) : NEW_LINE if ( count [ i ] > 0 ) : NEW_LINE INDENT print ( chr ( i ) , count [ i ] ) NEW_LINE DEDENT",
        "explain": "Traverse through string characters and count frequencies"
    },
    {
        "py": "def countEvenOdd ( arr , n , K ) : NEW_LINE INDENT even = 0 ; odd = 0 ; NEW_LINE DEDENT",
        "explain": "Function to store EVEN and odd variable"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Store the count of even and odd set bit"
    },
    {
        "py": "x = bin ( arr [ i ] ) . count ( '1' ) ; NEW_LINE if ( x % 2 == 0 ) : NEW_LINE INDENT even += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 ; NEW_LINE DEDENT",
        "explain": "Count the set bit using in built function"
    },
    {
        "py": "y = bin ( K ) . count ( '1' ) ; NEW_LINE",
        "explain": "Count of set - bit of K"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT print ( \" Even \u2581 = \" , odd , \" , \u2581 Odd \u2581 = \" , even ) ; NEW_LINE DEDENT",
        "explain": "If y is odd then , count of even and odd set bit will be interchanged"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Even \u2581 = \" , even , \" , \u2581 Odd \u2581 = \" , odd ) ; NEW_LINE DEDENT",
        "explain": "Else it will remain same as the original array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 2 , 15 , 9 , 8 , 8 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver 's Code"
    },
    {
        "py": "countEvenOdd ( arr , n , K ) ; NEW_LINE",
        "explain": "Function call to count even and odd"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program to convert given sentence to camel case ."
    },
    {
        "py": "def convert ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE s1 = \" \" NEW_LINE s1 = s1 + s [ 0 ] . lower ( ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE DEDENT",
        "explain": "Function to remove spaces and convert into camel case"
    },
    {
        "py": "if ( s [ i ] == ' \u2581 ' and i <= n ) : NEW_LINE",
        "explain": "check for spaces in the sentence"
    },
    {
        "py": "s1 = s1 + \" \u2581 \" + ( s [ i + 1 ] ) . lower ( ) NEW_LINE i = i + 1 NEW_LINE",
        "explain": "conversion into upper case"
    },
    {
        "py": "else : NEW_LINE INDENT s1 = s1 + ( s [ i ] ) . upper ( ) NEW_LINE DEDENT i = i + 1 NEW_LINE",
        "explain": "If not space , copy character"
    },
    {
        "py": "return s1 NEW_LINE",
        "explain": "return string to main"
    },
    {
        "py": "str = \" I \u2581 get \u2581 intern \u2581 at \u2581 geeksforgeeks \" NEW_LINE print ( convert ( str ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation to check if N is a Tcefrep number"
    },
    {
        "py": "def reverse ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT",
        "explain": "Iterative function to reverse digits of num"
    },
    {
        "py": "def properDivSum ( num ) : NEW_LINE",
        "explain": "Function to calculate sum of all proper divisors num -- > given natural number"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Final result of summation of divisors"
    },
    {
        "py": "' NEW_LINE INDENT for i in range ( 2 , ( int ) ( math . sqrt ( num ) ) + 1 ) : NEW_LINE DEDENT",
        "explain": "find all divisors which divides 'num"
    },
    {
        "py": "' NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE DEDENT",
        "explain": "if ' i ' is divisor of 'num"
    },
    {
        "py": "if ( i == ( num // i ) ) : NEW_LINE INDENT result += i NEW_LINE DEDENT else : NEW_LINE INDENT result += ( i + num / i ) NEW_LINE DEDENT",
        "explain": "if both divisors are same then add it only once else add both"
    },
    {
        "py": "return ( result + 1 ) NEW_LINE def isTcefrep ( n ) : NEW_LINE return properDivSum ( n ) == reverse ( n ) ; NEW_LINE",
        "explain": "Add 1 to the result as 1 is also a divisor"
    },
    {
        "py": "N = 6 NEW_LINE",
        "explain": "Given Number N"
    },
    {
        "py": "if ( isTcefrep ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "def reverse ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return reverse ( s [ 1 : ] ) + s [ 0 ] NEW_LINE DEDENT DEDENT def findNthNo ( n ) : NEW_LINE INDENT res = \" \" ; NEW_LINE while ( n >= 1 ) : NEW_LINE DEDENT",
        "explain": "Python3 program to find n - th number containing only 3 and 5."
    },
    {
        "py": "if ( n & 1 ) : NEW_LINE INDENT res = res + \"3\" ; NEW_LINE n = ( int ) ( ( n - 1 ) / 2 ) ; NEW_LINE DEDENT",
        "explain": "If n is odd , append 3 and move to parent"
    },
    {
        "py": "else : NEW_LINE INDENT res = res + \"5\" ; NEW_LINE n = ( int ) ( ( n - 2 ) / 2 ) ; NEW_LINE DEDENT",
        "explain": "If n is even , append 5 and move to parent"
    },
    {
        "py": "return reverse ( res ) ; NEW_LINE",
        "explain": "Reverse res and return ."
    },
    {
        "py": "n = 5 ; NEW_LINE print ( findNthNo ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find n - th non - square number ."
    },
    {
        "py": "def findNthNonSquare ( n ) : NEW_LINE",
        "explain": "function to find the nth Non - Square Number"
    },
    {
        "py": "x = n ; NEW_LINE",
        "explain": "conversion from int to long double is necessary in order to preserve decimal places after square root ."
    },
    {
        "py": "ans = x + math . floor ( 0.5 + math . sqrt ( x ) ) ; NEW_LINE return int ( ans ) ; NEW_LINE",
        "explain": "calculating the result"
    },
    {
        "py": "n = 16 ; NEW_LINE",
        "explain": "initializing the term number"
    },
    {
        "py": "print ( \" The \" , n , \" th \u2581 Non - Square \u2581 number \u2581 is \" , findNthNonSquare ( n ) ) ; NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "def seiresSum ( n , a ) : NEW_LINE INDENT return ( n * ( a [ 0 ] * a [ 0 ] - a [ 2 * n - 1 ] * a [ 2 * n - 1 ] ) / ( 2 * n - 1 ) ) NEW_LINE DEDENT",
        "explain": "Function to calculate series sum"
    },
    {
        "py": "n = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( int ( seiresSum ( n , a ) ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def checkdigit ( n , k ) : NEW_LINE INDENT while ( n ) : NEW_LINE DEDENT",
        "explain": "Function for checking if digit k is in n or not"
    },
    {
        "py": "rem = n % 10 NEW_LINE",
        "explain": "finding remainder"
    },
    {
        "py": "if ( rem == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT n = n / 10 NEW_LINE return 0 NEW_LINE",
        "explain": "if digit found"
    },
    {
        "py": "def findNthNumber ( n , k ) : NEW_LINE",
        "explain": "Function for finding nth number"
    },
    {
        "py": "i = k + 1 NEW_LINE count = 1 NEW_LINE while ( count < n ) : NEW_LINE",
        "explain": "since k is the first which satisfy th criteria , so consider it in count making count = 1 and starting from i = k + 1"
    },
    {
        "py": "if ( checkdigit ( i , k ) or ( i % k == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE return - 1 NEW_LINE",
        "explain": "checking that the number contain k digit or divisible by k"
    },
    {
        "py": "n = 10 NEW_LINE k = 2 NEW_LINE print ( findNthNumber ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def find_permutations ( arr ) : NEW_LINE INDENT cnt = 0 NEW_LINE max_ind = - 1 NEW_LINE min_ind = 10000000 ; NEW_LINE n = len ( arr ) NEW_LINE index_of = { } NEW_LINE DEDENT",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT index_of [ arr [ i ] ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Save index of numbers of the array"
    },
    {
        "py": "max_ind = max ( max_ind , index_of [ i ] ) NEW_LINE min_ind = min ( min_ind , index_of [ i ] ) NEW_LINE if ( max_ind - min_ind + 1 == i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE",
        "explain": "Update min and max index with the current index and check if it 's a  valid permutation"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT nums = [ ] NEW_LINE nums . append ( 2 ) NEW_LINE nums . append ( 3 ) NEW_LINE nums . append ( 1 ) NEW_LINE nums . append ( 5 ) NEW_LINE nums . append ( 4 ) NEW_LINE print ( find_permutations ( nums ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import gcd as __gcd NEW_LINE def getCount ( a , n ) : NEW_LINE",
        "explain": "Function to return the count of the required integers"
    },
    {
        "py": "gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( gcd , a [ i ] ) NEW_LINE DEDENT",
        "explain": "To store the gcd of the array elements"
    },
    {
        "py": "cnt = 0 NEW_LINE for i in range ( 1 , gcd + 1 ) : NEW_LINE INDENT if i * i > gcd : NEW_LINE INDENT break NEW_LINE DEDENT if ( gcd % i == 0 ) : NEW_LINE DEDENT",
        "explain": "To store the count of factors of the found gcd"
    },
    {
        "py": "if ( i * i == gcd ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT",
        "explain": "If g is a perfect square"
    },
    {
        "py": "else : NEW_LINE INDENT cnt += 2 NEW_LINE DEDENT return cnt NEW_LINE",
        "explain": "Factors appear in pairs"
    },
    {
        "py": "a = [ 4 , 16 , 1024 , 48 ] NEW_LINE n = len ( a ) NEW_LINE print ( getCount ( a , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def delCost ( s , cost ) : NEW_LINE",
        "explain": "Function to find the minimum cost of removing characters to make the string unique"
    },
    {
        "py": "visited = [ False ] * len ( s ) NEW_LINE",
        "explain": "Stores the visited characters"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the answer"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "Traverse the string"
    },
    {
        "py": "if visited [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If already visited"
    },
    {
        "py": "maxDel = 0 NEW_LINE",
        "explain": "Stores the maximum cost of removing a particular character"
    },
    {
        "py": "totCost = 0 NEW_LINE",
        "explain": "Store the total deletion cost of a particular character"
    },
    {
        "py": "visited [ i ] = True NEW_LINE",
        "explain": "Mark the current character visited"
    },
    {
        "py": "for j in range ( i , len ( s ) ) : NEW_LINE",
        "explain": "Traverse the indices of the string [ i , N - 1 ]"
    },
    {
        "py": "if s [ i ] == s [ j ] : NEW_LINE",
        "explain": "If any duplicate is found"
    },
    {
        "py": "maxDel = max ( maxDel , cost [ j ] ) NEW_LINE totCost += cost [ j ] NEW_LINE",
        "explain": "Update the maximum cost and total cost"
    },
    {
        "py": "visited [ j ] = True NEW_LINE",
        "explain": "Mark the current character visited"
    },
    {
        "py": "ans += totCost - maxDel NEW_LINE",
        "explain": "Keep the character with maximum cost and delete the rest"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the minimum cost"
    },
    {
        "py": "string = \" AAABBB \" NEW_LINE",
        "explain": "Driver code Given string"
    },
    {
        "py": "cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE",
        "explain": "input array"
    },
    {
        "py": "string = \" AAABBB \" NEW_LINE",
        "explain": "input array"
    },
    {
        "py": "print ( delCost ( string , cost ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def checkXOR ( arr , N ) : NEW_LINE",
        "explain": "Function to find triplets such that replacing them with their XOR make all array elements equal"
    },
    {
        "py": "if ( N % 2 == 0 ) : NEW_LINE",
        "explain": "If N is even"
    },
    {
        "py": "xro = 0 ; NEW_LINE",
        "explain": "Calculate xor of array elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "xro ^= arr [ i ] ; NEW_LINE",
        "explain": "Update xor"
    },
    {
        "py": "if ( xro != 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "If xor is not equal to 0"
    },
    {
        "py": "for i in range ( 0 , N - 3 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( i + 2 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal"
    },
    {
        "py": "for i in range ( 0 , N - 3 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( N - 1 ) , end = \" \u2581 \" ) ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]"
    },
    {
        "py": "for i in range ( 0 , N - 2 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( i + 2 ) ) ; NEW_LINE DEDENT",
        "explain": "Selecting the triplets such that elements of the pairs ( arr [ 0 ] , arr [ 1 ] ) , ( arr [ 2 ] , arr [ 3 ] ) . . . can be made equal"
    },
    {
        "py": "for i in range ( 0 , N - 2 , 2 ) : NEW_LINE INDENT print ( i , \" \u2581 \" , ( i + 1 ) , \" \u2581 \" , ( N - 1 ) ) ; NEW_LINE DEDENT",
        "explain": "Selecting the triplets such that all array elements can be made equal to arr [ N - 1 ]"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 4 , 2 , 1 , 7 , 2 ] ; NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) ; NEW_LINE",
        "explain": "Size of array"
    },
    {
        "py": "checkXOR ( arr , N ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def make_array_element_even ( arr , N ) : NEW_LINE",
        "explain": "Function to find minimum count of operations required to make all array elements even"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores minimum count of replacements to make all array elements even"
    },
    {
        "py": "odd_cont_seg = 0 NEW_LINE",
        "explain": "Stores the count of odd continuous numbers"
    },
    {
        "py": "for i in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( arr [ i ] % 2 == 1 ) : NEW_LINE",
        "explain": "If arr [ i ] is an odd number"
    },
    {
        "py": "odd_cont_seg += 1 NEW_LINE else : NEW_LINE if ( odd_cont_seg > 0 ) : NEW_LINE",
        "explain": "Update odd_cont_seg"
    },
    {
        "py": "if ( odd_cont_seg % 2 == 0 ) : NEW_LINE",
        "explain": "If odd_cont_seg is even"
    },
    {
        "py": "res += odd_cont_seg // 2 NEW_LINE else : NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "res += ( odd_cont_seg // 2 ) + 2 NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "odd_cont_seg = 0 NEW_LINE",
        "explain": "Reset odd_cont_seg = 0"
    },
    {
        "py": "if ( odd_cont_seg > 0 ) : NEW_LINE",
        "explain": "If odd_cont_seg exceeds 0"
    },
    {
        "py": "if ( odd_cont_seg % 2 == 0 ) : NEW_LINE",
        "explain": "If odd_cont_seg is even"
    },
    {
        "py": "res += odd_cont_seg // 2 NEW_LINE else : NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "res += odd_cont_seg // 2 + 2 NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Prthe result"
    },
    {
        "py": "arr = [ 2 , 4 , 5 , 11 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( make_array_element_even ( arr , N ) ) NEW_LINE",
        "explain": "Drivers Code"
    },
    {
        "py": "def zvalue ( nums ) : NEW_LINE",
        "explain": "Function to find K for which there are exactly K array elements greater than or equal to K"
    },
    {
        "py": "m = max ( nums ) NEW_LINE cnt = 0 NEW_LINE",
        "explain": "Finding the largest array element"
    },
    {
        "py": "for i in range ( 0 , m + 1 , 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT",
        "explain": "Possible values of K"
    },
    {
        "py": "for j in range ( 0 , len ( nums ) , 1 ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( nums [ j ] >= i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT",
        "explain": "If current array element is greater than or equal to i"
    },
    {
        "py": "if ( cnt == i ) : NEW_LINE INDENT return i NEW_LINE DEDENT",
        "explain": "If i array elements are greater than or equal to i"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT nums = [ 7 , 8 , 9 , 0 , 0 , 1 ] NEW_LINE print ( zvalue ( nums ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def lexico_smallest ( s1 , s2 ) : NEW_LINE",
        "explain": "Function to find the lexicographically smallest anagram of string which contains another string"
    },
    {
        "py": "M = { } NEW_LINE S = [ ] NEW_LINE pr = { } NEW_LINE",
        "explain": "Initializing the dictionary and set"
    },
    {
        "py": "for i in range ( len ( s1 ) ) : NEW_LINE",
        "explain": "Iterating over s1"
    },
    {
        "py": "if s1 [ i ] not in M : NEW_LINE INDENT M [ s1 [ i ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT M [ s1 [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "Storing the frequency of characters present in s1"
    },
    {
        "py": "S . append ( s1 [ i ] ) NEW_LINE S = list ( set ( S ) ) NEW_LINE S . sort ( ) NEW_LINE",
        "explain": "Storing the distinct characters present in s1"
    },
    {
        "py": "for i in range ( len ( s2 ) ) : NEW_LINE INDENT if s2 [ i ] in M : NEW_LINE INDENT M [ s2 [ i ] ] -= 1 NEW_LINE DEDENT DEDENT c = s2 [ 0 ] NEW_LINE index = 0 NEW_LINE res = \" \" NEW_LINE",
        "explain": "Decreasing the frequency of characters from M that are already present in s2"
    },
    {
        "py": "for x in S : NEW_LINE",
        "explain": "Traversing alphabets in sorted order"
    },
    {
        "py": "if ( x != c ) : NEW_LINE INDENT for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT else : NEW_LINE",
        "explain": "If current character of set is not equal to current character of s2"
    },
    {
        "py": "j = 0 NEW_LINE index = len ( res ) NEW_LINE",
        "explain": "If element is equal to current character of s2"
    },
    {
        "py": "while ( s2 [ j ] == x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT",
        "explain": "Checking for second distinct character in s2"
    },
    {
        "py": "if ( s2 [ j ] < c ) : NEW_LINE INDENT res += s2 NEW_LINE for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , M [ x ] + 1 ) : NEW_LINE INDENT res += x NEW_LINE DEDENT index += M [ x ] NEW_LINE res += s2 NEW_LINE DEDENT pr [ res ] = index NEW_LINE",
        "explain": "s2 [ j ] will store second distinct character"
    },
    {
        "py": "return pr NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "def lexico_largest ( s1 , s2 ) : NEW_LINE",
        "explain": "Function to find the lexicographically largest anagram of string which contains another string"
    },
    {
        "py": "Pr = dict ( lexico_smallest ( s1 , s2 ) ) NEW_LINE",
        "explain": "Getting the lexicographically smallest anagram"
    },
    {
        "py": "d1 = \" \" NEW_LINE key = [ * Pr ] [ 0 ] NEW_LINE for i in range ( Pr . get ( key ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT d1 += key [ i ] NEW_LINE DEDENT",
        "explain": "d1 stores the prefix"
    },
    {
        "py": "d2 = \" \" NEW_LINE for i in range ( len ( key ) - 1 , Pr [ key ] + len ( s2 ) - 1 , - 1 ) : NEW_LINE INDENT d2 += key [ i ] NEW_LINE DEDENT res = d2 + s2 + d1 NEW_LINE",
        "explain": "d2 stores the suffix"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "s1 = \" ethgakagmenpgs \" NEW_LINE s2 = \" geeks \" NEW_LINE",
        "explain": "Given two strings"
    },
    {
        "py": "print ( * lexico_smallest ( s1 , s2 ) ) NEW_LINE print ( lexico_largest ( s1 , s2 ) ) NEW_LINE",
        "explain": "Function Calls"
    },
    {
        "py": "sz = 100000 NEW_LINE",
        "explain": "Python3 implementation for the above approach"
    },
    {
        "py": "tree = [ [ ] for i in range ( sz ) ] NEW_LINE",
        "explain": "Adjacency list to represent the tree"
    },
    {
        "py": "n = 0 NEW_LINE",
        "explain": "Number of vertices"
    },
    {
        "py": "vis = [ False ] * sz NEW_LINE",
        "explain": "Mark visited / unvisited vertices"
    },
    {
        "py": "subtreeSize = [ 0 for i in range ( sz ) ] NEW_LINE",
        "explain": "Stores the subtree size of the corresponding nodes"
    },
    {
        "py": "def addEdge ( a , b ) : NEW_LINE INDENT global tree NEW_LINE DEDENT",
        "explain": "Function to create an edge between two vertices"
    },
    {
        "py": "tree [ a ] . append ( b ) NEW_LINE",
        "explain": "Add a to b 's list"
    },
    {
        "py": "tree [ b ] . append ( a ) NEW_LINE",
        "explain": "Add b to a 's list"
    },
    {
        "py": "def dfs ( x ) : NEW_LINE",
        "explain": "Function to perform DFS"
    },
    {
        "py": "global vis NEW_LINE global subtreeSize NEW_LINE global tree NEW_LINE vis [ x ] = True NEW_LINE",
        "explain": "Mark the vertex visited"
    },
    {
        "py": "subtreeSize [ x ] = 1 NEW_LINE",
        "explain": "Include the node in the subtree"
    },
    {
        "py": "for i in tree [ x ] : NEW_LINE INDENT if ( vis [ i ] == False ) : NEW_LINE INDENT dfs ( i ) NEW_LINE subtreeSize [ x ] += subtreeSize [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Traverse all its children"
    },
    {
        "py": "def countPairs ( a , b ) : NEW_LINE INDENT global subtreeSize NEW_LINE sub = min ( subtreeSize [ a ] , subtreeSize [ b ] ) NEW_LINE print ( sub * ( n - sub ) ) NEW_LINE DEDENT",
        "explain": "Function to print the required number of paths"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = 6 NEW_LINE addEdge ( 0 , 1 ) NEW_LINE addEdge ( 0 , 2 ) NEW_LINE addEdge ( 1 , 3 ) NEW_LINE addEdge ( 3 , 4 ) NEW_LINE addEdge ( 3 , 5 ) NEW_LINE",
        "explain": "Number of vertices"
    },
    {
        "py": "dfs ( 0 ) NEW_LINE",
        "explain": "Calling modified dfs function"
    },
    {
        "py": "countPairs ( 1 , 3 ) NEW_LINE countPairs ( 0 , 2 ) NEW_LINE",
        "explain": "Count pairs of vertices in the tree"
    },
    {
        "py": "def findPermutation ( arr , N ) : NEW_LINE INDENT pos = len ( arr ) + 1 NEW_LINE DEDENT",
        "explain": "Function to find the count of desired permutations"
    },
    {
        "py": "if ( pos > N ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "if ( i not in arr ) : NEW_LINE",
        "explain": "If i has not been inserted"
    },
    {
        "py": "if ( i % pos == 0 or pos % i == 0 ) : NEW_LINE",
        "explain": "Backtrack"
    },
    {
        "py": "arr . add ( i ) NEW_LINE",
        "explain": "Insert i"
    },
    {
        "py": "res += findPermutation ( arr , N ) NEW_LINE",
        "explain": "Recur to find valid permutations"
    },
    {
        "py": "arr . remove ( i ) NEW_LINE",
        "explain": "Remove i"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the final count"
    },
    {
        "py": "N = 5 NEW_LINE arr = set ( ) NEW_LINE print ( findPermutation ( arr , N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def solve ( arr , n , X , Y ) : NEW_LINE",
        "explain": "Function to check if it is possible to obtain sum Y from a sequence of sum X from the array arr [ ]"
    },
    {
        "py": "diff = Y - X NEW_LINE",
        "explain": "Store the difference"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT diff = diff % ( arr [ i ] - 1 ) NEW_LINE DEDENT DEDENT",
        "explain": "Iterate over the array"
    },
    {
        "py": "if ( diff == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "If diff reduced to 0"
    },
    {
        "py": "arr = [ 1 , 2 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE X , Y = 11 , 13 NEW_LINE solve ( arr , n , X , Y ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "maxN = 100001 NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "adj = [ [ ] for i in range ( maxN ) ] NEW_LINE",
        "explain": "Adjacency List to store the graph"
    },
    {
        "py": "height = [ 0 for i in range ( maxN ) ] NEW_LINE",
        "explain": "Stores the height of each node"
    },
    {
        "py": "dist = [ 0 for i in range ( maxN ) ] NEW_LINE",
        "explain": "Stores the maximum distance of a node from its ancestors"
    },
    {
        "py": "def addEdge ( u , v ) : NEW_LINE",
        "explain": "Function to add edge between two vertices"
    },
    {
        "py": "adj [ u ] . append ( v ) NEW_LINE",
        "explain": "Insert edge from u to v"
    },
    {
        "py": "adj [ v ] . append ( u ) NEW_LINE",
        "explain": "Insert edge from v to u"
    },
    {
        "py": "def dfs1 ( cur , par ) : NEW_LINE",
        "explain": "Function to calculate height of each Node"
    },
    {
        "py": "for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE DEDENT",
        "explain": "Iterate in the adjacency list of the current node"
    },
    {
        "py": "dfs1 ( u , cur ) NEW_LINE",
        "explain": "Dfs for child node"
    },
    {
        "py": "height [ cur ] = max ( height [ cur ] , height [ u ] ) NEW_LINE",
        "explain": "Calculate height of nodes"
    },
    {
        "py": "height [ cur ] += 1 NEW_LINE",
        "explain": "Increase height"
    },
    {
        "py": "def dfs2 ( cur , par ) : NEW_LINE INDENT max1 = 0 NEW_LINE max2 = 0 NEW_LINE DEDENT",
        "explain": "Function to calculate the maximum distance of a node from its ancestor"
    },
    {
        "py": "for u in adj [ cur ] : NEW_LINE INDENT if ( u != par ) : NEW_LINE DEDENT",
        "explain": "Iterate in the adjacency list of the current node"
    },
    {
        "py": "if ( height [ u ] >= max1 ) : NEW_LINE INDENT max2 = max1 NEW_LINE max1 = height [ u ] NEW_LINE DEDENT elif ( height [ u ] > max2 ) : NEW_LINE INDENT max2 = height [ u ] NEW_LINE DEDENT sum = 0 NEW_LINE for u in adj [ cur ] : NEW_LINE if ( u != par ) : NEW_LINE",
        "explain": "Find two children with maximum heights"
    },
    {
        "py": "sum = ( max2 if ( max1 == height [ u ] ) else max1 ) NEW_LINE if ( max1 == height [ u ] ) : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max2 , dist [ cur ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dist [ u ] = 1 + max ( 1 + max1 , dist [ cur ] ) NEW_LINE DEDENT",
        "explain": "Calculate the maximum distance with ancestor for every node"
    },
    {
        "py": "dfs2 ( u , cur ) NEW_LINE",
        "explain": "Calculating for children"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 6 NEW_LINE addEdge ( 1 , 2 ) NEW_LINE addEdge ( 2 , 3 ) NEW_LINE addEdge ( 2 , 4 ) NEW_LINE addEdge ( 2 , 5 ) NEW_LINE addEdge ( 5 , 6 ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "dfs1 ( 1 , 0 ) NEW_LINE",
        "explain": "Calculate height of nodes of the tree"
    },
    {
        "py": "dfs2 ( 1 , 0 ) NEW_LINE",
        "explain": "Calculate the maximum distance with ancestors"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( max ( dist [ i ] , height [ i ] ) - 1 , end = ' \u2581 ' ) NEW_LINE DEDENT",
        "explain": "Print the maximum of the two distances from each node"
    },
    {
        "py": "def middleOfThree ( a , b , c ) : NEW_LINE",
        "explain": "Python3 program to find middle of three distinct numbers"
    },
    {
        "py": "INDENT def middleOfThree ( a , b , c ) : NEW_LINE DEDENT",
        "explain": "Function to find the middle of three number"
    },
    {
        "py": "if ( ( a < b and b < c ) or ( c < b and b < a ) ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT",
        "explain": "Checking for b"
    },
    {
        "py": "if ( ( b < a and a < c ) or ( c < a and a < b ) ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return c NEW_LINE DEDENT",
        "explain": "Checking for a"
    },
    {
        "py": "a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def selectionSort ( arr , n ) : NEW_LINE",
        "explain": "Function to implement the selection sort"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE",
        "explain": "One by one move boundary of unsorted subarray"
    },
    {
        "py": "min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] < arr [ min_idx ] ) : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT",
        "explain": "Find the minimum element in unsorted array"
    },
    {
        "py": "arr [ min_idx ] , arr [ i ] = arr [ i ] , arr [ min_idx ] NEW_LINE",
        "explain": "Swap the found minimum element with the first element"
    },
    {
        "py": "def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Function to print an array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 64 , 25 , 12 , 22 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "selectionSort ( arr , n ) NEW_LINE print ( \" Sorted \u2581 array : \u2581 \" ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "printArray ( arr , n ) NEW_LINE",
        "explain": "Print the array"
    },
    {
        "py": "def checkStr1CanConStr2 ( str1 , str2 ) : NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "N = len ( str1 ) NEW_LINE",
        "explain": "Stores length of str1"
    },
    {
        "py": "M = len ( str2 ) NEW_LINE",
        "explain": "Stores length of str2"
    },
    {
        "py": "st1 = set ( [ ] ) NEW_LINE",
        "explain": "Stores distinct characters of str1"
    },
    {
        "py": "st2 = set ( [ ] ) NEW_LINE",
        "explain": "Stores distinct characters of str2"
    },
    {
        "py": "hash1 = [ 0 ] * 256 NEW_LINE",
        "explain": "Stores frequency of each character of str1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the string str1"
    },
    {
        "py": "hash1 [ ord ( str1 [ i ] ) ] += 1 NEW_LINE",
        "explain": "Update frequency of str1 [ i ]"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the string str1"
    },
    {
        "py": "st1 . add ( str1 [ i ] ) NEW_LINE",
        "explain": "Insert str1 [ i ] into st1"
    },
    {
        "py": "for i in range ( M ) : NEW_LINE",
        "explain": "Traverse the string str2"
    },
    {
        "py": "st2 . add ( str2 [ i ] ) NEW_LINE",
        "explain": "Insert str1 [ i ] into st1"
    },
    {
        "py": "if ( st1 != st2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If distinct characters in str1 and str2 are not same"
    },
    {
        "py": "hash2 = [ 0 ] * 256 NEW_LINE",
        "explain": "Stores frequency of each character of str2"
    },
    {
        "py": "for i in range ( M ) : NEW_LINE",
        "explain": "Traverse the string str2"
    },
    {
        "py": "hash2 [ ord ( str2 [ i ] ) ] += 1 NEW_LINE",
        "explain": "Update frequency of str2 [ i ]"
    },
    {
        "py": "hash1 . sort ( ) NEW_LINE",
        "explain": "Sort hash1 [ ] array"
    },
    {
        "py": "hash2 . sort ( ) NEW_LINE",
        "explain": "Sort hash2 [ ] array"
    },
    {
        "py": "for i in range ( 256 ) : NEW_LINE",
        "explain": "Traverse hash1 [ ] and hash2 [ ]"
    },
    {
        "py": "if ( hash1 [ i ] != hash2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "If hash1 [ i ] not equal to hash2 [ i ]"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" xyyzzlll \" NEW_LINE str2 = \" yllzzxxx \" NEW_LINE if ( checkStr1CanConStr2 ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" True \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" False \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def partSort ( arr , N , a , b ) : NEW_LINE",
        "explain": "Function to sort the elements of the array from index a to index b"
    },
    {
        "py": "l = min ( a , b ) NEW_LINE r = max ( a , b ) NEW_LINE arr = ( arr [ 0 : l ] + sorted ( arr [ l : r + 1 ] ) + arr [ r : N ] ) NEW_LINE",
        "explain": "Variables to store start and end of the index range"
    },
    {
        "py": "for i in range ( 0 , N , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the modified array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 8 , 4 , 5 , 2 ] NEW_LINE a = 1 NEW_LINE b = 4 NEW_LINE N = len ( arr ) NEW_LINE partSort ( arr , N , a , b ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "INF = 2147483647 NEW_LINE N = 4 NEW_LINE",
        "explain": "A Dynamic Programming based solution to find min cost to reach station N - 1 from station 0."
    },
    {
        "py": "def minCost ( cost ) : NEW_LINE",
        "explain": "This function returns the smallest possible cost to reach station N - 1 from station 0."
    },
    {
        "py": "dist = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dist [ i ] = INF NEW_LINE DEDENT dist [ 0 ] = 0 NEW_LINE",
        "explain": "dist [ i ] stores minimum cost to reach station i from station 0."
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) : NEW_LINE INDENT dist [ j ] = dist [ i ] + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dist [ N - 1 ] NEW_LINE",
        "explain": "Go through every station and check if using it as an intermediate station gives better path"
    },
    {
        "py": "cost = [ [ 0 , 15 , 80 , 90 ] , [ INF , 0 , 40 , 50 ] , [ INF , INF , 0 , 70 ] , [ INF , INF , INF , 0 ] ] NEW_LINE print ( \" The \u2581 Minimum \u2581 cost \u2581 to \u2581 reach \u2581 station \u2581 \" , N , \" \u2581 is \u2581 \" , minCost ( cost ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def numOfways ( n , k ) : NEW_LINE INDENT p = 1 NEW_LINE if ( k % 2 ) : NEW_LINE INDENT p = - 1 NEW_LINE DEDENT return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n NEW_LINE DEDENT",
        "explain": "Return the Number of ways from a node to make a loop of size K in undirected complete connected graph of N nodes"
    },
    {
        "py": "n = 4 NEW_LINE k = 2 NEW_LINE print ( numOfways ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def largest_alphabet ( a , n ) : NEW_LINE",
        "explain": "Function that return the largest alphabet"
    },
    {
        "py": "' NEW_LINE INDENT max = ' A ' NEW_LINE DEDENT",
        "explain": "Initializing max alphabet to 'a"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > max ) : NEW_LINE INDENT max = a [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Find largest alphabet"
    },
    {
        "py": "return max NEW_LINE",
        "explain": "Returning largest element"
    },
    {
        "py": "def smallest_alphabet ( a , n ) : NEW_LINE",
        "explain": "Function that return the smallest alphabet"
    },
    {
        "py": "' NEW_LINE INDENT min = ' z ' ; NEW_LINE DEDENT",
        "explain": "Initializing smallest alphabet to 'z"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] < min ) : NEW_LINE INDENT min = a [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Find smallest alphabet"
    },
    {
        "py": "return min NEW_LINE",
        "explain": "Returning smallest alphabet"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "a = \" GeEksforGeeks \" NEW_LINE",
        "explain": "Character array"
    },
    {
        "py": "size = len ( a ) NEW_LINE",
        "explain": "Calculating size of the string"
    },
    {
        "py": "print ( \" Largest \u2581 and \u2581 smallest \u2581 alphabet \u2581 is \u2581 : \u2581 \" , end = \" \" ) NEW_LINE print ( largest_alphabet ( a , size ) , end = \" \u2581 and \u2581 \" ) NEW_LINE print ( smallest_alphabet ( a , size ) ) NEW_LINE ' NEW_LINE",
        "explain": "Calling functions and print returned value"
    },
    {
        "py": "def maximumPalinUsingKChanges ( strr , k ) : NEW_LINE INDENT palin = strr [ : : ] NEW_LINE DEDENT",
        "explain": "Returns maximum possible palindrome using k changes"
    },
    {
        "py": "l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE",
        "explain": "Initialize l and r by leftmost and rightmost ends"
    },
    {
        "py": "while ( l <= r ) : NEW_LINE",
        "explain": "first try to make palindrome"
    },
    {
        "py": "if ( strr [ l ] != strr [ r ] ) : NEW_LINE INDENT palin [ l ] = palin [ r ] = NEW_LINE INDENT max ( strr [ l ] , strr [ r ] ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE",
        "explain": "Replace left and right character by maximum of both"
    },
    {
        "py": "if ( k < 0 ) : NEW_LINE INDENT return \" Not \u2581 possible \" NEW_LINE DEDENT l = 0 NEW_LINE r = len ( strr ) - 1 NEW_LINE while ( l <= r ) : NEW_LINE",
        "explain": "If k is negative then we can 't make  palindrome"
    },
    {
        "py": "if ( l == r ) : NEW_LINE INDENT if ( k > 0 ) : NEW_LINE INDENT palin [ l ] = '9' NEW_LINE DEDENT DEDENT",
        "explain": "At mid character , if K > 0 then change it to 9"
    },
    {
        "py": "if ( palin [ l ] < '9' ) : NEW_LINE",
        "explain": "If character at lth ( same as rth ) is less than 9"
    },
    {
        "py": "if ( k >= 2 and palin [ l ] == strr [ l ] and palin [ r ] == strr [ r ] ) : NEW_LINE INDENT k -= 2 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT",
        "explain": "If none of them is changed in the previous loop then subtract 2 from K and convert both to 9"
    },
    {
        "py": "elif ( k >= 1 and ( palin [ l ] != strr [ l ] or palin [ r ] != strr [ r ] ) ) : NEW_LINE INDENT k -= 1 NEW_LINE palin [ l ] = palin [ r ] = '9' NEW_LINE DEDENT l += 1 NEW_LINE r -= 1 NEW_LINE return palin NEW_LINE",
        "explain": "If one of them is changed in the previous loop then subtract 1 from K ( 1 more is subtracted already ) and make them 9"
    },
    {
        "py": "st = \"43435\" NEW_LINE strr = [ i for i in st ] NEW_LINE k = 3 NEW_LINE a = maximumPalinUsingKChanges ( strr , k ) NEW_LINE print ( \" \" . join ( a ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countTriplets ( A ) : NEW_LINE",
        "explain": "Function to find the number of triplets whose Bitwise AND is 0."
    },
    {
        "py": "cnt = 0 ; NEW_LINE",
        "explain": "Stores the count of triplets having bitwise AND equal to 0"
    },
    {
        "py": "tuples = { } ; NEW_LINE",
        "explain": "Stores frequencies of all possible A [ i ] & A [ j ]"
    },
    {
        "py": "for a in A : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "for b in A : NEW_LINE INDENT if ( a & b ) in tuples : NEW_LINE INDENT tuples [ a & b ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT tuples [ a & b ] = 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Update frequency of Bitwise AND of all array elements with a"
    },
    {
        "py": "for a in A : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "for t in tuples : NEW_LINE",
        "explain": "Iterate the map"
    },
    {
        "py": "if ( ( t & a ) == 0 ) : NEW_LINE INDENT cnt += tuples [ t ] ; NEW_LINE DEDENT",
        "explain": "If bitwise AND of triplet is zero , increment cnt"
    },
    {
        "py": "return cnt ; NEW_LINE",
        "explain": "Return the number of triplets whose Bitwise AND is 0."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = [ 2 , 1 , 3 ] ; NEW_LINE",
        "explain": "Input Array"
    },
    {
        "py": "print ( countTriplets ( A ) ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "mn = 1000 NEW_LINE",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "def parity ( even , odd , v , i ) : NEW_LINE INDENT global mn NEW_LINE DEDENT",
        "explain": "Recursive function to calculate minimum adjacent pairs with different parity"
    },
    {
        "py": "if ( i == len ( v ) or len ( even ) == 0 or len ( odd ) == 0 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( len ( v ) - 1 ) : NEW_LINE INDENT if ( v [ j ] % 2 != v [ j + 1 ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count < mn ) : NEW_LINE INDENT mn = count NEW_LINE DEDENT return NEW_LINE DEDENT",
        "explain": "If all the numbers are placed"
    },
    {
        "py": "if ( v [ i ] != - 1 ) : NEW_LINE INDENT parity ( even , odd , v , i + 1 ) NEW_LINE DEDENT",
        "explain": "If replacement is not required"
    },
    {
        "py": "else : NEW_LINE INDENT if ( len ( even ) != 0 ) : NEW_LINE INDENT x = even [ len ( even ) - 1 ] NEW_LINE even . remove ( even [ len ( even ) - 1 ] ) NEW_LINE v [ i ] = x NEW_LINE parity ( even , odd , v , i + 1 ) NEW_LINE DEDENT DEDENT",
        "explain": "If replacement is required"
    },
    {
        "py": "even . append ( x ) NEW_LINE if ( len ( odd ) != 0 ) : NEW_LINE x = odd [ len ( odd ) - 1 ] NEW_LINE odd . remove ( odd [ len ( odd ) - 1 ] ) NEW_LINE v [ i ] = x NEW_LINE parity ( even , odd , v , i + 1 ) NEW_LINE",
        "explain": "backtracking"
    },
    {
        "py": "odd . append ( x ) NEW_LINE",
        "explain": "backtracking"
    },
    {
        "py": "def mnDiffParity ( v , n ) : NEW_LINE INDENT global mn NEW_LINE DEDENT",
        "explain": "Function to display the minimum number of adjacent elements with different parity"
    },
    {
        "py": "even = [ ] NEW_LINE",
        "explain": "Store no of even numbers not present in the array"
    },
    {
        "py": "odd = [ ] NEW_LINE m = { i : 0 for i in range ( 100 ) } NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT m [ i ] = 1 NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE",
        "explain": "Store no of odd numbers not present in the array"
    },
    {
        "py": "if ( v [ i ] != - 1 ) : NEW_LINE INDENT m . pop ( v [ i ] ) NEW_LINE DEDENT",
        "explain": "Erase exisiting numbers"
    },
    {
        "py": "for key in m . keys ( ) : NEW_LINE INDENT if ( key % 2 == 0 ) : NEW_LINE INDENT even . append ( key ) NEW_LINE DEDENT else : NEW_LINE INDENT odd . append ( key ) NEW_LINE DEDENT DEDENT parity ( even , odd , v , 0 ) NEW_LINE print ( mn + 4 ) NEW_LINE",
        "explain": "Store non - exisiting even and odd numbers"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE v = [ 2 , 1 , 4 , - 1 , - 1 , 6 , - 1 , 8 ] NEW_LINE mnDiffParity ( v , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 100005 NEW_LINE adjacent = [ [ ] for i in range ( MAX ) ] NEW_LINE visited = [ False ] * MAX NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "startnode = endnode = thirdnode = None NEW_LINE maxi , N = - 1 , None NEW_LINE",
        "explain": "To store the required nodes"
    },
    {
        "py": "parent = [ None ] * MAX NEW_LINE",
        "explain": "Parent array to retrace the nodes"
    },
    {
        "py": "vis = [ False ] * MAX NEW_LINE",
        "explain": "Visited array to prevent DFS in direction on Diameter path"
    },
    {
        "py": "def dfs ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global startnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE dfs ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE startnode = u NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "DFS function to find the startnode"
    },
    {
        "py": "def dfs1 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global endnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if not visited [ adjacent [ u ] [ i ] ] : NEW_LINE INDENT temp += 1 NEW_LINE parent [ adjacent [ u ] [ i ] ] = u NEW_LINE dfs1 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE endnode = u NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "DFS function to find the endnode of diameter and maintain the parent array"
    },
    {
        "py": "def dfs2 ( u , count ) : NEW_LINE INDENT visited [ u ] = True NEW_LINE temp = 0 NEW_LINE global thirdnode , maxi NEW_LINE for i in range ( 0 , len ( adjacent [ u ] ) ) : NEW_LINE INDENT if ( not visited [ adjacent [ u ] [ i ] ] and not vis [ adjacent [ u ] [ i ] ] ) : NEW_LINE INDENT temp += 1 NEW_LINE dfs2 ( adjacent [ u ] [ i ] , count + 1 ) NEW_LINE DEDENT DEDENT if temp == 0 : NEW_LINE INDENT if maxi < count : NEW_LINE INDENT maxi = count NEW_LINE thirdnode = u NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "DFS function to find the end node of the Longest Branch to Diameter"
    },
    {
        "py": "def findNodes ( ) : NEW_LINE",
        "explain": "Function to find the required nodes"
    },
    {
        "py": "dfs ( 1 , 0 ) NEW_LINE global maxi NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT maxi = - 1 NEW_LINE",
        "explain": "To find start node of diameter"
    },
    {
        "py": "dfs1 ( startnode , 0 ) NEW_LINE for i in range ( 0 , N + 1 ) : NEW_LINE INDENT visited [ i ] = False NEW_LINE DEDENT",
        "explain": "To find end node of diameter"
    },
    {
        "py": "x = endnode NEW_LINE vis [ startnode ] = True NEW_LINE",
        "explain": "x is the end node of diameter"
    },
    {
        "py": "while x != startnode : NEW_LINE INDENT vis [ x ] = True NEW_LINE x = parent [ x ] NEW_LINE DEDENT maxi = - 1 NEW_LINE",
        "explain": "Mark all the nodes on diameter using back tracking"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if vis [ i ] : NEW_LINE INDENT dfs2 ( i , 0 ) NEW_LINE DEDENT DEDENT",
        "explain": "Find the end node of longest branch to diameter"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE adjacent [ 1 ] . append ( 2 ) NEW_LINE adjacent [ 2 ] . append ( 1 ) NEW_LINE adjacent [ 1 ] . append ( 3 ) NEW_LINE adjacent [ 3 ] . append ( 1 ) NEW_LINE adjacent [ 1 ] . append ( 4 ) NEW_LINE adjacent [ 4 ] . append ( 1 ) NEW_LINE findNodes ( ) NEW_LINE print ( \" ( { } , \u2581 { } , \u2581 { } ) \" . format ( startnode , endnode , thirdnode ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def newvol ( x ) : NEW_LINE INDENT print ( \" percentage \u2581 increase \u2581 in \u2581 the \" , pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 , \" % \" ) DEDENT",
        "explain": "Python3 program to find percentage increase in the volume of the sphere if radius is increased by a given percentage"
    },
    {
        "py": "x = 10.0 NEW_LINE newvol ( x ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 program to find the length chord of the circle whose radius and the angle subtended at the centre is also given"
    },
    {
        "py": "def length_of_chord ( r , x ) : NEW_LINE INDENT print ( \" The \u2581 length \u2581 of \u2581 the \u2581 chord \" , \" \u2581 of \u2581 the \u2581 circle \u2581 is \u2581 \" , 2 * r * mt . sin ( x * ( 3.14 / 180 ) ) ) NEW_LINE DEDENT",
        "explain": "Function to find the length of the chord"
    },
    {
        "py": "r = 4 NEW_LINE x = 63 ; NEW_LINE length_of_chord ( r , x ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "Python3 Program to find the area of the square inscribed within the circle which in turn is inscribed in an equilateral triangle"
    },
    {
        "py": "def area ( a ) : NEW_LINE",
        "explain": "Function to find the area of the square"
    },
    {
        "py": "if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "a cannot be negative"
    },
    {
        "py": "area = sqrt ( a ) / 6 NEW_LINE return area NEW_LINE",
        "explain": "area of the square"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE print ( round ( area ( a ) , 6 ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "Python 3 program to find the longest rod that can fit in a cuboid"
    },
    {
        "py": "def longestRodInCuboid ( length , breadth , height ) : NEW_LINE",
        "explain": "Function to find the length"
    },
    {
        "py": "temp = length * length + breadth * breadth + height * height NEW_LINE",
        "explain": "temporary variable to hold the intermediate result"
    },
    {
        "py": "result = sqrt ( temp ) NEW_LINE return result NEW_LINE",
        "explain": "length of longest rod is calculated using square root function"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT length , breadth , height = 12 , 9 , 8 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( longestRodInCuboid ( length , breadth , height ) ) NEW_LINE",
        "explain": "calling longestRodInCuboid ( ) function to get the length of longest rod"
    },
    {
        "py": "def LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT if ( x - y - b <= 0 and x - y + b >= 0 and x + y - 2 * a + b <= 0 and x + y - b >= 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "function to Check whether a given point lies inside or on the rectangle or not"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a , b , x , y = 7 , 2 , 4 , 5 NEW_LINE if LiesInsieRectangle ( a , b , x , y ) : NEW_LINE INDENT print ( \" Given \u2581 point \u2581 lies \u2581 inside \" \" \u2581 the \u2581 rectangle \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Given \u2581 point \u2581 does \u2581 not \u2581 lie \" \" \u2581 on \u2581 the \u2581 rectangle \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxvolume ( s ) : NEW_LINE INDENT maxvalue = 0 NEW_LINE DEDENT",
        "explain": "Return the maximum volume ."
    },
    {
        "py": "i = 1 NEW_LINE for i in range ( s - 1 ) : NEW_LINE INDENT j = 1 NEW_LINE DEDENT",
        "explain": "for length"
    },
    {
        "py": "for j in range ( s ) : NEW_LINE",
        "explain": "for breadth"
    },
    {
        "py": "k = s - i - j NEW_LINE",
        "explain": "for height"
    },
    {
        "py": "maxvalue = max ( maxvalue , i * j * k ) NEW_LINE return maxvalue NEW_LINE",
        "explain": "calculating maximum volume ."
    },
    {
        "py": "s = 8 NEW_LINE print ( maxvolume ( s ) ) NEW_LINE",
        "explain": "Driven Program"
    },
    {
        "py": "def maxvolume ( s ) : NEW_LINE",
        "explain": "Return the maximum volume ."
    },
    {
        "py": "length = int ( s / 3 ) NEW_LINE s -= length NEW_LINE",
        "explain": "finding length"
    },
    {
        "py": "breadth = s / 2 NEW_LINE",
        "explain": "finding breadth"
    },
    {
        "py": "height = s - breadth NEW_LINE return int ( length * breadth * height ) NEW_LINE",
        "explain": "finding height"
    },
    {
        "py": "s = 8 NEW_LINE print ( maxvolume ( s ) ) NEW_LINE",
        "explain": "Driven Program"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find area of a Hexagon"
    },
    {
        "py": "def hexagonArea ( s ) : NEW_LINE INDENT return ( ( 3 * math . sqrt ( 3 ) * ( s * s ) ) / 2 ) ; NEW_LINE DEDENT",
        "explain": "Function for calculating area of the hexagon ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "s = 4 NEW_LINE print ( \" Area : \" , \" { 0 : . 4f } \" . format ( hexagonArea ( s ) ) ) NEW_LINE",
        "explain": "length of a side ."
    },
    {
        "py": "def maxSquare ( b , m ) : NEW_LINE",
        "explain": "function for finding max squares"
    },
    {
        "py": "return ( b / m - 1 ) * ( b / m ) / 2 NEW_LINE",
        "explain": "return in O ( 1 ) with derived formula"
    },
    {
        "py": "b = 10 NEW_LINE m = 2 NEW_LINE print ( int ( maxSquare ( b , m ) ) ) NEW_LINE",
        "explain": "driver program"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python program to check existence of right triangle ."
    },
    {
        "py": "def findRightAngle ( A , H ) : NEW_LINE",
        "explain": "Prints three sides of a right triangle from given area and hypotenuse if triangle is possible , else prints - 1."
    },
    {
        "py": "D = pow ( H , 4 ) - 16 * A * A NEW_LINE if D >= 0 : NEW_LINE",
        "explain": "Descriminant of the equation"
    },
    {
        "py": "root1 = ( H * H + sqrt ( D ) ) / 2 NEW_LINE root2 = ( H * H - sqrt ( D ) ) / 2 NEW_LINE a = sqrt ( root1 ) NEW_LINE b = sqrt ( root2 ) NEW_LINE if b >= a : NEW_LINE INDENT print a , b , H NEW_LINE DEDENT else : NEW_LINE INDENT print b , a , H NEW_LINE DEDENT else : NEW_LINE print \" - 1\" NEW_LINE",
        "explain": "applying the linear equation formula to find both the roots"
    },
    {
        "py": "findRightAngle ( 6 , 5 ) NEW_LINE",
        "explain": "Driver code Area is 6 and hypotenuse is 5."
    },
    {
        "py": "def numberOfSquares ( base ) : NEW_LINE",
        "explain": "Python3 program to count number of 2 x 2 squares in a right isosceles triangle"
    },
    {
        "py": "base = ( base - 2 ) NEW_LINE",
        "explain": "removing the extra part we would always need"
    },
    {
        "py": "base = base // 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE",
        "explain": "Since each square has base of length of 2"
    },
    {
        "py": "base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def performQuery ( arr , Q ) : NEW_LINE",
        "explain": "Function to find the Bitwise OR of Bitwise AND of all possible subarrays after performing the every query"
    },
    {
        "py": "for i in range ( 0 , len ( Q ) ) : NEW_LINE",
        "explain": "Traversing each pair of the query"
    },
    {
        "py": "orr = 0 NEW_LINE",
        "explain": "Stores the Bitwise OR"
    },
    {
        "py": "x = Q [ i ] [ 0 ] NEW_LINE arr [ x - 1 ] = Q [ i ] [ 1 ] NEW_LINE",
        "explain": "Updating the array"
    },
    {
        "py": "for j in range ( 0 , len ( arr ) ) : NEW_LINE INDENT orr = orr | arr [ j ] NEW_LINE DEDENT",
        "explain": "Find the Bitwise OR of new updated array"
    },
    {
        "py": "print ( orr , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print the ans"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE Q = [ [ 1 , 4 ] , [ 3 , 0 ] ] NEW_LINE performQuery ( arr , Q ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def smallest ( k , d ) : NEW_LINE INDENT cnt = 1 NEW_LINE m = d % k NEW_LINE DEDENT",
        "explain": "Function to form the smallest number possible"
    },
    {
        "py": "v = [ 0 for i in range ( k ) ] ; NEW_LINE v [ m ] = 1 NEW_LINE",
        "explain": "Array to mark the remainders counted already"
    },
    {
        "py": "while ( 1 ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return cnt NEW_LINE DEDENT m = ( ( ( m * ( 10 % k ) ) % k ) + ( d % k ) ) % k NEW_LINE DEDENT",
        "explain": "Iterate over the range"
    },
    {
        "py": "if ( v [ m ] == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT v [ m ] = 1 NEW_LINE cnt += 1 NEW_LINE return - 1 NEW_LINE",
        "explain": "If that remainder is already found , return - 1"
    },
    {
        "py": "d = 1 NEW_LINE k = 41 NEW_LINE print ( smallest ( k , d ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT",
        "explain": "Function to find fibonacci number"
    },
    {
        "py": "def findVertices ( n ) : NEW_LINE",
        "explain": "Function for finding number of vertices in fibonacci cube graph"
    },
    {
        "py": "return fib ( n + 2 ) NEW_LINE",
        "explain": "return fibonacci number for f ( n + 2 )"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE print ( findVertices ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def checkCommonDivisor ( arr , N , X ) : NEW_LINE",
        "explain": "Function to check if it is possible to modify the array such that there is no common factor between array elements except 1"
    },
    {
        "py": "G = 0 NEW_LINE",
        "explain": "Stores GCD of the array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT G = math . gcd ( G , arr [ i ] ) NEW_LINE DEDENT copy_G = G NEW_LINE for divisor in range ( 2 , X + 1 ) : NEW_LINE",
        "explain": "Calculate GCD of the array"
    },
    {
        "py": "while ( G % divisor == 0 ) : NEW_LINE",
        "explain": "If the current divisor is smaller than X"
    },
    {
        "py": "G = G // divisor NEW_LINE",
        "explain": "Divide GCD by the current divisor"
    },
    {
        "py": "if ( G <= X ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT",
        "explain": "If possible"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] // copy_G , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the modified array"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 6 , 15 , 6 ] NEW_LINE X = 6 NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE checkCommonDivisor ( arr , N , X ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , next = None , prev = None , data = None ) : NEW_LINE INDENT self . next = next NEW_LINE self . prev = prev NEW_LINE self . data = data NEW_LINE DEDENT DEDENT",
        "explain": "Node of a doubly linked list"
    },
    {
        "py": "def reverse ( head_ref ) : NEW_LINE INDENT temp = None NEW_LINE current = head_ref NEW_LINE DEDENT",
        "explain": "Function to reverse a Doubly Linked List"
    },
    {
        "py": "while ( current != None ) : NEW_LINE INDENT temp = current . prev NEW_LINE current . prev = current . next NEW_LINE current . next = temp NEW_LINE current = current . prev NEW_LINE DEDENT",
        "explain": "swap next and prev for all nodes of doubly linked list"
    },
    {
        "py": "if ( temp != None ) : NEW_LINE INDENT head_ref = temp . prev NEW_LINE return head_ref NEW_LINE DEDENT",
        "explain": "Before changing head , check for the cases like empty list and list with only one node"
    },
    {
        "py": "def merge ( first , second ) : NEW_LINE",
        "explain": "Function to merge two sorted doubly linked lists"
    },
    {
        "py": "if ( first == None ) : NEW_LINE INDENT return second NEW_LINE DEDENT",
        "explain": "If first linked list is empty"
    },
    {
        "py": "if ( second == None ) : NEW_LINE INDENT return first NEW_LINE DEDENT",
        "explain": "If second linked list is empty"
    },
    {
        "py": "if ( first . data < second . data ) : NEW_LINE INDENT first . next = merge ( first . next , second ) NEW_LINE first . next . prev = first NEW_LINE first . prev = None NEW_LINE return first NEW_LINE DEDENT else : NEW_LINE INDENT second . next = merge ( first , second . next ) NEW_LINE second . next . prev = second NEW_LINE second . prev = None NEW_LINE return second NEW_LINE DEDENT",
        "explain": "Pick the smaller value"
    },
    {
        "py": "def sort ( head ) : NEW_LINE",
        "explain": "function to sort a biotonic doubly linked list"
    },
    {
        "py": "if ( head == None or head . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT current = head . next NEW_LINE while ( current != None ) : NEW_LINE",
        "explain": "if list is empty or if it contains a single node only"
    },
    {
        "py": "if ( current . data < current . prev . data ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "if true , then ' current ' is the first node which is smaller than its previous node"
    },
    {
        "py": "current = current . next NEW_LINE",
        "explain": "move to the next node"
    },
    {
        "py": "if ( current == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT",
        "explain": "if true , then list is already sorted"
    },
    {
        "py": "current . prev . next = None NEW_LINE current . prev = None NEW_LINE",
        "explain": "spilt into two lists , one starting with ' head ' and other starting with ' current '"
    },
    {
        "py": "current = reverse ( current ) NEW_LINE",
        "explain": "reverse the list starting with ' current '"
    },
    {
        "py": "return merge ( head , current ) NEW_LINE",
        "explain": "merge the two lists and return the final merged doubly linked list"
    },
    {
        "py": "def push ( head_ref , new_data ) : NEW_LINE",
        "explain": "Function to insert a node at the beginning of the Doubly Linked List"
    },
    {
        "py": "new_node = Node ( ) NEW_LINE",
        "explain": "allocate node"
    },
    {
        "py": "new_node . data = new_data NEW_LINE",
        "explain": "put in the data"
    },
    {
        "py": "new_node . prev = None NEW_LINE",
        "explain": "since we are adding at the beginning , prev is always None"
    },
    {
        "py": "new_node . next = ( head_ref ) NEW_LINE",
        "explain": "link the old list off the new node"
    },
    {
        "py": "if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT",
        "explain": "change prev of head node to new node"
    },
    {
        "py": "( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE",
        "explain": "move the head to point to the new node"
    },
    {
        "py": "def printList ( head ) : NEW_LINE",
        "explain": "Function to print nodes in a given doubly linked list"
    },
    {
        "py": "if ( head == None ) : NEW_LINE INDENT print ( \" Doubly \u2581 Linked \u2581 list \u2581 empty \" ) NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT",
        "explain": "if list is empty"
    },
    {
        "py": "head = None NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "head = push ( head , 1 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 2 ) NEW_LINE print ( \" Original \u2581 Doubly \u2581 linked \u2581 list : n \" ) NEW_LINE printList ( head ) NEW_LINE",
        "explain": "Create the doubly linked list : 2 < .5 < .7 < .12 < .10 < .6 < .4 < .1"
    },
    {
        "py": "head = sort ( head ) NEW_LINE print ( \" Doubly linked list after sorting : \" ) NEW_LINE printList ( head ) NEW_LINE",
        "explain": "sort the biotonic DLL"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "A linked list node"
    },
    {
        "py": "def printlist ( head ) : NEW_LINE INDENT if ( not head ) : NEW_LINE INDENT print ( \" Empty \u2581 List \" ) NEW_LINE return NEW_LINE DEDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE if ( head . next ) : NEW_LINE INDENT print ( end = \" - > \u2581 \" ) NEW_LINE DEDENT head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Utility function to print the linked list"
    },
    {
        "py": "def isVowel ( x ) : NEW_LINE INDENT return ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' or x == ' A ' or x == ' E ' or x == ' I ' or x == ' O ' or x == ' U ' ) NEW_LINE DEDENT",
        "explain": "Utility function for checking vowel"
    },
    {
        "py": "def arrange ( head ) : NEW_LINE INDENT newHead = head NEW_LINE DEDENT",
        "explain": "function to arrange consonants and vowels nodes"
    },
    {
        "py": "latestVowel = None NEW_LINE curr = head NEW_LINE",
        "explain": "for keep track of vowel"
    },
    {
        "py": "if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT",
        "explain": "list is empty"
    },
    {
        "py": "if ( isVowel ( head . data ) ) : NEW_LINE",
        "explain": "We need to discover the first vowel in the list . It is going to be the returned head , and also the initial latestVowel ."
    },
    {
        "py": "latestVowel = head NEW_LINE else : NEW_LINE",
        "explain": "first element is a vowel . It will also be the new head and the initial latestVowel"
    },
    {
        "py": "while ( curr . next != None and not isVowel ( curr . next . data ) ) : NEW_LINE INDENT curr = curr . next NEW_LINE DEDENT",
        "explain": "First element is not a vowel . Iterate through the list until we find a vowel . Note that curr points to the element * before * the element with the vowel ."
    },
    {
        "py": "if ( curr . next == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT",
        "explain": "This is an edge case where there are only consonants in the list ."
    },
    {
        "py": "latestVowel = newHead = curr . next NEW_LINE curr . next = curr . next . next NEW_LINE latestVowel . next = head NEW_LINE",
        "explain": "Set the initial latestVowel and the new head to the vowel item that we found . Relink the chain of consonants after that vowel item : old_head_consonant . consonant1 . consonant2 . vowel . rest_of_list becomes vowel . old_head_consonant . consonant1 . consonant2 . rest_of_list"
    },
    {
        "py": "while ( curr != None and curr . next != None ) : NEW_LINE INDENT if ( isVowel ( curr . next . data ) ) : NEW_LINE DEDENT",
        "explain": "Now traverse the list . Curr is always the item * before * the one we are checking , so that we can use it to re - link ."
    },
    {
        "py": "if ( curr == latestVowel ) : NEW_LINE",
        "explain": "The next discovered item is a vowel"
    },
    {
        "py": "latestVowel = curr = curr . next NEW_LINE else : NEW_LINE",
        "explain": "If it comes directly after the previous vowel , we don 't need to  move items around, just mark the  new latestVowel and advance curr."
    },
    {
        "py": "temp = latestVowel . next NEW_LINE",
        "explain": "But if it comes after an intervening chain of consonants , we need to chain the newly discovered vowel right after the old vowel . Curr is not changed as after the re - linking it will have a new next , that has not been checked yet , and we always keep curr at one before the next to check ."
    },
    {
        "py": "latestVowel . next = curr . next NEW_LINE",
        "explain": "Chain in new vowel"
    },
    {
        "py": "latestVowel = latestVowel . next NEW_LINE",
        "explain": "Advance latestVowel"
    },
    {
        "py": "curr . next = curr . next . next NEW_LINE",
        "explain": "Remove found vowel from previous place"
    },
    {
        "py": "latestVowel . next = temp NEW_LINE else : NEW_LINE",
        "explain": "Re - link chain of consonants after latestVowel"
    },
    {
        "py": "curr = curr . next NEW_LINE return newHead NEW_LINE",
        "explain": "No vowel in the next element , advance curr ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = Node ( ' a ' ) NEW_LINE head . next = Node ( ' b ' ) NEW_LINE head . next . next = Node ( ' c ' ) NEW_LINE head . next . next . next = Node ( ' e ' ) NEW_LINE head . next . next . next . next = Node ( ' d ' ) NEW_LINE head . next . next . next . next . next = Node ( ' o ' ) NEW_LINE head . next . next . next . next . next . next = Node ( ' x ' ) NEW_LINE head . next . next . next . next . next . next . next = Node ( ' i ' ) NEW_LINE print ( \" Linked \u2581 list \u2581 before \u2581 : \" ) NEW_LINE printlist ( head ) NEW_LINE head = arrange ( head ) NEW_LINE print ( \" Linked \u2581 list \u2581 after \u2581 : \" ) NEW_LINE printlist ( head ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = self . left = None NEW_LINE DEDENT DEDENT def KthLargestUsingMorrisTraversal ( root , k ) : NEW_LINE INDENT curr = root NEW_LINE Klargest = None NEW_LINE DEDENT",
        "explain": "helper function to create a new Node"
    },
    {
        "py": "count = 0 NEW_LINE while ( curr != None ) : NEW_LINE",
        "explain": "count variable to keep count of visited Nodes"
    },
    {
        "py": "if ( curr . right == None ) : NEW_LINE",
        "explain": "if right child is None"
    },
    {
        "py": "count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT Klargest = curr NEW_LINE DEDENT",
        "explain": "first increment count and check if count = k"
    },
    {
        "py": "curr = curr . left NEW_LINE else : NEW_LINE",
        "explain": "otherwise move to the left child"
    },
    {
        "py": "succ = curr . right NEW_LINE while ( succ . left != None and succ . left != curr ) : NEW_LINE INDENT succ = succ . left NEW_LINE DEDENT if ( succ . left == None ) : NEW_LINE",
        "explain": "find inorder successor of current Node"
    },
    {
        "py": "succ . left = curr NEW_LINE",
        "explain": "set left child of successor to the current Node"
    },
    {
        "py": "curr = curr . right NEW_LINE",
        "explain": "move current to its right"
    },
    {
        "py": "else : NEW_LINE INDENT succ . left = None NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT Klargest = curr NEW_LINE DEDENT DEDENT",
        "explain": "restoring the tree back to original binary search tree removing threaded links"
    },
    {
        "py": "curr = curr . left NEW_LINE return Klargest NEW_LINE",
        "explain": "move current to its left child"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "root = newNode ( 4 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 7 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 10 ) NEW_LINE print ( \" Finding \u2581 K - th \u2581 largest \u2581 Node \u2581 in \u2581 BST \u2581 : \u2581 \" , KthLargestUsingMorrisTraversal ( root , 2 ) . data ) NEW_LINE",
        "explain": "Constructed binary tree is 4 / \\ 2 7 / \\ / \\ 1 3 6 10"
    },
    {
        "py": "MAX_SIZE = 10 NEW_LINE",
        "explain": "Python implementation to sort the rows of matrix in ascending order followed by sorting the columns in descending order"
    },
    {
        "py": "def sortByRow ( mat , n , ascending ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ascending ) : NEW_LINE INDENT mat [ i ] . sort ( ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] . sort ( reverse = True ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "function to sort each row of the matrix according to the order specified by ascending ."
    },
    {
        "py": "def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT DEDENT",
        "explain": "function to find transpose of the matrix"
    },
    {
        "py": "temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = temp NEW_LINE",
        "explain": "swapping element at index ( i , j ) by element at index ( j , i )"
    },
    {
        "py": "def sortMatRowAndColWise ( mat , n ) : NEW_LINE",
        "explain": "function to sort the matrix row - wise and column - wise"
    },
    {
        "py": "sortByRow ( mat , n , True ) NEW_LINE",
        "explain": "sort rows of mat [ ] [ ]"
    },
    {
        "py": "transpose ( mat , n ) NEW_LINE",
        "explain": "get transpose of mat [ ] [ ]"
    },
    {
        "py": "sortByRow ( mat , n , False ) NEW_LINE",
        "explain": "again sort rows of mat [ ] [ ] in descending order ."
    },
    {
        "py": "transpose ( mat , n ) NEW_LINE",
        "explain": "again get transpose of mat [ ] [ ]"
    },
    {
        "py": "def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT",
        "explain": "function to print the matrix"
    },
    {
        "py": "n = 3 NEW_LINE mat = [ [ 3 , 2 , 1 ] , [ 9 , 8 , 7 ] , [ 6 , 5 , 4 ] ] NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix \u2581 After \u2581 Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX_SIZE = 10 NEW_LINE",
        "explain": "Python 3 implementation to sort the matrix row - wise and column - wise"
    },
    {
        "py": "def sortByRow ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "function to sort each row of the matrix"
    },
    {
        "py": "for j in range ( n - 1 ) : NEW_LINE INDENT if mat [ i ] [ j ] > mat [ i ] [ j + 1 ] : NEW_LINE INDENT temp = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ i ] [ j + 1 ] NEW_LINE mat [ i ] [ j + 1 ] = temp NEW_LINE DEDENT DEDENT",
        "explain": "sorting row number 'i"
    },
    {
        "py": "def transpose ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE DEDENT DEDENT",
        "explain": "function to find transpose of the matrix"
    },
    {
        "py": "t = mat [ i ] [ j ] NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = t NEW_LINE",
        "explain": "swapping element at index ( i , j ) by element at index ( j , i )"
    },
    {
        "py": "def sortMatRowAndColWise ( mat , n ) : NEW_LINE",
        "explain": "function to sort the matrix row - wise and column - wise"
    },
    {
        "py": "sortByRow ( mat , n ) NEW_LINE",
        "explain": "sort rows of mat [ ] [ ]"
    },
    {
        "py": "transpose ( mat , n ) NEW_LINE",
        "explain": "get transpose of mat [ ] [ ]"
    },
    {
        "py": "sortByRow ( mat , n ) NEW_LINE",
        "explain": "again sort rows of mat [ ] [ ]"
    },
    {
        "py": "transpose ( mat , n ) NEW_LINE",
        "explain": "again get transpose of mat [ ] [ ]"
    },
    {
        "py": "def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str ( mat [ i ] [ j ] ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT",
        "explain": "function to print the matrix"
    },
    {
        "py": "mat = [ [ 4 , 1 , 3 ] , [ 9 , 6 , 8 ] , [ 5 , 2 , 7 ] ] NEW_LINE n = 3 NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMatRowAndColWise ( mat , n ) NEW_LINE print ( \" Matrix After Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def DoublyEven ( n ) : NEW_LINE",
        "explain": "Function for calculating Magic square"
    },
    {
        "py": "arr = [ [ ( n * y ) + x + 1 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE",
        "explain": "2 - D matrix with all entries as 0"
    },
    {
        "py": "for i in range ( 0 , n / 4 ) : NEW_LINE INDENT for j in range ( 0 , n / 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Change value of array elements at fix location as per the rule ( n * n + 1 ) - arr [ i ] [ [ j ] Corners of order ( n / 4 ) * ( n / 4 ) Top left corner"
    },
    {
        "py": "for i in range ( 0 , n / 4 ) : NEW_LINE INDENT for j in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Top right corner"
    },
    {
        "py": "for i in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT for j in range ( 0 , n / 4 ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Bottom Left corner"
    },
    {
        "py": "for i in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT for j in range ( 3 * ( n / 4 ) , n ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Bottom Right corner"
    },
    {
        "py": "for i in range ( n / 4 , 3 * ( n / 4 ) ) : NEW_LINE INDENT for j in range ( n / 4 , 3 * ( n / 4 ) ) : NEW_LINE INDENT arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Centre of matrix , order ( n / 2 ) * ( n / 2 )"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ' % 2d \u2581 ' % ( arr [ i ] [ j ] ) , NEW_LINE DEDENT print NEW_LINE DEDENT",
        "explain": "Printing the square"
    },
    {
        "py": "n = 8 NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "DoublyEven ( n ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "cola = 2 NEW_LINE rowa = 3 NEW_LINE colb = 3 NEW_LINE rowb = 2 NEW_LINE",
        "explain": "rowa and cola are no of rows and columns of matrix A rowb and colb are no of rows and columns of matrix B"
    },
    {
        "py": "def Kroneckerproduct ( A , B ) : NEW_LINE INDENT C = [ [ 0 for j in range ( cola * colb ) ] for i in range ( rowa * rowb ) ] NEW_LINE DEDENT",
        "explain": "Function to computes the Kronecker Product of two matrices"
    },
    {
        "py": "for i in range ( 0 , rowa ) : NEW_LINE",
        "explain": "i loops till rowa"
    },
    {
        "py": "for k in range ( 0 , rowb ) : NEW_LINE",
        "explain": "k loops till rowb"
    },
    {
        "py": "for j in range ( 0 , cola ) : NEW_LINE",
        "explain": "j loops till cola"
    },
    {
        "py": "for l in range ( 0 , colb ) : NEW_LINE",
        "explain": "l loops till colb"
    },
    {
        "py": "C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] NEW_LINE print ( C [ i + l + 1 ] [ j + k + 1 ] , end = ' \u2581 ' ) NEW_LINE print ( \" \" ) NEW_LINE",
        "explain": "Each element of matrix A is multiplied by whole Matrix B resp and stored as Matrix C"
    },
    {
        "py": "A = [ [ 0 for j in range ( 2 ) ] for i in range ( 3 ) ] NEW_LINE B = [ [ 0 for j in range ( 3 ) ] for i in range ( 2 ) ] NEW_LINE A [ 0 ] [ 0 ] = 1 NEW_LINE A [ 0 ] [ 1 ] = 2 NEW_LINE A [ 1 ] [ 0 ] = 3 NEW_LINE A [ 1 ] [ 1 ] = 4 NEW_LINE A [ 2 ] [ 0 ] = 1 NEW_LINE A [ 2 ] [ 1 ] = 0 NEW_LINE B [ 0 ] [ 0 ] = 0 NEW_LINE B [ 0 ] [ 1 ] = 5 NEW_LINE B [ 0 ] [ 2 ] = 2 NEW_LINE B [ 1 ] [ 0 ] = 6 NEW_LINE B [ 1 ] [ 1 ] = 7 NEW_LINE B [ 1 ] [ 2 ] = 3 NEW_LINE Kroneckerproduct ( A , B ) NEW_LINE",
        "explain": "Driver code ."
    },
    {
        "py": "def islowertriangular ( M ) : NEW_LINE INDENT for i in range ( 0 , len ( M ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( M ) ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "Function to check matrix is in lower triangular"
    },
    {
        "py": "M = [ [ 1 , 0 , 0 , 0 ] , [ 1 , 4 , 0 , 0 ] , [ 4 , 6 , 2 , 0 ] , [ 0 , 4 , 7 , 6 ] ] NEW_LINE",
        "explain": "Driver function ."
    },
    {
        "py": "if islowertriangular ( M ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def isuppertriangular ( M ) : NEW_LINE INDENT for i in range ( 1 , len ( M ) ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( M [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "Function to check matrix is in upper triangular"
    },
    {
        "py": "M = [ [ 1 , 3 , 5 , 3 ] , [ 0 , 4 , 6 , 2 ] , [ 0 , 0 , 2 , 5 ] , [ 0 , 0 , 0 , 6 ] ] NEW_LINE if isuppertriangular ( M ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver function ."
    },
    {
        "py": "m = 3 NEW_LINE",
        "explain": "no of columns"
    },
    {
        "py": "n = 2 NEW_LINE",
        "explain": "no of rows"
    },
    {
        "py": "def countSets ( a ) : NEW_LINE",
        "explain": "function to calculate the number of non empty sets of cell"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "stores the final answer"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( m ) : NEW_LINE INDENT if a [ i ] [ j ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT",
        "explain": "traverses row - wise"
    },
    {
        "py": "for i in range ( m ) : NEW_LINE INDENT u = 0 NEW_LINE v = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if a [ j ] [ i ] : NEW_LINE INDENT u += 1 NEW_LINE DEDENT else : NEW_LINE INDENT v += 1 NEW_LINE DEDENT DEDENT res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 NEW_LINE DEDENT",
        "explain": "traverses column wise"
    },
    {
        "py": "return res - ( n * m ) NEW_LINE",
        "explain": "at the end subtract n * m as no of single sets have been added twice ."
    },
    {
        "py": "a = [ [ 1 , 0 , 1 ] , [ 0 , 1 , 0 ] ] NEW_LINE print ( countSets ( a ) ) NEW_LINE",
        "explain": "Driver program to test the above function ."
    },
    {
        "py": "def transpose ( mat , tr , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT tr [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Fills transpose of mat [ N ] [ N ] in tr [ N ] [ N ]"
    },
    {
        "py": "def isSymmetric ( mat , N ) : NEW_LINE INDENT tr = [ [ 0 for j in range ( len ( mat [ 0 ] ) ) ] for i in range ( len ( mat ) ) ] NEW_LINE transpose ( mat , tr , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "Returns true if mat [ N ] [ N ] is symmetric , else false"
    },
    {
        "py": "mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isSymmetric ( mat , N ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "Returns true if mat [ N ] [ N ] is symmetric , else false"
    },
    {
        "py": "mat = [ [ 1 , 3 , 5 ] , [ 3 , 2 , 4 ] , [ 5 , 4 , 1 ] ] NEW_LINE if ( isSymmetric ( mat , 3 ) ) : NEW_LINE INDENT print \" Yes \" NEW_LINE DEDENT else : NEW_LINE INDENT print \" No \" NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find trace and normal of given matrix"
    },
    {
        "py": "MAX = 100 ; NEW_LINE",
        "explain": "Size of given matrix"
    },
    {
        "py": "def findNormal ( mat , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return math . floor ( math . sqrt ( sum ) ) ; NEW_LINE DEDENT",
        "explain": "Returns Normal of a matrix of size n x n"
    },
    {
        "py": "def findTrace ( mat , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += mat [ i ] [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT",
        "explain": "Returns trace of a matrix of size n x n"
    },
    {
        "py": "mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] ; NEW_LINE print ( \" Trace \u2581 of \u2581 Matrix \u2581 = \" , findTrace ( mat , 5 ) ) ; NEW_LINE print ( \" Normal \u2581 of \u2581 Matrix \u2581 = \" , findNormal ( mat , 5 ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def maxDet ( n ) : NEW_LINE INDENT return 2 * n * n * n NEW_LINE DEDENT",
        "explain": "Function for maximum determinant"
    },
    {
        "py": "def resMatrix ( n ) : NEW_LINE INDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to print resulatant matrix"
    },
    {
        "py": "if i == 0 and j == 2 : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif i == 1 and j == 0 : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif i == 2 and j == 1 : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "three position where 0 appears"
    },
    {
        "py": "else : NEW_LINE INDENT print ( n , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" ) NEW_LINE",
        "explain": "position where n appears"
    },
    {
        "py": "n = 15 NEW_LINE print ( \" Maximum \u2581 Detrminat = \" , maxDet ( n ) ) NEW_LINE print ( \" Resultant \u2581 Matrix : \" ) NEW_LINE resMatrix ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countNegative ( M , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Python implementation of Naive method to count of negative numbers in M [ n ] [ m ]"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE DEDENT DEDENT",
        "explain": "Follow the path shown using arrows above"
    },
    {
        "py": "break NEW_LINE return count NEW_LINE",
        "explain": "no more negative numbers in this row"
    },
    {
        "py": "M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE print ( countNegative ( M , 3 , 4 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countNegative ( M , n , m ) : NEW_LINE",
        "explain": "Function to count negative number"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "initialize result"
    },
    {
        "py": "i = 0 NEW_LINE j = m - 1 NEW_LINE",
        "explain": "Start with top right corner"
    },
    {
        "py": "while j >= 0 and i < n : NEW_LINE INDENT if M [ i ] [ j ] < 0 : NEW_LINE DEDENT",
        "explain": "Follow the path shown using arrows above"
    },
    {
        "py": "count += ( j + 1 ) NEW_LINE",
        "explain": "j is the index of the last negative number in this row . So there must be ( j + 1 )"
    },
    {
        "py": "i += 1 NEW_LINE else : NEW_LINE",
        "explain": "negative numbers in this row ."
    },
    {
        "py": "j -= 1 NEW_LINE return count NEW_LINE",
        "explain": "move to the left and see if we can find a negative number there"
    },
    {
        "py": "M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE print ( countNegative ( M , 3 , 4 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getLastNegativeIndex ( array , start , end , n ) : NEW_LINE",
        "explain": "Recursive binary search to get last negative value in a row between a start and an end"
    },
    {
        "py": "if ( start == end ) : NEW_LINE INDENT return start NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "mid = start + ( end - start ) // 2 NEW_LINE",
        "explain": "Get the mid for binary search"
    },
    {
        "py": "if ( array [ mid ] < 0 ) : NEW_LINE",
        "explain": "If current element is negative"
    },
    {
        "py": "if ( mid + 1 < n and array [ mid + 1 ] >= 0 ) : NEW_LINE INDENT return mid NEW_LINE DEDENT",
        "explain": "If it is the rightmost negative element in the current row"
    },
    {
        "py": "return getLastNegativeIndex ( array , mid + 1 , end , n ) NEW_LINE else : NEW_LINE",
        "explain": "Check in the right half of the array"
    },
    {
        "py": "return getLastNegativeIndex ( array , start , mid - 1 , n ) NEW_LINE",
        "explain": "Check in the left half of the array"
    },
    {
        "py": "def countNegative ( M , n , m ) : NEW_LINE",
        "explain": "Function to return the count of negative numbers in the given matrix"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "nextEnd = m - 1 NEW_LINE",
        "explain": "To store the index of the rightmost negative element in the row under consideration"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate over all rows of the matrix"
    },
    {
        "py": "if ( M [ i ] [ 0 ] >= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If the first element of the current row is positive then there will be no negatives in the matrix below or after it"
    },
    {
        "py": "nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd , 4 ) NEW_LINE count += nextEnd + 1 NEW_LINE return count NEW_LINE",
        "explain": "Run binary search only until the index of last negative Integer in the above row"
    },
    {
        "py": "M = [ [ - 3 , - 2 , - 1 , 1 ] , [ - 2 , 2 , 3 , 4 ] , [ 4 , 5 , 7 , 8 ] ] NEW_LINE r = 3 NEW_LINE c = 4 NEW_LINE print ( countNegative ( M , r , c ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "N = 5 NEW_LINE",
        "explain": "A Naive method to find maximum value of mat [ d ] [ e ] - mat [ a ] [ b ] such that d > a and e > b"
    },
    {
        "py": "def findMaxValue ( mat ) : NEW_LINE",
        "explain": "The function returns maximum value A ( d , e ) - A ( a , b ) over all choices of indexes such that both d > a and e > b ."
    },
    {
        "py": "maxValue = 0 NEW_LINE",
        "explain": "stores maximum value"
    },
    {
        "py": "for a in range ( N - 1 ) : NEW_LINE INDENT for b in range ( N - 1 ) : NEW_LINE INDENT for d in range ( a + 1 , N ) : NEW_LINE INDENT for e in range ( b + 1 , N ) : NEW_LINE INDENT if maxValue < int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) : NEW_LINE INDENT maxValue = int ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return maxValue ; NEW_LINE",
        "explain": "Consider all possible pairs mat [ a ] [ b ] and mat [ d ] [ e ]"
    },
    {
        "py": "mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] ; NEW_LINE print ( \" Maximum \u2581 Value \u2581 is \u2581 \" + str ( findMaxValue ( mat ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE N = 5 NEW_LINE",
        "explain": "An efficient method to find maximum value of mat [ d ] - ma [ a ] [ b ] such that c > a and d > b"
    },
    {
        "py": "def findMaxValue ( mat ) : NEW_LINE",
        "explain": "The function returns maximum value A ( c , d ) - A ( a , b ) over all choices of indexes such that both c > a and d > b ."
    },
    {
        "py": "maxValue = - sys . maxsize - 1 NEW_LINE",
        "explain": "stores maximum value"
    },
    {
        "py": "maxArr = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE",
        "explain": "maxArr [ i ] [ j ] stores max of elements in matrix from ( i , j ) to ( N - 1 , N - 1 )"
    },
    {
        "py": "maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] NEW_LINE",
        "explain": "last element of maxArr will be same 's as of the input matrix"
    },
    {
        "py": "maxv = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ N - 1 ] [ j ] > maxv ) : NEW_LINE INDENT maxv = mat [ N - 1 ] [ j ] NEW_LINE DEDENT maxArr [ N - 1 ] [ j ] = maxv NEW_LINE DEDENT",
        "explain": "preprocess last row Initialize max"
    },
    {
        "py": "maxv = mat [ N - 1 ] [ N - 1 ] ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] > maxv ) : NEW_LINE INDENT maxv = mat [ i ] [ N - 1 ] NEW_LINE DEDENT maxArr [ i ] [ N - 1 ] = maxv NEW_LINE DEDENT",
        "explain": "preprocess last column Initialize max"
    },
    {
        "py": "for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( N - 2 , - 1 , - 1 ) : NEW_LINE DEDENT",
        "explain": "preprocess rest of the matrix from bottom"
    },
    {
        "py": "if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) : NEW_LINE INDENT maxValue = ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ) NEW_LINE DEDENT",
        "explain": "Update maxValue"
    },
    {
        "py": "maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) NEW_LINE return maxValue NEW_LINE",
        "explain": "set maxArr ( i , j )"
    },
    {
        "py": "mat = [ [ 1 , 2 , - 1 , - 4 , - 20 ] , [ - 8 , - 3 , 4 , 2 , 1 ] , [ 3 , 8 , 6 , 1 , 3 ] , [ - 4 , - 1 , 1 , 7 , - 6 ] , [ 0 , - 4 , 10 , - 5 , 1 ] ] NEW_LINE print ( \" Maximum \u2581 Value \u2581 is \" , findMaxValue ( mat ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE INF = sys . maxsize NEW_LINE N = 4 NEW_LINE",
        "explain": "Python 3 program to Print all elements in sorted order from row and column wise sorted matrix"
    },
    {
        "py": "def youngify ( mat , i , j ) : NEW_LINE",
        "explain": "A utility function to youngify a Young Tableau . This is different from standard youngify . It assumes that the value at mat [ 0 ] [ 0 ] is infinite ."
    },
    {
        "py": "downVal = mat [ i + 1 ] [ j ] if ( i + 1 < N ) else INF NEW_LINE rightVal = mat [ i ] [ j + 1 ] if ( j + 1 < N ) else INF NEW_LINE",
        "explain": "Find the values at down and right sides of mat [ i ] [ j ]"
    },
    {
        "py": "if ( downVal == INF and rightVal == INF ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "If mat [ i ] [ j ] is the down right corner element , return"
    },
    {
        "py": "if ( downVal < rightVal ) : NEW_LINE INDENT mat [ i ] [ j ] = downVal NEW_LINE mat [ i + 1 ] [ j ] = INF NEW_LINE youngify ( mat , i + 1 , j ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = rightVal NEW_LINE mat [ i ] [ j + 1 ] = INF NEW_LINE youngify ( mat , i , j + 1 ) NEW_LINE DEDENT",
        "explain": "Move the smaller of two values ( downVal and rightVal ) to mat [ i ] [ j ] and recur for smaller value"
    },
    {
        "py": "def extractMin ( mat ) : NEW_LINE INDENT ret = mat [ 0 ] [ 0 ] NEW_LINE mat [ 0 ] [ 0 ] = INF NEW_LINE youngify ( mat , 0 , 0 ) NEW_LINE return ret NEW_LINE DEDENT",
        "explain": "A utility function to extract minimum element from Young tableau"
    },
    {
        "py": "def printSorted ( mat ) : NEW_LINE INDENT print ( \" Elements \u2581 of \u2581 matrix \u2581 in \u2581 sorted \u2581 order \u2581 n \" ) NEW_LINE i = 0 NEW_LINE while i < N * N : NEW_LINE INDENT print ( extractMin ( mat ) , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT",
        "explain": "This function uses extractMin ( ) to print elements in sorted order"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] NEW_LINE printSorted ( mat ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "n = 5 NEW_LINE",
        "explain": "size k x k Size of given matrix"
    },
    {
        "py": "def printSumSimple ( mat , k ) : NEW_LINE",
        "explain": "A simple function to find sum of all sub - squares of size k x k in a given square matrix of size n x n"
    },
    {
        "py": "if ( k > n ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "k must be smaller than or equal to n"
    },
    {
        "py": "for i in range ( n - k + 1 ) : NEW_LINE",
        "explain": "row number of first cell in current sub - square of size k x k"
    },
    {
        "py": "for j in range ( n - k + 1 ) : NEW_LINE",
        "explain": "column of first cell in current sub - square of size k x k"
    },
    {
        "py": "sum = 0 NEW_LINE for p in range ( i , k + i ) : NEW_LINE INDENT for q in range ( j , k + j ) : NEW_LINE INDENT sum += mat [ p ] [ q ] NEW_LINE DEDENT DEDENT print ( sum , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Calculate and print sum of current sub - square"
    },
    {
        "py": "print ( ) NEW_LINE",
        "explain": "Line separator for sub - squares starting with next row"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumSimple ( mat , k ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "n = 5 NEW_LINE",
        "explain": "Size of given matrix"
    },
    {
        "py": "def printSumTricky ( mat , k ) : NEW_LINE INDENT global n NEW_LINE DEDENT",
        "explain": "A O ( n ^ 2 ) function to find sum of all sub - squares of size k x k in a given square matrix of size n x n"
    },
    {
        "py": "if k > n : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "k must be smaller than or equal to n"
    },
    {
        "py": "stripSum = [ [ None ] * n for i in range ( n ) ] NEW_LINE",
        "explain": "1 : PREPROCESSING To store sums of all strips of size k x 1"
    },
    {
        "py": "for j in range ( n ) : NEW_LINE",
        "explain": "Go column by column"
    },
    {
        "py": "Sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT Sum += mat [ i ] [ j ] NEW_LINE DEDENT stripSum [ 0 ] [ j ] = Sum NEW_LINE",
        "explain": "Calculate sum of first k x 1 rectangle in this column"
    },
    {
        "py": "for i in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) NEW_LINE stripSum [ i ] [ j ] = Sum NEW_LINE DEDENT",
        "explain": "Calculate sum of remaining rectangles"
    },
    {
        "py": "for i in range ( n - k + 1 ) : NEW_LINE",
        "explain": "2 : CALCULATE SUM of Sub - Squares using stripSum [ ] [ ]"
    },
    {
        "py": "Sum = 0 NEW_LINE for j in range ( k ) : NEW_LINE INDENT Sum += stripSum [ i ] [ j ] NEW_LINE DEDENT print ( Sum , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Calculate and prsum of first subsquare in this row"
    },
    {
        "py": "for j in range ( 1 , n - k + 1 ) : NEW_LINE INDENT Sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) NEW_LINE print ( Sum , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Calculate sum of remaining squares in current row by removing the leftmost strip of previous sub - square and adding a new strip"
    },
    {
        "py": "mat = [ [ 1 , 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 , 4 ] , [ 5 , 5 , 5 , 5 , 5 ] ] NEW_LINE k = 3 NEW_LINE printSumTricky ( mat , k ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "M = 3 NEW_LINE N = 4 NEW_LINE",
        "explain": "Python3 Program to find transpose of a matrix"
    },
    {
        "py": "def transpose ( A , B ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT B [ i ] [ j ] = A [ j ] [ i ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "This function stores transpose of A [ ] [ ] in B [ ] [ ]"
    },
    {
        "py": "A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] ] NEW_LINE B = [ [ 0 for x in range ( M ) ] for y in range ( N ) ] NEW_LINE transpose ( A , B ) NEW_LINE print ( \" Result \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( B [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "driver code"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Python3 Program to find transpose of a matrix"
    },
    {
        "py": "def transpose ( A ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT A [ i ] [ j ] , A [ j ] [ i ] = A [ j ] [ i ] , A [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Finds transpose of A [ ] [ ] in - place"
    },
    {
        "py": "A = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE transpose ( A ) NEW_LINE print ( \" Modified \u2581 matrix \u2581 is \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( A [ i ] [ j ] , \" \u2581 \" , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "driver code"
    },
    {
        "py": "R = 3 NEW_LINE C = 3 NEW_LINE",
        "explain": "A Naive Recursive Python program to count paths with exactly ' k ' coins"
    },
    {
        "py": "def pathCountRec ( mat , m , n , k ) : NEW_LINE",
        "explain": "Recursive function to count paths with sum k from ( 0 , 0 ) to ( m , n )"
    },
    {
        "py": "if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "return ( pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE",
        "explain": "( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )"
    },
    {
        "py": "def pathCount ( mat , k ) : NEW_LINE INDENT return pathCountRec ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT",
        "explain": "A wrapper over pathCountRec ( )"
    },
    {
        "py": "k = 12 NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] NEW_LINE print ( pathCount ( mat , k ) ) NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "R = 3 NEW_LINE C = 3 NEW_LINE MAX_K = 1000 NEW_LINE def pathCountDPRecDP ( mat , m , n , k ) : NEW_LINE",
        "explain": "A Dynamic Programming based Python3 program to count paths with exactly ' k ' coins"
    },
    {
        "py": "if m < 0 or n < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif m == 0 and n == 0 : NEW_LINE INDENT return k == mat [ m ] [ n ] NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "if ( dp [ m ] [ n ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ m ] [ n ] [ k ] NEW_LINE DEDENT",
        "explain": "If this subproblem is already solved"
    },
    {
        "py": "dp [ m ] [ n ] [ k ] = ( pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ) NEW_LINE return dp [ m ] [ n ] [ k ] NEW_LINE",
        "explain": "( m , n ) can be reached either through ( m - 1 , n ) or through ( m , n - 1 )"
    },
    {
        "py": "def pathCountDP ( mat , k ) : NEW_LINE INDENT return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) NEW_LINE DEDENT",
        "explain": "A wrapper over pathCountDPRecDP ( )"
    },
    {
        "py": "k = 12 NEW_LINE dp = [ [ [ - 1 for col in range ( MAX_K ) ] for col in range ( C ) ] for row in range ( R ) ] NEW_LINE mat = [ [ 1 , 2 , 3 ] , [ 4 , 6 , 5 ] , [ 3 , 2 , 1 ] ] NEW_LINE print ( pathCountDP ( mat , k ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "SIZE = 10 NEW_LINE",
        "explain": "Python3 implementation to sort the given matrix"
    },
    {
        "py": "def sortMat ( mat , n ) : NEW_LINE",
        "explain": "Function to sort the given matrix"
    },
    {
        "py": "temp = [ 0 ] * ( n * n ) NEW_LINE k = 0 NEW_LINE",
        "explain": "Temporary matrix of size n ^ 2"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT temp [ k ] = mat [ i ] [ j ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Copy the elements of matrix one by one into temp [ ]"
    },
    {
        "py": "temp . sort ( ) NEW_LINE",
        "explain": "sort temp [ ]"
    },
    {
        "py": "k = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT mat [ i ] [ j ] = temp [ k ] NEW_LINE k += 1 NEW_LINE DEDENT DEDENT",
        "explain": "copy the elements of temp [ ] one by one in mat [ ] [ ]"
    },
    {
        "py": "def printMat ( mat , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the given matrix"
    },
    {
        "py": "mat = [ [ 5 , 4 , 7 ] , [ 1 , 3 , 8 ] , [ 2 , 9 , 6 ] ] NEW_LINE n = 3 NEW_LINE print ( \" Original \u2581 Matrix : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE sortMat ( mat , n ) NEW_LINE print ( \" Matrix After Sorting : \" ) NEW_LINE printMat ( mat , n ) NEW_LINE",
        "explain": "Driver program to test above"
    },
    {
        "py": "def bubbleSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT swapped = False NEW_LINE for j in range ( 0 , n - i - 1 ) : NEW_LINE INDENT if arr [ j ] > arr [ j + 1 ] : NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "An optimized version of Bubble Sort"
    },
    {
        "py": "arr [ j ] , arr [ j + 1 ] = arr [ j + 1 ] , arr [ j ] NEW_LINE swapped = True NEW_LINE",
        "explain": "traverse the array from 0 to n - i - 1. Swap if the element found is greater than the next element"
    },
    {
        "py": "if swapped == False : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "IF no two elements were swapped by inner loop , then break"
    },
    {
        "py": "arr = [ 64 , 34 , 25 , 12 , 22 , 11 , 90 ] NEW_LINE bubbleSort ( arr ) NEW_LINE print ( \" Sorted \u2581 array \u2581 : \" ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( \" % d \" % arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Driver code to test above"
    },
    {
        "py": "def findCrossOver ( arr , low , high , x ) : NEW_LINE",
        "explain": "Function to find the cross over point ( the point before which elements aresmaller than or equal to x and afterwhich greater than x )"
    },
    {
        "py": "if ( arr [ high ] <= x ) : NEW_LINE INDENT return high NEW_LINE DEDENT",
        "explain": "Base cases x is greater than all"
    },
    {
        "py": "if ( arr [ low ] > x ) : NEW_LINE INDENT return low NEW_LINE DEDENT",
        "explain": "x is smaller than all"
    },
    {
        "py": "mid = ( low + high ) // 2 NEW_LINE",
        "explain": "Find the middle point"
    },
    {
        "py": "if ( arr [ mid ] <= x and arr [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT",
        "explain": "If x is same as middle element , then return mid"
    },
    {
        "py": "if ( arr [ mid ] < x ) : NEW_LINE INDENT return findCrossOver ( arr , mid + 1 , high , x ) NEW_LINE DEDENT return findCrossOver ( arr , low , mid - 1 , x ) NEW_LINE",
        "explain": "If x is greater than arr [ mid ] , then either arr [ mid + 1 ] is ceiling of x or ceiling lies in arr [ mid + 1. . . high ]"
    },
    {
        "py": "def printKclosest ( arr , x , k , n ) : NEW_LINE",
        "explain": "This function prints k closest elements to x in arr [ ] . n is the number of elements in arr [ ]"
    },
    {
        "py": "l = findCrossOver ( arr , 0 , n - 1 , x ) NEW_LINE",
        "explain": "Find the crossover point"
    },
    {
        "py": "r = l + 1 NEW_LINE",
        "explain": "Right index to search"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "To keep track of count of elements already printed"
    },
    {
        "py": "if ( arr [ l ] == x ) : NEW_LINE INDENT l -= 1 NEW_LINE DEDENT",
        "explain": "If x is present in arr [ ] , then reduce left index . Assumption : all elements in arr [ ] are distinct"
    },
    {
        "py": "while ( l >= 0 and r < n and count < k ) : NEW_LINE INDENT if ( x - arr [ l ] < arr [ r ] - x ) : NEW_LINE INDENT print ( arr [ l ] , end = \" \u2581 \" ) NEW_LINE l -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ r ] , end = \" \u2581 \" ) NEW_LINE r += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT",
        "explain": "Compare elements on left and right of crossover point to find the k closest elements"
    },
    {
        "py": "while ( count < k and l >= 0 ) : NEW_LINE INDENT print ( arr [ l ] , end = \" \u2581 \" ) NEW_LINE l -= 1 NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "If there are no more elements on right side , then print left elements"
    },
    {
        "py": "while ( count < k and r < n ) : NEW_LINE INDENT print ( arr [ r ] , end = \" \u2581 \" ) NEW_LINE r += 1 NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "If there are no more elements on left side , then print right elements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 ] NEW_LINE n = len ( arr ) NEW_LINE x = 35 NEW_LINE k = 4 NEW_LINE printKclosest ( arr , x , 4 , n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Pyhton implementation of above algorithm"
    },
    {
        "py": "def push ( head_ref , new_data ) : NEW_LINE",
        "explain": "A utility function to insert a node at the beginning of linked list"
    },
    {
        "py": "new_node = Node ( 0 ) NEW_LINE new_node . data = new_data NEW_LINE",
        "explain": "allocate node"
    },
    {
        "py": "new_node . next = ( head_ref ) NEW_LINE",
        "explain": "link the old list off the new node"
    },
    {
        "py": "( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE",
        "explain": "move the head to point to the new node"
    },
    {
        "py": "def insertionSort ( head_ref ) : NEW_LINE",
        "explain": "function to sort a singly linked list using insertion sort"
    },
    {
        "py": "sorted = None NEW_LINE",
        "explain": "Initialize sorted linked list"
    },
    {
        "py": "current = head_ref NEW_LINE while ( current != None ) : NEW_LINE",
        "explain": "Traverse the given linked list and insert every node to sorted"
    },
    {
        "py": "next = current . next NEW_LINE",
        "explain": "Store next for next iteration"
    },
    {
        "py": "sorted = sortedInsert ( sorted , current ) NEW_LINE",
        "explain": "insert current in sorted linked list"
    },
    {
        "py": "current = next NEW_LINE",
        "explain": "Update current"
    },
    {
        "py": "head_ref = sorted NEW_LINE return head_ref NEW_LINE",
        "explain": "Update head_ref to point to sorted linked list"
    },
    {
        "py": "def sortedInsert ( head_ref , new_node ) : NEW_LINE INDENT current = None NEW_LINE DEDENT",
        "explain": "function to insert a new_node in a list . Note that this function expects a pointer to head_ref as this can modify the head of the input linked list ( similar to push ( ) )"
    },
    {
        "py": "if ( head_ref == None or ( head_ref ) . data >= new_node . data ) : NEW_LINE INDENT new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE DEDENT else : NEW_LINE INDENT current = head_ref NEW_LINE DEDENT",
        "explain": "Special case for the head end"
    },
    {
        "py": "while ( current . next != None and current . next . data < new_node . data ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT new_node . next = current . next NEW_LINE current . next = new_node NEW_LINE return head_ref NEW_LINE",
        "explain": "Locate the node before the point of insertion"
    },
    {
        "py": "def printList ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT",
        "explain": "BELOW FUNCTIONS ARE JUST UTILITY TO TEST sortedInsert Function to print linked list"
    },
    {
        "py": "a = None NEW_LINE a = push ( a , 5 ) NEW_LINE a = push ( a , 20 ) NEW_LINE a = push ( a , 4 ) NEW_LINE a = push ( a , 3 ) NEW_LINE a = push ( a , 30 ) NEW_LINE print ( \" Linked \u2581 List \u2581 before \u2581 sorting \u2581 \" ) NEW_LINE printList ( a ) NEW_LINE a = insertionSort ( a ) NEW_LINE print ( \" Linked List after sorting   \" ) NEW_LINE printList ( a ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "def count ( S , m , n ) : NEW_LINE",
        "explain": "Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If n is 0 then there is 1 solution ( do not include any coin )"
    },
    {
        "py": "if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "If n is less than 0 then no solution exists"
    },
    {
        "py": "if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If there are no coins and n is greater than 0 , then no solution exist"
    },
    {
        "py": "return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE",
        "explain": "count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ]"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def count ( S , m , n ) : NEW_LINE",
        "explain": "Dynamic Programming Python implementation of Coin Change problem"
    },
    {
        "py": "table = [ 0 for k in range ( n + 1 ) ] NEW_LINE",
        "explain": "table [ i ] will be storing the number of solutions for value i . We need n + 1 rows as the table is constructed in bottom up manner using the base case ( n = 0 ) Initialize all table values as 0"
    },
    {
        "py": "table [ 0 ] = 1 NEW_LINE",
        "explain": "Base case ( If given value is 0 )"
    },
    {
        "py": "for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( S [ i ] , n + 1 ) : NEW_LINE INDENT table [ j ] += table [ j - S [ i ] ] NEW_LINE DEDENT DEDENT return table [ n ] NEW_LINE",
        "explain": "Pick all coins one by one and update the table [ ] values after the index greater than or equal to the value of the picked coin"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE n = 4 NEW_LINE x = count ( arr , m , n ) NEW_LINE print ( x ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "import sys NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE",
        "explain": "Python program using memoization"
    },
    {
        "py": "def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT",
        "explain": "Function for matrix chain multiplication"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \" , MatrixChainOrder ( arr , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Dynamic Programming Python implementation of Matrix Chain Multiplication . See the Cormen book for details of the following algorithm"
    },
    {
        "py": "def MatrixChainOrder ( p , n ) : NEW_LINE",
        "explain": "Matrix Ai has dimension p [ i - 1 ] x p [ i ] for i = 1. . n"
    },
    {
        "py": "m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE",
        "explain": "For simplicity of the program , one extra row and one extra column are allocated in m [ ] [ ] . 0 th row and 0 th column of m [ ] [ ] are not used"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT",
        "explain": "cost is zero when multiplying one matrix ."
    },
    {
        "py": "for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE DEDENT DEDENT",
        "explain": "L is chain length ."
    },
    {
        "py": "q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE",
        "explain": "q = cost / scalar multiplications"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" + str ( MatrixChainOrder ( arr , size ) ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "A Naive recursive solution for Rod cutting problem"
    },
    {
        "py": "def max ( a , b ) : NEW_LINE INDENT return a if ( a > b ) else b NEW_LINE DEDENT",
        "explain": "A utility function to get the maximum of two integers"
    },
    {
        "py": "def cutRod ( price , n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_val = - sys . maxsize - 1 NEW_LINE DEDENT",
        "explain": "Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) NEW_LINE DEDENT return max_val NEW_LINE",
        "explain": "Recursively cut the rod in different pieces and compare different configurations"
    },
    {
        "py": "arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \" , cutRod ( arr , size ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "INT_MIN = - 32767 NEW_LINE",
        "explain": "A Dynamic Programming solution for Rod cutting problem"
    },
    {
        "py": "def cutRod ( price , n ) : NEW_LINE INDENT val = [ 0 for x in range ( n + 1 ) ] NEW_LINE val [ 0 ] = 0 NEW_LINE DEDENT",
        "explain": "Returns the best obtainable price for a rod of length n and price [ ] as prices of different pieces"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT max_val = INT_MIN NEW_LINE for j in range ( i ) : NEW_LINE INDENT max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) NEW_LINE DEDENT val [ i ] = max_val NEW_LINE DEDENT return val [ n ] NEW_LINE",
        "explain": "Build the table val [ ] in bottom up manner and return the last entry from the table"
    },
    {
        "py": "arr = [ 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 ] NEW_LINE size = len ( arr ) NEW_LINE print ( \" Maximum \u2581 Obtainable \u2581 Value \u2581 is \u2581 \" + str ( cutRod ( arr , size ) ) ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "def multiply ( x , y ) : NEW_LINE",
        "explain": "Function to multiply two numbers x and y"
    },
    {
        "py": "if ( y == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "0 multiplied with anything gives 0"
    },
    {
        "py": "if ( y > 0 ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) NEW_LINE DEDENT",
        "explain": "Add x one by one"
    },
    {
        "py": "if ( y < 0 ) : NEW_LINE INDENT return - multiply ( x , - y ) NEW_LINE DEDENT",
        "explain": "The case where y is negative"
    },
    {
        "py": "print ( multiply ( 5 , - 11 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def SieveOfEratosthenes ( n ) : NEW_LINE",
        "explain": "Python program to print all primes smaller than or equal to n using Sieve of Eratosthenes"
    },
    {
        "py": "prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."
    },
    {
        "py": "if ( prime [ p ] == True ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT print p , NEW_LINE DEDENT DEDENT",
        "explain": "Print all prime numbers"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 30 NEW_LINE print \" Following \u2581 are \u2581 the \u2581 prime \u2581 numbers \u2581 smaller \" , NEW_LINE print \" than \u2581 or \u2581 equal \u2581 to \" , n NEW_LINE SieveOfEratosthenes ( n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT",
        "explain": "binomialCoeff"
    },
    {
        "py": "def printPascal ( n ) : NEW_LINE",
        "explain": "A simple O ( n ^ 3 ) program for Pascal ' s \u2581 Triangle \u2581 Function \u2581 to \u2581 print \u2581 first \u2581 n \u2581 lines \u2581 of \u2581 Pascal ' s Triangle"
    },
    {
        "py": "for line in range ( 0 , n ) : NEW_LINE",
        "explain": "Iterate through every line and print entries in it"
    },
    {
        "py": "for i in range ( 0 , line + 1 ) : NEW_LINE INDENT print ( binomialCoeff ( line , i ) , \" \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Every line has number of integers equal to line number"
    },
    {
        "py": "n = 7 NEW_LINE printPascal ( n ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def printPascal ( n : int ) : NEW_LINE",
        "explain": "A O ( n ^ 2 ) time and O ( n ^ 2 ) extra space method for Pascal 's Triangle"
    },
    {
        "py": "arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE",
        "explain": "An auxiliary array to store generated pascal triangle values"
    },
    {
        "py": "for line in range ( 0 , n ) : NEW_LINE",
        "explain": "Iterate through every line and print integer ( s ) in it"
    },
    {
        "py": "for i in range ( 0 , line + 1 ) : NEW_LINE",
        "explain": "Every line has number of integers equal to line number"
    },
    {
        "py": "if ( i == 0 or i == line ) : NEW_LINE INDENT arr [ line ] [ i ] = 1 NEW_LINE print ( arr [ line ] [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "First and last values in every row are 1"
    },
    {
        "py": "else : NEW_LINE INDENT arr [ line ] [ i ] = ( arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ) NEW_LINE print ( arr [ line ] [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE",
        "explain": "Other values are sum of values just above and left of above"
    },
    {
        "py": "n = 5 NEW_LINE printPascal ( n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE DEDENT",
        "explain": "Python3 program for Pascal ' s \u2581 Triangle \u2581 A \u2581 O ( n ^ 2 ) \u2581 time \u2581 and \u2581 O ( 1 ) \u2581 extra \u2581 space \u2581 method \u2581 for \u2581 Pascal ' s Triangle Pascal function"
    },
    {
        "py": "C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE",
        "explain": "used to represent C ( line , i )"
    },
    {
        "py": "print ( C , end = \" \u2581 \" ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE print ( \" \" ) ; NEW_LINE",
        "explain": "The first value in a line is always 1"
    },
    {
        "py": "n = 5 ; NEW_LINE printPascal ( n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def Add ( x , y ) : NEW_LINE",
        "explain": "Python3 Program to add two numbers without using arithmetic operator"
    },
    {
        "py": "while ( y != 0 ) : NEW_LINE",
        "explain": "Iterate till there is no carry"
    },
    {
        "py": "carry = x & y NEW_LINE",
        "explain": "carry now contains common set bits of x and y"
    },
    {
        "py": "x = x ^ y NEW_LINE",
        "explain": "Sum of bits of x and y where at least one of the bits is not set"
    },
    {
        "py": "y = carry << 1 NEW_LINE return x NEW_LINE",
        "explain": "Carry is shifted by one so that adding it to x gives the required sum"
    },
    {
        "py": "print ( Add ( 15 , 32 ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def getModulo ( n , d ) : NEW_LINE INDENT return ( n & ( d - 1 ) ) NEW_LINE DEDENT",
        "explain": "This function will return n % d . d must be one of : 1 , 2 , 4 , 8 , 16 , 32 , ..."
    },
    {
        "py": "n = 6 NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "d = 4 NEW_LINE print ( n , \" moduo \" , d , \" is \" , getModulo ( n , d ) ) NEW_LINE",
        "explain": "d must be a power of 2"
    },
    {
        "py": "def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "explain": "Function to get no of set bits in binary representation of positive integer n"
    },
    {
        "py": "i = 9 NEW_LINE print ( countSetBits ( i ) ) NEW_LINE",
        "explain": "Program to test function countSetBits"
    },
    {
        "py": "def countSetBits ( n ) : NEW_LINE",
        "explain": "recursive function to count set bits"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "n = 9 NEW_LINE",
        "explain": "Get value from user"
    },
    {
        "py": "print ( countSetBits ( n ) ) NEW_LINE",
        "explain": "function calling"
    },
    {
        "py": "BitsSetTable256 = [ 0 ] * 256 NEW_LINE",
        "explain": "Lookup table"
    },
    {
        "py": "def initialize ( ) : NEW_LINE",
        "explain": "Function to initialise the lookup table"
    },
    {
        "py": "BitsSetTable256 [ 0 ] = 0 NEW_LINE for i in range ( 256 ) : NEW_LINE INDENT BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i // 2 ] NEW_LINE DEDENT",
        "explain": "To initially generate the table algorithmically"
    },
    {
        "py": "def countSetBits ( n ) : NEW_LINE INDENT return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) NEW_LINE DEDENT",
        "explain": "Function to return the count of set bits in n"
    },
    {
        "py": "initialize ( ) NEW_LINE n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE",
        "explain": "Initialise the lookup table"
    },
    {
        "py": "print ( bin ( 4 ) . count ( '1' ) ) ; NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "num_to_bits = [ 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 ] ; NEW_LINE",
        "explain": "Python3 program to count set bits by pre - storing count set bits in nibbles ."
    },
    {
        "py": "def countSetBitsRec ( num ) : NEW_LINE INDENT nibble = 0 ; NEW_LINE if ( 0 == num ) : NEW_LINE INDENT return num_to_bits [ 0 ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Recursively get nibble of a given number and map them in the array"
    },
    {
        "py": "nibble = num & 0xf ; NEW_LINE",
        "explain": "Find last nibble"
    },
    {
        "py": "return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; NEW_LINE",
        "explain": "Use pre - stored values to find count in last nibble plus recursively add remaining nibbles ."
    },
    {
        "py": "num = 31 ; NEW_LINE print ( countSetBitsRec ( num ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countSetBits ( N ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Check each bit in a number is set or not and return the total count of the set bits"
    },
    {
        "py": "INDENT for i in range ( 4 * 8 ) : NEW_LINE INDENT if ( N & ( 1 << i ) ) : NEW_LINE count += 1 NEW_LINE return count NEW_LINE DEDENT DEDENT",
        "explain": "( 1 << i ) = pow ( 2 , i )"
    },
    {
        "py": "N = 15 NEW_LINE print ( countSetBits ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def getParity ( n ) : NEW_LINE INDENT parity = 0 NEW_LINE while n : NEW_LINE INDENT parity = ~ parity NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return parity NEW_LINE DEDENT",
        "explain": "Function to get parity of number n . It returns 1 if n has odd parity , and returns 0 if n has even parity"
    },
    {
        "py": "n = 7 NEW_LINE print ( \" Parity \u2581 of \u2581 no \u2581 \" , n , \" \u2581 = \u2581 \" , ( \" odd \" if getParity ( n ) else \" even \" ) ) NEW_LINE",
        "explain": "Driver program to test getParity ( )"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 Program to find whether a no is power of two"
    },
    {
        "py": "def Log2 ( x ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return false ; NEW_LINE DEDENT return ( math . log10 ( x ) / math . log10 ( 2 ) ) ; NEW_LINE DEDENT",
        "explain": "Function to check Log base 2"
    },
    {
        "py": "def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( Log2 ( n ) ) == math . floor ( Log2 ( n ) ) ) ; NEW_LINE DEDENT",
        "explain": "Function to check if x is power of 2"
    },
    {
        "py": "if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def isPowerOfTwo ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT",
        "explain": "Function to check if x is power of 2"
    },
    {
        "py": "if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def powerof2 ( n ) : NEW_LINE",
        "explain": "function which checks whether a number is a power of 2"
    },
    {
        "py": "if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "base cases '1' is the only odd number which is a power of 2 ( 2 ^ 0 )"
    },
    {
        "py": "elif n % 2 != 0 or n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "all other odd numbers are not powers of 2"
    },
    {
        "py": "return powerof2 ( n / 2 ) NEW_LINE",
        "explain": "recursive function call"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( powerof2 ( 64 ) ) NEW_LINE",
        "explain": "True"
    },
    {
        "py": "print ( powerof2 ( 12 ) ) NEW_LINE",
        "explain": "False"
    },
    {
        "py": "def isPowerOfTwo ( x ) : NEW_LINE",
        "explain": "Function to check if x is power of 2"
    },
    {
        "py": "return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE",
        "explain": "First x in the below expression is for the case when x is 0"
    },
    {
        "py": "if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxRepeating ( arr , n , k ) : NEW_LINE",
        "explain": "Returns maximum repeating element in arr [ 0. . n - 1 ] . The array elements are in range from 0 to k - 1"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT arr [ arr [ i ] % k ] += k NEW_LINE DEDENT",
        "explain": "Iterate though input array , for every element arr [ i ] , increment arr [ arr [ i ] % k ] by k"
    },
    {
        "py": "max = arr [ 0 ] NEW_LINE result = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE result = i NEW_LINE DEDENT DEDENT",
        "explain": "Find index of the maximum repeating element"
    },
    {
        "py": "return result NEW_LINE",
        "explain": "Return index of the maximum element"
    },
    {
        "py": "arr = [ 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE print ( \" The \u2581 maximum \u2581 repeating \u2581 number \u2581 is \" , maxRepeating ( arr , n , k ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def fun ( x ) : NEW_LINE INDENT y = ( x // 4 ) * 4 NEW_LINE DEDENT",
        "explain": "function return derived formula value ."
    },
    {
        "py": "ans = 0 NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT ans ^= i NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "finding xor value of range [ y ... x ]"
    },
    {
        "py": "def query ( x ) : NEW_LINE",
        "explain": "function to solve query for l and r ."
    },
    {
        "py": "if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = ( x + 1 ) // 2 NEW_LINE",
        "explain": "if l or r is 0."
    },
    {
        "py": "if x % 2 == 0 : NEW_LINE INDENT return ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * fun ( k ) ) NEW_LINE DEDENT def allQueries ( q , l , r ) : NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) NEW_LINE DEDENT",
        "explain": "finding x is divisible by 2 or not ."
    },
    {
        "py": "q = 3 NEW_LINE l = [ 2 , 2 , 5 ] NEW_LINE r = [ 4 , 8 , 9 ] NEW_LINE allQueries ( q , l , r ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def prefixXOR ( arr , preXOR , n ) : NEW_LINE",
        "explain": "Precompute the prefix XOR of greatest odd divisor"
    },
    {
        "py": "for i in range ( 0 , n , 1 ) : NEW_LINE INDENT while ( arr [ i ] % 2 != 1 ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] / 2 ) NEW_LINE DEDENT preXOR [ i ] = arr [ i ] NEW_LINE DEDENT",
        "explain": "Finding the Greatest Odd divisor"
    },
    {
        "py": "for i in range ( 1 , n , 1 ) : NEW_LINE INDENT preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] NEW_LINE DEDENT",
        "explain": "Finding prefix XOR"
    },
    {
        "py": "def query ( preXOR , l , r ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return preXOR [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return preXOR [ r ] ^ preXOR [ l - 1 ] NEW_LINE DEDENT DEDENT",
        "explain": "Return XOR of the range"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE preXOR = [ 0 for i in range ( n ) ] NEW_LINE prefixXOR ( arr , preXOR , n ) NEW_LINE print ( query ( preXOR , 0 , 2 ) ) NEW_LINE print ( query ( preXOR , 1 , 2 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findMinSwaps ( arr , n ) : NEW_LINE",
        "explain": "Function to find minimum swaps to sort an array of 0 s and 1 s ."
    },
    {
        "py": "noOfZeroes = [ 0 ] * n NEW_LINE count = 0 NEW_LINE",
        "explain": "Array to store count of zeroes"
    },
    {
        "py": "noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i + 1 ] NEW_LINE if ( arr [ i ] == 0 ) : NEW_LINE INDENT noOfZeroes [ i ] = noOfZeroes [ i ] + 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count number of zeroes on right side of every one ."
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT count = count + noOfZeroes [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE",
        "explain": "Count total number of swaps by adding number of zeroes on right side of every one ."
    },
    {
        "py": "arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinSwaps ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE print ( minswaps ( arr ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def arraySortedOrNot ( arr , n ) : NEW_LINE",
        "explain": "Function that returns true if array is sorted in non - decreasing order ."
    },
    {
        "py": "if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE",
        "explain": "Array has one or no element"
    },
    {
        "py": "if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Unsorted pair found"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "No unsorted pair found"
    },
    {
        "py": "arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printTwoOdd ( arr , size ) : NEW_LINE",
        "explain": "Prints two numbers that occur odd number of times . The function assumes that the array size is at least 2 and there are exactly two numbers occurring odd number of times ."
    },
    {
        "py": "xor2 = arr [ 0 ] NEW_LINE",
        "explain": "Will hold XOR of two odd occurring elements"
    },
    {
        "py": "set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE",
        "explain": "Will have only single set bit of xor2"
    },
    {
        "py": "for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT",
        "explain": "Get the xor of all elements in arr [ ] . The xor will basically be xor of two odd occurring elements"
    },
    {
        "py": "set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE",
        "explain": "Get one set bit in the xor2 . We get rightmost set bit in the following line as it is easy to get"
    },
    {
        "py": "for i in range ( size ) : NEW_LINE",
        "explain": "Now divide elements in two sets : 1 ) The elements having the corresponding bit as 1. 2 ) The elements having the corresponding bit as 0."
    },
    {
        "py": "if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT",
        "explain": "XOR of first set is finally going to hold one odd occurring number x"
    },
    {
        "py": "else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT print ( \" The \u2581 two \u2581 ODD \u2581 elements \u2581 are \" , x , \" & \" , y ) NEW_LINE",
        "explain": "XOR of second set is finally going to hold the other odd occurring number y"
    },
    {
        "py": "arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findPair ( arr , n ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE DEDENT",
        "explain": "The function assumes that the array is sorted"
    },
    {
        "py": "i , j = 0 , 1 NEW_LINE",
        "explain": "Initialize positions of two elements"
    },
    {
        "py": "while i < size and j < size : NEW_LINE INDENT if i != j and arr [ j ] - arr [ i ] == n : NEW_LINE INDENT print \" Pair \u2581 found \u2581 ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" NEW_LINE return True NEW_LINE DEDENT elif arr [ j ] - arr [ i ] < n : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print \" No \u2581 pair \u2581 found \" NEW_LINE return False NEW_LINE",
        "explain": "Search for a pair"
    },
    {
        "py": "arr = [ 1 , 8 , 30 , 40 , 100 ] NEW_LINE n = 60 NEW_LINE findPair ( arr , n ) NEW_LINE",
        "explain": "Driver function to test above function"
    },
    {
        "py": "def printMax ( arr , k , n ) : NEW_LINE",
        "explain": "Function to pr m Maximum elements"
    },
    {
        "py": "brr = arr . copy ( ) NEW_LINE",
        "explain": "vector to store the copy of the original array"
    },
    {
        "py": "brr . sort ( reverse = True ) NEW_LINE",
        "explain": "Sorting the vector in descending order . Please refer below link for details"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] in brr [ 0 : k ] ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Traversing through original array and pring all those elements that are in first k of sorted vector ."
    },
    {
        "py": "arr = [ 50 , 8 , 45 , 12 , 25 , 40 , 84 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printMax ( arr , k , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def binary_search ( arr , low , high , ele ) : NEW_LINE INDENT while low < high : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] == ele : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > ele : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT",
        "explain": "Function for binary_search"
    },
    {
        "py": "def printSmall ( arr , asize , n ) : NEW_LINE",
        "explain": "Function to print smallest n numbers"
    },
    {
        "py": "copy_arr = arr . copy ( ) NEW_LINE",
        "explain": "Make copy of array"
    },
    {
        "py": "copy_arr . sort ( ) NEW_LINE",
        "explain": "Sort copy array"
    },
    {
        "py": "for i in range ( asize ) : NEW_LINE INDENT if binary_search ( copy_arr , low = 0 , high = n , ele = arr [ i ] ) > - 1 : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "For each arr [ i ] find whether it is a part of n - smallest with binary search"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE asize = len ( arr ) NEW_LINE n = 5 NEW_LINE printSmall ( arr , asize , n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE DEDENT",
        "explain": "Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort array"
    },
    {
        "py": "d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "After sorting , difference between consecutive elements must be same ."
    },
    {
        "py": "arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Yes \" ) if ( checkIsAP ( arr , n ) ) else print ( \" No \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def checkIsAP ( arr , n ) : NEW_LINE INDENT hm = { } NEW_LINE smallest = float ( ' inf ' ) NEW_LINE second_smallest = float ( ' inf ' ) NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression"
    },
    {
        "py": "if ( arr [ i ] < smallest ) : NEW_LINE INDENT second_smallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT",
        "explain": "Find the smallest and and update second smallest"
    },
    {
        "py": "elif ( arr [ i ] != smallest and arr [ i ] < second_smallest ) : NEW_LINE INDENT second_smallest = arr [ i ] NEW_LINE DEDENT",
        "explain": "Find second smallest"
    },
    {
        "py": "if arr [ i ] not in hm : NEW_LINE INDENT hm [ arr [ i ] ] = 1 NEW_LINE DEDENT",
        "explain": "Check if the duplicate element found or not"
    },
    {
        "py": "else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If duplicate found then return false"
    },
    {
        "py": "diff = second_smallest - smallest NEW_LINE",
        "explain": "Find the difference between smallest and second smallest"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT if ( second_smallest ) not in hm : NEW_LINE INDENT return False NEW_LINE DEDENT second_smallest += diff NEW_LINE DEDENT return True NEW_LINE",
        "explain": "As we have used smallest and second smallest , so we should now only check for n - 2 elements"
    },
    {
        "py": "arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkIsAP ( arr , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countPairs ( a , n ) : NEW_LINE",
        "explain": "Python Code to find no . of Ways of choosing a pair with maximum difference"
    },
    {
        "py": "mn = + 2147483647 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( mn , a [ i ] ) NEW_LINE mx = max ( mx , a [ i ] ) NEW_LINE DEDENT",
        "explain": "To find minimum and maximum of the array"
    },
    {
        "py": "c1 = 0 NEW_LINE",
        "explain": "to find the count of minimum and maximum elements"
    },
    {
        "py": "c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == mn ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( a [ i ] == mx ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count variables"
    },
    {
        "py": "if ( mn == mx ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return c1 * c2 NEW_LINE DEDENT",
        "explain": "condition for all elements equal"
    },
    {
        "py": "a = [ 3 , 2 , 1 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , x ) : NEW_LINE INDENT self . data = x NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Python3 code to rearrange linked list in place"
    },
    {
        "py": "def rearrange ( head ) : NEW_LINE",
        "explain": "Function for rearranging a linked list with high and low value"
    },
    {
        "py": "if ( head == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "prev , curr = head , head . next NEW_LINE while ( curr ) : NEW_LINE",
        "explain": "Two pointer variable"
    },
    {
        "py": "if ( prev . data > curr . data ) : NEW_LINE INDENT prev . data , curr . data = curr . data , prev . data NEW_LINE DEDENT",
        "explain": "Swap function for swapping data"
    },
    {
        "py": "if ( curr . next and curr . next . data > curr . data ) : NEW_LINE INDENT curr . next . data , curr . data = curr . data , curr . next . data NEW_LINE DEDENT prev = curr . next NEW_LINE if ( not curr . next ) : NEW_LINE INDENT break NEW_LINE DEDENT curr = curr . next . next NEW_LINE return head NEW_LINE",
        "explain": "Swap function for swapping data"
    },
    {
        "py": "def push ( head , k ) : NEW_LINE INDENT tem = Node ( k ) NEW_LINE tem . data = k NEW_LINE tem . next = head NEW_LINE head = tem NEW_LINE return head NEW_LINE DEDENT",
        "explain": "Function to insert a node in the linked list at the beginning"
    },
    {
        "py": "def display ( head ) : NEW_LINE INDENT curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( curr . data , end = \" \u2581 \" ) NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT",
        "explain": "Function to display node of linked list"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "head = push ( head , 7 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 9 ) NEW_LINE head = rearrange ( head ) NEW_LINE display ( head ) NEW_LINE",
        "explain": "Let create a linked list 9 . 6 . 8 . 3 . 7"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Python3 implementation"
    },
    {
        "py": "def printlist ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE if ( head . next != None ) : NEW_LINE INDENT print ( \" - > \" , end = \" \" ) NEW_LINE DEDENT head = head . next NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Function to print the list"
    },
    {
        "py": "def rearrange ( head ) : NEW_LINE INDENT global left NEW_LINE if ( head != None ) : NEW_LINE INDENT left = head NEW_LINE reorderListUtil ( left ) NEW_LINE DEDENT DEDENT def reorderListUtil ( right ) : NEW_LINE INDENT global left NEW_LINE if ( right == None ) : NEW_LINE INDENT return NEW_LINE DEDENT reorderListUtil ( right . next ) NEW_LINE DEDENT",
        "explain": "Function to rearrange"
    },
    {
        "py": "if ( left == None ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "We set left = null , when we reach stop condition , so no processing required after that"
    },
    {
        "py": "if ( left != right and left . next != right ) : NEW_LINE INDENT temp = left . next NEW_LINE left . next = right NEW_LINE right . next = temp NEW_LINE left = temp NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Stop condition : odd case : left = right , even case : left . next = right"
    },
    {
        "py": "if ( left . next == right ) : NEW_LINE",
        "explain": "Stop condition , set null to left nodes"
    },
    {
        "py": "left . next . next = None NEW_LINE left = None NEW_LINE else : NEW_LINE",
        "explain": "Even case"
    },
    {
        "py": "left . next = None NEW_LINE left = None NEW_LINE",
        "explain": "Odd case"
    },
    {
        "py": "head = Node ( 1 ) NEW_LINE head . next = Node ( 2 ) NEW_LINE head . next . next = Node ( 3 ) NEW_LINE head . next . next . next = Node ( 4 ) NEW_LINE head . next . next . next . next = Node ( 5 ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "printlist ( head ) NEW_LINE",
        "explain": "Print original list"
    },
    {
        "py": "rearrange ( head ) NEW_LINE",
        "explain": "Modify the list"
    },
    {
        "py": "printlist ( head ) NEW_LINE",
        "explain": "Print modified list"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , new_data ) : NEW_LINE INDENT self . data = new_data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = data NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT",
        "explain": "A linked List Node"
    },
    {
        "py": "def getLength ( Node ) : NEW_LINE INDENT size = 0 NEW_LINE while ( Node != None ) : NEW_LINE INDENT Node = Node . next NEW_LINE size = size + 1 NEW_LINE DEDENT return size NEW_LINE DEDENT",
        "explain": "A utility function to get length of linked list"
    },
    {
        "py": "def paddZeros ( sNode , diff ) : NEW_LINE INDENT if ( sNode == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT zHead = newNode ( 0 ) NEW_LINE diff = diff - 1 NEW_LINE temp = zHead NEW_LINE while ( diff > 0 ) : NEW_LINE INDENT diff = diff - 1 NEW_LINE temp . next = newNode ( 0 ) NEW_LINE temp = temp . next NEW_LINE DEDENT temp . next = sNode NEW_LINE return zHead NEW_LINE DEDENT borrow = True NEW_LINE",
        "explain": "A Utility that padds zeros in front of the Node , with the given diff"
    },
    {
        "py": "def subtractLinkedListHelper ( l1 , l2 ) : NEW_LINE INDENT global borrow NEW_LINE if ( l1 == None and l2 == None and not borrow ) : NEW_LINE INDENT return None NEW_LINE DEDENT l3 = None NEW_LINE l4 = None NEW_LINE if ( l1 != None ) : NEW_LINE INDENT l3 = l1 . next NEW_LINE DEDENT if ( l2 != None ) : NEW_LINE INDENT l4 = l2 . next NEW_LINE DEDENT previous = subtractLinkedListHelper ( l3 , l4 ) NEW_LINE d1 = l1 . data NEW_LINE d2 = l2 . data NEW_LINE sub = 0 NEW_LINE DEDENT",
        "explain": "Subtract LinkedList Helper is a recursive function , move till the last Node , and subtract the digits and create the Node and return the Node . If d1 < d2 , we borrow the number from previous digit ."
    },
    {
        "py": "if ( borrow ) : NEW_LINE INDENT d1 = d1 - 1 NEW_LINE borrow = False NEW_LINE DEDENT",
        "explain": "if you have given the value value to next digit then reduce the d1 by 1"
    },
    {
        "py": "if ( d1 < d2 ) : NEW_LINE INDENT borrow = True NEW_LINE d1 = d1 + 10 NEW_LINE DEDENT",
        "explain": "If d1 < d2 , then borrow the number from previous digit . Add 10 to d1 and set borrow = True"
    },
    {
        "py": "sub = d1 - d2 NEW_LINE",
        "explain": "subtract the digits"
    },
    {
        "py": "current = newNode ( sub ) NEW_LINE",
        "explain": "Create a Node with sub value"
    },
    {
        "py": "current . next = previous NEW_LINE return current NEW_LINE",
        "explain": "Set the Next pointer as Previous"
    },
    {
        "py": "def subtractLinkedList ( l1 , l2 ) : NEW_LINE",
        "explain": "This API subtracts two linked lists and returns the linked list which shall have the subtracted result ."
    },
    {
        "py": "if ( l1 == None and l2 == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT",
        "explain": "Base Case ."
    },
    {
        "py": "len1 = getLength ( l1 ) NEW_LINE len2 = getLength ( l2 ) NEW_LINE lNode = None NEW_LINE sNode = None NEW_LINE temp1 = l1 NEW_LINE temp2 = l2 NEW_LINE",
        "explain": "In either of the case , get the lengths of both Linked list ."
    },
    {
        "py": "if ( len1 != len2 ) : NEW_LINE INDENT if ( len1 > len2 ) : NEW_LINE INDENT lNode = l1 NEW_LINE DEDENT else : NEW_LINE INDENT lNode = l2 NEW_LINE DEDENT if ( len1 > len2 ) : NEW_LINE INDENT sNode = l2 NEW_LINE DEDENT else : NEW_LINE INDENT sNode = l1 NEW_LINE DEDENT sNode = paddZeros ( sNode , abs ( len1 - len2 ) ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If lengths differ , calculate the smaller Node and padd zeros for smaller Node and ensure both larger Node and smaller Node has equal length ."
    },
    {
        "py": "while ( l1 != None and l2 != None ) : NEW_LINE INDENT if ( l1 . data != l2 . data ) : NEW_LINE INDENT if ( l1 . data > l2 . data ) : NEW_LINE INDENT lNode = temp1 NEW_LINE DEDENT else : NEW_LINE INDENT lNode = temp2 NEW_LINE DEDENT if ( l1 . data > l2 . data ) : NEW_LINE INDENT sNode = temp2 NEW_LINE DEDENT else : NEW_LINE INDENT sNode = temp1 NEW_LINE DEDENT break NEW_LINE DEDENT l1 = l1 . next NEW_LINE l2 = l2 . next NEW_LINE DEDENT global borrow NEW_LINE",
        "explain": "If both list lengths are equal , then calculate the larger and smaller list . If 5 - 6 - 7 & 5 - 6 - 8 are linked list , then walk through linked list at last Node as 7 < 8 , larger Node is 5 - 6 - 8 and smaller Node is 5 - 6 - 7."
    },
    {
        "py": "borrow = False NEW_LINE return subtractLinkedListHelper ( lNode , sNode ) NEW_LINE",
        "explain": "After calculating larger and smaller Node , call subtractLinkedListHelper which returns the subtracted linked list ."
    },
    {
        "py": "def printList ( Node ) : NEW_LINE INDENT while ( Node != None ) : NEW_LINE INDENT print ( Node . data , end = \" \u2581 \" ) NEW_LINE Node = Node . next NEW_LINE DEDENT print ( \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "A utility function to print linked list"
    },
    {
        "py": "head1 = newNode ( 1 ) NEW_LINE head1 . next = newNode ( 0 ) NEW_LINE head1 . next . next = newNode ( 0 ) NEW_LINE head2 = newNode ( 1 ) NEW_LINE result = subtractLinkedList ( head1 , head2 ) NEW_LINE printList ( result ) NEW_LINE",
        "explain": "Driver program to test above functions"
    },
    {
        "py": "class Node : NEW_LINE",
        "explain": "Node class"
    },
    {
        "py": "def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT",
        "explain": "constructor to create a new node"
    },
    {
        "py": "def insertAtMid ( head , x ) : NEW_LINE",
        "explain": "function to insert node at the middle of linked list given the head"
    },
    {
        "py": "if ( head == None ) : NEW_LINE INDENT head = Node ( x ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "if the list is empty"
    },
    {
        "py": "newNode = Node ( x ) NEW_LINE ptr = head NEW_LINE length = 0 NEW_LINE",
        "explain": "create a new node for the value to be inserted"
    },
    {
        "py": "while ( ptr != None ) : NEW_LINE INDENT ptr = ptr . next NEW_LINE length += 1 NEW_LINE DEDENT",
        "explain": "calcualte the length of the linked list"
    },
    {
        "py": "if ( length % 2 == 0 ) : NEW_LINE INDENT count = length / 2 NEW_LINE DEDENT else : NEW_LINE INDENT ( length + 1 ) / 2 NEW_LINE DEDENT ptr = head NEW_LINE",
        "explain": "' count ' the number of node after which the new node has to be inserted"
    },
    {
        "py": "while ( count > 1 ) : NEW_LINE INDENT count -= 1 NEW_LINE ptr = ptr . next NEW_LINE DEDENT",
        "explain": "move ptr to the node after which the new node has to inserted"
    },
    {
        "py": "newNode . next = ptr . next NEW_LINE ptr . next = newNode NEW_LINE",
        "explain": "insert the ' newNode ' and adjust links accordingly"
    },
    {
        "py": "def display ( head ) : NEW_LINE INDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( str ( temp . data ) , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT",
        "explain": "function to displat the linked list"
    },
    {
        "py": "head = Node ( 1 ) NEW_LINE head . next = Node ( 2 ) NEW_LINE head . next . next = Node ( 4 ) NEW_LINE head . next . next . next = Node ( 5 ) NEW_LINE print ( \" Linked \u2581 list \u2581 before \u2581 insertion : \u2581 \" , end = \" \" ) NEW_LINE display ( head ) NEW_LINE",
        "explain": "Creating the linked list 1.2 . 4.5"
    },
    {
        "py": "x = 3 NEW_LINE insertAtMid ( head , x ) NEW_LINE print ( \" Linked list after insertion : \" \u2581 , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE display ( head ) NEW_LINE",
        "explain": "inserting 3 in the middle of the linked list ."
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Node of a doubly linked list"
    },
    {
        "py": "def getNode ( data ) : NEW_LINE",
        "explain": "function to create and return a new node of a doubly linked list"
    },
    {
        "py": "newNode = Node ( 0 ) NEW_LINE",
        "explain": "allocate node"
    },
    {
        "py": "newNode . data = data NEW_LINE newNode . prev = newNode . next = None NEW_LINE return newNode NEW_LINE",
        "explain": "put in the data"
    },
    {
        "py": "def sortedInsert ( head_ref , newNode ) : NEW_LINE INDENT current = None NEW_LINE DEDENT",
        "explain": "function to insert a new node in sorted way in a sorted doubly linked list"
    },
    {
        "py": "if ( head_ref == None ) : NEW_LINE INDENT head_ref = newNode NEW_LINE DEDENT",
        "explain": "if list is empty"
    },
    {
        "py": "elif ( ( head_ref ) . data >= newNode . data ) : NEW_LINE INDENT newNode . next = head_ref NEW_LINE newNode . next . prev = newNode NEW_LINE head_ref = newNode NEW_LINE DEDENT else : NEW_LINE INDENT current = head_ref NEW_LINE DEDENT",
        "explain": "if the node is to be inserted at the beginning of the doubly linked list"
    },
    {
        "py": "while ( current . next != None and current . next . data < newNode . data ) : NEW_LINE INDENT current = current . next NEW_LINE DEDENT",
        "explain": "locate the node after which the new node is to be inserted"
    },
    {
        "py": "newNode . next = current . next NEW_LINE",
        "explain": "Make the appropriate links"
    },
    {
        "py": "if ( current . next != None ) : NEW_LINE INDENT newNode . next . prev = newNode NEW_LINE DEDENT current . next = newNode NEW_LINE newNode . prev = current NEW_LINE return head_ref ; NEW_LINE",
        "explain": "if the new node is not inserted at the end of the list"
    },
    {
        "py": "def insertionSort ( head_ref ) : NEW_LINE",
        "explain": "function to sort a doubly linked list using insertion sort"
    },
    {
        "py": "sorted = None NEW_LINE",
        "explain": "Initialize ' sorted ' - a sorted doubly linked list"
    },
    {
        "py": "current = head_ref NEW_LINE while ( current != None ) : NEW_LINE",
        "explain": "Traverse the given doubly linked list and insert every node to 'sorted"
    },
    {
        "py": "next = current . next NEW_LINE",
        "explain": "Store next for next iteration"
    },
    {
        "py": "current . prev = current . next = None NEW_LINE",
        "explain": "removing all the links so as to create ' current ' as a new node for insertion"
    },
    {
        "py": "sorted = sortedInsert ( sorted , current ) NEW_LINE",
        "explain": "insert current in ' sorted ' doubly linked list"
    },
    {
        "py": "current = next NEW_LINE",
        "explain": "Update current"
    },
    {
        "py": "head_ref = sorted NEW_LINE return head_ref NEW_LINE",
        "explain": "Update head_ref to point to sorted doubly linked list"
    },
    {
        "py": "def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = \" \u2581 \" ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT",
        "explain": "function to print the doubly linked list"
    },
    {
        "py": "def push ( head_ref , new_data ) : NEW_LINE",
        "explain": "function to insert a node at the beginning of the doubly linked list"
    },
    {
        "py": "new_node = Node ( 0 ) NEW_LINE",
        "explain": "allocate node"
    },
    {
        "py": "new_node . data = new_data NEW_LINE",
        "explain": "put in the data"
    },
    {
        "py": "new_node . next = ( head_ref ) NEW_LINE new_node . prev = None NEW_LINE",
        "explain": "Make next of new node as head and previous as None"
    },
    {
        "py": "if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . prev = new_node NEW_LINE DEDENT",
        "explain": "change prev of head node to new node"
    },
    {
        "py": "( head_ref ) = new_node NEW_LINE return head_ref NEW_LINE",
        "explain": "move the head to point to the new node"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "head = None NEW_LINE",
        "explain": "start with the empty doubly linked list"
    },
    {
        "py": "head = push ( head , 9 ) NEW_LINE head = push ( head , 3 ) NEW_LINE head = push ( head , 5 ) NEW_LINE head = push ( head , 10 ) NEW_LINE head = push ( head , 12 ) NEW_LINE head = push ( head , 8 ) NEW_LINE print ( \" Doubly \u2581 Linked \u2581 List \u2581 Before \u2581 Sorting \" ) NEW_LINE printList ( head ) NEW_LINE head = insertionSort ( head ) NEW_LINE print ( \" Doubly Linked List After Sorting \" ) NEW_LINE printList ( head ) NEW_LINE",
        "explain": "insert the following data"
    },
    {
        "py": "def reverse ( arr , s , e ) : NEW_LINE INDENT while s < e : NEW_LINE INDENT tem = arr [ s ] NEW_LINE arr [ s ] = arr [ e ] NEW_LINE arr [ e ] = tem NEW_LINE s = s + 1 NEW_LINE e = e - 1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to reverse array between indices s and e"
    },
    {
        "py": "def fun ( arr , k ) : NEW_LINE INDENT n = len ( arr ) - 1 NEW_LINE v = n - k NEW_LINE if v >= 0 : NEW_LINE INDENT reverse ( arr , 0 , v ) NEW_LINE reverse ( arr , v + 1 , n ) NEW_LINE reverse ( arr , 0 , n ) NEW_LINE return arr NEW_LINE DEDENT DEDENT",
        "explain": "Function to generate all possible rotations of array"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT count = 0 NEW_LINE p = fun ( arr , i ) NEW_LINE print ( p , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 100005 NEW_LINE",
        "explain": "Python3 program to find Bitwise OR of two equal halves of an array after performing K right circular shifts"
    },
    {
        "py": "seg = [ 0 ] * ( 4 * MAX ) NEW_LINE",
        "explain": "Array for storing the segment tree"
    },
    {
        "py": "def build ( node , l , r , a ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg [ node ] = a [ l ] NEW_LINE DEDENT else : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE build ( 2 * node , l , mid , a ) NEW_LINE build ( 2 * node + 1 , mid + 1 , r , a ) NEW_LINE seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to build the segment tree"
    },
    {
        "py": "def query ( node , l , r , start , end , a ) : NEW_LINE",
        "explain": "Function to return the OR of elements in the range [ l , r ]"
    },
    {
        "py": "if ( l > end or r < start ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( start <= l and r <= end ) : NEW_LINE INDENT return seg [ node ] NEW_LINE DEDENT",
        "explain": "Check for out of bound condition"
    },
    {
        "py": "mid = ( l + r ) // 2 NEW_LINE",
        "explain": "Find middle of the range"
    },
    {
        "py": "return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) NEW_LINE",
        "explain": "Recurse for all the elements in array"
    },
    {
        "py": "def orsum ( a , n , q , k ) : NEW_LINE",
        "explain": "Function to find the OR sum"
    },
    {
        "py": "build ( 1 , 0 , n - 1 , a ) NEW_LINE",
        "explain": "Function to build the segment Tree"
    },
    {
        "py": "for j in range ( q ) : NEW_LINE",
        "explain": "Loop to handle q queries"
    },
    {
        "py": "i = k [ j ] % ( n // 2 ) NEW_LINE",
        "explain": "Effective number of right circular shifts"
    },
    {
        "py": "sec = query ( 1 , 0 , n - 1 , n // 2 - i , n - i - 1 , a ) NEW_LINE",
        "explain": "OR of second half of the array [ n / 2 - i , n - 1 - i ]"
    },
    {
        "py": "first = ( query ( 1 , 0 , n - 1 , 0 , n // 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) NEW_LINE temp = sec + first NEW_LINE",
        "explain": "OR of first half of the array [ n - i , n - 1 ] OR [ 0 , n / 2 - 1 - i ]"
    },
    {
        "py": "print ( temp ) NEW_LINE",
        "explain": "Print final answer to the query"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 ] NEW_LINE n = len ( a ) NEW_LINE q = 2 NEW_LINE k = [ 4 , 2 ] NEW_LINE orsum ( a , n , q , k ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maximumEqual ( a , b , n ) : NEW_LINE",
        "explain": "Function that prints maximum equal elements"
    },
    {
        "py": "store = [ 0 ] * 10 ** 5 NEW_LINE",
        "explain": "List to store the index of elements of array b"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT store [ b [ i ] ] = i + 1 NEW_LINE DEDENT",
        "explain": "Storing the positions of array B"
    },
    {
        "py": "ans = [ 0 ] * 10 ** 5 NEW_LINE",
        "explain": "Frequency array to keep count of elements with similar difference in distances"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate through all element in arr1 [ ]"
    },
    {
        "py": "d = abs ( store [ a [ i ] ] - ( i + 1 ) ) NEW_LINE",
        "explain": "Calculate number of shift required to make current element equal"
    },
    {
        "py": "if ( store [ a [ i ] ] < i + 1 ) : NEW_LINE INDENT d = n - d NEW_LINE DEDENT",
        "explain": "If d is less than 0"
    },
    {
        "py": "ans [ d ] += 1 NEW_LINE finalans = 0 NEW_LINE",
        "explain": "Store the frequency of current diff"
    },
    {
        "py": "for i in range ( 10 ** 5 ) : NEW_LINE INDENT finalans = max ( finalans , ans [ i ] ) NEW_LINE DEDENT",
        "explain": "Compute the maximum frequency stored"
    },
    {
        "py": "print ( finalans ) NEW_LINE",
        "explain": "Printing the maximum number of equal elements"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = [ 6 , 7 , 3 , 9 , 5 ] NEW_LINE B = [ 7 , 3 , 9 , 5 , 6 ] NEW_LINE size = len ( A ) NEW_LINE",
        "explain": "Given two arrays"
    },
    {
        "py": "maximumEqual ( A , B , size ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def RightRotate ( a , n , k ) : NEW_LINE",
        "explain": "Function to rightRotate array"
    },
    {
        "py": "k = k % n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE DEDENT",
        "explain": "If rotation is greater than size of array"
    },
    {
        "py": "print ( a [ n + i - k ] , end = \" \u2581 \" ) ; NEW_LINE else : NEW_LINE",
        "explain": "Printing rightmost kth elements"
    },
    {
        "py": "print ( a [ i - k ] , end = \" \u2581 \" ) ; NEW_LINE print ( \" \" ) ; NEW_LINE",
        "explain": "Prints array after ' k ' elements"
    },
    {
        "py": "Array = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE N = len ( Array ) ; NEW_LINE K = 2 ; NEW_LINE RightRotate ( Array , N , K ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def restoreSortedArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to restore the Original Sort"
    },
    {
        "py": "reverse ( arr , 0 , i ) ; NEW_LINE reverse ( arr , i + 1 , n ) ; NEW_LINE reverse ( arr , 0 , n ) ; NEW_LINE def reverse ( arr , i , j ) : NEW_LINE while ( i < j ) : NEW_LINE temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE",
        "explain": "In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one ."
    },
    {
        "py": "def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the Array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 4 , 5 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE restoreSortedArray ( arr , n - 1 ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findStartIndexOfArray ( arr , low , high ) : NEW_LINE INDENT if ( low > high ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( low == high ) : NEW_LINE INDENT return low ; NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE if ( arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid + 1 ; NEW_LINE DEDENT if ( arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ low ] > arr [ mid ] ) : NEW_LINE INDENT return findStartIndexOfArray ( arr , low , mid - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return findStartIndexOfArray ( arr , mid + 1 , high ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to find start index of array"
    },
    {
        "py": "def restoreSortedArray ( arr , n ) : NEW_LINE",
        "explain": "Function to restore the Original Sort"
    },
    {
        "py": "if ( arr [ 0 ] < arr [ n - 1 ] ) : NEW_LINE INDENT return ; NEW_LINE DEDENT start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; NEW_LINE",
        "explain": "array is already sorted"
    },
    {
        "py": "reverse ( arr , 0 , start ) ; NEW_LINE reverse ( arr , start , n ) ; NEW_LINE reverse ( arr ) ; NEW_LINE",
        "explain": "In reverse ( ) , the first parameter is iterator to beginning element and second parameter is iterator to last element plus one ."
    },
    {
        "py": "def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) ; NEW_LINE DEDENT DEDENT def reverse ( arr , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the Array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE restoreSortedArray ( arr , n ) ; NEW_LINE printArray ( arr , n ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def leftrotate ( s , d ) : NEW_LINE INDENT tmp = s [ d : ] + s [ 0 : d ] NEW_LINE return tmp NEW_LINE DEDENT",
        "explain": "In - place rotates s towards left by d"
    },
    {
        "py": "def rightrotate ( s , d ) : NEW_LINE INDENT return leftrotate ( s , len ( s ) - d ) NEW_LINE DEDENT",
        "explain": "In - place rotates s towards right by d"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" GeeksforGeeks \" NEW_LINE print ( leftrotate ( str1 , 2 ) ) NEW_LINE str2 = \" GeeksforGeeks \" NEW_LINE print ( rightrotate ( str2 , 2 ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to illustrate inserting a Node in a Cicular Doubly Linked list in begging , end and middle"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "Structure of a Node"
    },
    {
        "py": "def insertNode ( start , value ) : NEW_LINE",
        "explain": "Function to insert a node at the end"
    },
    {
        "py": "if ( start == None ) : NEW_LINE INDENT new_node = Node ( value ) NEW_LINE new_node . data = value NEW_LINE new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE start = new_node NEW_LINE return new_node NEW_LINE DEDENT",
        "explain": "If the list is empty , create a single node circular and doubly list"
    },
    {
        "py": "last = start . prev NEW_LINE",
        "explain": "Find last node"
    },
    {
        "py": "new_node = Node ( value ) NEW_LINE new_node . data = value NEW_LINE",
        "explain": "Create Node dynamically"
    },
    {
        "py": "new_node . next = start NEW_LINE",
        "explain": "Start is going to be next of new_node"
    },
    {
        "py": "( start ) . prev = new_node NEW_LINE",
        "explain": "Make new node previous of start"
    },
    {
        "py": "new_node . prev = last NEW_LINE",
        "explain": "Make last preivous of new node"
    },
    {
        "py": "last . next = new_node NEW_LINE return start NEW_LINE",
        "explain": "Make new node next of old last"
    },
    {
        "py": "def displayList ( start ) : NEW_LINE INDENT temp = start NEW_LINE while ( temp . next != start ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT",
        "explain": "Function to display the circular doubly linked list"
    },
    {
        "py": "def searchList ( start , search ) : NEW_LINE",
        "explain": "Function to search the particular element from the list"
    },
    {
        "py": "temp = start NEW_LINE",
        "explain": "Declare the temp variable"
    },
    {
        "py": "count = 0 NEW_LINE flag = 0 NEW_LINE value = 0 NEW_LINE",
        "explain": "Declare other control variable for the searching"
    },
    {
        "py": "if ( temp == None ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If start is None return - 1"
    },
    {
        "py": "while ( temp . next != start ) : NEW_LINE",
        "explain": "Move the temp pointer until , temp . next doesn 't move  start address (Circular Fashion)"
    },
    {
        "py": "count = count + 1 NEW_LINE",
        "explain": "Increment count for location"
    },
    {
        "py": "if ( temp . data == search ) : NEW_LINE INDENT flag = 1 NEW_LINE count = count - 1 NEW_LINE break NEW_LINE DEDENT",
        "explain": "If it is found raise the flag and break the loop"
    },
    {
        "py": "temp = temp . next NEW_LINE",
        "explain": "Increment temp pointer"
    },
    {
        "py": "if ( temp . data == search ) : NEW_LINE INDENT count = count + 1 NEW_LINE flag = 1 NEW_LINE DEDENT",
        "explain": "Check whether last element in the list content the value if contain , raise a flag and increment count"
    },
    {
        "py": "if ( flag == 1 ) : NEW_LINE INDENT print ( search , \" found \u2581 at \u2581 location \u2581 \" , count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( search , \" \u2581 not \u2581 found \" ) NEW_LINE DEDENT return - 1 NEW_LINE",
        "explain": "If flag is true , then element found , else not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "start = None NEW_LINE",
        "explain": "Start with the empty list"
    },
    {
        "py": "start = insertNode ( start , 4 ) NEW_LINE",
        "explain": "Insert 4. So linked list becomes 4. None"
    },
    {
        "py": "start = insertNode ( start , 5 ) NEW_LINE",
        "explain": "Insert 5. So linked list becomes 4.5"
    },
    {
        "py": "start = insertNode ( start , 7 ) NEW_LINE",
        "explain": "Insert 7. So linked list becomes 4.5 . 7"
    },
    {
        "py": "start = insertNode ( start , 8 ) NEW_LINE",
        "explain": "Insert 8. So linked list becomes 4.5 . 7.8"
    },
    {
        "py": "start = insertNode ( start , 6 ) NEW_LINE print ( \" Created \u2581 circular \u2581 doubly \u2581 linked \u2581 list \u2581 is : \u2581 \" , end = \" \" ) NEW_LINE displayList ( start ) NEW_LINE searchList ( start , 5 ) NEW_LINE",
        "explain": "Insert 6. So linked list becomes 4.5 . 7.8 . 6"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation to revesre a doubly circular linked list"
    },
    {
        "py": "class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT",
        "explain": "structure of a node of linked list"
    },
    {
        "py": "def getNode ( data ) : NEW_LINE INDENT newNode = Node ( data ) NEW_LINE newNode . data = data NEW_LINE return newNode NEW_LINE DEDENT",
        "explain": "function to create and return a new node"
    },
    {
        "py": "def insertEnd ( head , new_node ) : NEW_LINE",
        "explain": "Function to insert at the end"
    },
    {
        "py": "if ( head == None ) : NEW_LINE INDENT new_node . next = new_node NEW_LINE new_node . prev = new_node NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT",
        "explain": "If the list is empty , create a single node circular and doubly list"
    },
    {
        "py": "last = head . prev NEW_LINE",
        "explain": "Find last node"
    },
    {
        "py": "new_node . next = head NEW_LINE",
        "explain": "Start is going to be next of new_node"
    },
    {
        "py": "head . prev = new_node NEW_LINE",
        "explain": "Make new node previous of start"
    },
    {
        "py": "new_node . prev = last NEW_LINE",
        "explain": "Make last preivous of new node"
    },
    {
        "py": "last . next = new_node NEW_LINE return head NEW_LINE",
        "explain": "Make new node next of old last"
    },
    {
        "py": "def reverse ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT DEDENT",
        "explain": "Uitlity function to revesre a doubly circular linked list"
    },
    {
        "py": "new_head = None NEW_LINE",
        "explain": "Initialize a new head pointer"
    },
    {
        "py": "last = head . prev NEW_LINE",
        "explain": "get pointer to the the last node"
    },
    {
        "py": "curr = last NEW_LINE",
        "explain": "set ' curr ' to last node"
    },
    {
        "py": "while ( curr . prev != last ) : NEW_LINE INDENT prev = curr . prev NEW_LINE DEDENT",
        "explain": "traverse list in backward direction"
    },
    {
        "py": "new_head = insertEnd ( new_head , curr ) NEW_LINE curr = prev NEW_LINE new_head = insertEnd ( new_head , curr ) NEW_LINE",
        "explain": "insert ' curr ' at the end of the list starting with the ' new _ head ' pointer"
    },
    {
        "py": "return new_head NEW_LINE",
        "explain": "head pointer of the reversed list"
    },
    {
        "py": "def display ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( \" Forward \u2581 direction : \u2581 \" , end = \" \" ) NEW_LINE while ( temp . next != head ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( temp . data ) NEW_LINE last = head . prev NEW_LINE temp = last NEW_LINE print ( \" Backward \u2581 direction : \u2581 \" , end = \" \" ) NEW_LINE while ( temp . prev != last ) : NEW_LINE INDENT print ( temp . data , end = \" \u2581 \" ) NEW_LINE temp = temp . prev NEW_LINE DEDENT print ( temp . data ) NEW_LINE DEDENT",
        "explain": "function to display a doubly circular list in forward and backward direction"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertEnd ( head , getNode ( 1 ) ) NEW_LINE head = insertEnd ( head , getNode ( 2 ) ) NEW_LINE head = insertEnd ( head , getNode ( 3 ) ) NEW_LINE head = insertEnd ( head , getNode ( 4 ) ) NEW_LINE head = insertEnd ( head , getNode ( 5 ) ) NEW_LINE print ( \" Current \u2581 list : \" ) NEW_LINE display ( head ) NEW_LINE head = reverse ( head ) NEW_LINE print ( \" Reversed list : \" ) NEW_LINE display ( head ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAXN = 1001 NEW_LINE",
        "explain": "Python3 implementation to find LCA in a tree"
    },
    {
        "py": "depth = [ 0 for i in range ( MAXN ) ] ; NEW_LINE",
        "explain": "stores depth for each node"
    },
    {
        "py": "parent = [ 0 for i in range ( MAXN ) ] ; NEW_LINE adj = [ [ ] for i in range ( MAXN ) ] NEW_LINE def addEdge ( u , v ) : NEW_LINE INDENT adj [ u ] . append ( v ) ; NEW_LINE adj [ v ] . append ( u ) ; NEW_LINE DEDENT def dfs ( cur , prev ) : NEW_LINE",
        "explain": "stores first parent for each node"
    },
    {
        "py": "parent [ cur ] = prev ; NEW_LINE",
        "explain": "marking parent for each node"
    },
    {
        "py": "depth [ cur ] = depth [ prev ] + 1 ; NEW_LINE",
        "explain": "marking depth for each node"
    },
    {
        "py": "for i in range ( len ( adj [ cur ] ) ) : NEW_LINE INDENT if ( adj [ cur ] [ i ] != prev ) : NEW_LINE INDENT dfs ( adj [ cur ] [ i ] , cur ) ; NEW_LINE DEDENT DEDENT def preprocess ( ) : NEW_LINE",
        "explain": "propogating marking down the tree"
    },
    {
        "py": "depth [ 0 ] = - 1 ; NEW_LINE",
        "explain": "a dummy node"
    },
    {
        "py": "dfs ( 1 , 0 ) ; NEW_LINE",
        "explain": "precalculating 1 ) depth . 2 ) parent . for each node"
    },
    {
        "py": "def LCANaive ( u , v ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT return u ; NEW_LINE DEDENT if ( depth [ u ] > depth [ v ] ) : NEW_LINE INDENT u , v = v , u NEW_LINE DEDENT v = parent [ v ] ; NEW_LINE return LCANaive ( u , v ) ; NEW_LINE DEDENT",
        "explain": "Time Complexity : O ( Height of tree ) recursively jumps one node above till both the nodes become equal"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "addEdge ( 1 , 2 ) ; NEW_LINE addEdge ( 1 , 3 ) ; NEW_LINE addEdge ( 1 , 4 ) ; NEW_LINE addEdge ( 2 , 5 ) ; NEW_LINE addEdge ( 2 , 6 ) ; NEW_LINE addEdge ( 3 , 7 ) ; NEW_LINE addEdge ( 4 , 8 ) ; NEW_LINE addEdge ( 4 , 9 ) ; NEW_LINE addEdge ( 9 , 10 ) ; NEW_LINE addEdge ( 9 , 11 ) ; NEW_LINE addEdge ( 7 , 12 ) ; NEW_LINE addEdge ( 7 , 13 ) ; NEW_LINE preprocess ( ) ; NEW_LINE print ( ' LCA ( 11,8 ) \u2581 : \u2581 ' + str ( LCANaive ( 11 , 8 ) ) ) NEW_LINE print ( ' LCA ( 3,13 ) \u2581 : \u2581 ' + str ( LCANaive ( 3 , 13 ) ) ) NEW_LINE",
        "explain": "adding edges to the tree"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( pow ( 2 , N + 1 ) - 2 ) NEW_LINE",
        "explain": "Formula for number of trails for N consecutive heads"
    },
    {
        "py": "def countOfNum ( n , a , b ) : NEW_LINE INDENT cnt_of_a , cnt_of_b , cnt_of_ab , sum = 0 , 0 , 0 , 0 NEW_LINE DEDENT",
        "explain": "Function to return the count of numbers which are divisible by both A and B in the range [ 1 , N ] in constant time"
    },
    {
        "py": "cnt_of_a = n // a NEW_LINE",
        "explain": "Compute the count of numbers divisible by A in the range [ 1 , N ]"
    },
    {
        "py": "cnt_of_b = n // b NEW_LINE",
        "explain": "Compute the count of numbers divisible by B in the range [ 1 , N ]"
    },
    {
        "py": "sum = cnt_of_b + cnt_of_a NEW_LINE",
        "explain": "Adding the counts which are divisible by A and B"
    },
    {
        "py": "cnt_of_ab = n // ( a * b ) NEW_LINE",
        "explain": "The above value might contain repeated values which are divisible by both A and B . Therefore , the count of numbers which are divisible by both A and B are found"
    },
    {
        "py": "sum = sum - cnt_of_ab NEW_LINE return sum NEW_LINE",
        "explain": "The count computed above is subtracted to compute the final count"
    },
    {
        "py": "def sumOfNum ( n , a , b ) : NEW_LINE INDENT i = 0 NEW_LINE sum = 0 NEW_LINE DEDENT",
        "explain": "Function to return the sum of numbers which are divisible by both A and B in the range [ 1 , N ]"
    },
    {
        "py": "ans = dict ( ) NEW_LINE",
        "explain": "Set to store the numbers so that the numbers are not repeated"
    },
    {
        "py": "for i in range ( a , n + 1 , a ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT",
        "explain": "For loop to find the numbers which are divisible by A and insert them into the set"
    },
    {
        "py": "for i in range ( b , n + 1 , b ) : NEW_LINE INDENT ans [ i ] = 1 NEW_LINE DEDENT",
        "explain": "For loop to find the numbers which are divisible by A and insert them into the set"
    },
    {
        "py": "for it in ans : NEW_LINE INDENT sum = sum + it NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "For loop to iterate through the set and find the sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 88 NEW_LINE A = 11 NEW_LINE B = 8 NEW_LINE count = countOfNum ( N , A , B ) NEW_LINE sumofnum = sumOfNum ( N , A , B ) NEW_LINE print ( sumofnum % count ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def get ( L , R ) : NEW_LINE",
        "explain": "Function to return the value of the given expression"
    },
    {
        "py": "x = 1.0 / L ; NEW_LINE",
        "explain": "Value of the first term"
    },
    {
        "py": "y = 1.0 / ( R + 1.0 ) ; NEW_LINE return ( x - y ) ; NEW_LINE",
        "explain": "Value of the last term"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT L = 6 ; R = 12 ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "ans = get ( L , R ) ; NEW_LINE print ( round ( ans , 2 ) ) ; NEW_LINE",
        "explain": "Get the result"
    },
    {
        "py": "from bisect import bisect_right as upper_bound NEW_LINE MAX = 100000 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "v = [ ] NEW_LINE",
        "explain": "To store the pre - computed integers"
    },
    {
        "py": "def consecutiveOnes ( x ) : NEW_LINE",
        "explain": "Function that returns true if the binary representation of x contains consecutive 1 s"
    },
    {
        "py": "p = 0 NEW_LINE while ( x > 0 ) : NEW_LINE",
        "explain": "To store the previous bit"
    },
    {
        "py": "if ( x % 2 == 1 and p == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Check whether the previous bit and the current bit are both 1"
    },
    {
        "py": "p = x % 2 NEW_LINE",
        "explain": "Update previous bit"
    },
    {
        "py": "x //= 2 NEW_LINE return False NEW_LINE",
        "explain": "Go to the next bit"
    },
    {
        "py": "def preCompute ( ) : NEW_LINE",
        "explain": "Function to pre - compute the valid numbers from 0 to MAX"
    },
    {
        "py": "for i in range ( MAX + 1 ) : NEW_LINE INDENT if ( consecutiveOnes ( i ) == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT",
        "explain": "Store all the numbers which do not have consecutive 1 s"
    },
    {
        "py": "def nextValid ( n ) : NEW_LINE",
        "explain": "Function to return the minimum number greater than n which does not contain consecutive 1 s"
    },
    {
        "py": "it = upper_bound ( v , n ) NEW_LINE val = v [ it ] NEW_LINE return val NEW_LINE",
        "explain": "Search for the next greater element with no consecutive 1 s"
    },
    {
        "py": "def performQueries ( queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( nextValid ( queries [ i ] ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to perform the queries"
    },
    {
        "py": "queries = [ 4 , 6 ] NEW_LINE q = len ( queries ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "preCompute ( ) NEW_LINE",
        "explain": "Pre - compute the numbers"
    },
    {
        "py": "performQueries ( queries , q ) NEW_LINE",
        "explain": "Perform the queries"
    },
    {
        "py": "def changeToOnes ( string ) : NEW_LINE",
        "explain": "Function to return the number of operations required"
    },
    {
        "py": "ctr = 0 ; NEW_LINE l = len ( string ) ; NEW_LINE",
        "explain": "ctr will store the number of consecutive ones at the end of the given binary string"
    },
    {
        "py": "for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Loop to find number of 1 s at the end of the string"
    },
    {
        "py": "if ( string [ i ] == '1' ) : NEW_LINE INDENT ctr += 1 ; NEW_LINE DEDENT",
        "explain": "If the current character is 1"
    },
    {
        "py": "else : NEW_LINE INDENT break ; NEW_LINE DEDENT",
        "explain": "If we encounter the first 0 from the LSB position then we 'll break the loop"
    },
    {
        "py": "return l - ctr ; NEW_LINE",
        "explain": "Number of operations required is ( l - ctr )"
    },
    {
        "py": "def removeZeroesFromFront ( string ) : NEW_LINE INDENT s = \" \" ; NEW_LINE i = 0 ; NEW_LINE DEDENT",
        "explain": "Function to remove leading zeroes from the string"
    },
    {
        "py": "while ( i < len ( string ) and string [ i ] == '0' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT",
        "explain": "Loop until s [ i ] becomes not equal to 1"
    },
    {
        "py": "if ( i == len ( string ) ) : NEW_LINE INDENT s = \"0\" ; NEW_LINE DEDENT",
        "explain": "If we reach the end of the string , it means that string contains only 0 's"
    },
    {
        "py": "else : NEW_LINE INDENT s = string [ i : len ( string ) - i ] ; NEW_LINE DEDENT return s ; NEW_LINE",
        "explain": "Return the string without leading zeros"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"10010111\" ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "string = removeZeroesFromFront ( string ) ; NEW_LINE print ( changeToOnes ( string ) ) ; NEW_LINE",
        "explain": "Removing the leading zeroes"
    },
    {
        "py": "def MinDeletion ( a , n ) : NEW_LINE",
        "explain": "Function to return the minimum deletions required"
    },
    {
        "py": "map = dict . fromkeys ( a , 0 ) ; NEW_LINE",
        "explain": "To store the frequency of the array elements"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT map [ a [ i ] ] += 1 ; NEW_LINE DEDENT",
        "explain": "Store frequency of each element"
    },
    {
        "py": "ans = 0 ; NEW_LINE for key , value in map . items ( ) : NEW_LINE",
        "explain": "To store the minimum deletions required"
    },
    {
        "py": "x = key ; NEW_LINE",
        "explain": "Value"
    },
    {
        "py": "frequency = value ; NEW_LINE",
        "explain": "It 's frequency"
    },
    {
        "py": "if ( x <= frequency ) : NEW_LINE",
        "explain": "If number less than or equal to it 's frequency"
    },
    {
        "py": "ans += ( frequency - x ) ; NEW_LINE",
        "explain": "Delete extra occurrences"
    },
    {
        "py": "else : NEW_LINE INDENT ans += frequency ; NEW_LINE DEDENT return ans ; NEW_LINE",
        "explain": "Delete every occurrence of x"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinDeletion ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxCountAB ( s , n ) : NEW_LINE",
        "explain": "Function to find maximum number of ABs"
    },
    {
        "py": "A = 0 NEW_LINE B = 0 NEW_LINE BA = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = s [ i ] NEW_LINE L = len ( S ) NEW_LINE for j in range ( L - 1 ) : NEW_LINE DEDENT",
        "explain": "variable A , B , AB for count strings that end with ' A ' but not end with ' B ' , ' B ' but does not end with ' A ' and ' B ' and ends with ' A ' respectively ."
    },
    {
        "py": "if ( S [ j ] == ' A ' and S [ j + 1 ] == ' B ' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT",
        "explain": "' AB ' is already present in string before concatenate them"
    },
    {
        "py": "if ( S [ 0 ] == ' B ' and S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT BA += 1 NEW_LINE DEDENT",
        "explain": "count of strings that begins with ' B ' and ends with 'A"
    },
    {
        "py": "' NEW_LINE INDENT elif ( S [ 0 ] == ' B ' ) : NEW_LINE INDENT B += 1 NEW_LINE DEDENT DEDENT",
        "explain": "count of strings that begins with ' B ' but does not end with 'A"
    },
    {
        "py": "' NEW_LINE INDENT elif ( S [ L - 1 ] == ' A ' ) : NEW_LINE INDENT A += 1 NEW_LINE DEDENT DEDENT",
        "explain": "count of strings that ends with ' A ' but not end with 'B"
    },
    {
        "py": "' NEW_LINE INDENT if ( BA == 0 ) : NEW_LINE INDENT ans += min ( B , A ) NEW_LINE DEDENT elif ( A + B == 0 ) : NEW_LINE INDENT ans += BA - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += BA + min ( B , A ) NEW_LINE DEDENT return ans NEW_LINE DEDENT",
        "explain": "updating the value of ans and add extra count of 'AB"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ \" ABCA \" , \" BOOK \" , \" BAND \" ] NEW_LINE n = len ( s ) NEW_LINE print ( maxCountAB ( s , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MinOperations ( n , x , arr ) : NEW_LINE",
        "explain": "Function to return the minimum number of operations required"
    },
    {
        "py": "total = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store total operations required"
    },
    {
        "py": "if ( arr [ i ] > x ) : NEW_LINE INDENT difference = arr [ i ] - x NEW_LINE total = total + difference NEW_LINE arr [ i ] = x NEW_LINE DEDENT",
        "explain": "First make all elements equal to x which are currenctly greater"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Left scan the array"
    },
    {
        "py": "if ( LeftNeigbouringSum > x ) : NEW_LINE INDENT current_diff = LeftNeigbouringSum - x NEW_LINE arr [ i ] = max ( 0 , arr [ i ] - current_diff ) NEW_LINE total = total + current_diff NEW_LINE DEDENT return total NEW_LINE",
        "explain": "Update the current element such that neighbouring sum is < x"
    },
    {
        "py": "X = 1 NEW_LINE arr = [ 1 , 6 , 1 , 2 , 0 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( MinOperations ( N , X , arr ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def findNumbers ( arr , n ) : NEW_LINE",
        "explain": "Function to print the required numbers"
    },
    {
        "py": "sumN = ( n * ( n + 1 ) ) / 2 ; NEW_LINE",
        "explain": "Sum of first n natural numbers"
    },
    {
        "py": "sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE",
        "explain": "Sum of squares of first n natural numbers"
    },
    {
        "py": "sum = 0 ; NEW_LINE sumSq = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE sumSq = sumSq + ( math . pow ( arr [ i ] , 2 ) ) ; NEW_LINE DEDENT B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; NEW_LINE A = sum - sumN + B ; NEW_LINE print ( \" A \u2581 = \u2581 \" , int ( A ) ) ; NEW_LINE print ( \" B \u2581 = \u2581 \" , int ( B ) ) ; NEW_LINE",
        "explain": "To store the sum and sum of squares of the array elements"
    },
    {
        "py": "arr = [ 1 , 2 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNumbers ( arr , n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def is_prefix ( temp , str ) : NEW_LINE",
        "explain": "Function to find the whether the string temp starts with str or not"
    },
    {
        "py": "if ( len ( temp ) < len ( str ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != temp [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE",
        "explain": "Check for the corresponding characters in temp & str"
    },
    {
        "py": "def lexicographicallyString ( input , n , str ) : NEW_LINE",
        "explain": "Function to find lexicographic smallest string consisting of the string str as prefix"
    },
    {
        "py": "input . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = input [ i ] NEW_LINE DEDENT",
        "explain": "Sort the given array string arr [ ]"
    },
    {
        "py": "if ( is_prefix ( temp , str ) ) : NEW_LINE INDENT return temp NEW_LINE DEDENT",
        "explain": "If the i - th string contains given string as a prefix , then print the result"
    },
    {
        "py": "return \" - 1\" NEW_LINE",
        "explain": "If no string exists then return \" - 1\""
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" apple \" , \" appe \" , \" apl \" , \" aapl \" , \" appax \" ] NEW_LINE S = \" app \" NEW_LINE N = 5 NEW_LINE print ( lexicographicallyString ( arr , N , S ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def Rearrange ( arr , K , N ) : NEW_LINE",
        "explain": "Function to rearrange the array"
    },
    {
        "py": "ans = [ 0 ] * ( N + 1 ) NEW_LINE",
        "explain": "Stores the rearranged array"
    },
    {
        "py": "f = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans [ i ] = - 1 NEW_LINE DEDENT",
        "explain": "Stores whether the arrangement is possible or not"
    },
    {
        "py": "K = arr . index ( K ) NEW_LINE",
        "explain": "Update K with the position of K"
    },
    {
        "py": "smaller = [ ] NEW_LINE greater = [ ] NEW_LINE",
        "explain": "Stores all elements lesser than and greater than in vector smaller and greater respectively"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if ( arr [ i ] < arr [ K ] ) : NEW_LINE INDENT smaller . append ( arr [ i ] ) NEW_LINE DEDENT",
        "explain": "If arr [ i ] is less than arr [ K ]"
    },
    {
        "py": "elif ( arr [ i ] > arr [ K ] ) : NEW_LINE INDENT greater . append ( arr [ i ] ) NEW_LINE DEDENT low = 0 NEW_LINE high = N - 1 NEW_LINE",
        "explain": "Else"
    },
    {
        "py": "while ( low <= high ) : NEW_LINE",
        "explain": "Iterate unil low is less than or equal to high"
    },
    {
        "py": "mid = ( low + high ) // 2 NEW_LINE",
        "explain": "Stores mid point"
    },
    {
        "py": "if ( mid == K ) : NEW_LINE INDENT ans [ mid ] = arr [ K ] NEW_LINE f = 1 NEW_LINE break NEW_LINE DEDENT",
        "explain": "If mid is equal to K"
    },
    {
        "py": "elif ( mid < K ) : NEW_LINE INDENT if ( len ( smaller ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans [ mid ] = smaller [ - 1 ] NEW_LINE smaller . pop ( ) NEW_LINE low = mid + 1 NEW_LINE DEDENT",
        "explain": "If mid is less than K"
    },
    {
        "py": "else : NEW_LINE INDENT if ( len ( greater ) == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT ans [ mid ] = greater [ - 1 ] NEW_LINE greater . pop ( ) NEW_LINE high = mid - 1 NEW_LINE DEDENT",
        "explain": "If mid is greater than K"
    },
    {
        "py": "if ( f == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If f is - 1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate in the range [ 1 , N ]"
    },
    {
        "py": "if ( ans [ i ] == - 1 ) : NEW_LINE INDENT if ( len ( smaller ) ) : NEW_LINE INDENT ans [ i ] = smaller [ - 1 ] NEW_LINE smaller . pop ( ) NEW_LINE DEDENT elif ( len ( greater ) ) : NEW_LINE INDENT ans [ i ] = greater [ - 1 ] NEW_LINE greater . pop ( ) NEW_LINE DEDENT DEDENT",
        "explain": "If ans [ i ] is equal to - 1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the rearranged array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 10 , 7 , 2 , 5 , 3 , 8 ] NEW_LINE K = 7 NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Input"
    },
    {
        "py": "Rearrange ( arr , K , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python 3 program for the above approach"
    },
    {
        "py": "def minimumK ( arr , M , N ) : NEW_LINE",
        "explain": "Function to find minimum value of K such that the first person gets at least ( N / ( M + 1 ) ) candies"
    },
    {
        "py": "good = math . ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) NEW_LINE",
        "explain": "Find the minimum required value of candies for the first person"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT K = i NEW_LINE DEDENT",
        "explain": "Iterate K from [ 1 , n ]"
    },
    {
        "py": "candies = N NEW_LINE",
        "explain": "Total number of candies"
    },
    {
        "py": "taken = 0 NEW_LINE while ( candies > 0 ) : NEW_LINE",
        "explain": "Candies taken by Person 1"
    },
    {
        "py": "taken += min ( K , candies ) NEW_LINE candies -= min ( K , candies ) NEW_LINE",
        "explain": "Candies taken by 1 st person is minimum of K and candies left"
    },
    {
        "py": "for j in range ( M ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "consume = ( arr [ j ] * candies ) / 100 NEW_LINE",
        "explain": "Amount consumed by the person j"
    },
    {
        "py": "candies -= consume NEW_LINE",
        "explain": "Update the number of candies"
    },
    {
        "py": "if ( taken >= good ) : NEW_LINE print ( i ) NEW_LINE return NEW_LINE",
        "explain": "Good share of candies achieved"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 13 NEW_LINE M = 1 NEW_LINE arr = [ 50 ] NEW_LINE minimumK ( arr , M , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def calcTotalTime ( path ) : NEW_LINE",
        "explain": "Function to calculate time taken to travel the path"
    },
    {
        "py": "time = 0 NEW_LINE",
        "explain": "Stores total time"
    },
    {
        "py": "x = 0 NEW_LINE y = 0 NEW_LINE",
        "explain": "Initial position"
    },
    {
        "py": "s = set ( [ ] ) NEW_LINE for i in range ( len ( path ) ) : NEW_LINE INDENT p = x NEW_LINE q = y NEW_LINE if ( path [ i ] == ' N ' ) : NEW_LINE INDENT y += 1 NEW_LINE DEDENT elif ( path [ i ] == ' S ' ) : NEW_LINE INDENT y -= 1 NEW_LINE DEDENT elif ( path [ i ] == ' E ' ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT elif ( path [ i ] == ' W ' ) : NEW_LINE INDENT x -= 1 NEW_LINE DEDENT DEDENT",
        "explain": "Stores visited segments"
    },
    {
        "py": "if ( p + x , q + y ) not in s : NEW_LINE",
        "explain": "Check whether segment is present in the set"
    },
    {
        "py": "time += 2 NEW_LINE",
        "explain": "Increment the value of time by 2"
    },
    {
        "py": "s . add ( ( p + x , q + y ) ) NEW_LINE else : NEW_LINE time += 1 NEW_LINE",
        "explain": "Insert segment into the set"
    },
    {
        "py": "print ( time ) NEW_LINE",
        "explain": "Print the value of time"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT path = \" NSE \" NEW_LINE calcTotalTime ( path ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findCost ( A , N ) : NEW_LINE",
        "explain": "Function to calculate the cost required to make all array elements equal to 1"
    },
    {
        "py": "totalCost = 0 NEW_LINE",
        "explain": "Stores the total cost"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if ( A [ i ] == 0 ) : NEW_LINE",
        "explain": "If current element is 0"
    },
    {
        "py": "A [ i ] = 1 NEW_LINE",
        "explain": "Convert 0 to 1"
    },
    {
        "py": "totalCost += i NEW_LINE",
        "explain": "Add the cost"
    },
    {
        "py": "return totalCost NEW_LINE",
        "explain": "Return the total cost"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findCost ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def peakIndex ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Function to find the peak index for the given array"
    },
    {
        "py": "if ( len ( arr ) < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 0 NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "while ( i + 1 < N ) : NEW_LINE",
        "explain": "Check for strictly increasing array"
    },
    {
        "py": "if ( arr [ i + 1 ] < arr [ i ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE if ( i == 0 or i == N - 1 ) : NEW_LINE return - 1 NEW_LINE",
        "explain": "If the strictly increasing condition is violated , then break"
    },
    {
        "py": "ans = i NEW_LINE",
        "explain": "Stores the value of i , which is a potential peak index"
    },
    {
        "py": "while ( i < N - 1 ) : NEW_LINE",
        "explain": "Second traversal , for strictly decreasing array"
    },
    {
        "py": "if ( arr [ i ] < arr [ i + 1 ] or arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "When the strictly decreasing condition is violated , then break"
    },
    {
        "py": "if ( i == N - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT",
        "explain": "If i = N - 1 , it means that ans is the peak index"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "Otherwise , peak index doesn 't exist"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 1 , 0 ] NEW_LINE print ( peakIndex ( arr ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def hasArrayTwoPairs ( nums , n , target ) : NEW_LINE",
        "explain": "Function to check if the array has 2 elements whose sum is equal to the given value"
    },
    {
        "py": "nums = sorted ( nums ) NEW_LINE",
        "explain": "Sort the array in increasing order"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array , nums [ ]"
    },
    {
        "py": "x = target - nums [ i ] NEW_LINE",
        "explain": "Store the required number to be found"
    },
    {
        "py": "low , high = 0 , n - 1 NEW_LINE while ( low <= high ) : NEW_LINE",
        "explain": "Perform binary search"
    },
    {
        "py": "mid = low + ( ( high - low ) // 2 ) NEW_LINE",
        "explain": "Store the mid value"
    },
    {
        "py": "if ( nums [ mid ] > x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT",
        "explain": "If nums [ mid ] is greater than x , then update high to mid - 1"
    },
    {
        "py": "elif ( nums [ mid ] < x ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT",
        "explain": "If nums [ mid ] is less than x , then update low to mid + 1"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if ( mid == i ) : NEW_LINE INDENT if ( ( mid - 1 >= 0 ) and nums [ mid - 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = \" , \u2581 \" ) NEW_LINE print ( nums [ mid - 1 ] ) NEW_LINE return NEW_LINE DEDENT if ( ( mid + 1 < n ) and nums [ mid + 1 ] == x ) : NEW_LINE INDENT print ( nums [ i ] , end = \" , \u2581 \" ) NEW_LINE print ( nums [ mid + 1 ] ) NEW_LINE return NEW_LINE DEDENT break NEW_LINE DEDENT",
        "explain": "If mid is equal i , check mid - 1 and mid + 1"
    },
    {
        "py": "else : NEW_LINE INDENT print ( nums [ i ] , end = \" , \u2581 \" ) NEW_LINE print ( nums [ mid ] ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Otherwise , prthe pair and return"
    },
    {
        "py": "print ( - 1 ) NEW_LINE",
        "explain": "If no such pair is found , then pr - 1"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , - 1 , 2 , - 3 , 1 ] NEW_LINE X = - 2 NEW_LINE N = len ( A ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "hasArrayTwoPairs ( A , N , X ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "from math import sqrt , floor , ceil NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def findClosest ( N , target ) : NEW_LINE INDENT closest = - 1 NEW_LINE diff = 10 ** 18 NEW_LINE DEDENT",
        "explain": "Function to find the divisor of N closest to the target"
    },
    {
        "py": "for i in range ( 1 , ceil ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE DEDENT",
        "explain": "Iterate till square root of N"
    },
    {
        "py": "if ( N // i == i ) : NEW_LINE",
        "explain": "Check if divisors are equal"
    },
    {
        "py": "if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Check if i is the closest"
    },
    {
        "py": "if ( abs ( target - i ) < diff ) : NEW_LINE INDENT diff = abs ( target - i ) NEW_LINE closest = i NEW_LINE DEDENT",
        "explain": "Check if i is the closest"
    },
    {
        "py": "if ( abs ( target - N // i ) < diff ) : NEW_LINE INDENT diff = abs ( target - N // i ) NEW_LINE closest = N // i NEW_LINE DEDENT",
        "explain": "Check if n / i is the closest"
    },
    {
        "py": "print ( closest ) NEW_LINE",
        "explain": "Prthe closest value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N , X = 16 , 5 NEW_LINE",
        "explain": "Given N & X"
    },
    {
        "py": "findClosest ( N , X ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def power ( A , N ) : NEW_LINE",
        "explain": "Function to calculate the minimum power of A and B greater than N"
    },
    {
        "py": "count = 0 ; NEW_LINE if ( A == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( N > 0 ) : NEW_LINE",
        "explain": "Stores the power of A which is greater than N"
    },
    {
        "py": "count += 1 ; NEW_LINE",
        "explain": "Increment count by 1"
    },
    {
        "py": "N //= A ; NEW_LINE return int ( count ) ; NEW_LINE",
        "explain": "Divide N by A"
    },
    {
        "py": "def Pairs ( N , A , B ) : NEW_LINE INDENT powerA , powerB = 0 , 0 ; NEW_LINE DEDENT",
        "explain": "Function to find a pair ( a , b ) such that A ^ a + B ^ b = N"
    },
    {
        "py": "powerA = power ( A , N ) ; NEW_LINE",
        "explain": "Calculate the minimum power of A greater than N"
    },
    {
        "py": "powerB = power ( B , N ) ; NEW_LINE",
        "explain": "Calculate the minimum power of B greater than N"
    },
    {
        "py": "intialB = B ; NEW_LINE intialA = A ; NEW_LINE",
        "explain": "Make copy of A and B"
    },
    {
        "py": "A = 1 ; NEW_LINE for i in range ( powerA + 1 ) : NEW_LINE INDENT B = 1 ; NEW_LINE for j in range ( powerB + 1 ) : NEW_LINE DEDENT",
        "explain": "Traverse for every pair ( i , j )"
    },
    {
        "py": "if ( B == N - A ) : NEW_LINE INDENT print ( i , \" \u2581 \" , j ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "Check if B ^ j + A ^ i = N To overcome the overflow problem use B = N - A rather than B + A = N"
    },
    {
        "py": "B *= intialB ; NEW_LINE",
        "explain": "Increment power B by 1"
    },
    {
        "py": "A *= intialA ; NEW_LINE",
        "explain": "Increment power A by 1"
    },
    {
        "py": "print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE",
        "explain": "Finally pr - 1 if no pair is found"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 106 ; NEW_LINE A = 3 ; NEW_LINE B = 5 ; NEW_LINE",
        "explain": "Given A , B and N"
    },
    {
        "py": "Pairs ( N , A , B ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findNonMultiples ( arr , n , k ) : NEW_LINE",
        "explain": "Function to find the non - multiples till k"
    },
    {
        "py": "multiples = set ( [ ] ) NEW_LINE",
        "explain": "Stores all unique multiples"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate the array"
    },
    {
        "py": "if ( arr [ i ] not in multiples ) : NEW_LINE",
        "explain": "For finding duplicates only once"
    },
    {
        "py": "for j in range ( 1 , k // arr [ i ] + 1 ) : NEW_LINE INDENT multiples . add ( arr [ i ] * j ) NEW_LINE DEDENT",
        "explain": "Inserting all multiples into the set"
    },
    {
        "py": "return k - len ( multiples ) NEW_LINE",
        "explain": "Returning only the count of numbers that are not divisible by any of the array elements"
    },
    {
        "py": "def countValues ( arr , N , L , R ) : NEW_LINE",
        "explain": "Function to count the total values in the range [ L , R ]"
    },
    {
        "py": "return ( findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ) NEW_LINE",
        "explain": "Count all values in the range using exclusion principle"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE L = 1 NEW_LINE R = 20 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( countValues ( arr , N , L , R ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def minCollectingSpeed ( piles , H ) : NEW_LINE",
        "explain": "Function to find the minimum number of coins to be collected per hour to empty N piles in H hours"
    },
    {
        "py": "ans = - 1 NEW_LINE low = 1 NEW_LINE",
        "explain": "Stores the minimum coins to be removed per hour"
    },
    {
        "py": "high = max ( piles ) NEW_LINE",
        "explain": "Find the maximum array element"
    },
    {
        "py": "while ( low <= high ) : NEW_LINE",
        "explain": "Perform Binary Search"
    },
    {
        "py": "K = low + ( high - low ) // 2 NEW_LINE time = 0 NEW_LINE",
        "explain": "Store the mid value of the range in K"
    },
    {
        "py": "for ai in piles : NEW_LINE time += ( ai + K - 1 ) // K NEW_LINE",
        "explain": "Find the total time taken to empty N piles by removing K coins per hour"
    },
    {
        "py": "if ( time <= H ) : NEW_LINE INDENT ans = K NEW_LINE high = K - 1 NEW_LINE DEDENT",
        "explain": "If total time does not exceed H"
    },
    {
        "py": "else : NEW_LINE INDENT low = K + 1 NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Prthe required result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 7 , 11 ] NEW_LINE H = 8 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "minCollectingSpeed ( arr , H ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def cntDisPairs ( arr , N , K ) : NEW_LINE",
        "explain": "Function to count distinct pairs in array whose sum equal to K"
    },
    {
        "py": "cntPairs = 0 NEW_LINE",
        "explain": "Stores count of distinct pairs whose sum equal to K"
    },
    {
        "py": "arr = sorted ( arr ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "i = 0 NEW_LINE",
        "explain": "Stores index of the left pointer"
    },
    {
        "py": "j = N - 1 NEW_LINE",
        "explain": "Stores index of the right pointer"
    },
    {
        "py": "while ( i < j ) : NEW_LINE",
        "explain": "Calculate count of distinct pairs whose sum equal to K"
    },
    {
        "py": "if ( arr [ i ] + arr [ j ] == K ) : NEW_LINE",
        "explain": "If sum of current pair is equal to K"
    },
    {
        "py": "while ( i < j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE",
        "explain": "Remove consecutive duplicate array elements"
    },
    {
        "py": "i += 1 NEW_LINE",
        "explain": "Update i"
    },
    {
        "py": "while ( i < j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE",
        "explain": "Remove consecutive duplicate array elements"
    },
    {
        "py": "j -= 1 NEW_LINE",
        "explain": "Update j"
    },
    {
        "py": "cntPairs += 1 NEW_LINE",
        "explain": "Update cntPairs"
    },
    {
        "py": "i += 1 NEW_LINE",
        "explain": "Update i"
    },
    {
        "py": "j -= 1 NEW_LINE",
        "explain": "Update j"
    },
    {
        "py": "elif ( arr [ i ] + arr [ j ] < K ) : NEW_LINE",
        "explain": "If sum of current pair less than K"
    },
    {
        "py": "i += 1 NEW_LINE else : NEW_LINE",
        "explain": "Update i"
    },
    {
        "py": "j -= 1 NEW_LINE return cntPairs NEW_LINE",
        "explain": "Update j"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( cntDisPairs ( arr , N , K ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def cntDisPairs ( arr , N , K ) : NEW_LINE",
        "explain": "Function to count distinct pairs in array whose sum equal to K"
    },
    {
        "py": "cntPairs = 0 NEW_LINE",
        "explain": "Stores count of distinct pairs whose sum equal to K"
    },
    {
        "py": "cntFre = { } NEW_LINE for i in arr : NEW_LINE",
        "explain": "Store frequency of each distinct element of the array"
    },
    {
        "py": "if i in cntFre : NEW_LINE INDENT cntFre [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntFre [ i ] = 1 NEW_LINE DEDENT",
        "explain": "Update frequency of arr [ i ]"
    },
    {
        "py": "for key , value in cntFre . items ( ) : NEW_LINE",
        "explain": "Traverse the map"
    },
    {
        "py": "i = key NEW_LINE",
        "explain": "Stores key value of the map"
    },
    {
        "py": "if ( 2 * i == K ) : NEW_LINE",
        "explain": "If i is the half of K"
    },
    {
        "py": "if ( cntFre [ i ] > 1 ) : NEW_LINE INDENT cntPairs += 2 NEW_LINE DEDENT else : NEW_LINE if ( cntFre [ K - i ] ) : NEW_LINE",
        "explain": "If frequency of i greater than 1"
    },
    {
        "py": "cntPairs += 1 NEW_LINE",
        "explain": "Update cntPairs"
    },
    {
        "py": "cntPairs = cntPairs / 2 NEW_LINE return cntPairs NEW_LINE",
        "explain": "Update cntPairs"
    },
    {
        "py": "arr = [ 5 , 6 , 5 , 7 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 13 NEW_LINE print ( int ( cntDisPairs ( arr , N , K ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT for i in range ( Q ) : NEW_LINE DEDENT",
        "explain": "Function to find the length of the longest subsequence such that no two adjacent elements are equal"
    },
    {
        "py": "x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE",
        "explain": "Replace element at index x with y"
    },
    {
        "py": "arr [ x - 1 ] = y NEW_LINE",
        "explain": "Since x is 1 - indexed , decrement x by 1"
    },
    {
        "py": "count = 1 NEW_LINE for j in range ( 1 , N ) : NEW_LINE",
        "explain": "Keep track of number of elements in subsequence"
    },
    {
        "py": "if ( arr [ j ] != arr [ j - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "If previous element is not same as current element"
    },
    {
        "py": "print ( count , end = ' \u2581 ' ) NEW_LINE",
        "explain": "Print the desired count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Q = 2 NEW_LINE Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "longestSubsequence ( N , Q , arr , Queries ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def longestSubsequence ( N , Q , arr , Queries ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if ( arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "If previous element is not same as current element"
    },
    {
        "py": "for i in range ( Q ) : NEW_LINE",
        "explain": "Traverse the queries"
    },
    {
        "py": "x = Queries [ i ] [ 0 ] NEW_LINE y = Queries [ i ] [ 1 ] NEW_LINE",
        "explain": "Replace element at index x with y"
    },
    {
        "py": "if ( x > 1 ) : NEW_LINE",
        "explain": "Recalculate for index x"
    },
    {
        "py": "if ( arr [ x - 1 ] != arr [ x - 2 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT",
        "explain": "Subtract contribution of element at index x"
    },
    {
        "py": "if ( arr [ x - 2 ] != y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Add contribution of y"
    },
    {
        "py": "if ( x < N ) : NEW_LINE",
        "explain": "Recalculate for index x + 1"
    },
    {
        "py": "if ( arr [ x ] != arr [ x - 1 ] ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT",
        "explain": "Subtract contribution of element at index x + 1"
    },
    {
        "py": "if ( y != arr [ x ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count , end = ' \u2581 ' ) NEW_LINE",
        "explain": "Adds contribution of y"
    },
    {
        "py": "arr [ x - 1 ] = y NEW_LINE",
        "explain": "Replace the element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 5 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE Q = 2 NEW_LINE Queries = [ [ 1 , 3 ] , [ 4 , 2 ] ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "longestSubsequence ( N , Q , arr , Queries ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def sum_i ( arr , n ) : NEW_LINE",
        "explain": "Function to find sum of differences of indices of occurrences of each unique array element"
    },
    {
        "py": "mp = defaultdict ( lambda : [ ] ) NEW_LINE",
        "explain": "Stores indices of each array element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] . append ( i ) NEW_LINE DEDENT",
        "explain": "Store the indices"
    },
    {
        "py": "ans = [ 0 ] * n NEW_LINE",
        "explain": "Stores the sums"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Find sum for each element"
    },
    {
        "py": "for it in mp [ arr [ i ] ] : NEW_LINE",
        "explain": "Iterate over the Map"
    },
    {
        "py": "sum += abs ( it - i ) NEW_LINE",
        "explain": "Calculate sum of occurrences of arr [ i ]"
    },
    {
        "py": "ans [ i ] = sum NEW_LINE",
        "explain": "Store sum for current element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print answer for each element"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 1 , 3 , 1 , 1 , 2 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "n = len ( arr ) NEW_LINE",
        "explain": "Given size"
    },
    {
        "py": "sum_i ( arr , n ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def conVowUpp ( str ) : NEW_LINE",
        "explain": "Function to convert vowels into uppercase"
    },
    {
        "py": "N = len ( str ) NEW_LINE str1 = \" \" NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) : NEW_LINE INDENT c = ( str [ i ] ) . upper ( ) NEW_LINE str1 += c NEW_LINE DEDENT else : NEW_LINE INDENT str1 += str [ i ] NEW_LINE DEDENT DEDENT print ( str1 ) NEW_LINE",
        "explain": "Stores the length of str"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" eutopia \" NEW_LINE conVowUpp ( str ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "mp = { } NEW_LINE N , P = 0 , 0 NEW_LINE",
        "explain": "Stores the frequency of each type of chocolate"
    },
    {
        "py": "def helper ( mid ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in mp : NEW_LINE INDENT temp = mp [ i ] NEW_LINE while ( temp >= mid ) : NEW_LINE INDENT temp -= mid NEW_LINE cnt += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to check if chocolates can be eaten for ' mid ' no . of days"
    },
    {
        "py": "return cnt >= N NEW_LINE",
        "explain": "If cnt exceeds N , return true"
    },
    {
        "py": "def findMaximumDays ( arr ) : NEW_LINE",
        "explain": "Function to find the maximum number of days for which chocolates can be eaten"
    },
    {
        "py": "for i in range ( P ) : NEW_LINE INDENT mp [ arr [ i ] ] = mp . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Store the frequency of each type of chocolate"
    },
    {
        "py": "start = 0 NEW_LINE end = P NEW_LINE ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE",
        "explain": "Initialize start and end with 0 and P respectively"
    },
    {
        "py": "mid = start + ( ( end - start ) // 2 ) NEW_LINE",
        "explain": "Calculate mid"
    },
    {
        "py": "if ( mid != 0 and helper ( mid ) ) : NEW_LINE INDENT ans = mid NEW_LINE DEDENT",
        "explain": "Check if chocolates can be distributed for mid days"
    },
    {
        "py": "start = mid + 1 NEW_LINE elif ( mid == 0 ) : NEW_LINE start = mid + 1 NEW_LINE else : NEW_LINE end = mid - 1 NEW_LINE return ans NEW_LINE",
        "explain": "Check if chocolates can be distributed for more than mid consecutive days"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE P = 10 NEW_LINE arr = [ 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 ] NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( findMaximumDays ( arr ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def countSubarrays ( a , n , k ) : NEW_LINE",
        "explain": "Function that counts the subarrays having sum modulo k equal to the length of subarray"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the count of subarrays"
    },
    {
        "py": "pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE",
        "explain": "Stores prefix sum of the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT",
        "explain": "Calculate prefix sum array"
    },
    {
        "py": "for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , 1 ) : NEW_LINE DEDENT",
        "explain": "Generate all the subarrays"
    },
    {
        "py": "if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT",
        "explain": "Check if this subarray is a valid subarray or not"
    },
    {
        "py": "print ( ans , end = ' \u2581 ' ) NEW_LINE",
        "explain": "Total count of subarrays"
    },
    {
        "py": "arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] NEW_LINE",
        "explain": "Given arr [ ]"
    },
    {
        "py": "N = len ( arr ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "K = 4 NEW_LINE",
        "explain": "Given K"
    },
    {
        "py": "countSubarrays ( arr , N , K ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def countSubarrays ( a , n , k ) : NEW_LINE",
        "explain": "Function that counts the subarrays s . t . sum of elements in the subarray modulo k is equal to size of subarray"
    },
    {
        "py": "cnt = { } NEW_LINE",
        "explain": "Stores the count of ( pref [ i ] - i ) % k"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the count of subarray"
    },
    {
        "py": "pref = [ ] NEW_LINE pref . append ( 0 ) NEW_LINE",
        "explain": "Stores prefix sum of the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT pref . append ( ( a [ i ] + pref [ i ] ) % k ) NEW_LINE DEDENT",
        "explain": "Find prefix sum array"
    },
    {
        "py": "cnt [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Base Condition"
    },
    {
        "py": "remIdx = i - k NEW_LINE if ( remIdx >= 0 ) : NEW_LINE INDENT if ( ( pref [ remIdx ] - remIdx % k + k ) % k in cnt ) : NEW_LINE INDENT cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] = - 1 NEW_LINE DEDENT DEDENT",
        "explain": "Remove the index at present after K indices from the current index"
    },
    {
        "py": "if ( pref [ i ] - i % k + k ) % k in cnt : NEW_LINE INDENT ans += cnt [ ( pref [ i ] - i % k + k ) % k ] NEW_LINE DEDENT",
        "explain": "Update the answer for subarrays ending at the i - th index"
    },
    {
        "py": "if ( pref [ i ] - i % k + k ) % k in cnt : NEW_LINE INDENT cnt [ ( pref [ i ] - i % k + k ) % k ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ ( pref [ i ] - i % k + k ) % k ] = 1 NEW_LINE DEDENT",
        "explain": "Add the calculated value of current index to count"
    },
    {
        "py": "print ( ans , end = ' \u2581 ' ) NEW_LINE",
        "explain": "Print the count of subarrays"
    },
    {
        "py": "arr = [ 2 , 3 , 5 , 3 , 1 , 5 ] NEW_LINE",
        "explain": "Given arr [ ]"
    },
    {
        "py": "N = len ( arr ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "K = 4 NEW_LINE",
        "explain": "Given K"
    },
    {
        "py": "countSubarrays ( arr , N , K ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def check ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to check if the substring of length K has equal 0 and 1"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE INDENT for j in range ( i , n , k ) : NEW_LINE DEDENT",
        "explain": "Traverse the string"
    },
    {
        "py": "if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = 0 NEW_LINE",
        "explain": "Check if every K - th character is the same or not"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE",
        "explain": "Traverse substring of length K"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE",
        "explain": "If current character is 0"
    },
    {
        "py": "c += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "c -= 1 NEW_LINE",
        "explain": "Decrement count"
    },
    {
        "py": "if ( c == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check for equal 0 s and 1 s"
    },
    {
        "py": "s = \"101010\" NEW_LINE k = 2 NEW_LINE if ( check ( s , k ) != 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def isSame ( str , n ) : NEW_LINE",
        "explain": "Function to check if the freq of any character is divisible by N"
    },
    {
        "py": "mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT mp [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for it in mp . keys ( ) : NEW_LINE",
        "explain": "Stores the frequency of characters"
    },
    {
        "py": "if ( mp [ it ] >= n ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "If frequency of a character is not divisible by n"
    },
    {
        "py": "return False NEW_LINE",
        "explain": "If no character has frequency at least N"
    },
    {
        "py": "str = \" ccabcba \" NEW_LINE n = 4 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "if ( isSame ( str , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "import math NEW_LINE eps = 1e-6 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def func ( a , b , c , x ) : NEW_LINE INDENT return a * x * x + b * x + c NEW_LINE DEDENT",
        "explain": "Given function"
    },
    {
        "py": "def findRoot ( a , b , c , low , high ) : NEW_LINE INDENT x = - 1 NEW_LINE DEDENT",
        "explain": "Function to find the root of the given non - decreasing Function"
    },
    {
        "py": "while abs ( high - low ) > eps : NEW_LINE",
        "explain": "To get the minimum possible answer for the root"
    },
    {
        "py": "x = ( low + high ) / 2 NEW_LINE",
        "explain": "Find mid"
    },
    {
        "py": "if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) : NEW_LINE INDENT high = x NEW_LINE DEDENT",
        "explain": "Search in [ low , x ]"
    },
    {
        "py": "else : NEW_LINE INDENT low = x NEW_LINE DEDENT",
        "explain": "Search in [ x , high ]"
    },
    {
        "py": "return x NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "def solve ( a , b , c , A , B ) : NEW_LINE",
        "explain": "Function to find the roots of the given equation within range [ a , b ]"
    },
    {
        "py": "if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) : NEW_LINE INDENT print ( \" No \u2581 solution \" ) NEW_LINE DEDENT",
        "explain": "If root doesn 't exists"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" { : . 4f } \" . format ( findRoot ( a , b , c , A , B ) ) ) NEW_LINE DEDENT",
        "explain": "Else find the root upto 4 decimal places"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "a = 2 NEW_LINE b = - 3 NEW_LINE c = - 2 NEW_LINE A = 0 NEW_LINE B = 3 NEW_LINE",
        "explain": "Given range"
    },
    {
        "py": "solve ( a , b , c , A , B ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def possible ( mid , a ) : NEW_LINE",
        "explain": "Function check if mid can be median index of the difference array"
    },
    {
        "py": "n = len ( a ) ; NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "total = ( n * ( n - 1 ) ) // 2 ; NEW_LINE",
        "explain": "Total possible no of pair possible"
    },
    {
        "py": "need = ( total + 1 ) // 2 ; NEW_LINE count = 0 ; NEW_LINE start = 0 ; end = 1 ; NEW_LINE",
        "explain": "The index of the element in the difference of all pairs from the array"
    },
    {
        "py": "while ( end < n ) : NEW_LINE INDENT if ( a [ end ] - a [ start ] <= mid ) : NEW_LINE INDENT end += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( end - start - 1 ) ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Count the number of pairs having difference <= mid"
    },
    {
        "py": "if ( end == n and start < end and a [ end - 1 ] - a [ start ] <= mid ) : NEW_LINE INDENT t = end - start - 1 ; NEW_LINE count += ( t * ( t + 1 ) // 2 ) ; NEW_LINE DEDENT",
        "explain": "If the difference between end and first element is less then or equal to mid"
    },
    {
        "py": "if ( count >= need ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT",
        "explain": "Checking for the no of element less than or equal to mid is greater than median or not"
    },
    {
        "py": "def findMedian ( a ) : NEW_LINE",
        "explain": "Function to calculate the median of differences of all pairs from the array"
    },
    {
        "py": "n = len ( a ) ; NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "low = 0 ; high = a [ n - 1 ] - a [ 0 ] ; NEW_LINE",
        "explain": "Initialising the low and high"
    },
    {
        "py": "while ( low <= high ) : NEW_LINE",
        "explain": "Binary search"
    },
    {
        "py": "mid = ( low + high ) // 2 ; NEW_LINE",
        "explain": "Calculate mid"
    },
    {
        "py": "if ( possible ( mid , a ) ) : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT",
        "explain": "If mid can be the median of the array"
    },
    {
        "py": "return high + 1 ; NEW_LINE",
        "explain": "Returning the median of the differences of pairs from the array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 7 , 5 , 2 ] ; NEW_LINE a . sort ( ) NEW_LINE print ( findMedian ( a ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def UniversalSubset ( A , B ) : NEW_LINE",
        "explain": "Function to find strings from A [ ] having all strings in B [ ] as subsequence"
    },
    {
        "py": "n1 = len ( A ) NEW_LINE n2 = len ( B ) NEW_LINE",
        "explain": "Calculate respective sizes"
    },
    {
        "py": "res = [ ] NEW_LINE",
        "explain": "Stores the answer"
    },
    {
        "py": "A_freq = [ [ 0 for x in range ( 26 ) ] for y in range ( n1 ) ] NEW_LINE",
        "explain": "Stores the frequency of each character in strings of A [ ]"
    },
    {
        "py": "for i in range ( n1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT A_freq [ i ] [ ord ( A [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Compute the frequencies of characters of all strings"
    },
    {
        "py": "B_freq = [ 0 ] * 26 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT arr = [ 0 ] * 26 NEW_LINE for j in range ( len ( B [ i ] ) ) : NEW_LINE INDENT arr [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE B_freq [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] = max ( B_freq [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] , arr [ ord ( B [ i ] [ j ] ) - ord ( ' a ' ) ] ) NEW_LINE DEDENT DEDENT for i in range ( n1 ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE DEDENT",
        "explain": "Stores the frequency of each character in strings of B [ ] each character of a string in B [ ]"
    },
    {
        "py": "if ( A_freq [ i ] [ j ] < B_freq [ j ] ) : NEW_LINE",
        "explain": "If the frequency of a character in B [ ] exceeds that in A [ ]"
    },
    {
        "py": "flag = 1 NEW_LINE break NEW_LINE",
        "explain": "A string exists in B [ ] which is not a proper subset of A [ i ]"
    },
    {
        "py": "if ( flag == 0 ) : NEW_LINE",
        "explain": "If all strings in B [ ] are proper subset of A [ ]"
    },
    {
        "py": "res . append ( A [ i ] ) NEW_LINE",
        "explain": "Push the string in resultant vector"
    },
    {
        "py": "if ( len ( res ) ) : NEW_LINE",
        "explain": "If any string is found"
    },
    {
        "py": "for i in range ( len ( res ) ) : NEW_LINE INDENT for j in range ( len ( res [ i ] ) ) : NEW_LINE INDENT print ( res [ i ] [ j ] , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Print those strings"
    },
    {
        "py": "else : NEW_LINE INDENT print ( - 1 , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ \" geeksforgeeks \" , \" topcoder \" , \" leetcode \" ] NEW_LINE B = [ \" geek \" , \" ee \" ] NEW_LINE UniversalSubset ( A , B ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def findPair ( a , n ) : NEW_LINE",
        "explain": "Function to find the minimum distance pair where one is the multiple of the other"
    },
    {
        "py": "min_dist = sys . maxsize NEW_LINE index_a = - 1 NEW_LINE index_b = - 1 NEW_LINE",
        "explain": "Initialize the variables"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate for all the elements"
    },
    {
        "py": "for j in range ( i + 1 , n ) : NEW_LINE",
        "explain": "Loop to make pairs"
    },
    {
        "py": "if ( j - i < min_dist ) : NEW_LINE",
        "explain": "Check for minimum distance"
    },
    {
        "py": "if ( ( a [ i ] % a [ j ] == 0 ) or ( a [ j ] % a [ i ] == 0 ) ) : NEW_LINE",
        "explain": "Check if one is a multiple of other"
    },
    {
        "py": "min_dist = j - i NEW_LINE",
        "explain": "Update the distance"
    },
    {
        "py": "index_a = i NEW_LINE index_b = j NEW_LINE",
        "explain": "Store indexes"
    },
    {
        "py": "if ( index_a == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "If no such pair exists"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" ( \" , a [ index_a ] , \" , \u2581 \" , a [ index_b ] , \" ) \" ) NEW_LINE DEDENT",
        "explain": "Print the answer"
    },
    {
        "py": "a = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "findPair ( a , n ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def printNum ( L , R ) : NEW_LINE",
        "explain": "Function to print all numbers in the range [ L , R ] having digits in strictly increasing order"
    },
    {
        "py": "for i in range ( L , R + 1 ) : NEW_LINE INDENT temp = i NEW_LINE c = 10 NEW_LINE flag = 0 NEW_LINE DEDENT",
        "explain": "Iterate over the range"
    },
    {
        "py": "while ( temp > 0 ) : NEW_LINE",
        "explain": "Iterate over the digits"
    },
    {
        "py": "if ( temp % 10 >= c ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT c = temp % 10 NEW_LINE temp //= 10 NEW_LINE",
        "explain": "Check if the current digit is >= the previous digit"
    },
    {
        "py": "if ( flag == 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If the digits are in ascending order"
    },
    {
        "py": "L = 10 NEW_LINE R = 15 NEW_LINE",
        "explain": "Given range L and R"
    },
    {
        "py": "printNum ( L , R ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def findMissing ( arr , left , right , diff ) : NEW_LINE",
        "explain": "Function to find the missing element"
    },
    {
        "py": "if ( right <= left ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT",
        "explain": "Fix left and right boundary for binary search"
    },
    {
        "py": "mid = left + ( right - left ) // 2 NEW_LINE",
        "explain": "Find index of middle element"
    },
    {
        "py": "if ( arr [ mid + 1 ] - arr [ mid ] != diff ) : NEW_LINE INDENT return ( arr [ mid ] + diff ) NEW_LINE DEDENT",
        "explain": "Check if the element just after the middle element is missing"
    },
    {
        "py": "if ( mid > 0 and arr [ mid ] - arr [ mid - 1 ] != diff ) : NEW_LINE INDENT return ( arr [ mid - 1 ] + diff ) NEW_LINE DEDENT",
        "explain": "Check if the element just before mid is missing"
    },
    {
        "py": "if ( arr [ mid ] == arr [ 0 ] + mid * diff ) : NEW_LINE INDENT return findMissing ( arr , mid + 1 , right , diff ) NEW_LINE DEDENT",
        "explain": "Check if the elements till mid follow the AP , then recur for right half"
    },
    {
        "py": "return findMissing ( arr , left , mid - 1 , diff ) NEW_LINE",
        "explain": "Else recur for left half"
    },
    {
        "py": "def missingElement ( arr , n ) : NEW_LINE",
        "explain": "Function to find the missing element in AP series"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array arr [ ]"
    },
    {
        "py": "diff = ( arr [ n - 1 ] - arr [ 0 ] ) // n NEW_LINE",
        "explain": "Calculate Common Difference"
    },
    {
        "py": "return findMissing ( arr , 0 , n - 1 , diff ) NEW_LINE",
        "explain": "Binary search for the missing"
    },
    {
        "py": "arr = [ 2 , 8 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "print ( missingElement ( arr , n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def power ( x , y ) : NEW_LINE INDENT if ( y == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = power ( x , y // 2 ) ; NEW_LINE if ( y % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return x * temp * temp ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to calculate x raised to the power y in O ( logn )"
    },
    {
        "py": "def nthRootSearch ( low , high , N , K ) : NEW_LINE",
        "explain": "Function to find the Kth root of the number N using BS"
    },
    {
        "py": "if ( low <= high ) : NEW_LINE",
        "explain": "If the range is still valid"
    },
    {
        "py": "mid = ( low + high ) // 2 ; NEW_LINE",
        "explain": "Find the mid - value of range"
    },
    {
        "py": "if ( ( power ( mid , K ) <= N ) and ( power ( mid + 1 , K ) > N ) ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "elif ( power ( mid , K ) < N ) : NEW_LINE INDENT return nthRootSearch ( mid + 1 , high , N , K ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return nthRootSearch ( low , mid - 1 , N , K ) ; NEW_LINE DEDENT return low ; NEW_LINE",
        "explain": "Condition to check if the left search space is useless"
    },
    {
        "py": "N = 16 ; K = 4 ; NEW_LINE",
        "explain": "Given N and K"
    },
    {
        "py": "print ( nthRootSearch ( 0 , N , N , K ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def get_subset_count ( arr , K , N ) : NEW_LINE",
        "explain": "Function that return the count of subset such that min ( S ) + max ( S ) < K"
    },
    {
        "py": "arr . sort ( ) NEW_LINE left = 0 ; NEW_LINE right = N - 1 ; NEW_LINE",
        "explain": "Sorting the array"
    },
    {
        "py": "ans = 0 ; NEW_LINE while ( left <= right ) : NEW_LINE INDENT if ( arr [ left ] + arr [ right ] < K ) : NEW_LINE DEDENT",
        "explain": "ans stores total number of subsets"
    },
    {
        "py": "ans += 1 << ( right - left ) ; NEW_LINE left += 1 ; NEW_LINE else : NEW_LINE",
        "explain": "Add all possible subsets between i and j"
    },
    {
        "py": "right -= 1 ; NEW_LINE return ans ; NEW_LINE",
        "explain": "Decrease the sum"
    },
    {
        "py": "arr = [ 2 , 4 , 5 , 7 ] ; NEW_LINE K = 8 ; NEW_LINE print ( get_subset_count ( arr , K , 4 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minMaxDiff ( arr , n , k ) : NEW_LINE INDENT max_adj_dif = float ( ' - inf ' ) ; NEW_LINE DEDENT",
        "explain": "Python3 program to find the minimum of maximum difference between adjacent elements after at most K insertions"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE INDENT max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; NEW_LINE DEDENT",
        "explain": "Calculate the maximum adjacent difference"
    },
    {
        "py": "if ( max_adj_dif == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "If the maximum adjacent difference is already zero"
    },
    {
        "py": "best = 1 ; NEW_LINE worst = max_adj_dif ; NEW_LINE while ( best < worst ) : NEW_LINE INDENT mid = ( best + worst ) // 2 ; NEW_LINE DEDENT",
        "explain": "best and worst specifies range of the maximum adjacent difference"
    },
    {
        "py": "required = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) // mid NEW_LINE DEDENT",
        "explain": "To store the no of insertions required for respective values of mid"
    },
    {
        "py": "if ( required > k ) : NEW_LINE INDENT best = mid + 1 ; NEW_LINE DEDENT",
        "explain": "If the number of insertions required exceeds K"
    },
    {
        "py": "else : NEW_LINE INDENT worst = mid NEW_LINE DEDENT return worst NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "arr = [ 3 , 12 , 25 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( minMaxDiff ( arr , n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation to Check if the minimum element in the array is greater than or equal to half of every other element"
    },
    {
        "py": "def checkMin ( arr , n ) : NEW_LINE",
        "explain": "Function to Check if the minimum element in the array is greater than or equal to half of every other element"
    },
    {
        "py": "smallest = math . inf NEW_LINE secondSmallest = math . inf NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Initialise the variables to store smallest and second smallest"
    },
    {
        "py": "if ( arr [ i ] < smallest ) : NEW_LINE INDENT secondSmallest = smallest NEW_LINE smallest = arr [ i ] NEW_LINE DEDENT",
        "explain": "Check if current element is smaller than smallest , the current smallest will become secondSmallest and current element will be the new smallest"
    },
    {
        "py": "elif ( arr [ i ] < secondSmallest ) : NEW_LINE INDENT secondSmallest = arr [ i ] NEW_LINE DEDENT if ( 2 * smallest <= secondSmallest ) : NEW_LINE print ( \" Yes \" ) NEW_LINE else : NEW_LINE print ( \" No \" ) NEW_LINE",
        "explain": "Check if current element is smaller than secondSmallest simply update the latter"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE checkMin ( arr , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python 3 program to find minimum and maximum fibonacci number in given array"
    },
    {
        "py": "def createHash ( hash , maxElement ) : NEW_LINE",
        "explain": "Function to create hash table to check Fibonacci numbers"
    },
    {
        "py": "prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE",
        "explain": "Insert initial two numbers in the hash table"
    },
    {
        "py": "temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE",
        "explain": "Sum of previous two numbers"
    },
    {
        "py": "prev = curr NEW_LINE curr = temp NEW_LINE",
        "explain": "Update the variable each time"
    },
    {
        "py": "def fibonacci ( arr , n ) : NEW_LINE",
        "explain": "Function to find minimum and maximum fibonacci number in given array"
    },
    {
        "py": "max_val = max ( arr ) NEW_LINE",
        "explain": "Find maximum value in the array"
    },
    {
        "py": "hash = set ( ) NEW_LINE createHash ( hash , max_val ) NEW_LINE",
        "explain": "Creating a set containing all Fibonacci numbers up to maximum value in the array"
    },
    {
        "py": "minimum = sys . maxsize NEW_LINE maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "For storing the Minimum and Maximum Fibonacci number"
    },
    {
        "py": "if ( arr [ i ] in hash ) : NEW_LINE",
        "explain": "Check if current element is a fibonacci number"
    },
    {
        "py": "minimum = min ( minimum , arr [ i ] ) NEW_LINE maximum = max ( maximum , arr [ i ] ) NEW_LINE print ( minimum , end = \" , \u2581 \" ) NEW_LINE print ( maximum ) NEW_LINE",
        "explain": "Update the maximum and minimum accordingly"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fibonacci ( arr , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isValidLen ( s , lenn , k ) : NEW_LINE",
        "explain": "Function that returns True if there is a sub of length len with <= k unique characters"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "Size of the"
    },
    {
        "py": "mp = dict ( ) NEW_LINE right = 0 NEW_LINE",
        "explain": "Map to store the characters and their frequency"
    },
    {
        "py": "while ( right < lenn ) : NEW_LINE INDENT mp [ s [ right ] ] = mp . get ( s [ right ] , 0 ) + 1 NEW_LINE right += 1 NEW_LINE DEDENT if ( len ( mp ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Update the map for the first sub"
    },
    {
        "py": "while ( right < n ) : NEW_LINE",
        "explain": "Check for the rest of the subs"
    },
    {
        "py": "mp [ s [ right ] ] = mp . get ( s [ right ] , 0 ) + 1 NEW_LINE",
        "explain": "Add the new character"
    },
    {
        "py": "mp [ s [ right - lenn ] ] -= 1 NEW_LINE",
        "explain": "Remove the first character of the previous window"
    },
    {
        "py": "if ( mp [ s [ right - lenn ] ] == 0 ) : NEW_LINE INDENT del mp [ s [ right - lenn ] ] NEW_LINE DEDENT if ( len ( mp ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT right += 1 NEW_LINE return len ( mp ) <= k NEW_LINE",
        "explain": "Update the map"
    },
    {
        "py": "def maxLenSubStr ( s , k ) : NEW_LINE",
        "explain": "Function to return the length of the longest sub which has K unique characters"
    },
    {
        "py": "uni = dict ( ) NEW_LINE for x in s : NEW_LINE INDENT uni [ x ] = 1 NEW_LINE DEDENT if ( len ( uni ) < k ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Check if the complete contains K unique characters"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "Size of the"
    },
    {
        "py": "lo = - 1 NEW_LINE hi = n + 1 NEW_LINE while ( hi - lo > 1 ) : NEW_LINE INDENT mid = lo + hi >> 1 NEW_LINE if ( isValidLen ( s , mid , k ) ) : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT DEDENT return lo NEW_LINE",
        "explain": "Apply binary search"
    },
    {
        "py": "s = \" aabacbebebe \" NEW_LINE k = 3 NEW_LINE print ( maxLenSubStr ( s , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isSquarePossible ( arr , n , l ) : NEW_LINE",
        "explain": "Function that returns true if it is possible to make a square with side equal to l"
    },
    {
        "py": "cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store the count of elements greater than or equal to l"
    },
    {
        "py": "if arr [ i ] >= l : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT",
        "explain": "Increment the count"
    },
    {
        "py": "if cnt >= l : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If the count becomes greater than or equal to l"
    },
    {
        "py": "def maxArea ( arr , n ) : NEW_LINE INDENT l , r = 0 , n NEW_LINE len = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the maximum area of the square that can be obtained"
    },
    {
        "py": "if isSquarePossible ( arr , n , m ) : NEW_LINE INDENT len = m NEW_LINE l = m + 1 NEW_LINE DEDENT",
        "explain": "If square is possible with side length m"
    },
    {
        "py": "else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT",
        "explain": "Try to find a square with smaller side length"
    },
    {
        "py": "return ( len * len ) NEW_LINE",
        "explain": "Return the area"
    },
    {
        "py": "arr = [ 1 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxArea ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def insertNames ( arr , n ) : NEW_LINE",
        "explain": "Function to insert the names and check whether they appear for the first time"
    },
    {
        "py": "string = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store the names of the employees"
    },
    {
        "py": "if arr [ i ] not in string : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE string . add ( arr [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT",
        "explain": "If current name is appearing for the first time"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ \" geeks \" , \" for \" , \" geeks \" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE insertNames ( arr , n ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countLessThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE DEDENT",
        "explain": "Function to return the count of elements in arr [ ] which are less than the given key"
    },
    {
        "py": "while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] < key ) : NEW_LINE INDENT l = m + 1 NEW_LINE index = m NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( index + 1 ) NEW_LINE",
        "explain": "Modified binary search"
    },
    {
        "py": "def countGreaterThan ( arr , n , key ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE index = - 1 NEW_LINE DEDENT",
        "explain": "Function to return the count of elements in arr [ ] which are greater than the given key"
    },
    {
        "py": "while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 NEW_LINE if ( arr [ m ] <= key ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE index = m NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n - index ) NEW_LINE",
        "explain": "Modified binary search"
    },
    {
        "py": "def countTriplets ( n , a , b , c ) : NEW_LINE",
        "explain": "Function to return the count of the required triplets"
    },
    {
        "py": "a . sort NEW_LINE b . sort ( ) NEW_LINE c . sort ( ) NEW_LINE count = 0 NEW_LINE",
        "explain": "Sort all three arrays"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT current = b [ i ] NEW_LINE a_index = - 1 NEW_LINE c_index = - 1 NEW_LINE DEDENT",
        "explain": "Iterate for all the elements of array B"
    },
    {
        "py": "low = countLessThan ( a , n , current ) NEW_LINE",
        "explain": "Count of elements in A [ ] which are less than the chosen element from B [ ]"
    },
    {
        "py": "high = countGreaterThan ( c , n , current ) NEW_LINE",
        "explain": "Count of elements in C [ ] which are greater than the chosen element from B [ ]"
    },
    {
        "py": "count += ( low * high ) NEW_LINE return count NEW_LINE",
        "explain": "Update the count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 5 ] NEW_LINE b = [ 2 , 4 ] NEW_LINE c = [ 3 , 6 ] NEW_LINE size = len ( a ) NEW_LINE print ( countTriplets ( size , a , b , c ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def costToBalance ( s ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT",
        "explain": "Python 3 code to calculate the minimum cost to make the given parentheses balanced"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "To store absolute count of balanced and unbalanced parenthesis"
    },
    {
        "py": "' NEW_LINE INDENT o = 0 NEW_LINE c = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT o += 1 NEW_LINE DEDENT if ( s [ i ] == ' ) ' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( o != c ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = [ 0 for i in range ( len ( s ) ) ] NEW_LINE if ( s [ 0 ] == ' ( ' ) : NEW_LINE INDENT a [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ 0 ] = - 1 NEW_LINE DEDENT if ( a [ 0 ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ 0 ] ) NEW_LINE DEDENT for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] = a [ i - 1 ] - 1 NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT ans += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT",
        "explain": "o ( open bracket ) stores count of ' ( ' and c ( close bracket ) stores count of ')"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : s = \" ) ) ) ( ( ( \" NEW_LINE INDENT print ( costToBalance ( s ) ) s = \" ) ) ( ( \" NEW_LINE print ( costToBalance ( s ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def middleOfThree ( a , b , c ) : NEW_LINE",
        "explain": "Function to find the middle of three number"
    },
    {
        "py": "x = a - b NEW_LINE",
        "explain": "x is positive if a is greater than b . x is negative if b is greater than a ."
    },
    {
        "py": "y = b - c NEW_LINE",
        "explain": "Similar to x"
    },
    {
        "py": "z = a - c NEW_LINE",
        "explain": "Similar to x and y ."
    },
    {
        "py": "if x * y > 0 : NEW_LINE INDENT return b NEW_LINE DEDENT",
        "explain": "Checking if b is middle ( x and y both are positive )"
    },
    {
        "py": "elif ( x * z > 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT",
        "explain": "Checking if c is middle ( x and z both are positive )"
    },
    {
        "py": "a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def missing4 ( arr ) : NEW_LINE",
        "explain": "Finds missing 4 numbers in O ( N ) time and O ( 1 ) auxiliary space ."
    },
    {
        "py": "helper = [ 0 ] * 4 NEW_LINE",
        "explain": "To keep track of 4 possible numbers greater than length of input array In Java , helper is automatically initialized as 0."
    },
    {
        "py": "for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT temp = abs ( arr [ i ] ) NEW_LINE DEDENT",
        "explain": "Traverse the input array and mark visited elements either by marking them as negative in arr [ ] or in helper [ ] ."
    },
    {
        "py": "if ( temp <= len ( arr ) ) : NEW_LINE INDENT arr [ temp - 1 ] = arr [ temp - 1 ] * ( - 1 ) NEW_LINE DEDENT",
        "explain": "If element is smaller than or equal to length , mark its presence in arr [ ]"
    },
    {
        "py": "elif ( temp > len ( arr ) ) : NEW_LINE INDENT if ( temp % len ( arr ) ) : NEW_LINE INDENT helper [ temp % len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT else : NEW_LINE INDENT helper [ ( temp % len ( arr ) ) + len ( arr ) - 1 ] = - 1 NEW_LINE DEDENT DEDENT",
        "explain": "Mark presence in helper [ ]"
    },
    {
        "py": "for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT print ( ( i + 1 ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( helper ) ) : NEW_LINE INDENT if ( helper [ i ] >= 0 ) : NEW_LINE INDENT print ( ( len ( arr ) + i + 1 ) , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Print all those elements whose presence is not marked ."
    },
    {
        "py": "arr = [ 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 ] NEW_LINE missing4 ( arr ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def lexiMiddleSmallest ( K , N ) : NEW_LINE",
        "explain": "Function that finds the middle the lexicographical smallest sequence"
    },
    {
        "py": "if ( K % 2 == 0 ) : NEW_LINE",
        "explain": "If K is even"
    },
    {
        "py": "print ( K // 2 , end = \" \u2581 \" ) NEW_LINE",
        "explain": "First element is K / 2"
    },
    {
        "py": "for i in range ( N - 1 ) : NEW_LINE INDENT print ( K , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE",
        "explain": "Remaining elements of the sequence are all integer K"
    },
    {
        "py": "a = [ ( K + 1 ) // 2 ] * ( N ) NEW_LINE",
        "explain": "Stores the sequence when K is odd"
    },
    {
        "py": "for i in range ( N // 2 ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , N / 2 ]"
    },
    {
        "py": "if ( a [ - 1 ] == 1 ) : NEW_LINE",
        "explain": "Check if the sequence ends with in 1 or not"
    },
    {
        "py": "del a [ - 1 ] NEW_LINE",
        "explain": "Remove the sequence ending in 1"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If it doesn 't end in 1"
    },
    {
        "py": "a [ - 1 ] -= 1 NEW_LINE",
        "explain": "Decrement by 1"
    },
    {
        "py": "while ( len ( a ) < N ) : NEW_LINE INDENT a . append ( K ) NEW_LINE DEDENT",
        "explain": "Insert K to the sequence till its size is N"
    },
    {
        "py": "for i in a : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Prthe sequence stored in the vector"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K , N = 2 , 4 NEW_LINE lexiMiddleSmallest ( K , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findLastElement ( arr , N ) : NEW_LINE",
        "explain": "Function to find the last remaining array element after repeatedly removing the smallest from pairs having absolute difference 2 or 0"
    },
    {
        "py": "arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE",
        "explain": "Sort the given array in ascending order"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( arr [ i ] - arr [ i - 1 ] != 0 \\ and arr [ i ] - arr [ i - 1 ] != 2 ) : NEW_LINE INDENT print ( \" - 1\" ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "If difference between adjacent elements is not equal to 0 or 2"
    },
    {
        "py": "print ( arr [ N - 1 ] ) ; NEW_LINE",
        "explain": "If operations can be performed"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 6 , 8 , 0 , 8 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE findLastElement ( arr , N ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxDivisions ( arr , N , X ) : NEW_LINE",
        "explain": "Function to count maximum subsets into which the given array can be split such that it satisfies the given condition"
    },
    {
        "py": "arr . sort ( reverse = True ) NEW_LINE",
        "explain": "Sort the array in decreasing order"
    },
    {
        "py": "maxSub = 0 ; NEW_LINE",
        "explain": "Stores count of subsets possible"
    },
    {
        "py": "size = 0 ; NEW_LINE",
        "explain": "Stores count of elements in current subset"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "size += 1 ; NEW_LINE",
        "explain": "Update size"
    },
    {
        "py": "if ( arr [ i ] * size >= X ) : NEW_LINE",
        "explain": "If product of the smallest element present in the current subset and size of current subset is >= K"
    },
    {
        "py": "maxSub += 1 ; NEW_LINE",
        "explain": "Update maxSub"
    },
    {
        "py": "size = 0 ; NEW_LINE print ( maxSub ) ; NEW_LINE",
        "explain": "Update size"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 1 , 3 , 3 , 7 ] ; NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) ; NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "X = 3 ; NEW_LINE maxDivisions ( arr , N , X ) ; NEW_LINE",
        "explain": "Given value of X"
    },
    {
        "py": "def maxPossibleSum ( arr , N ) : NEW_LINE",
        "explain": "Function to find maximum possible sum of second minimums in each quadruple"
    },
    {
        "py": "arr . sort ( ) NEW_LINE sum = 0 NEW_LINE j = N - 3 NEW_LINE while ( j >= 0 ) : NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "sum += arr [ j ] NEW_LINE j -= 3 NEW_LINE",
        "explain": "Add the second minimum"
    },
    {
        "py": "print ( sum ) NEW_LINE",
        "explain": "Print maximum possible sum"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = 8 NEW_LINE maxPossibleSum ( arr , N ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "def insertionSort ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE key = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE j = i - 1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to sort an array using insertion sort"
    },
    {
        "py": "while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE",
        "explain": "Move elements of arr [ 0. . i - 1 ] , that are greater than key to one position ahead of their current position"
    },
    {
        "py": "def printArray ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE DEDENT",
        "explain": "Function to print an array of size N"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , end \u2581 = \u2581 \" \" ) NEW_LINE",
        "explain": "Print the array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "insertionSort ( arr , N ) NEW_LINE printArray ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def getPairs ( arr , N , K ) : NEW_LINE",
        "explain": "Function to find the count required pairs"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores count of pairs"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( arr [ i ] > K * arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE",
        "explain": "Check if the condition is satisfied or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 2 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "getPairs ( arr , N , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def merge ( arr , temp , l , m , r , K ) : NEW_LINE",
        "explain": "Function to merge two sorted arrays"
    },
    {
        "py": "i = l NEW_LINE",
        "explain": "i : index to left subarray"
    },
    {
        "py": "j = m + 1 NEW_LINE",
        "explain": "j : index to right subarray"
    },
    {
        "py": "cnt = 0 NEW_LINE for l in range ( m + 1 ) : NEW_LINE INDENT found = False NEW_LINE DEDENT",
        "explain": "Stores count of pairs that satisfy the given condition"
    },
    {
        "py": "while ( j <= r ) : NEW_LINE",
        "explain": "Traverse to check for the valid conditions"
    },
    {
        "py": "if ( arr [ i ] >= K * arr [ j ] ) : NEW_LINE INDENT found = True NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE",
        "explain": "If condition satisfies"
    },
    {
        "py": "if ( found ) : NEW_LINE INDENT cnt += j - ( m + 1 ) NEW_LINE j -= 1 NEW_LINE DEDENT",
        "explain": "All elements in the right side of the left subarray also satisfies"
    },
    {
        "py": "k = l NEW_LINE i = l NEW_LINE j = m + 1 NEW_LINE while ( i <= m and j <= r ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Sort the two given arrays and store in the resultant array"
    },
    {
        "py": "while ( i <= m ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "Elements which are left in the left subarray"
    },
    {
        "py": "while ( j <= r ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT",
        "explain": "Elements which are left in the right subarray"
    },
    {
        "py": "return cnt NEW_LINE",
        "explain": "Return the count obtained"
    },
    {
        "py": "def mergeSortUtil ( arr , temp , l , r , K ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( l < r ) : NEW_LINE DEDENT",
        "explain": "Function to partition array into two halves"
    },
    {
        "py": "m = ( l + r ) // 2 NEW_LINE",
        "explain": "Same as ( l + r ) / 2 , but avoids overflow for large l and h"
    },
    {
        "py": "cnt += mergeSortUtil ( arr , temp , l , m , K ) NEW_LINE cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) NEW_LINE",
        "explain": "Sort first and second halves"
    },
    {
        "py": "cnt += merge ( arr , temp , l , m , r , K ) NEW_LINE return cnt NEW_LINE",
        "explain": "Call the merging function"
    },
    {
        "py": "def mergeSort ( arr , N , K ) : NEW_LINE INDENT temp = [ 0 ] * N NEW_LINE print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) NEW_LINE DEDENT",
        "explain": "Function to print the count of required pairs using Merge Sort"
    },
    {
        "py": "arr = [ 5 , 6 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "mergeSort ( arr , N , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def minRemovals ( A , N ) : NEW_LINE",
        "explain": "Function to count minimum consecutive removals of elements of the same type"
    },
    {
        "py": "A . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "mx = A [ N - 1 ] NEW_LINE",
        "explain": "Stores the maximum element present in the array"
    },
    {
        "py": "sum = 1 NEW_LINE",
        "explain": "stores the sum of array"
    },
    {
        "py": "for i in range ( 0 , N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE DEDENT if ( ( sum - mx ) >= mx ) : NEW_LINE INDENT print ( 0 , end = \" \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 * mx - sum , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Calculate sum of array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 3 , 3 , 2 ] NEW_LINE N = len ( A ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "minRemovals ( A , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def rearrangeArray ( a , n ) : NEW_LINE",
        "explain": "Function to rearrange the array a [ ] such that none of the array elements is same as its index"
    },
    {
        "py": "a = sorted ( a ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "for i in range ( n - 1 ) : NEW_LINE",
        "explain": "Traverse the indices [ 0 , N - 2 ] of the given array"
    },
    {
        "py": "if ( a [ i ] == i + 1 ) : NEW_LINE",
        "explain": "Check if the current element is equal to its index"
    },
    {
        "py": "a [ i ] , a [ i + 1 ] = a [ i + 1 ] , a [ i ] NEW_LINE",
        "explain": "If found to be true , swap current element with the next element"
    },
    {
        "py": "if ( a [ n - 1 ] == n ) : NEW_LINE",
        "explain": "Check if the last element is same as its index"
    },
    {
        "py": "a [ n - 1 ] , a [ n - 2 ] = a [ n - 2 ] , a [ n - 1 ] NEW_LINE",
        "explain": "If found to be true , swap current element with the previous element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Prthe modified array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "rearrangeArray ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def minOperations ( arr1 , arr2 , i , j ) : NEW_LINE",
        "explain": "Function that counts the minimum moves required to covert arr [ ] to brr [ ]"
    },
    {
        "py": "if arr1 == arr2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if i >= len ( arr1 ) or j >= len ( arr2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if arr1 [ i ] < arr2 [ j ] : NEW_LINE",
        "explain": "If arr [ i ] < arr [ j ]"
    },
    {
        "py": "return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 ) NEW_LINE",
        "explain": "Include the current element"
    },
    {
        "py": "return max ( minOperations ( arr1 , arr2 , i , j + 1 ) , minOperations ( arr1 , arr2 , i + 1 , j ) ) NEW_LINE",
        "explain": "Otherwise , excluding the current element"
    },
    {
        "py": "def minOperationsUtil ( arr ) : NEW_LINE INDENT brr = sorted ( arr ) ; NEW_LINE DEDENT",
        "explain": "Function that counts the minimum moves required to sort the array"
    },
    {
        "py": "if ( arr == brr ) : NEW_LINE",
        "explain": "If both the arrays are equal"
    },
    {
        "py": "print ( \"0\" ) NEW_LINE",
        "explain": "No moves required"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "print ( minOperations ( arr , brr , 0 , 0 ) ) NEW_LINE",
        "explain": "Print minimum operations required"
    },
    {
        "py": "arr = [ 4 , 7 , 2 , 3 , 9 ] NEW_LINE minOperationsUtil ( arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def canTransform ( s , t ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to check if str1 can be transformed to t by sorting substrings"
    },
    {
        "py": "occur = [ [ ] for i in range ( 26 ) ] NEW_LINE for x in range ( n ) : NEW_LINE INDENT ch = ord ( s [ x ] ) - ord ( ' a ' ) NEW_LINE occur [ ch ] . append ( x ) NEW_LINE DEDENT",
        "explain": "Occur [ i ] stores the indices of ( ' a ' + i ) in string s"
    },
    {
        "py": "idx = [ 0 ] * ( 26 ) NEW_LINE poss = True NEW_LINE for x in range ( n ) : NEW_LINE INDENT ch = ord ( t [ x ] ) - ord ( ' a ' ) NEW_LINE DEDENT",
        "explain": "idx [ i ] stores the next available index of ( ' a ' + i ) in occur [ i ]"
    },
    {
        "py": "if ( idx [ ch ] >= len ( occur [ ch ] ) ) : NEW_LINE",
        "explain": "If this is not available anymore"
    },
    {
        "py": "poss = False NEW_LINE break NEW_LINE for small in range ( ch ) : NEW_LINE",
        "explain": "Conversion not possible"
    },
    {
        "py": "if ( idx [ small ] < len ( occur [ small ] ) and occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) : NEW_LINE",
        "explain": "If one of the smaller characters is available and occurs before"
    },
    {
        "py": "poss = False NEW_LINE break NEW_LINE idx [ ch ] += 1 NEW_LINE",
        "explain": "Conversion not possible"
    },
    {
        "py": "if ( poss ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Print the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hdecb \" NEW_LINE t = \" cdheb \" NEW_LINE canTransform ( s , t ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def inversionCount ( s ) : NEW_LINE",
        "explain": "function to count inversion count of the string"
    },
    {
        "py": "freq = [ 0 for _ in range ( 26 ) ] NEW_LINE inv = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "for storing frequency"
    },
    {
        "py": "temp = 0 NEW_LINE for j in range ( ord ( s [ i ] ) - ord ( ' a ' ) ) : NEW_LINE",
        "explain": "we 'll add all the characters  which are less than the ith  character before i."
    },
    {
        "py": "temp += freq [ j ] NEW_LINE inv += ( i - temp ) NEW_LINE",
        "explain": "adding the count to inversion count"
    },
    {
        "py": "freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE return inv NEW_LINE",
        "explain": "updating the character in the frequency array"
    },
    {
        "py": "def haveRepeated ( S1 , S2 ) : NEW_LINE INDENT freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE INDENT if freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT freq [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( S2 ) ) : NEW_LINE INDENT if freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT",
        "explain": "function to check whether any of the string have a repeated character"
    },
    {
        "py": "def checkToMakeEqual ( S1 , S2 ) : NEW_LINE",
        "explain": "function to check whether the string S1 and S2 can be made equal by reversing sub strings ofsame size in both strings"
    },
    {
        "py": "freq = [ 0 for _ in range ( 26 ) ] NEW_LINE for i in range ( len ( S1 ) ) : NEW_LINE",
        "explain": "frequency array to check whether both string have same character or not"
    },
    {
        "py": "freq [ ord ( S1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE flag = 0 NEW_LINE for i in range ( len ( S2 ) ) : NEW_LINE if freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE",
        "explain": "adding the frequency ;"
    },
    {
        "py": "flag = 1 NEW_LINE break NEW_LINE",
        "explain": "if the character is not in S1"
    },
    {
        "py": "freq [ ord ( S2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if flag == 1 : NEW_LINE",
        "explain": "decrementing the frequency"
    },
    {
        "py": "print ( \" No \" ) NEW_LINE return NEW_LINE",
        "explain": "If both string does not have same characters or not"
    },
    {
        "py": "invCount1 = inversionCount ( S1 ) NEW_LINE invCount2 = inversionCount ( S2 ) NEW_LINE if ( ( invCount1 == invCount2 ) or ( ( invCount1 % 2 ) == ( invCount2 % 2 ) ) or haveRepeated ( S1 , S2 ) == 1 ) : NEW_LINE",
        "explain": "finding inversion count of both strings"
    },
    {
        "py": "print ( \" Yes \" ) NEW_LINE else : NEW_LINE print ( \" No \" ) NEW_LINE",
        "explain": "If inversion count is same , or have same parity or if any of the string have a repeated character then the answer is Yes else No"
    },
    {
        "py": "S1 = \" abbca \" NEW_LINE S2 = \" acabb \" NEW_LINE checkToMakeEqual ( S1 , S2 ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def sortArr ( a , n ) : NEW_LINE",
        "explain": "Function to sort bitonic array in constant space"
    },
    {
        "py": "k = int ( math . log ( n , 2 ) ) NEW_LINE k = int ( pow ( 2 , k ) ) NEW_LINE",
        "explain": "Initialize thevalue of k"
    },
    {
        "py": "while ( k > 0 ) : NEW_LINE INDENT i = 0 NEW_LINE while i + k < n : NEW_LINE INDENT if a [ i ] > a [ i + k ] : NEW_LINE INDENT a [ i ] , a [ i + k ] = a [ i + k ] , a [ i ] NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT",
        "explain": "In each iteration compare elements k distance apart and swap it they are not in order"
    },
    {
        "py": "k = k // 2 NEW_LINE",
        "explain": "k is reduced to half after every iteration"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the array elements"
    },
    {
        "py": "a = [ 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 ] NEW_LINE n = len ( a ) NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "sortArr ( a , n ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def maximumSum ( arr , n , k ) : NEW_LINE",
        "explain": "Function that prints the maximum sum possible"
    },
    {
        "py": "elt = n // k ; NEW_LINE sum = 0 ; NEW_LINE",
        "explain": "Find elements in each group"
    },
    {
        "py": "arr . sort ( ) ; NEW_LINE count = 0 ; NEW_LINE i = n - 1 ; NEW_LINE",
        "explain": "Sort all elements in non - descending order"
    },
    {
        "py": "while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE i -= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE",
        "explain": "Add K largest elements"
    },
    {
        "py": "while ( count < k ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE i += elt - 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT",
        "explain": "For sum of minimum elements from each subset"
    },
    {
        "py": "print ( sum ) ; NEW_LINE",
        "explain": "Printing the maximum sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 1 , 13 , 7 , 17 , 6 , 5 ] ; NEW_LINE K = 2 ; NEW_LINE size = len ( Arr ) ; NEW_LINE maximumSum ( Arr , size , K ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findMinSum ( arr , K , L , size ) : NEW_LINE INDENT if ( K * L > size ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minsum = 0 NEW_LINE DEDENT",
        "explain": "Function to find the minimum sum"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "for i in range ( K ) : NEW_LINE INDENT minsum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Calculate sum of smallest K elements"
    },
    {
        "py": "return minsum NEW_LINE",
        "explain": "Return the sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 ] NEW_LINE K = 3 NEW_LINE L = 2 NEW_LINE length = len ( arr ) NEW_LINE print ( findMinSum ( arr , K , L , length ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findKthSmallest ( arr , n , k ) : NEW_LINE",
        "explain": "Function to find the Kth smallest element in Unsorted Array"
    },
    {
        "py": "max = 0 NEW_LINE",
        "explain": "Initialize the max Element as 0"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Iterate arr [ ] and find the maximum element in it"
    },
    {
        "py": "counter = [ 0 ] * ( max + 1 ) NEW_LINE",
        "explain": "Frequency array to store the frequencies"
    },
    {
        "py": "smallest = 0 NEW_LINE",
        "explain": "Counter variable"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT counter [ arr [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "Counting the frequencies"
    },
    {
        "py": "for num in range ( 1 , max + 1 ) : NEW_LINE",
        "explain": "Iterate through the freq [ ]"
    },
    {
        "py": "if ( counter [ num ] > 0 ) : NEW_LINE",
        "explain": "Check if num is present in the array"
    },
    {
        "py": "smallest += counter [ num ] NEW_LINE",
        "explain": "Increment the counter with the frequency of num"
    },
    {
        "py": "if ( smallest >= k ) : NEW_LINE",
        "explain": "Checking if we have reached the Kth smallest element"
    },
    {
        "py": "return num NEW_LINE",
        "explain": "Return the Kth smallest element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 7 , 1 , 4 , 4 , 20 , 15 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE K = 5 NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "print ( findKthSmallest ( arr , N , K ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def lexNumbers ( n ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s . append ( str ( i ) ) NEW_LINE DEDENT s . sort ( ) NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans . append ( int ( s [ i ] ) ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = ' \u2581 ' ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to print all the numbers up to n in lexicographical order"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 15 NEW_LINE lexNumbers ( n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "N = 4 NEW_LINE def func ( a ) : NEW_LINE",
        "explain": "Python3 implementation to print row of matrix in ascending or descending order alternatively"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate matrix rowwise"
    },
    {
        "py": "if i % 2 == 0 : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE DEDENT DEDENT",
        "explain": "Sort even rows in ascending order"
    },
    {
        "py": "if a [ i ] [ j ] > a [ i ] [ k ] : NEW_LINE",
        "explain": "Compare adjacent elements"
    },
    {
        "py": "temp = a [ i ] [ j ] NEW_LINE a [ i ] [ j ] = a [ i ] [ k ] NEW_LINE a [ i ] [ k ] = temp NEW_LINE",
        "explain": "Swap adjacent element"
    },
    {
        "py": "else : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE DEDENT DEDENT",
        "explain": "Sort even rows in descending order"
    },
    {
        "py": "if a [ i ] [ j ] < a [ i ] [ k ] : NEW_LINE",
        "explain": "Compare adjacent elements"
    },
    {
        "py": "temp = a [ i ] [ j ] NEW_LINE a [ i ] [ j ] = a [ i ] [ k ] NEW_LINE a [ i ] [ k ] = temp NEW_LINE",
        "explain": "Swap adjacent element"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Printing the final output"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ 5 , 7 , 3 , 4 ] , [ 9 , 5 , 8 , 2 ] , [ 6 , 3 , 8 , 1 ] , [ 5 , 8 , 9 , 3 ] ] NEW_LINE func ( a ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "g = [ dict ( ) for i in range ( 200005 ) ] NEW_LINE s = set ( ) NEW_LINE ns = set ( ) NEW_LINE",
        "explain": "To store the edges of the given graph"
    },
    {
        "py": "def dfs ( x ) : NEW_LINE INDENT global s , g , ns NEW_LINE v = [ ] NEW_LINE v . clear ( ) ; NEW_LINE ns . clear ( ) ; NEW_LINE DEDENT",
        "explain": "A utility function to perform DFS Traversal"
    },
    {
        "py": "for it in s : NEW_LINE",
        "explain": "Check those vertices which are stored in the set"
    },
    {
        "py": "if ( x in g and not g [ x ] [ it ] ) : NEW_LINE INDENT v . append ( it ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ns . add ( it ) ; NEW_LINE DEDENT s = ns ; NEW_LINE for i in v : NEW_LINE dfs ( i ) ; NEW_LINE",
        "explain": "Vertices are included if the weight of edge is 0"
    },
    {
        "py": "def weightOfMST ( N ) : NEW_LINE",
        "explain": "A utility function to find the weight of Minimum Spanning Tree"
    },
    {
        "py": "cnt = 0 ; NEW_LINE",
        "explain": "To count the connected components"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT s . add ( i ) ; NEW_LINE DEDENT",
        "explain": "Inserting the initial vertices in the set"
    },
    {
        "py": "while ( len ( s ) != 0 ) : NEW_LINE",
        "explain": "Traversing vertices stored in the set and Run DFS Traversal for each vertices"
    },
    {
        "py": "cnt += 1 NEW_LINE t = list ( s ) [ 0 ] NEW_LINE s . discard ( t ) ; NEW_LINE",
        "explain": "Incrementing the zero weight connected components"
    },
    {
        "py": "dfs ( t ) ; NEW_LINE print ( cnt ) NEW_LINE",
        "explain": "DFS Traversal for every vertex remove"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE M = 11 ; NEW_LINE edges = [ [ 1 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 1 , 6 ] , [ 2 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 2 , 6 ] , [ 3 , 4 ] , [ 3 , 5 ] , [ 3 , 6 ] ] ; NEW_LINE DEDENT",
        "explain": "Driver 's Code"
    },
    {
        "py": "for i in range ( M ) : NEW_LINE INDENT u = edges [ i ] [ 0 ] ; NEW_LINE v = edges [ i ] [ 1 ] ; NEW_LINE g [ u ] [ v ] = 1 ; NEW_LINE g [ v ] [ u ] = 1 ; NEW_LINE DEDENT",
        "explain": "Insert edges"
    },
    {
        "py": "weightOfMST ( N ) ; NEW_LINE",
        "explain": "Function call find the weight of Minimum Spanning Tree"
    },
    {
        "py": "def countPairs ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( A [ i ] > B [ ans ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT",
        "explain": "Function to return the count of pairs"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 30 , 28 , 45 , 22 ] NEW_LINE B = [ 35 , 25 , 22 , 48 ] NEW_LINE print ( countPairs ( A , B ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxMod ( arr , n ) : NEW_LINE INDENT maxVal = max ( arr ) NEW_LINE secondMax = 0 NEW_LINE DEDENT",
        "explain": "Function to return the maximum mod value for any pair from the array"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < maxVal and arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT DEDENT return secondMax NEW_LINE",
        "explain": "Find the second maximum element from the array"
    },
    {
        "py": "arr = [ 2 , 4 , 1 , 5 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxMod ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isPossible ( A , B , n , m , x , y ) : NEW_LINE",
        "explain": "Function to that returns true if it possible to choose the elements"
    },
    {
        "py": "if ( x > n or y > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If elements can 't be chosen"
    },
    {
        "py": "A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE",
        "explain": "Sort both the arrays"
    },
    {
        "py": "if ( A [ x - 1 ] < B [ m - y ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If xth smallest element of A [ ] is smaller than the yth greatest element of B [ ]"
    },
    {
        "py": "A = [ 1 , 1 , 1 , 1 , 1 ] NEW_LINE B = [ 2 , 2 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE if ( isPossible ( A , B , n , m , x , y ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 100005 NEW_LINE",
        "explain": "Python 3 program to minimum changes required in an array for k distinct elements ."
    },
    {
        "py": "def Min_Replace ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE DEDENT",
        "explain": "Function to minimum changes required in an array for k distinct elements ."
    },
    {
        "py": "freq = [ 0 for i in range ( MAX ) ] NEW_LINE p = 0 NEW_LINE freq [ p ] = 1 NEW_LINE",
        "explain": "Store the frequency of each element"
    },
    {
        "py": "for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT freq [ p ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT p += 1 NEW_LINE freq [ p ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Store the frequency of elements"
    },
    {
        "py": "freq . sort ( reverse = True ) NEW_LINE",
        "explain": "Sort frequencies in descending order"
    },
    {
        "py": "ans = 0 NEW_LINE for i in range ( k , p + 1 , 1 ) : NEW_LINE INDENT ans += freq [ i ] NEW_LINE DEDENT",
        "explain": "To store the required answer"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( Min_Replace ( arr , n , k ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Segment ( x , l , n ) : NEW_LINE",
        "explain": "Function to find maximum number of elements without overlapping in a line"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If n = 1 , then answer is one"
    },
    {
        "py": "ans = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE",
        "explain": "We can always make 1 st element to cover left segment and nth the right segment"
    },
    {
        "py": "if ( x [ i ] - l [ i ] > x [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT",
        "explain": "If left segment for ith element doesnt overlap with i - 1 th element then do left"
    },
    {
        "py": "elif ( x [ i ] + l [ i ] < x [ i + 1 ] ) : NEW_LINE",
        "explain": "else try towards right if possible"
    },
    {
        "py": "x [ i ] = x [ i ] + l [ i ] NEW_LINE ans += 1 NEW_LINE",
        "explain": "update x [ i ] to right endpoof segment covered by it"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "x = [ 1 , 3 , 4 , 5 , 8 ] NEW_LINE l = [ 10 , 1 , 2 , 2 , 5 ] NEW_LINE n = len ( x ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( Segment ( x , l , n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def MinimizeleftOverSum ( a , n ) : NEW_LINE INDENT v1 , v2 = [ ] , [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT v1 . append ( a [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( a [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to find the minimized sum"
    },
    {
        "py": "if ( len ( v1 ) > len ( v2 ) ) : NEW_LINE",
        "explain": "If more odd elements"
    },
    {
        "py": "v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE",
        "explain": "Sort the elements"
    },
    {
        "py": "x = len ( v1 ) - len ( v2 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE",
        "explain": "Left - over elements"
    },
    {
        "py": "while ( i < x ) : NEW_LINE INDENT sum += v1 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "Find the sum of leftover elements"
    },
    {
        "py": "return sum ; NEW_LINE",
        "explain": "Return the sum"
    },
    {
        "py": "elif ( len ( v2 ) > len ( v1 ) ) : NEW_LINE",
        "explain": "If more even elements"
    },
    {
        "py": "v1 . sort ( ) ; NEW_LINE v2 . sort ( ) ; NEW_LINE",
        "explain": "Sort the elements"
    },
    {
        "py": "x = len ( v2 ) - len ( v1 ) - 1 ; NEW_LINE sum = 0 ; NEW_LINE i = 0 ; NEW_LINE",
        "explain": "Left - over elements"
    },
    {
        "py": "while ( i < x ) : NEW_LINE INDENT sum += v2 [ i ] ; NEW_LINE i += 1 NEW_LINE DEDENT",
        "explain": "Find the sum of leftover elements"
    },
    {
        "py": "return sum ; NEW_LINE",
        "explain": "Return the sum"
    },
    {
        "py": "else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "If same elements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 2 , 2 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinimizeleftOverSum ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minOperation ( S , N , K ) : NEW_LINE",
        "explain": "Function to find the minimum number of operations to convert the given string"
    },
    {
        "py": "if N % K : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Check if N is divisible by K"
    },
    {
        "py": "count = [ 0 ] * 26 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT count [ ord ( S [ i ] ) - 97 ] += 1 NEW_LINE DEDENT E = N // K NEW_LINE greaterE = [ ] NEW_LINE lessE = [ ] NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE",
        "explain": "Array to store frequency of characters in given string"
    },
    {
        "py": "if count [ i ] < E : NEW_LINE INDENT lessE . append ( E - count [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT greaterE . append ( count [ i ] - E ) NEW_LINE DEDENT greaterE . sort ( ) NEW_LINE lessE . sort ( ) NEW_LINE mi = float ( ' inf ' ) NEW_LINE for i in range ( 0 , K + 1 ) : NEW_LINE",
        "explain": "Two arrays with number of operations required"
    },
    {
        "py": "set1 , set2 = i , K - i NEW_LINE if ( len ( greaterE ) >= set1 and len ( lessE ) >= set2 ) : NEW_LINE INDENT step1 , step2 = 0 , 0 NEW_LINE for j in range ( 0 , set1 ) : NEW_LINE INDENT step1 += greaterE [ j ] NEW_LINE DEDENT for j in range ( 0 , set2 ) : NEW_LINE INDENT step2 += lessE [ j ] NEW_LINE DEDENT mi = min ( mi , max ( step1 , step2 ) ) NEW_LINE DEDENT print ( mi ) NEW_LINE",
        "explain": "Checking for all possibility"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" accb \" NEW_LINE N = len ( S ) NEW_LINE K = 2 NEW_LINE minOperation ( S , N , K ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT",
        "explain": "Function to find minimum range increments to sort an array"
    },
    {
        "py": "if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT",
        "explain": "If current element is found greater than last element Increment all terms in range i + 1 to n - 1"
    },
    {
        "py": "return moves NEW_LINE",
        "explain": "mn = arr [ i ] Minimum in range i to n - 1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMovesToSort ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def SieveOfEratosthenes ( n ) : NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= n : NEW_LINE",
        "explain": "false here indicates that it is not prime"
    },
    {
        "py": "if prime [ p ] : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p , set them to non - prime"
    },
    {
        "py": "def sortPrimes ( arr , n ) : NEW_LINE INDENT SieveOfEratosthenes ( 100005 ) NEW_LINE DEDENT",
        "explain": "Function that sorts all the prime numbers from the array in descending"
    },
    {
        "py": "v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE",
        "explain": "This vector will contain prime numbers to sort"
    },
    {
        "py": "if prime [ arr [ i ] ] : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT v . sort ( reverse = True ) NEW_LINE j = 0 NEW_LINE",
        "explain": "If the element is prime"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT arr [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE",
        "explain": "update the array elements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 3 , 2 , 6 , 100 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE prime = [ True ] * 100006 NEW_LINE arr = sortPrimes ( arr , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "print the results ."
    },
    {
        "py": "def findOptimalPairs ( arr , N ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE DEDENT",
        "explain": "Python 3 Program to divide the array into N pairs such that maximum pair is minimized"
    },
    {
        "py": "i = 0 NEW_LINE j = N - 1 NEW_LINE while ( i <= j ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" \u2581 \" ) NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT",
        "explain": "After Sorting Maintain two variables i and j pointing to start and end of array Such that smallest element of array pairs with largest element"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 6 , 5 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE findOptimalPairs ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "explain": "a utility function that returns total set bits count in an integer"
    },
    {
        "py": "def insertionSort ( arr , aux , n ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE DEDENT",
        "explain": "Function to simultaneously sort both arrays using insertion sort ( http : quiz . geeksforgeeks . org / insertion - sort / )"
    },
    {
        "py": "key1 = aux [ i ] NEW_LINE key2 = arr [ i ] NEW_LINE j = i - 1 NEW_LINE",
        "explain": "use 2 keys because we need to sort both arrays simultaneously"
    },
    {
        "py": "while ( j >= 0 and aux [ j ] < key1 ) : NEW_LINE INDENT aux [ j + 1 ] = aux [ j ] NEW_LINE arr [ j + 1 ] = arr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT aux [ j + 1 ] = key1 NEW_LINE arr [ j + 1 ] = key2 NEW_LINE",
        "explain": "Move elements of arr [ 0. . i - 1 ] and aux [ 0. . i - 1 ] , such that elements of aux [ 0. . i - 1 ] are greater than key1 , to one position ahead of their current position"
    },
    {
        "py": "def sortBySetBitCount ( arr , n ) : NEW_LINE",
        "explain": "Function to sort according to bit count using an auxiliary array"
    },
    {
        "py": "aux = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT aux [ i ] = countBits ( arr [ i ] ) NEW_LINE DEDENT",
        "explain": "Create an array and store count of set bits in it ."
    },
    {
        "py": "insertionSort ( arr , aux , n ) NEW_LINE",
        "explain": "Sort arr [ ] according to values in aux [ ]"
    },
    {
        "py": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Utility function to print an array"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countBits ( a ) : NEW_LINE INDENT count = 0 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT a = a >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "explain": "a utility function that returns total set bits count in an integer"
    },
    {
        "py": "def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ [ ] for i in range ( 32 ) ] NEW_LINE setbitcount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT setbitcount = countBits ( arr [ i ] ) NEW_LINE count [ setbitcount ] . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to sort according to bit count This function assumes that there are 32 bits in an integer ."
    },
    {
        "py": "for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT v1 = count [ i ] NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT arr [ j ] = v1 [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse through all bit counts ( Note that we sort array in decreasing order )"
    },
    {
        "py": "def printArr ( arr , n ) : NEW_LINE INDENT print ( * arr ) NEW_LINE DEDENT",
        "explain": "Utility function to pran array"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE printArr ( arr , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def generateString ( k1 , k2 , s ) : NEW_LINE",
        "explain": "Function to find lexicographically smallest string having number of 1 s greater than number of 0 s"
    },
    {
        "py": "s = list ( s ) NEW_LINE C1s = 0 NEW_LINE C0s = 0 NEW_LINE flag = 0 NEW_LINE pos = [ ] NEW_LINE",
        "explain": "C1s And C0s stores the count of 1 s and 0 s at every position"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT C0s += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the string S"
    },
    {
        "py": "if ( ( i + 1 ) % k1 != 0 and ( i + 1 ) % k2 != 0 ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT else : NEW_LINE C1s += 1 NEW_LINE if ( C0s >= C1s ) : NEW_LINE",
        "explain": "If the position is not divisible by k1 and k2"
    },
    {
        "py": "if ( len ( pos ) == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT",
        "explain": "If C0s >= C1s and pos [ ] is empty then the string can 't  be formed"
    },
    {
        "py": "else : NEW_LINE INDENT k = pos [ len ( pos ) - 1 ] NEW_LINE s [ k ] = '1' NEW_LINE C0s -= 1 NEW_LINE C1s += 1 NEW_LINE pos = pos [ : - 1 ] NEW_LINE DEDENT",
        "explain": "If pos [ ] is not empty then flip the bit of last position present in pos [ ]"
    },
    {
        "py": "s = ' ' . join ( s ) NEW_LINE if ( flag == 0 ) : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K1 = 2 NEW_LINE K2 = 4 NEW_LINE S = \"11000100\" NEW_LINE generateString ( K1 , K2 , S ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "python 3 program for the above approach"
    },
    {
        "py": "def maximizeProduct ( N ) : NEW_LINE",
        "explain": "Function to find the pair ( X , Y ) such that X xor Y = N and the count of set bits in X and Y is less than count of set bit in N"
    },
    {
        "py": "MSB = ( int ) ( math . log2 ( N ) ) NEW_LINE",
        "explain": "Stores MSB ( Most Significant Bit )"
    },
    {
        "py": "X = 1 << MSB NEW_LINE",
        "explain": "Stores the value of X"
    },
    {
        "py": "Y = N - ( 1 << MSB ) NEW_LINE",
        "explain": "/ Stores the value of Y"
    },
    {
        "py": "for i in range ( MSB ) : NEW_LINE",
        "explain": "Traversing over all bits of N"
    },
    {
        "py": "if ( not ( N & ( 1 << i ) ) ) : NEW_LINE",
        "explain": "If ith bit of N is 0"
    },
    {
        "py": "X += 1 << i NEW_LINE",
        "explain": "/ Set ith bit of X to 1"
    },
    {
        "py": "Y += 1 << i NEW_LINE",
        "explain": "Set ith bit of Y to 1"
    },
    {
        "py": "print ( X , Y ) NEW_LINE",
        "explain": "Print Answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 45 NEW_LINE maximizeProduct ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import log10 NEW_LINE",
        "explain": "python 3 program for the above approach"
    },
    {
        "py": "def check ( num ) : NEW_LINE",
        "explain": "Function to check if the number is valid"
    },
    {
        "py": "sm = 0 NEW_LINE",
        "explain": "Sum of digits of num"
    },
    {
        "py": "num2 = num * num NEW_LINE while ( num ) : NEW_LINE INDENT sm += num % 10 NEW_LINE num //= 10 NEW_LINE DEDENT",
        "explain": "Squared number"
    },
    {
        "py": "sm2 = 0 NEW_LINE while ( num2 ) : NEW_LINE INDENT sm2 += num2 % 10 NEW_LINE num2 //= 10 NEW_LINE DEDENT return ( ( sm * sm ) == sm2 ) NEW_LINE",
        "explain": "Sum of digits of ( num * num )"
    },
    {
        "py": "def convert ( s ) : NEW_LINE INDENT val = 0 NEW_LINE s = s [ : : - 1 ] NEW_LINE cur = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val += ( ord ( s [ i ] ) - ord ( '0' ) ) * cur NEW_LINE cur *= 10 NEW_LINE DEDENT return val NEW_LINE DEDENT",
        "explain": "Function to convert a string to an integer"
    },
    {
        "py": "def generate ( s , len1 , uniq ) : NEW_LINE",
        "explain": "Function to generate all possible strings of length len"
    },
    {
        "py": "if ( len ( s ) == len1 ) : NEW_LINE",
        "explain": "Desired string"
    },
    {
        "py": "if ( check ( convert ( s ) ) ) : NEW_LINE INDENT uniq . add ( convert ( s ) ) NEW_LINE DEDENT return NEW_LINE",
        "explain": "Take only valid numbers"
    },
    {
        "py": "for i in range ( 4 ) : NEW_LINE INDENT generate ( s + chr ( i + ord ( '0' ) ) , len1 , uniq ) NEW_LINE DEDENT",
        "explain": "Recurse for all possible digits"
    },
    {
        "py": "def totalNumbers ( L , R ) : NEW_LINE",
        "explain": "Function to calculate unique numbers in range [ L , R ]"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Initialize a variable to store the answer"
    },
    {
        "py": "max_len = int ( log10 ( R ) ) + 1 NEW_LINE",
        "explain": "Calculate the maximum possible length"
    },
    {
        "py": "uniq = set ( ) NEW_LINE for i in range ( 1 , max_len + 1 , 1 ) : NEW_LINE",
        "explain": "Set to store distinct valid numbers"
    },
    {
        "py": "generate ( \" \" , i , uniq ) NEW_LINE",
        "explain": "Generate all possible strings of length i"
    },
    {
        "py": "for x in uniq : NEW_LINE INDENT if ( x >= L and x <= R ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE",
        "explain": "Iterate the set to get the count of valid numbers in the range [ L , R ]"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 22 NEW_LINE R = 22 NEW_LINE print ( totalNumbers ( L , R ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def convertXintoY ( X , Y ) : NEW_LINE",
        "explain": "Function to check if X can be converted to Y by multiplying X by 2 or appending 1 at the end"
    },
    {
        "py": "while ( Y > X ) : NEW_LINE",
        "explain": "Iterate until Y is at least X"
    },
    {
        "py": "if ( Y % 2 == 0 ) : NEW_LINE INDENT Y //= 2 NEW_LINE DEDENT",
        "explain": "If Y is even"
    },
    {
        "py": "elif ( Y % 10 == 1 ) : NEW_LINE INDENT Y //= 10 NEW_LINE DEDENT",
        "explain": "If the last digit of Y is 1"
    },
    {
        "py": "else : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if ( X == Y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Check if X is equal to Y"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X , Y = 100 , 40021 NEW_LINE convertXintoY ( X , Y ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def generateString ( K ) : NEW_LINE",
        "explain": "Function to find the lexicographically smallest string of the first K lower case alphabets having unique substrings"
    },
    {
        "py": "s = \" \" NEW_LINE",
        "explain": "Stores the resultant string"
    },
    {
        "py": "for i in range ( 97 , 97 + K , 1 ) : NEW_LINE INDENT s = s + chr ( i ) ; NEW_LINE DEDENT",
        "explain": "Iterate through all the characters"
    },
    {
        "py": "for j in range ( i + 1 , 97 + K , 1 ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE DEDENT",
        "explain": "Inner Loop for making pairs and adding them into string"
    },
    {
        "py": "s += chr ( 97 ) NEW_LINE",
        "explain": "Adding first character so that substring consisting of the last the first alphabet is present"
    },
    {
        "py": "print ( s ) NEW_LINE",
        "explain": "Print the resultant string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 4 NEW_LINE generateString ( K ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findEquation ( S , M ) : NEW_LINE",
        "explain": "Function to find the quadratic equation from the given sum and products of roots"
    },
    {
        "py": "print ( \"1 \u2581 \" , ( ( - 1 ) * S ) , \" \u2581 \" , M ) NEW_LINE",
        "explain": "Print the coefficients"
    },
    {
        "py": "S = 5 NEW_LINE M = 6 NEW_LINE findEquation ( S , M ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def minSteps ( a , n ) : NEW_LINE",
        "explain": "Function to count the minimum number of pairs of adjacent elements required to be replaced by their sum to make all arrat elements equal"
    },
    {
        "py": "prefix_sum = a [ : ] NEW_LINE",
        "explain": "Stores the prefix sum of the array"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum [ i ] += prefix_sum [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Calculate the prefix sum array"
    },
    {
        "py": "mx = - 1 NEW_LINE",
        "explain": "Stores the maximum number of subarrays into which the array can be split"
    },
    {
        "py": "for subgroupsum in prefix_sum : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE grp_count = 0 NEW_LINE DEDENT",
        "explain": "Iterate over all possible sums"
    },
    {
        "py": "while i < n : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "if sum == subgroupsum : NEW_LINE",
        "explain": "If the sum is equal to the current prefix sum"
    },
    {
        "py": "grp_count += 1 NEW_LINE sum = 0 NEW_LINE",
        "explain": "Increment count of groups by 1"
    },
    {
        "py": "elif sum > subgroupsum : NEW_LINE INDENT grp_count = - 1 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "Otherwise discard this subgroup sum"
    },
    {
        "py": "if grp_count > mx : NEW_LINE INDENT mx = grp_count NEW_LINE DEDENT",
        "explain": "Update the maximum this of subarrays"
    },
    {
        "py": "return n - mx NEW_LINE",
        "explain": "Return the minimum number of operations"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 2 , 1 , 3 ] NEW_LINE N = len ( A ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( minSteps ( A , N ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def maxOccuringCharacter ( s ) : NEW_LINE",
        "explain": "Function to find the most frequent character after replacing X with either '0' or '1' according as per the given conditions"
    },
    {
        "py": "INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE DEDENT",
        "explain": "Store the count of 0 s and 1 s in the S"
    },
    {
        "py": "INDENT for i in range ( len ( s ) ) : NEW_LINE DEDENT",
        "explain": "Count the frequency of 0 and 1"
    },
    {
        "py": "if ( s [ i ] == '1' ) : NEW_LINE count1 += 1 NEW_LINE",
        "explain": "If the character is 1"
    },
    {
        "py": "elif ( s [ i ] == '0' ) : NEW_LINE count0 += 1 NEW_LINE",
        "explain": "If the character is 0"
    },
    {
        "py": "INDENT prev = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE prev = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Stores first occurence of 1"
    },
    {
        "py": "INDENT for i in range ( prev + 1 , len ( s ) ) : NEW_LINE DEDENT",
        "explain": "Traverse the to count the number of X between two consecutive 1 s"
    },
    {
        "py": "if ( s [ i ] != ' X ' ) : NEW_LINE",
        "explain": "If the current character is not X"
    },
    {
        "py": "if ( s [ i ] == '1' ) : NEW_LINE INDENT count1 += i - prev - 1 NEW_LINE prev = i NEW_LINE DEDENT",
        "explain": "If the current character is 1 , add the number of Xs to count1 and set prev to i"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE if ( s [ j ] == '1' ) : NEW_LINE INDENT flag = False NEW_LINE prev = j NEW_LINE break NEW_LINE DEDENT",
        "explain": "Find next occurence of 1 in the string"
    },
    {
        "py": "if ( flag == False ) : NEW_LINE i = prev NEW_LINE",
        "explain": "If it is found , set i to prev"
    },
    {
        "py": "else : NEW_LINE i = len ( s ) NEW_LINE",
        "explain": "Otherwise , break out of the loop"
    },
    {
        "py": "INDENT prev = - 1 NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE prev = i NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Store the first occurence of 0"
    },
    {
        "py": "INDENT for i in range ( prev + 1 , len ( s ) ) : NEW_LINE DEDENT",
        "explain": "Repeat the same procedure to count the number of X between two consecutive 0 s"
    },
    {
        "py": "if ( s [ i ] != ' X ' ) : NEW_LINE",
        "explain": "If the current character is not X"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE",
        "explain": "If the current character is 0"
    },
    {
        "py": "count0 += i - prev - 1 NEW_LINE",
        "explain": "Add the count of Xs to count0"
    },
    {
        "py": "prev = i NEW_LINE",
        "explain": "Set prev to i"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "flag = True NEW_LINE for j in range ( i + 1 , len ( s ) ) : NEW_LINE if ( s [ j ] == '0' ) : NEW_LINE INDENT prev = j NEW_LINE flag = False NEW_LINE break NEW_LINE DEDENT",
        "explain": "Find the next occurence of 0 in the string"
    },
    {
        "py": "if ( flag == False ) : NEW_LINE i = prev NEW_LINE",
        "explain": "If it is found , set i to prev"
    },
    {
        "py": "else : NEW_LINE i = len ( s ) NEW_LINE",
        "explain": "Otherwise , break out of the loop"
    },
    {
        "py": "INDENT if ( s [ 0 ] == ' X ' ) : NEW_LINE DEDENT",
        "explain": "Count number of X present in the starting of the string as XXXX1 ..."
    },
    {
        "py": "count = 0 NEW_LINE i = 0 NEW_LINE while ( s [ i ] == ' X ' ) : NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE",
        "explain": "Store the count of X"
    },
    {
        "py": "if ( s [ i ] == '1' ) : NEW_LINE count1 += count NEW_LINE",
        "explain": "Increment count1 by count if the condition is satisfied"
    },
    {
        "py": "INDENT if ( s [ ( len ( s ) - 1 ) ] == ' X ' ) : NEW_LINE DEDENT",
        "explain": "Count the number of X present in the ending of the as ... XXXX0"
    },
    {
        "py": "count = 0 NEW_LINE i = len ( s ) - 1 NEW_LINE while ( s [ i ] == ' X ' ) : NEW_LINE count += 1 NEW_LINE i -= 1 NEW_LINE",
        "explain": "Store the count of X"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE count0 += count NEW_LINE",
        "explain": "Increment count0 by count if the condition is satisfied"
    },
    {
        "py": "INDENT if ( count0 == count1 ) : NEW_LINE INDENT print ( \" X \" ) NEW_LINE DEDENT DEDENT",
        "explain": "If count of 1 is equal to count of 0 , prX"
    },
    {
        "py": "INDENT elif ( count0 > count1 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT DEDENT",
        "explain": "Otherwise , if count of 1 is greater than count of 0"
    },
    {
        "py": "INDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT DEDENT",
        "explain": "Otherwise , pr0"
    },
    {
        "py": "S = \" XX10XX10XXX1XX \" NEW_LINE maxOccuringCharacter ( S ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def maxSheets ( A , B ) : NEW_LINE INDENT area = A * B NEW_LINE DEDENT",
        "explain": "Function to calculate the maximum number of sheets possible by given operations"
    },
    {
        "py": "count = 1 NEW_LINE",
        "explain": "Initial count of sheets"
    },
    {
        "py": "while ( area % 2 == 0 ) : NEW_LINE",
        "explain": "Keep dividing the sheets into half"
    },
    {
        "py": "area //= 2 NEW_LINE",
        "explain": "Reduce area by half"
    },
    {
        "py": "count *= 2 NEW_LINE return count NEW_LINE",
        "explain": "Increase count by twice"
    },
    {
        "py": "A = 5 NEW_LINE B = 10 NEW_LINE print ( maxSheets ( A , B ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findMinMoves ( a , b ) : NEW_LINE",
        "explain": "function to find the minimum moves required to reach origin from ( a , b )"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the minimum number of moves"
    },
    {
        "py": "if ( a == b or abs ( a - b ) == 1 ) : NEW_LINE INDENT ans = a + b NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Check if the absolute difference is 1 or 0"
    },
    {
        "py": "k = min ( a , b ) NEW_LINE",
        "explain": "Store the minimum of a , b"
    },
    {
        "py": "j = max ( a , b ) NEW_LINE ans = 2 * k + 2 * ( j - k ) - 1 NEW_LINE",
        "explain": "Store the maximum of a , b"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Prthe answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "a , b = 3 , 5 NEW_LINE",
        "explain": "Given co - ordinates"
    },
    {
        "py": "findMinMoves ( a , b ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def cntEvenSumPairs ( X , Y ) : NEW_LINE",
        "explain": "Function to count even sum pairs in the given range"
    },
    {
        "py": "cntXEvenNums = X / 2 NEW_LINE",
        "explain": "Stores the count of even numbers between 1 to X"
    },
    {
        "py": "cntXOddNums = ( X + 1 ) / 2 NEW_LINE",
        "explain": "Stores the count of odd numbers between 1 to X"
    },
    {
        "py": "cntYEvenNums = Y / 2 NEW_LINE",
        "explain": "Stores the count of even numbers between 1 to Y"
    },
    {
        "py": "cntYOddNums = ( Y + 1 ) / 2 NEW_LINE",
        "explain": "Stores the count of odd numbers between 1 to Y"
    },
    {
        "py": "cntPairs = ( ( cntXEvenNums * cntYEvenNums ) + ( cntXOddNums * cntYOddNums ) ) NEW_LINE",
        "explain": "Stores the count of pairs having even sum"
    },
    {
        "py": "return cntPairs NEW_LINE",
        "explain": "Returns the count of pairs having even sum"
    },
    {
        "py": "X = 2 NEW_LINE Y = 3 NEW_LINE print ( cntEvenSumPairs ( X , Y ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def minMoves ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Function to calculate minimum number of moves to make the sequence a Fibonacci series"
    },
    {
        "py": "if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If number of elements is less than 3"
    },
    {
        "py": "ans = sys . maxsize NEW_LINE",
        "explain": "Initialize the value of the result"
    },
    {
        "py": "for i in range ( - 1 , 2 ) : NEW_LINE INDENT for j in range ( - 1 , 2 ) : NEW_LINE DEDENT",
        "explain": "Try all permutations of the first two elements"
    },
    {
        "py": "num1 = arr [ 0 ] + i NEW_LINE",
        "explain": "Value of first element after operation"
    },
    {
        "py": "num2 = arr [ 1 ] + j NEW_LINE flag = 1 NEW_LINE moves = abs ( i ) + abs ( j ) NEW_LINE",
        "explain": "Value of second element after operation"
    },
    {
        "py": "for idx in range ( 2 , N ) : NEW_LINE",
        "explain": "Calculate number of moves for rest of the elements of the array"
    },
    {
        "py": "num = num1 + num2 NEW_LINE",
        "explain": "Element at idx index"
    },
    {
        "py": "if ( abs ( arr [ idx ] - num ) > 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT",
        "explain": "If it is not possible to change the element in atmost one move"
    },
    {
        "py": "else : NEW_LINE INDENT moves += abs ( arr [ idx ] - num ) NEW_LINE DEDENT num1 = num2 NEW_LINE num2 = num NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if ( flag ) : NEW_LINE INDENT ans = min ( ans , moves ) NEW_LINE DEDENT",
        "explain": "Update the answer"
    },
    {
        "py": "if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 4 , 8 , 9 , 17 , 27 ] NEW_LINE print ( minMoves ( arr ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def querySum ( arr , N , Q , M ) : NEW_LINE",
        "explain": "Function to Find the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ... for all queries"
    },
    {
        "py": "for i in range ( M ) : NEW_LINE INDENT x = Q [ i ] [ 0 ] NEW_LINE y = Q [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Iterate over each query"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Stores the sum of arr [ x ] + arr [ x + y ] + arr [ x + 2 * y ] + ..."
    },
    {
        "py": "while ( x < N ) : NEW_LINE",
        "explain": "Traverse the array and calculate the sum of the expression"
    },
    {
        "py": "sum += arr [ x ] NEW_LINE",
        "explain": "Update sum"
    },
    {
        "py": "x += y NEW_LINE print ( sum , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Update x"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 7 , 5 , 4 ] ; NEW_LINE Q = [ [ 2 , 1 ] , [ 3 , 2 ] ] NEW_LINE N = len ( arr ) NEW_LINE M = len ( Q ) NEW_LINE querySum ( arr , N , Q , M ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findBitwiseORGivenXORAND ( X , Y ) : NEW_LINE INDENT return X + Y NEW_LINE DEDENT",
        "explain": "Function to calculate Bitwise OR from given bitwise XOR and bitwise AND values"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 5 NEW_LINE Y = 2 NEW_LINE print ( findBitwiseORGivenXORAND ( X , Y ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def GCD ( a , b ) : NEW_LINE",
        "explain": "Function to return GCD of two numbers a and b"
    },
    {
        "py": "if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "return GCD ( b , a % b ) NEW_LINE",
        "explain": "Recursively Find the GCD"
    },
    {
        "py": "def canReach ( N , A , B , K ) : NEW_LINE",
        "explain": "Function to check of B can be reaced from A with a jump of K elements in the circular queue"
    },
    {
        "py": "gcd = GCD ( N , K ) NEW_LINE",
        "explain": "Find GCD of N and K"
    },
    {
        "py": "if ( abs ( A - B ) % gcd == 0 ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT",
        "explain": "If A - B is divisible by gcd then prYes"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE A = 2 NEW_LINE B = 1 NEW_LINE K = 2 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "canReach ( N , A , B , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def countOfSubarray ( arr , N ) : NEW_LINE",
        "explain": "Function that counts the subarrays with sum of its elements as its length"
    },
    {
        "py": "mp = defaultdict ( lambda : 0 ) NEW_LINE",
        "explain": "Store count of elements upto current element with length i"
    },
    {
        "py": "answer = 0 NEW_LINE",
        "explain": "Stores the final count of subarray"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Stores the prefix sum"
    },
    {
        "py": "mp [ 1 ] += 1 NEW_LINE",
        "explain": "If size of subarray is 1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate the array"
    },
    {
        "py": "sum += arr [ i ] NEW_LINE answer += mp [ sum - i ] NEW_LINE",
        "explain": "Find the sum"
    },
    {
        "py": "mp [ sum - i ] += 1 NEW_LINE",
        "explain": "Update frequency in map"
    },
    {
        "py": "print ( answer ) NEW_LINE",
        "explain": "Print the total count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "countOfSubarray ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def minAbsDiff ( N ) : NEW_LINE",
        "explain": "Function to split the first N natural numbers into two sets having minimum absolute difference of their sums"
    },
    {
        "py": "sumSet1 = 0 NEW_LINE",
        "explain": "Stores the sum of elements of set1"
    },
    {
        "py": "sumSet2 = 0 NEW_LINE",
        "explain": "Stores the sum of elements of set2"
    },
    {
        "py": "for i in reversed ( range ( N + 1 ) ) : NEW_LINE",
        "explain": "Traverse first N natural numbers"
    },
    {
        "py": "if sumSet1 <= sumSet2 : NEW_LINE sumSet1 = sumSet1 + i NEW_LINE else : NEW_LINE sumSet2 = sumSet2 + i NEW_LINE return abs ( sumSet1 - sumSet2 ) NEW_LINE",
        "explain": "Check if sum of elements of set1 is less than or equal to sum of elements of set2"
    },
    {
        "py": "N = 6 NEW_LINE print ( minAbsDiff ( N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def checkDigits ( n ) : NEW_LINE",
        "explain": "Function to check if N contains digits 0 , 1 , 2 , 5 , 8 only"
    },
    {
        "py": "while True : NEW_LINE INDENT r = n % 10 NEW_LINE DEDENT",
        "explain": "Extract digits of N"
    },
    {
        "py": "if ( r == 3 or r == 4 or r == 6 or r == 7 or r == 9 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n //= 10 NEW_LINE if n == 0 : NEW_LINE INDENT break NEW_LINE DEDENT return True NEW_LINE",
        "explain": "Return false if any of these digits are present"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if N is prime or not"
    },
    {
        "py": "for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "Check for all factors"
    },
    {
        "py": "def isAllPrime ( n ) : NEW_LINE INDENT return isPrime ( n ) and checkDigits ( n ) NEW_LINE DEDENT",
        "explain": "Function to check if n is prime in all the desired forms"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 101 NEW_LINE if ( isAllPrime ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minCost ( str , a , b ) : NEW_LINE",
        "explain": "Function to calculate the minimum cost required to generate a balanced bracket sequence"
    },
    {
        "py": "openUnbalanced = 0 ; NEW_LINE",
        "explain": "Stores the count of unbalanced open brackets"
    },
    {
        "py": "closedUnbalanced = 0 ; NEW_LINE",
        "explain": "Stores the count of unbalanced closed brackets"
    },
    {
        "py": "openCount = 0 ; NEW_LINE",
        "explain": "Stores the count of open brackets"
    },
    {
        "py": "closedCount = 0 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE",
        "explain": "Stores the count of closed brackets"
    },
    {
        "py": "if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT openUnbalanced += 1 ; NEW_LINE openCount += 1 ; NEW_LINE DEDENT",
        "explain": "If open brace is encountered"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if ( openUnbalanced == 0 ) : NEW_LINE",
        "explain": "If no unbalanced open brackets are present"
    },
    {
        "py": "closedUnbalanced += 1 ; NEW_LINE",
        "explain": "Increase count of unbalanced closed brackets"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "openUnbalanced -= 1 ; NEW_LINE",
        "explain": "Reduce count of unbalanced open brackets"
    },
    {
        "py": "closedCount += 1 ; NEW_LINE",
        "explain": "Increase count of closed brackets"
    },
    {
        "py": "result = a * ( abs ( openCount - closedCount ) ) ; NEW_LINE",
        "explain": "Calculate lower bound of minimum cost"
    },
    {
        "py": "if ( closedCount > openCount ) : NEW_LINE INDENT closedUnbalanced -= ( closedCount - openCount ) ; NEW_LINE DEDENT if ( openCount > closedCount ) : NEW_LINE INDENT openUnbalanced -= ( openCount - closedCount ) ; NEW_LINE DEDENT",
        "explain": "Reduce excess open or closed brackets to prevent counting them twice"
    },
    {
        "py": "result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; NEW_LINE",
        "explain": "Update answer by adding minimum of removing both unbalanced open and closed brackets or inserting closed unbalanced brackets to end of String"
    },
    {
        "py": "print ( result ) ; NEW_LINE",
        "explain": "Prthe result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : str = \" ) ) ( ) ( ( ) ( ) ( \" ; NEW_LINE INDENT A = 1 ; B = 3 ; NEW_LINE minCost ( str , A , B ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countEvenSum ( low , high , k ) : NEW_LINE",
        "explain": "Function to return the number of all permutations such that sum of K numbers in range is even"
    },
    {
        "py": "even_count = high / 2 - ( low - 1 ) / 2 NEW_LINE odd_count = ( high + 1 ) / 2 - low / 2 NEW_LINE even_sum = 1 NEW_LINE odd_sum = 0 NEW_LINE",
        "explain": "Find total count of even and odd number in given range"
    },
    {
        "py": "for i in range ( 0 , k ) : NEW_LINE",
        "explain": "Iterate loop k times and update even_sum & odd_sum using previous values"
    },
    {
        "py": "prev_even = even_sum NEW_LINE prev_odd = odd_sum NEW_LINE",
        "explain": "Update the prev_even and odd_sum"
    },
    {
        "py": "even_sum = ( ( prev_even * even_count ) + ( prev_odd * odd_count ) ) NEW_LINE",
        "explain": "Even sum"
    },
    {
        "py": "odd_sum = ( ( prev_even * odd_count ) + ( prev_odd * even_count ) ) NEW_LINE",
        "explain": "Odd sum"
    },
    {
        "py": "print ( int ( even_sum ) ) NEW_LINE",
        "explain": "Return even_sum"
    },
    {
        "py": "low = 4 ; NEW_LINE high = 5 ; NEW_LINE",
        "explain": "Given ranges"
    },
    {
        "py": "K = 3 ; NEW_LINE",
        "explain": "Length of permutation"
    },
    {
        "py": "countEvenSum ( low , high , K ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def count ( n , k ) : NEW_LINE INDENT count = ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; NEW_LINE DEDENT",
        "explain": "Function to count the number of N - digit numbers such that sum of every K consecutive digits are equal"
    },
    {
        "py": "print ( count ) ; NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 ; NEW_LINE k = 1 ; NEW_LINE count ( n , k ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def func ( N , P ) : NEW_LINE",
        "explain": "Function to find the sum of largest divisors of numbers in range 1 to N not divisible by prime number P"
    },
    {
        "py": "sumUptoN = ( N * ( N + 1 ) / 2 ) ; NEW_LINE sumOfMultiplesOfP = 0 ; NEW_LINE",
        "explain": "Total sum upto N"
    },
    {
        "py": "if ( N < P ) : NEW_LINE INDENT return sumUptoN ; NEW_LINE DEDENT",
        "explain": "If no multiple of P exist up to N"
    },
    {
        "py": "elif ( ( N / P ) == 1 ) : NEW_LINE INDENT return sumUptoN - P + 1 ; NEW_LINE DEDENT",
        "explain": "If only P itself is in the range from 1 to N"
    },
    {
        "py": "sumOfMultiplesOfP = ( ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ) ; NEW_LINE",
        "explain": "Sum of those that are divisible by P"
    },
    {
        "py": "return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; NEW_LINE",
        "explain": "Recursively function call to find the sum for N / P"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 10 ; NEW_LINE P = 5 ; NEW_LINE",
        "explain": "Given N and P"
    },
    {
        "py": "print ( func ( N , P ) ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def findShifts ( A , N ) : NEW_LINE",
        "explain": "Function to find the right shifts required for each element to reach its sorted array position in A [ ]"
    },
    {
        "py": "shift = [ 0 for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "Stores required number of shifts for each element"
    },
    {
        "py": "if ( i == A [ i ] - 1 ) : NEW_LINE INDENT shift [ i ] = 0 NEW_LINE DEDENT",
        "explain": "If the element is at sorted position"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "shift [ i ] = ( A [ i ] - 1 - i + N ) % N NEW_LINE",
        "explain": "Calculate right shift"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( shift [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the respective shifts"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 3 , 2 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findShifts ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def constructmatrix ( N ) : NEW_LINE INDENT check = bool ( True ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to construct matrix with diagonal sum equal to matrix sum"
    },
    {
        "py": "if ( i == j ) : NEW_LINE INDENT print ( 1 , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( check ) : NEW_LINE",
        "explain": "If diagonal position"
    },
    {
        "py": "print ( 2 , end = \" \u2581 \" ) NEW_LINE check = bool ( False ) NEW_LINE else : NEW_LINE",
        "explain": "Positive element"
    },
    {
        "py": "print ( - 2 , end = \" \u2581 \" ) NEW_LINE check = bool ( True ) NEW_LINE print ( ) NEW_LINE",
        "explain": "Negative element"
    },
    {
        "py": "N = 5 NEW_LINE constructmatrix ( 5 ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def check ( unit_digit , X ) : NEW_LINE",
        "explain": "Function to calculate and return the minimum number of times a number with unit digit X needs to be added to get a sum N"
    },
    {
        "py": "for times in range ( 1 , 11 ) : NEW_LINE INDENT digit = ( X * times ) % 10 NEW_LINE if ( digit == unit_digit ) : NEW_LINE INDENT return times NEW_LINE DEDENT DEDENT",
        "explain": "Calculate the number of additions required to get unit digit of N"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "If unit digit of N cannot be obtained"
    },
    {
        "py": "def getNum ( N , X ) : NEW_LINE",
        "explain": "Function to return the minimum number required to represent N"
    },
    {
        "py": "unit_digit = N % 10 NEW_LINE",
        "explain": "Stores unit digit of N"
    },
    {
        "py": "times = check ( unit_digit , X ) NEW_LINE",
        "explain": "Stores minimum addition of X required to obtain unit digit of N"
    },
    {
        "py": "if ( times == - 1 ) : NEW_LINE INDENT return times NEW_LINE DEDENT",
        "explain": "If unit digit of N cannot be obtained"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if ( N >= ( times * X ) ) : NEW_LINE",
        "explain": "If N is greater than or equal to ( X * times )"
    },
    {
        "py": "return times NEW_LINE",
        "explain": "Minimum count of numbers that needed to represent N"
    },
    {
        "py": "else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Representation not possible"
    },
    {
        "py": "N = 58 NEW_LINE X = 7 NEW_LINE print ( getNum ( N , X ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def minPoints ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT",
        "explain": "Function to find the minimum number of Points required to cover a grid"
    },
    {
        "py": "if ( ( n % 2 != 0 ) and ( m % 2 != 0 ) ) : NEW_LINE INDENT ans = ( ( n * m ) // 2 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( n * m ) // 2 NEW_LINE DEDENT",
        "explain": "If number of block is even"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the minimum points"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "N = 5 NEW_LINE M = 7 NEW_LINE",
        "explain": "Given size of grid"
    },
    {
        "py": "print ( minPoints ( N , M ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def getLargestString ( s , k ) : NEW_LINE",
        "explain": "Function to find the largest lexicographical string with given constraints ."
    },
    {
        "py": "frequency_array = [ 0 ] * 26 NEW_LINE",
        "explain": "Vector containing frequency of each character ."
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE INDENT frequency_array [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Assigning frequency to"
    },
    {
        "py": "ans = \" \" NEW_LINE",
        "explain": "Empty string of string class type"
    },
    {
        "py": "i = 25 NEW_LINE while i >= 0 : NEW_LINE",
        "explain": "Loop to iterate over maximum priority first ."
    },
    {
        "py": "if ( frequency_array [ i ] > k ) : NEW_LINE",
        "explain": "If frequency is greater than or equal to k ."
    },
    {
        "py": "temp = k NEW_LINE st = chr ( i + ord ( ' a ' ) ) NEW_LINE while ( temp > 0 ) : NEW_LINE",
        "explain": "Temporary variable to operate in - place of k ."
    },
    {
        "py": "ans += st NEW_LINE temp -= 1 NEW_LINE frequency_array [ i ] -= k NEW_LINE",
        "explain": "concatenating with the resultant string ans ."
    },
    {
        "py": "j = i - 1 NEW_LINE while ( frequency_array [ j ] <= 0 and j >= 0 ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT",
        "explain": "Handling k case by adjusting with just smaller priority element ."
    },
    {
        "py": "if ( frequency_array [ j ] > 0 and j >= 0 ) : NEW_LINE INDENT str1 = chr ( j + ord ( ' a ' ) ) NEW_LINE ans += str1 NEW_LINE frequency_array [ j ] -= 1 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Condition to verify if index j does have frequency greater than 0 ;"
    },
    {
        "py": "break NEW_LINE",
        "explain": "if no such element is found than string can not be processed further ."
    },
    {
        "py": "elif ( frequency_array [ i ] > 0 ) : NEW_LINE",
        "explain": "If frequency is greater than 0 and less than k ."
    },
    {
        "py": "temp = frequency_array [ i ] NEW_LINE frequency_array [ i ] -= temp NEW_LINE st = chr ( i + ord ( ' a ' ) ) NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT ans += st NEW_LINE temp -= 1 NEW_LINE DEDENT",
        "explain": "Here we don 't need to fix K  consecutive element criteria."
    },
    {
        "py": "else : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "Otherwise check for next possible element ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \" xxxxzza \" NEW_LINE k = 3 NEW_LINE print ( getLargestString ( S , k ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minOperations ( a , b , n ) : NEW_LINE",
        "explain": "Function to find the minimum operations required to make all elements of the array equal"
    },
    {
        "py": "minA = min ( a ) ; NEW_LINE",
        "explain": "Minimum element of A"
    },
    {
        "py": "for x in range ( minA , - 1 , - 1 ) : NEW_LINE",
        "explain": "Traverse through all final values"
    },
    {
        "py": "check = True ; NEW_LINE",
        "explain": "Variable indicating whether all elements can be converted to x or not"
    },
    {
        "py": "operations = 0 ; NEW_LINE",
        "explain": "Total operations"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( x % b [ i ] == a [ i ] % b [ i ] ) : NEW_LINE INDENT operations += ( a [ i ] - x ) / b [ i ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Traverse through all array elements"
    },
    {
        "py": "else : NEW_LINE INDENT check = False ; NEW_LINE break ; NEW_LINE DEDENT if ( check ) : NEW_LINE return operations ; NEW_LINE return - 1 ; NEW_LINE",
        "explain": "All elements can 't  be converted to x"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE A = [ 5 , 7 , 10 , 5 , 15 ] ; NEW_LINE B = [ 2 , 2 , 1 , 3 , 5 ] ; NEW_LINE print ( int ( minOperations ( A , B , N ) ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def getLargestSum ( N ) : NEW_LINE",
        "explain": "Function to return the maximum sum of a + b satisfying the given condition"
    },
    {
        "py": "max_sum = 0 NEW_LINE",
        "explain": "Initialize max_sum"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N + 1 , 1 ) : NEW_LINE DEDENT",
        "explain": "Consider all the possible pairs"
    },
    {
        "py": "if ( i * j % ( i + j ) == 0 ) : NEW_LINE",
        "explain": "Check if the product is divisible by the sum"
    },
    {
        "py": "max_sum = max ( max_sum , i + j ) NEW_LINE",
        "explain": "Storing the maximum sum in the max_sum variable"
    },
    {
        "py": "return max_sum NEW_LINE",
        "explain": "Return the max_sum value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE max_sum = getLargestSum ( N ) NEW_LINE print ( max_sum ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - 10 ** 9 NEW_LINE max_ending_here = 0 NEW_LINE DEDENT",
        "explain": "Kadane 's algorithm to find the maximum subarray sum"
    },
    {
        "py": "for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE",
        "explain": "Loop to find the maximum subarray array sum in the given array"
    },
    {
        "py": "def maxSum ( a , n ) : NEW_LINE",
        "explain": "Function to find the maximum sum of the array by multiplying the prefix and suffix by - 1"
    },
    {
        "py": "S = 0 NEW_LINE",
        "explain": "Total intital sum"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT S += a [ i ] NEW_LINE DEDENT X = maxSubArraySum ( a , n ) NEW_LINE",
        "explain": "Loop to find the maximum sum of the array"
    },
    {
        "py": "return 2 * X - S NEW_LINE",
        "explain": "Maximum value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 1 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE max_sum = maxSum ( a , n ) NEW_LINE print ( max_sum ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find the number of interesting primes up to N"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT",
        "explain": "Function to check if a number is prime or not"
    },
    {
        "py": "i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if flag == 1 else False ) NEW_LINE",
        "explain": "If n is divisible by any number between 2 and sqrt ( n ) , it is not prime"
    },
    {
        "py": "def isPerfectSquare ( x ) : NEW_LINE",
        "explain": "Function to check if a number is perfect square or not"
    },
    {
        "py": "sr = math . sqrt ( x ) NEW_LINE",
        "explain": "Find floating povalue of square root of x ."
    },
    {
        "py": "return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE",
        "explain": "If square root is an integer"
    },
    {
        "py": "def countInterestingPrimes ( n ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE DEDENT",
        "explain": "Function to find the number of interesting primes less than equal to N ."
    },
    {
        "py": "if ( isPrime ( i ) ) : NEW_LINE",
        "explain": "Check whether the number is prime or not"
    },
    {
        "py": "j = 1 NEW_LINE while ( j * j * j * j <= i ) : NEW_LINE",
        "explain": "Iterate for values of b"
    },
    {
        "py": "if ( isPerfectSquare ( i - j * j * j * j ) ) : NEW_LINE INDENT answer += 1 NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE",
        "explain": "Check condition for a"
    },
    {
        "py": "return answer NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( countInterestingPrimes ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python implementation of the approach"
    },
    {
        "py": "def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT",
        "explain": "Function to convert decimal number n to its binary representation stored as an array arr [ ]"
    },
    {
        "py": "def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT",
        "explain": "Function to convert the number represented as a binary array arr [ ] into its decimal equivalent"
    },
    {
        "py": "def maxNum ( n , k ) : NEW_LINE",
        "explain": "Function to return the maximized number by flipping atmost k bits"
    },
    {
        "py": "l = int ( math . log2 ( n ) ) + 1 NEW_LINE",
        "explain": "Number of bits in n"
    },
    {
        "py": "a = [ 0 for i in range ( 0 , l ) ] NEW_LINE decBinary ( a , n ) NEW_LINE",
        "explain": "Find the binary representation of n"
    },
    {
        "py": "cn = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( a [ i ] == 0 and cn < k ) : NEW_LINE INDENT a [ i ] = 1 NEW_LINE cn = cn + 1 NEW_LINE DEDENT DEDENT",
        "explain": "To count the number of 0 s flipped"
    },
    {
        "py": "return binaryDec ( a , l ) NEW_LINE",
        "explain": "Return the decimal equivalent of the maximized number"
    },
    {
        "py": "n = 4 NEW_LINE k = 1 NEW_LINE print ( maxNum ( n , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findSubSeq ( arr , n , sum ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT",
        "explain": "Function to find the required subsequence"
    },
    {
        "py": "if ( sum < arr [ i ] ) : NEW_LINE INDENT arr [ i ] = - 1 ; NEW_LINE DEDENT",
        "explain": "Current element cannot be a part of the required subsequence"
    },
    {
        "py": "else : NEW_LINE INDENT sum -= arr [ i ] ; NEW_LINE DEDENT",
        "explain": "Include current element in the required subsequence So update the sum"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Print the elements of the required subsequence"
    },
    {
        "py": "if ( arr [ i ] != - 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "If the current element was included in the subsequence"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 17 , 25 , 46 , 94 , 201 , 400 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE sum = 272 ; NEW_LINE findSubSeq ( arr , n , sum ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 26 NEW_LINE",
        "explain": "Python implementation of the approach"
    },
    {
        "py": "def maxAlpha ( str , len ) : NEW_LINE",
        "explain": "Function to return the maximum valued alphabet"
    },
    {
        "py": "first = [ - 1 for x in range ( MAX ) ] NEW_LINE last = [ - 1 for x in range ( MAX ) ] NEW_LINE",
        "explain": "Set the first and the last occurrence of all the characters to - 1"
    },
    {
        "py": "for i in range ( 0 , len ) : NEW_LINE INDENT index = ord ( str [ i ] ) - 97 NEW_LINE DEDENT",
        "explain": "Update the occurrences of the characters"
    },
    {
        "py": "if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i NEW_LINE DEDENT last [ index ] = i NEW_LINE",
        "explain": "Only set the first occurrence if it hasn 't already been set"
    },
    {
        "py": "ans = - 1 NEW_LINE maxVal = - 1 NEW_LINE",
        "explain": "To store the result"
    },
    {
        "py": "for i in range ( 0 , MAX ) : NEW_LINE",
        "explain": "For every alphabet"
    },
    {
        "py": "if ( first [ i ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If current alphabet doesn 't appear  in the given string"
    },
    {
        "py": "if ( ( last [ i ] - first [ i ] ) > maxVal ) : NEW_LINE INDENT maxVal = last [ i ] - first [ i ] ; NEW_LINE ans = i NEW_LINE DEDENT return chr ( ans + 97 ) NEW_LINE",
        "explain": "If the current character has the highest value so far"
    },
    {
        "py": "str = \" abbba \" NEW_LINE len = len ( str ) NEW_LINE print ( maxAlpha ( str , len ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 100001 ; NEW_LINE",
        "explain": "Python implementation of the approach"
    },
    {
        "py": "def find_distinct ( a , n , q , queries ) : NEW_LINE INDENT check = [ 0 ] * MAX ; NEW_LINE idx = [ 0 ] * MAX ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT",
        "explain": "Function to perform queries to find number of distinct elements from a given index till last index in an array"
    },
    {
        "py": "if ( check [ a [ i ] ] == 0 ) : NEW_LINE",
        "explain": "Check if current element already visited or not"
    },
    {
        "py": "idx [ i ] = cnt ; NEW_LINE check [ a [ i ] ] = 1 ; NEW_LINE cnt += 1 ; NEW_LINE else : NEW_LINE",
        "explain": "If not visited store current counter and increment it and mark check as 1"
    },
    {
        "py": "idx [ i ] = cnt - 1 ; NEW_LINE",
        "explain": "Otherwise if visited simply store current counter"
    },
    {
        "py": "for i in range ( 0 , q ) : NEW_LINE INDENT m = queries [ i ] ; NEW_LINE print ( idx [ m ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Perform queries"
    },
    {
        "py": "a = [ 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( a ) ; NEW_LINE queries = [ 0 , 3 , 5 , 7 ] ; NEW_LINE q = len ( queries ) ; NEW_LINE find_distinct ( a , n , q , queries ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 24 ; NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def countOp ( x ) : NEW_LINE",
        "explain": "Function to return the count of operations required"
    },
    {
        "py": "arr = [ 0 ] * MAX ; NEW_LINE arr [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , MAX ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] * 2 ; NEW_LINE DEDENT",
        "explain": "To store the powers of 2"
    },
    {
        "py": "temp = x ; NEW_LINE flag = True ; NEW_LINE",
        "explain": "Temporary variable to store x"
    },
    {
        "py": "ans = 0 ; NEW_LINE",
        "explain": "To store the index of smaller number larger than x"
    },
    {
        "py": "operations = 0 ; NEW_LINE flag2 = False ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr [ i ] - 1 == x ) : NEW_LINE INDENT flag2 = True ; NEW_LINE DEDENT DEDENT",
        "explain": "To store the count of operations"
    },
    {
        "py": "if ( arr [ i ] > x ) : NEW_LINE INDENT ans = i ; NEW_LINE break ; NEW_LINE DEDENT",
        "explain": "Stores the index of number in the form of 2 ^ n - 1"
    },
    {
        "py": "if ( flag2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( flag ) : NEW_LINE",
        "explain": "If x is already in the form 2 ^ n - 1 then no operation is required"
    },
    {
        "py": "if ( arr [ ans ] < x ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT operations += 1 ; NEW_LINE",
        "explain": "If number is less than x increase the index"
    },
    {
        "py": "for i in range ( MAX ) : NEW_LINE INDENT take = x ^ ( arr [ i ] - 1 ) ; NEW_LINE if ( take <= arr [ ans ] - 1 ) : NEW_LINE DEDENT",
        "explain": "Calculate all the values ( x xor 2 ^ n - 1 ) for all possible n"
    },
    {
        "py": "if ( take > temp ) : NEW_LINE INDENT temp = take ; NEW_LINE DEDENT",
        "explain": "Only take value which is closer to the number"
    },
    {
        "py": "if ( temp == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT temp += 1 ; NEW_LINE operations += 1 ; NEW_LINE x = temp ; NEW_LINE if ( x == arr [ ans ] - 1 ) : NEW_LINE INDENT flag = False ; NEW_LINE DEDENT",
        "explain": "If number is in the form of 2 ^ n - 1 then break"
    },
    {
        "py": "return operations ; NEW_LINE",
        "explain": "Return the count of operations required to obtain the number"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 39 ; NEW_LINE print ( countOp ( x ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT",
        "explain": "Function to return the minimum operations required"
    },
    {
        "py": "freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "Count the frequency of each element"
    },
    {
        "py": "maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE DEDENT",
        "explain": "Maximum element from the array"
    },
    {
        "py": "for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE",
        "explain": "Find all the multiples of i"
    },
    {
        "py": "freq [ j ] = 0 NEW_LINE",
        "explain": "Delete the multiples"
    },
    {
        "py": "result += 1 NEW_LINE return result NEW_LINE",
        "explain": "Increment the operations"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import gcd NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def minGCD ( arr , n ) : NEW_LINE INDENT minGCD = 0 ; NEW_LINE DEDENT",
        "explain": "Function to return minimum GCD among all subarrays"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT minGCD = gcd ( minGCD , arr [ i ] ) ; NEW_LINE DEDENT return minGCD ; NEW_LINE",
        "explain": "Minimum GCD among all sub - arrays will be the GCD of all the elements of the array"
    },
    {
        "py": "def minLCM ( arr , n ) : NEW_LINE INDENT minLCM = arr [ 0 ] ; NEW_LINE DEDENT",
        "explain": "Function to return minimum LCM among all subarrays"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT minLCM = min ( minLCM , arr [ i ] ) ; NEW_LINE DEDENT return minLCM ; NEW_LINE",
        "explain": "Minimum LCM among all sub - arrays will be the minimum element from the array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 66 , 14 , 521 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( \" LCM \u2581 = \u2581 \" , minLCM ( arr , n ) , \" , \u2581 GCD \u2581 = \" , minGCD ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def formStringMinOperations ( ss ) : NEW_LINE",
        "explain": "Function that returns the modified lexicographically smallest string after performing minimum number of given operations"
    },
    {
        "py": "count = [ 0 ] * 3 ; NEW_LINE s = list ( ss ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 ; NEW_LINE DEDENT",
        "explain": "Stores the initial frequencies of characters 0 s , 1 s and 2 s"
    },
    {
        "py": "processed = [ 0 ] * 3 ; NEW_LINE",
        "explain": "Stores number of processed characters upto that point of each type"
    },
    {
        "py": "reqd = math . floor ( len ( s ) / 3 ) ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "Required number of characters of each type"
    },
    {
        "py": "if ( count [ ord ( s [ i ] ) - ord ( '0' ) ] == reqd ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT",
        "explain": "If the current type has already reqd number of characters , no need to perform any operation"
    },
    {
        "py": "if ( s [ i ] == '0' and count [ 0 ] > reqd and processed [ 0 ] >= reqd ) : NEW_LINE",
        "explain": "Process all 3 cases"
    },
    {
        "py": "if ( count [ 1 ] < reqd ) : NEW_LINE INDENT s [ i ] = '1' ; NEW_LINE count [ 1 ] += 1 ; NEW_LINE count [ 0 ] -= 1 ; NEW_LINE DEDENT",
        "explain": "Check for 1 first"
    },
    {
        "py": "elif ( count [ 2 ] < reqd ) : NEW_LINE INDENT s [ i ] = '2' ; NEW_LINE count [ 2 ] += 1 ; NEW_LINE count [ 0 ] -= 1 ; NEW_LINE DEDENT",
        "explain": "Else 2"
    },
    {
        "py": "if ( s [ i ] == '1' and count [ 1 ] > reqd ) : NEW_LINE INDENT if ( count [ 0 ] < reqd ) : NEW_LINE INDENT s [ i ] = '0' ; NEW_LINE count [ 0 ] += 1 ; NEW_LINE count [ 1 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 2 ] < reqd and processed [ 1 ] >= reqd ) : NEW_LINE INDENT s [ i ] = '2' ; NEW_LINE count [ 2 ] += 1 ; NEW_LINE count [ 1 ] -= 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Here we need to check processed [ 1 ] only for 2 since 0 is less than 1 and we can replace it anytime"
    },
    {
        "py": "if ( s [ i ] == '2' and count [ 2 ] > reqd ) : NEW_LINE INDENT if ( count [ 0 ] < reqd ) : NEW_LINE INDENT s [ i ] = '0' ; NEW_LINE count [ 0 ] += 1 ; NEW_LINE count [ 2 ] -= 1 ; NEW_LINE DEDENT elif ( count [ 1 ] < reqd ) : NEW_LINE INDENT s [ i ] = '1' ; NEW_LINE count [ 1 ] += 1 ; NEW_LINE count [ 2 ] -= 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Here we can replace 2 with 0 and 1 anytime"
    },
    {
        "py": "processed [ ord ( s [ i ] ) - ord ( '0' ) ] += 1 ; NEW_LINE return ' ' . join ( s ) ; NEW_LINE",
        "explain": "keep count of processed characters of each type"
    },
    {
        "py": "s = \"011200\" ; NEW_LINE print ( formStringMinOperations ( s ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findMinimumAdjacentSwaps ( arr , N ) : NEW_LINE",
        "explain": "Function to find minimum swaps"
    },
    {
        "py": "visited = [ False ] * ( N + 1 ) NEW_LINE minimumSwaps = 0 NEW_LINE for i in range ( 2 * N ) : NEW_LINE",
        "explain": "visited array to check if value is seen already"
    },
    {
        "py": "if ( visited [ arr [ i ] ] == False ) : NEW_LINE INDENT visited [ arr [ i ] ] = True NEW_LINE DEDENT",
        "explain": "If the arr [ i ] is seen first time"
    },
    {
        "py": "count = 0 NEW_LINE for j in range ( i + 1 , 2 * N ) : NEW_LINE",
        "explain": "stores the number of swaps required to find the correct position of current element 's partner"
    },
    {
        "py": "if ( visited [ arr [ j ] ] == False ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Increment count only if the current element has not been visited yet ( if is visited , means it has already been placed at its correct position )"
    },
    {
        "py": "elif ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT minimumSwaps += count NEW_LINE DEDENT return minimumSwaps NEW_LINE",
        "explain": "If current element 's partner is found"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 3 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE N //= 2 NEW_LINE print ( findMinimumAdjacentSwaps ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 program to print the largest palindromic number by permuting digits of a number"
    },
    {
        "py": "def possibility ( m , length , s ) : NEW_LINE",
        "explain": "Function to check if a number can be permuted to form a palindrome number"
    },
    {
        "py": "countodd = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE",
        "explain": "counts the occurrence of number which is odd"
    },
    {
        "py": "if m [ int ( s [ i ] ) ] & 1 : NEW_LINE INDENT countodd += 1 NEW_LINE DEDENT",
        "explain": "if occurrence is odd"
    },
    {
        "py": "if countodd > 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "if number exceeds 1"
    },
    {
        "py": "def largestPalindrome ( s ) : NEW_LINE",
        "explain": "Function to print the largest palindromic number by permuting digits of a number"
    },
    {
        "py": "l = len ( s ) NEW_LINE",
        "explain": "string length"
    },
    {
        "py": "m = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT m [ int ( s [ i ] ) ] += 1 NEW_LINE DEDENT",
        "explain": "map that marks the occurrence of a number"
    },
    {
        "py": "if possibility ( m , l , s ) == False : NEW_LINE INDENT print ( \" Palindrome \u2581 cannot \u2581 be \u2581 formed \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "check the possibility of a palindromic number"
    },
    {
        "py": "largest = [ None ] * l NEW_LINE",
        "explain": "string array that stores the largest permuted palindromic number"
    },
    {
        "py": "front = 0 NEW_LINE",
        "explain": "pointer of front"
    },
    {
        "py": "for i in range ( 9 , - 1 , - 1 ) : NEW_LINE",
        "explain": "greedily start from 9 to 0 and place the greater number in front and odd in the middle"
    },
    {
        "py": "if m [ i ] & 1 : NEW_LINE",
        "explain": "if the occurrence of number is odd"
    },
    {
        "py": "largest [ l // 2 ] = chr ( i + 48 ) NEW_LINE",
        "explain": "place one odd occurring number in the middle"
    },
    {
        "py": "m [ i ] -= 1 NEW_LINE",
        "explain": "decrease the count"
    },
    {
        "py": "while m [ i ] > 0 : NEW_LINE INDENT largest [ front ] = chr ( i + 48 ) NEW_LINE largest [ l - front - 1 ] = chr ( i + 48 ) NEW_LINE m [ i ] -= 2 NEW_LINE front += 1 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "place the rest of numbers greedily"
    },
    {
        "py": "while m [ i ] > 0 : NEW_LINE",
        "explain": "if all numbers occur even times , then place greedily"
    },
    {
        "py": "largest [ front ] = chr ( i + 48 ) NEW_LINE largest [ l - front - 1 ] = chr ( i + 48 ) NEW_LINE",
        "explain": "place greedily at front"
    },
    {
        "py": "m [ i ] -= 2 NEW_LINE",
        "explain": "2 numbers are placed , so decrease the count"
    },
    {
        "py": "front += 1 NEW_LINE",
        "explain": "increase placing position"
    },
    {
        "py": "for i in range ( 0 , l ) : NEW_LINE INDENT print ( largest [ i ] , end = \" \" ) NEW_LINE DEDENT",
        "explain": "print the largest string thus formed"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"313551\" NEW_LINE largestPalindrome ( s ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def swapCount ( s ) : NEW_LINE",
        "explain": "Function to calculate swaps required"
    },
    {
        "py": "' NEW_LINE INDENT pos = [ ] NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' [ ' ) : NEW_LINE INDENT pos . append ( i ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Keep track of '["
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "To count number of encountered ' [ '"
    },
    {
        "py": "p = 0 NEW_LINE",
        "explain": "To track position of next ' [ ' in pos"
    },
    {
        "py": "sum = 0 NEW_LINE s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "To store result"
    },
    {
        "py": "if ( s [ i ] == ' [ ' ) : NEW_LINE INDENT count += 1 NEW_LINE p += 1 NEW_LINE DEDENT elif ( s [ i ] == ' ] ' ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT",
        "explain": "Increment count and move p to next position"
    },
    {
        "py": "if ( count < 0 ) : NEW_LINE",
        "explain": "We have encountered an unbalanced part of string"
    },
    {
        "py": "sum += pos [ p ] - i NEW_LINE s [ i ] , s [ pos [ p ] ] = ( s [ pos [ p ] ] , s [ i ] ) NEW_LINE p += 1 NEW_LINE",
        "explain": "Increment sum by number of swaps required i . e . position of next ' [ ' - current position"
    },
    {
        "py": "count = 1 NEW_LINE return sum NEW_LINE",
        "explain": "Reset count to 1"
    },
    {
        "py": "s = \" [ ] ] [ ] [ \" NEW_LINE print ( swapCount ( s ) ) NEW_LINE s = \" [ [ ] [ ] ] \" NEW_LINE print ( swapCount ( s ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minimumCostOfBreaking ( X , Y , m , n ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT",
        "explain": "Method returns minimum cost to break board into m * n squares"
    },
    {
        "py": "X . sort ( reverse = True ) NEW_LINE",
        "explain": "sort the horizontal cost in reverse order"
    },
    {
        "py": "Y . sort ( reverse = True ) NEW_LINE",
        "explain": "sort the vertical cost in reverse order"
    },
    {
        "py": "hzntl = 1 ; vert = 1 NEW_LINE",
        "explain": "initialize current width as 1"
    },
    {
        "py": "i = 0 ; j = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( X [ i ] > Y [ j ] ) : NEW_LINE INDENT res += X [ i ] * vert NEW_LINE DEDENT DEDENT",
        "explain": "loop until one or both cost array are processed"
    },
    {
        "py": "hzntl += 1 NEW_LINE i += 1 NEW_LINE else : NEW_LINE res += Y [ j ] * hzntl NEW_LINE",
        "explain": "increase current horizontal part count by 1"
    },
    {
        "py": "vert += 1 NEW_LINE j += 1 NEW_LINE",
        "explain": "increase current vertical part count by 1"
    },
    {
        "py": "total = 0 NEW_LINE while ( i < m ) : NEW_LINE INDENT total += X [ i ] NEW_LINE i += 1 NEW_LINE DEDENT res += total * vert NEW_LINE",
        "explain": "loop for horizontal array , if remains"
    },
    {
        "py": "total = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT total += Y [ j ] NEW_LINE j += 1 NEW_LINE DEDENT res += total * hzntl NEW_LINE return res NEW_LINE",
        "explain": "loop for vertical array , if remains"
    },
    {
        "py": "m = 6 ; n = 4 NEW_LINE X = [ 2 , 1 , 3 , 1 , 4 ] NEW_LINE Y = [ 4 , 1 , 2 ] NEW_LINE print ( minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ) NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "def getMin ( x , y , z ) : NEW_LINE INDENT return min ( min ( x , y ) , z ) NEW_LINE DEDENT",
        "explain": "Function to find the minimum of the three numbers"
    },
    {
        "py": "def editDistance ( str1 , str2 , m , n ) : NEW_LINE",
        "explain": "Function to find the minimum number operations required to convert string str1 to str2 using the operations"
    },
    {
        "py": "dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE",
        "explain": "Stores the results of subproblems"
    },
    {
        "py": "for i in range ( 0 , m + 1 ) : NEW_LINE INDENT for j in range ( 0 , n + 1 ) : NEW_LINE DEDENT",
        "explain": "Fill dp [ ] [ ] in bottom up manner"
    },
    {
        "py": "if ( i == 0 ) : NEW_LINE",
        "explain": "If str1 is empty , then insert all characters of string str2"
    },
    {
        "py": "dp [ i ] [ j ] = j NEW_LINE",
        "explain": "Minimum operations is j"
    },
    {
        "py": "elif ( j == 0 ) : NEW_LINE",
        "explain": "If str2 is empty , then remove all characters of string str2"
    },
    {
        "py": "dp [ i ] [ j ] = i NEW_LINE",
        "explain": "Minimum operations is i"
    },
    {
        "py": "elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT",
        "explain": "If the last characters are same , then ignore last character"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "If the last character is different , then find the minimum"
    },
    {
        "py": "dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) NEW_LINE",
        "explain": "Perform one of the insert , remove and the replace"
    },
    {
        "py": "return dp [ m ] [ n ] NEW_LINE",
        "explain": "Return the minimum number of steps required"
    },
    {
        "py": "def minimumSteps ( S , N ) : NEW_LINE",
        "explain": "Function to find the minimum number of steps to modify the string such that first half and second half becomes the same"
    },
    {
        "py": "ans = 10 ** 10 NEW_LINE",
        "explain": "Stores the minimum number of operations required"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT S1 = S [ : i ] NEW_LINE S2 = S [ i : ] NEW_LINE DEDENT",
        "explain": "Traverse the given string S"
    },
    {
        "py": "count = editDistance ( S1 , S2 , len ( S1 ) , len ( S2 ) ) NEW_LINE",
        "explain": "Find the minimum operations"
    },
    {
        "py": "ans = min ( ans , count ) NEW_LINE",
        "explain": "Update the ans"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "S = \" aabb \" NEW_LINE N = len ( S ) NEW_LINE minimumSteps ( S , N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def minimumOperations ( N ) : NEW_LINE",
        "explain": "Function to find the minimum number of operations to reduce N to 2 by dividing N by 5 or decrementing by 3"
    },
    {
        "py": "dp = [ 0 for i in range ( N + 1 ) ] NEW_LINE",
        "explain": "Initialize the dp array"
    },
    {
        "py": "for i in range ( N + 1 ) : NEW_LINE INDENT dp [ i ] = 1000000000 NEW_LINE DEDENT",
        "explain": "Initialize the array dp [ ]"
    },
    {
        "py": "dp [ 2 ] = 0 NEW_LINE",
        "explain": "For N = 2 number of operations needed is zero"
    },
    {
        "py": "for i in range ( 2 , N + 1 , 1 ) : NEW_LINE",
        "explain": "Iterating over the range [ 1 , N ]"
    },
    {
        "py": "if ( dp [ i ] == 1000000000 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If it 's not possible to  create current N"
    },
    {
        "py": "if ( i * 5 <= N ) : NEW_LINE INDENT dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) NEW_LINE DEDENT",
        "explain": "Multiply with 5"
    },
    {
        "py": "if ( i + 3 <= N ) : NEW_LINE INDENT dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) NEW_LINE DEDENT",
        "explain": "Adding the value 3"
    },
    {
        "py": "if ( dp [ N ] == 1000000000 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Checking if not possible to make the number as 2"
    },
    {
        "py": "return dp [ N ] NEW_LINE",
        "explain": "Return the minimum number of operations"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( minimumOperations ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MaxProfit ( arr , n , transactionFee ) : NEW_LINE INDENT buy = - arr [ 0 ] NEW_LINE sell = 0 NEW_LINE DEDENT",
        "explain": "Function to find the maximum profit with transaction fee"
    },
    {
        "py": "for i in range ( 1 , n , 1 ) : NEW_LINE INDENT temp = buy NEW_LINE DEDENT",
        "explain": "Traversing the stocks for each day"
    },
    {
        "py": "buy = max ( buy , sell - arr [ i ] ) NEW_LINE sell = max ( sell , temp + arr [ i ] - transactionFee ) NEW_LINE",
        "explain": "Update buy and sell"
    },
    {
        "py": "return max ( sell , buy ) NEW_LINE",
        "explain": "Return the maximum profit"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE transactionFee = 2 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( MaxProfit ( arr , n , transactionFee ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "start = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE",
        "explain": "Stores the maximum path sum from the cell ( 1 , 1 ) to ( N , M )"
    },
    {
        "py": "ending = [ [ 0 for i in range ( 3 ) ] for j in range ( 3 ) ] NEW_LINE",
        "explain": "Stores the maximum path sum from the cell ( j , j ) to ( N , M )"
    },
    {
        "py": "def calculateStart ( n , m ) : NEW_LINE",
        "explain": "Function to find the maximum path sum from the cell ( 1 , 1 ) to ( N , M )"
    },
    {
        "py": "for i in range ( 1 , m , 1 ) : NEW_LINE INDENT start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Traverse the first row"
    },
    {
        "py": "for i in range ( 1 , n , 1 ) : NEW_LINE INDENT start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] NEW_LINE DEDENT",
        "explain": "Traverse the first column"
    },
    {
        "py": "for i in range ( 1 , n , 1 ) : NEW_LINE INDENT for j in range ( 1 , m , 1 ) : NEW_LINE DEDENT",
        "explain": "Traverse the matrix"
    },
    {
        "py": "start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) NEW_LINE",
        "explain": "Update the value of start [ i ] [ j ]"
    },
    {
        "py": "def calculateEnd ( n , m ) : NEW_LINE",
        "explain": "Function to find the maximum path sum from the cell ( j , j ) to ( N , M )"
    },
    {
        "py": "i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT",
        "explain": "Traverse the last row"
    },
    {
        "py": "i = m - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT",
        "explain": "Traverse the last column"
    },
    {
        "py": "i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT j = m - 2 NEW_LINE while ( j >= 0 ) : NEW_LINE DEDENT",
        "explain": "Traverse the matrix"
    },
    {
        "py": "ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) NEW_LINE j -= 1 NEW_LINE i -= 1 NEW_LINE",
        "explain": "Update the value of ending [ i ] [ j ]"
    },
    {
        "py": "def maximumPathSum ( mat , n , m , q , coordinates ) : NEW_LINE",
        "explain": "Function to find the maximum path sum from the top - left to the bottom right cell such that path contains one of the cells in the array coordinates [ ] [ ]"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT start [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE ending [ i ] [ j ] = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT",
        "explain": "Initialize the start and the end matrices"
    },
    {
        "py": "calculateStart ( n , m ) NEW_LINE",
        "explain": "Calculate the start matrix"
    },
    {
        "py": "calculateEnd ( n , m ) NEW_LINE",
        "explain": "Calculate the end matrix"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the maximum path sum"
    },
    {
        "py": "for i in range ( q ) : NEW_LINE INDENT X = coordinates [ i ] [ 0 ] - 1 NEW_LINE Y = coordinates [ i ] [ 1 ] - 1 NEW_LINE DEDENT",
        "explain": "Traverse the coordinates"
    },
    {
        "py": "ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) NEW_LINE",
        "explain": "Update the value of ans"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the resultant maximum sum path value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE N = 3 NEW_LINE M = 3 NEW_LINE Q = 2 NEW_LINE coordinates = [ [ 1 , 2 ] , [ 2 , 2 ] ] NEW_LINE maximumPathSum ( mat , N , M , Q , coordinates ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MaxSubsetlength ( arr , A , B ) : NEW_LINE",
        "explain": "Function to find the length of the longest subset of an array of strings with at most A 0 s and B 1 s"
    },
    {
        "py": "dp = [ [ 0 for i in range ( B + 1 ) ] for i in range ( A + 1 ) ] NEW_LINE",
        "explain": "Initialize a 2D array with its entries as 0"
    },
    {
        "py": "for str in arr : NEW_LINE",
        "explain": "Traverse the given array"
    },
    {
        "py": "zeros = str . count ( '0' ) NEW_LINE ones = str . count ( '1' ) NEW_LINE",
        "explain": "Store the count of 0 s and 1 s in the current string"
    },
    {
        "py": "for i in range ( A , zeros - 1 , - 1 ) : NEW_LINE",
        "explain": "Iterate in the range [ A , zeros ]"
    },
    {
        "py": "for j in range ( B , ones - 1 , - 1 ) : NEW_LINE",
        "explain": "Iterate in the range [ B , ones ]"
    },
    {
        "py": "dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) NEW_LINE",
        "explain": "Update the value of dp [ i ] [ j ]"
    },
    {
        "py": "return dp [ A ] [ B ] NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \"1\" , \"0\" , \"0001\" , \"10\" , \"111001\" ] NEW_LINE A , B = 5 , 3 NEW_LINE print ( MaxSubsetlength ( arr , A , B ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def numOfWays ( a , n , i = 0 , blue = [ ] ) : NEW_LINE",
        "explain": "Function to count ways to select N distinct pairs of candies with different colours"
    },
    {
        "py": "if i == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If n pairs are selected"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores count of ways to select the i - th pair"
    },
    {
        "py": "for j in range ( n ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , n ]"
    },
    {
        "py": "if mat [ i ] [ j ] == 1 and j not in blue : NEW_LINE INDENT count += numOfWays ( mat , n , i + 1 , blue + [ j ] ) NEW_LINE DEDENT return count NEW_LINE",
        "explain": "If pair ( i , j ) is not included"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 0 , 1 , 1 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE print ( numOfWays ( mat , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minCost ( arr , n ) : NEW_LINE",
        "explain": "Function to find the minimum cost to reach the end of an array"
    },
    {
        "py": "if ( n < 3 ) : NEW_LINE INDENT print ( arr [ 0 ] ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Base Case : When N < 3"
    },
    {
        "py": "dp = [ 0 ] * n NEW_LINE",
        "explain": "Store the results in table"
    },
    {
        "py": "dp [ 0 ] = arr [ 0 ] NEW_LINE dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] NEW_LINE",
        "explain": "Initialize base cases"
    },
    {
        "py": "for i in range ( 2 , n - 1 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) NEW_LINE DEDENT",
        "explain": "Iterate over the range [ 2 , N - 2 ] to construct the dp array"
    },
    {
        "py": "dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) NEW_LINE",
        "explain": "Handle case for the last index , i . e . N - 1"
    },
    {
        "py": "print ( dp [ n - 1 ] ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 9 , 4 , 6 , 8 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE minCost ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "M = 1000000007 NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def power ( X , Y ) : NEW_LINE",
        "explain": "Function to find the value of power ( X , Y ) in O ( log Y )"
    },
    {
        "py": "res = 1 NEW_LINE",
        "explain": "Stores power ( X , Y )"
    },
    {
        "py": "X = X % M NEW_LINE",
        "explain": "Update X"
    },
    {
        "py": "if ( X == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "while ( Y > 0 ) : NEW_LINE",
        "explain": "Calculate power ( X , Y )"
    },
    {
        "py": "if ( Y & 1 ) : NEW_LINE",
        "explain": "If Y is an odd number"
    },
    {
        "py": "res = ( res * X ) % M NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "Y = Y >> 1 NEW_LINE",
        "explain": "Update Y"
    },
    {
        "py": "X = ( X * X ) % M NEW_LINE return res NEW_LINE",
        "explain": "Update X"
    },
    {
        "py": "def findValue ( n ) : NEW_LINE",
        "explain": "Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"
    },
    {
        "py": "X = 0 NEW_LINE",
        "explain": "Stores binary representation of n"
    },
    {
        "py": "pow_10 = 1 NEW_LINE",
        "explain": "Stores power of 10"
    },
    {
        "py": "while ( n ) : NEW_LINE",
        "explain": "Calculate the binary representation of n"
    },
    {
        "py": "if ( n & 1 ) : NEW_LINE",
        "explain": "If n is an odd number"
    },
    {
        "py": "X += pow_10 NEW_LINE",
        "explain": "Update X"
    },
    {
        "py": "pow_10 *= 10 NEW_LINE",
        "explain": "Update pow_10"
    },
    {
        "py": "n //= 2 NEW_LINE",
        "explain": "Update n"
    },
    {
        "py": "X = ( X * 2 ) % M NEW_LINE",
        "explain": "Double the value of X"
    },
    {
        "py": "res = power ( 2 , X ) NEW_LINE return res NEW_LINE",
        "explain": "Stores the value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 2 NEW_LINE print ( findValue ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "M = 1000000007 ; NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def power ( X , Y ) : NEW_LINE",
        "explain": "Function to find the value of power ( X , Y ) in O ( log Y )"
    },
    {
        "py": "res = 1 ; NEW_LINE",
        "explain": "Stores power ( X , Y )"
    },
    {
        "py": "X = X % M ; NEW_LINE",
        "explain": "Update X"
    },
    {
        "py": "if ( X == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "while ( Y > 0 ) : NEW_LINE",
        "explain": "Calculate power ( X , Y )"
    },
    {
        "py": "if ( Y % 2 == 1 ) : NEW_LINE",
        "explain": "If Y is an odd number"
    },
    {
        "py": "res = ( res * X ) % M ; NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "Y = Y >> 1 ; NEW_LINE",
        "explain": "Update Y"
    },
    {
        "py": "X = ( X * X ) % M ; NEW_LINE return res ; NEW_LINE",
        "explain": "Update X"
    },
    {
        "py": "def findValue ( N ) : NEW_LINE",
        "explain": "Function to calculate ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"
    },
    {
        "py": "dp = [ 0 ] * ( N + 1 ) ; NEW_LINE",
        "explain": "dp [ N ] * dp [ N ] : Stores value of ( 2 ^ ( 2 * x ) ) % ( 10 ^ 9 + 7 )"
    },
    {
        "py": "dp [ 1 ] = 2 ; NEW_LINE dp [ 2 ] = 1024 ; NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "for i in range ( 3 , N + 1 ) : NEW_LINE",
        "explain": "Iterate over the range [ 3 , N ]"
    },
    {
        "py": "y = ( i & ( - i ) ) ; NEW_LINE",
        "explain": "Stores rightmost bit of i"
    },
    {
        "py": "x = i - y ; NEW_LINE",
        "explain": "Stores the value of ( i - y )"
    },
    {
        "py": "if ( x == 0 ) : NEW_LINE",
        "explain": "If x is power of 2"
    },
    {
        "py": "dp [ i ] = power ( dp [ i // 2 ] , 10 ) ; NEW_LINE else : NEW_LINE",
        "explain": "Update dp [ i ]"
    },
    {
        "py": "dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; NEW_LINE return ( dp [ N ] * dp [ N ] ) % M ; NEW_LINE",
        "explain": "Update dp [ i ]"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 150 ; NEW_LINE print ( findValue ( n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findWays ( N ) : NEW_LINE",
        "explain": "Function to find the number of ways to get the sum N with throw of dice"
    },
    {
        "py": "if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "cnt = 0 NEW_LINE",
        "explain": "Stores the count of total number of ways to get sum N"
    },
    {
        "py": "for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = cnt + findWays ( N - i ) NEW_LINE DEDENT DEDENT",
        "explain": "Recur for all 6 states"
    },
    {
        "py": "return cnt NEW_LINE",
        "explain": "Return answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( findWays ( N ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE",
        "explain": "Utility function to check array can be partition to 3 subsequences of equal sum or not"
    },
    {
        "py": "if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE",
        "explain": "When element at index j is added to sm1"
    },
    {
        "py": "m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE",
        "explain": "When element at index j is added to sm2"
    },
    {
        "py": "r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE",
        "explain": "When element at index j is added to sm3"
    },
    {
        "py": "return max ( l , m , r ) NEW_LINE",
        "explain": "Return maximum value among all above 3 recursive call"
    },
    {
        "py": "def checkEqualSum ( arr , N ) : NEW_LINE",
        "explain": "Function to check array can be partition to 3 subsequences of equal sum or not"
    },
    {
        "py": "sum1 = sum2 = sum3 = 0 NEW_LINE",
        "explain": "Initialise 3 sums to 0"
    },
    {
        "py": "if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "checkEqualSum ( arr , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "dp = { } NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 , j ) : NEW_LINE INDENT s = str ( sm1 ) + \" _ \" + str ( sm2 ) + str ( j ) NEW_LINE DEDENT",
        "explain": "Function to check array can be partition into sum of 3 equal"
    },
    {
        "py": "if j == N : NEW_LINE INDENT if sm1 == sm2 and sm2 == sm3 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if s in dp : NEW_LINE INDENT return dp [ s ] NEW_LINE DEDENT",
        "explain": "If value at particular index is not - 1 then return value at that index which ensure no more further calls"
    },
    {
        "py": "l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) NEW_LINE",
        "explain": "When element at index j is added to sm1"
    },
    {
        "py": "m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) NEW_LINE",
        "explain": "When element at index j is added to sm2"
    },
    {
        "py": "r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) NEW_LINE",
        "explain": "When element at index j is added to sm3"
    },
    {
        "py": "dp [ s ] = max ( l , m , r ) NEW_LINE return dp [ s ] NEW_LINE",
        "explain": "Update the current state and return that value"
    },
    {
        "py": "def checkEqualSum ( arr , N ) : NEW_LINE",
        "explain": "Function to check array can be partition to 3 subsequences of equal sum or not"
    },
    {
        "py": "sum1 = sum2 = sum3 = 0 NEW_LINE",
        "explain": "Initialise 3 sums to 0"
    },
    {
        "py": "if checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "arr = [ 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "checkEqualSum ( arr , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def precompute ( nextpos , arr , N ) : NEW_LINE",
        "explain": "Precompute the index of next different element in the array for every array element"
    },
    {
        "py": "nextpos [ N - 1 ] = N NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Default value"
    },
    {
        "py": "if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT nextpos [ i ] = nextpos [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT nextpos [ i ] = i + 1 NEW_LINE DEDENT",
        "explain": "Compute nextpos [ i ] using nextpos [ i + 1 ]"
    },
    {
        "py": "def findIndex ( query , arr , N , Q ) : NEW_LINE",
        "explain": "Function to return the smallest index"
    },
    {
        "py": "nextpos = [ 0 ] * N NEW_LINE precompute ( nextpos , arr , N ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT l = query [ i ] [ 0 ] NEW_LINE r = query [ i ] [ 1 ] NEW_LINE x = query [ i ] [ 2 ] NEW_LINE ans = - 1 NEW_LINE DEDENT",
        "explain": "nextpos [ i ] will store the next position p where arr [ p ] != arr [ i ]"
    },
    {
        "py": "if arr [ l ] != x : NEW_LINE INDENT ans = l NEW_LINE DEDENT",
        "explain": "If X is not present at l"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "d = nextpos [ l ] NEW_LINE",
        "explain": "Find the index which stores a value different from X"
    },
    {
        "py": "if d <= r : NEW_LINE INDENT ans = d NEW_LINE DEDENT print ( ans ) NEW_LINE",
        "explain": "If that index is within the range"
    },
    {
        "py": "N = 6 NEW_LINE Q = 3 NEW_LINE arr = [ 1 , 2 , 1 , 1 , 3 , 5 ] NEW_LINE query = [ [ 0 , 3 , 1 ] , [ 1 , 5 , 2 ] , [ 2 , 3 , 1 ] ] NEW_LINE findIndex ( query , arr , N , Q ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "mod = 1000000007 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def countWays ( s , t , k ) : NEW_LINE",
        "explain": "Function to count number of ways to convert string S to string T by performing K cyclic shifts"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "Calculate length of string"
    },
    {
        "py": "a = 0 NEW_LINE b = 0 NEW_LINE",
        "explain": "a is no . of good cyclic shifts b is no . of bad cyclic shifts"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT p = s [ i : n - i + 1 ] + s [ : i + 1 ] NEW_LINE DEDENT",
        "explain": "Iterate in string"
    },
    {
        "py": "if ( p == t ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT",
        "explain": "Precompute the number of good and bad cyclic shifts"
    },
    {
        "py": "dp1 = [ 0 ] * ( k + 1 ) NEW_LINE dp2 = [ 0 ] * ( k + 1 ) NEW_LINE if ( s == t ) : NEW_LINE INDENT dp1 [ 0 ] = 1 NEW_LINE dp2 [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp1 [ 0 ] = 0 NEW_LINE dp2 [ 0 ] = 1 NEW_LINE DEDENT",
        "explain": "dp2 [ i ] to store the no of ways to get to a bad shift in i moves"
    },
    {
        "py": "for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod NEW_LINE dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod NEW_LINE DEDENT",
        "explain": "Calculate good and bad shifts"
    },
    {
        "py": "return ( dp1 [ k ] ) NEW_LINE",
        "explain": "Return the required number of ways"
    },
    {
        "py": "S = ' ab ' NEW_LINE T = ' ab ' NEW_LINE",
        "explain": "Given Strings"
    },
    {
        "py": "K = 2 NEW_LINE",
        "explain": "Given K shifts required"
    },
    {
        "py": "print ( countWays ( S , T , K ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def minOperation ( k ) : NEW_LINE",
        "explain": "Function to find minimum operations"
    },
    {
        "py": "dp = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 1 NEW_LINE DEDENT",
        "explain": "dp is initialised to store the steps"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , dp [ i // 2 ] + 1 ) NEW_LINE DEDENT return dp [ k ] NEW_LINE",
        "explain": "For all even numbers"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 12 NEW_LINE print ( minOperation ( k ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxSum ( p0 , p1 , a , pos , n ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( p0 == p1 ) : NEW_LINE INDENT return p0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to find the maximum subset sum"
    },
    {
        "py": "ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; NEW_LINE",
        "explain": "Ignore the current element"
    },
    {
        "py": "ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; NEW_LINE",
        "explain": "including element in partition 1"
    },
    {
        "py": "ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; NEW_LINE return ans ; NEW_LINE",
        "explain": "including element in partition 2"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( 0 , 0 , a , 0 , n ) ) ; NEW_LINE",
        "explain": "size of the array"
    },
    {
        "py": "import numpy as np NEW_LINE import sys NEW_LINE INT_MIN = - ( sys . maxsize - 1 ) NEW_LINE",
        "explain": "Python3 implementation for the above mentioned Dynamic Programming approach"
    },
    {
        "py": "def maxSum ( a , n ) : NEW_LINE",
        "explain": "Function to find the maximum subset sum"
    },
    {
        "py": "sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT limit = 2 * sum + 1 ; NEW_LINE",
        "explain": "sum of all elements"
    },
    {
        "py": "dp = np . zeros ( ( n + 1 , limit ) ) ; NEW_LINE",
        "explain": "bottom up lookup table ;"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE INDENT dp [ i ] [ j ] = INT_MIN ; NEW_LINE DEDENT DEDENT",
        "explain": "initialising dp table with INT_MIN where , INT_MIN means no solution"
    },
    {
        "py": "dp [ 0 ] [ sum ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( limit ) : NEW_LINE DEDENT",
        "explain": "Case when diff is 0"
    },
    {
        "py": "if ( ( j - a [ i - 1 ] ) >= 0 and dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; NEW_LINE DEDENT",
        "explain": "Putting ith element in g0"
    },
    {
        "py": "if ( ( j + a [ i - 1 ] ) < limit and dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; NEW_LINE DEDENT",
        "explain": "Putting ith element in g1"
    },
    {
        "py": "if ( dp [ i - 1 ] [ j ] != INT_MIN ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT return dp [ n ] [ sum ] ; NEW_LINE",
        "explain": "Ignoring ith element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE a = [ 1 , 2 , 3 , 6 ] ; NEW_LINE print ( maxSum ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "fib = [ 0 ] * 100005 ; NEW_LINE",
        "explain": "Array to find the fibonacci sequence"
    },
    {
        "py": "def computeFibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 ; NEW_LINE fib [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , 100005 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to find the fibonacci sequence"
    },
    {
        "py": "def countString ( string ) : NEW_LINE",
        "explain": "Function to count all possible strings"
    },
    {
        "py": "ans = 1 ; NEW_LINE cnt = 1 ; NEW_LINE for i in range ( 1 , len ( string ) ) : NEW_LINE",
        "explain": "Initialize ans = 1"
    },
    {
        "py": "if ( string [ i ] == string [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT",
        "explain": "If two consecutive char are same increase cnt"
    },
    {
        "py": "else : NEW_LINE INDENT ans = ans * fib [ cnt ] ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT",
        "explain": "Else multiply the fib [ cnt ] to ans and initialize ans to 1"
    },
    {
        "py": "ans = ans * fib [ cnt ] ; NEW_LINE",
        "explain": "If str = abcdeeee , then for last \" eeee \" the count munst be updated"
    },
    {
        "py": "return ans ; NEW_LINE",
        "explain": "Return the total count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abdllldefkkkk \" ; NEW_LINE DEDENT",
        "explain": "Driver 's Code"
    },
    {
        "py": "computeFibonacci ( ) ; NEW_LINE",
        "explain": "Function to precompute all the fibonacci number"
    },
    {
        "py": "print ( countString ( string ) ) ; NEW_LINE",
        "explain": "Function call to find the count"
    },
    {
        "py": "MAX = 100001 NEW_LINE",
        "explain": "Python3 program to find the first N terms of Golomb Sequence"
    },
    {
        "py": "def printGolombSequence ( N ) : NEW_LINE",
        "explain": "Function to print the Golomb Sequence"
    },
    {
        "py": "arr = [ 0 ] * MAX NEW_LINE",
        "explain": "Initialise the array"
    },
    {
        "py": "cnt = 0 NEW_LINE",
        "explain": "Initialise the cnt to 0"
    },
    {
        "py": "arr [ 0 ] = 0 NEW_LINE arr [ 1 ] = 1 NEW_LINE",
        "explain": "First and second element of Golomb Sequence is 0 , 1"
    },
    {
        "py": "M = dict ( ) NEW_LINE",
        "explain": "Map to store the count of current element in Golomb Sequence"
    },
    {
        "py": "M [ 2 ] = 2 NEW_LINE",
        "explain": "Store the count of 2"
    },
    {
        "py": "for i in range ( 2 , N + 1 ) : NEW_LINE",
        "explain": "Iterate over 2 to N"
    },
    {
        "py": "if ( cnt == 0 ) : NEW_LINE INDENT arr [ i ] = 1 + arr [ i - 1 ] NEW_LINE cnt = M [ arr [ i ] ] NEW_LINE cnt -= 1 NEW_LINE DEDENT",
        "explain": "If cnt is equals to 0 then we have new number for Golomb Sequence which is 1 + previous element"
    },
    {
        "py": "else : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE cnt -= 1 NEW_LINE DEDENT",
        "explain": "Else the current element is the previous element in this Sequence"
    },
    {
        "py": "M [ i ] = arr [ i ] NEW_LINE",
        "explain": "Map the current index to current value in arr [ ]"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the Golomb Sequence"
    },
    {
        "py": "N = 11 NEW_LINE printGolombSequence ( N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def number_of_ways ( n ) : NEW_LINE",
        "explain": "Function to find the number the number of ways to reach Nth stair"
    },
    {
        "py": "includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE",
        "explain": "Array including number of ways that includes 3"
    },
    {
        "py": "not_includes_3 = [ 0 ] * ( n + 1 ) NEW_LINE",
        "explain": "Array including number of ways that doesn 't includes 3"
    },
    {
        "py": "includes_3 [ 3 ] = 1 NEW_LINE not_includes_3 [ 1 ] = 1 NEW_LINE not_includes_3 [ 2 ] = 2 NEW_LINE not_includes_3 [ 3 ] = 3 NEW_LINE",
        "explain": "Initially to reach 3 stairs by taking 3 steps can be reached by 1 way"
    },
    {
        "py": "for i in range ( 4 , n + 1 ) : NEW_LINE INDENT includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] NEW_LINE not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] NEW_LINE DEDENT return includes_3 [ n ] NEW_LINE",
        "explain": "Loop to find the number the number of ways to reach Nth stair"
    },
    {
        "py": "n = 7 NEW_LINE print ( number_of_ways ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "from math import ceil , sqrt NEW_LINE MAX = 100000 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "divisors = [ 0 ] * MAX NEW_LINE",
        "explain": "Map to store the divisor count"
    },
    {
        "py": "def generateDivisors ( n ) : NEW_LINE INDENT for i in range ( 1 , ceil ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT divisors [ i ] += 1 NEW_LINE divisors [ n // i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT",
        "explain": "Function to generate the divisors of all the array elements"
    },
    {
        "py": "def findMaxMultiples ( arr , n ) : NEW_LINE",
        "explain": "Function to find the maximum number of multiples in an array before it"
    },
    {
        "py": "ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To store the maximum divisor count"
    },
    {
        "py": "ans = max ( divisors [ arr [ i ] ] , ans ) NEW_LINE",
        "explain": "Update ans if more number of divisors are found"
    },
    {
        "py": "generateDivisors ( arr [ i ] ) NEW_LINE return ans NEW_LINE",
        "explain": "Generating all the divisors of the next element of the array"
    },
    {
        "py": "arr = [ 8 , 1 , 28 , 4 , 2 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxMultiples ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = 3 NEW_LINE maxV = 20 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "dp = [ [ [ 0 for i in range ( maxV ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE",
        "explain": "3d array to store states of dp"
    },
    {
        "py": "v = [ [ [ 0 for i in range ( maxV ) ] for i in range ( n ) ] for i in range ( n ) ] NEW_LINE",
        "explain": "Array to determine whether a state has been solved before"
    },
    {
        "py": "def countWays ( i , j , x , arr ) : NEW_LINE",
        "explain": "Function to return the count of required paths"
    },
    {
        "py": "if ( i == n or j == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = ( x & arr [ i ] [ j ] ) NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == n - 1 and j == n - 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "if ( v [ i ] [ j ] [ x ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ x ] NEW_LINE DEDENT v [ i ] [ j ] [ x ] = 1 NEW_LINE",
        "explain": "If a state has been solved before it won 't be evaluated again"
    },
    {
        "py": "dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; NEW_LINE return dp [ i ] [ j ] [ x ] NEW_LINE",
        "explain": "Recurrence relation"
    },
    {
        "py": "arr = [ [ 1 , 2 , 1 ] , [ 1 , 1 , 0 ] , [ 2 , 1 , 1 ] ] NEW_LINE print ( countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def FindMaximumSum ( ind , kon , a , b , c , n , dp ) : NEW_LINE",
        "explain": "Function to return the maximum sum"
    },
    {
        "py": "if ind == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "if dp [ ind ] [ kon ] != - 1 : NEW_LINE INDENT return dp [ ind ] [ kon ] NEW_LINE DEDENT ans = - 10 ** 9 + 5 NEW_LINE",
        "explain": "Already visited"
    },
    {
        "py": "if kon == 0 : NEW_LINE INDENT ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT",
        "explain": "If the element has been taken from first array in previous step"
    },
    {
        "py": "elif kon == 1 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) NEW_LINE DEDENT",
        "explain": "If the element has been taken from second array in previous step"
    },
    {
        "py": "elif kon == 2 : NEW_LINE INDENT ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) NEW_LINE ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) NEW_LINE DEDENT dp [ ind ] [ kon ] = ans NEW_LINE return ans NEW_LINE",
        "explain": "If the element has been taken from third array in previous step"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 3 NEW_LINE a = [ 6 , 8 , 2 , 7 , 4 , 2 , 7 ] NEW_LINE b = [ 7 , 8 , 5 , 8 , 6 , 3 , 5 ] NEW_LINE c = [ 8 , 3 , 2 , 6 , 8 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE dp = [ [ - 1 for i in range ( N ) ] for j in range ( n ) ] NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) NEW_LINE",
        "explain": "Pick element from first array"
    },
    {
        "py": "y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) NEW_LINE",
        "explain": "Pick element from second array"
    },
    {
        "py": "z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) NEW_LINE",
        "explain": "Pick element from third array"
    },
    {
        "py": "print ( max ( x , y , z ) ) NEW_LINE",
        "explain": "Print the maximum of them"
    },
    {
        "py": "mod = 1000000007 ; NEW_LINE",
        "explain": "Python3 iimplementation of the above approach"
    },
    {
        "py": "def noOfBinaryStrings ( N , k ) : NEW_LINE INDENT dp = [ 0 ] * 100002 ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT dp [ i ] = 1 ; NEW_LINE DEDENT dp [ k ] = 2 ; NEW_LINE for i in range ( k + 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; NEW_LINE DEDENT return dp [ N ] ; NEW_LINE DEDENT",
        "explain": "Function to return no of ways to build a binary string of length N such that 0 s always occur in groups of size K"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 ; NEW_LINE K = 2 ; NEW_LINE print ( noOfBinaryStrings ( N , K ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findWays ( p ) : NEW_LINE",
        "explain": "Function to find number of ways to pair people in party"
    },
    {
        "py": "dp = [ 0 ] * ( p + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 2 NEW_LINE",
        "explain": "To store count of number of ways ."
    },
    {
        "py": "for i in range ( 3 , p + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return dp [ p ] NEW_LINE",
        "explain": "Using the recurrence defined find count for different values of p ."
    },
    {
        "py": "p = 3 NEW_LINE print ( findWays ( p ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def CountWays ( n ) : NEW_LINE",
        "explain": "A simple recursive implementation for counting ways to reach a score using 1 and 2 with consecutive 2 allowed"
    },
    {
        "py": "if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 1 + 1 NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "return CountWays ( n - 1 ) + CountWays ( n - 3 ) NEW_LINE",
        "explain": "For cases n > 2"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python 3 program to check if the number is weird or not"
    },
    {
        "py": "def factors ( n ) : NEW_LINE",
        "explain": "code to find all the factors of the number excluding the number itself"
    },
    {
        "py": "v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE",
        "explain": "vector to store the factors"
    },
    {
        "py": "for i in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE",
        "explain": "note that this loop runs till sqrt ( n )"
    },
    {
        "py": "if ( n % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE DEDENT",
        "explain": "if the value of i is a factor"
    },
    {
        "py": "if ( int ( n / i ) != i ) : NEW_LINE INDENT v . append ( int ( n / i ) ) NEW_LINE DEDENT",
        "explain": "condition to check the divisor is not the number itself"
    },
    {
        "py": "return v NEW_LINE",
        "explain": "return the vector"
    },
    {
        "py": "def checkAbundant ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT",
        "explain": "Function to check if the number is abundant or not"
    },
    {
        "py": "v = factors ( n ) NEW_LINE",
        "explain": "find the divisors using function"
    },
    {
        "py": "for i in range ( len ( v ) ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT",
        "explain": "sum all the factors"
    },
    {
        "py": "if ( sum > n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "check for abundant or not"
    },
    {
        "py": "def checkSemiPerfect ( n ) : NEW_LINE",
        "explain": "Function to check if the number is semi - perfect or not"
    },
    {
        "py": "v = factors ( n ) NEW_LINE",
        "explain": "find the divisors"
    },
    {
        "py": "v . sort ( reverse = False ) NEW_LINE r = len ( v ) NEW_LINE",
        "explain": "sorting the vector"
    },
    {
        "py": "subset = [ [ 0 for i in range ( n + 1 ) ] for j in range ( r + 1 ) ] NEW_LINE",
        "explain": "subset to check if no is semiperfect"
    },
    {
        "py": "for i in range ( r + 1 ) : NEW_LINE INDENT subset [ i ] [ 0 ] = True NEW_LINE DEDENT",
        "explain": "initialising 1 st column to true"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE INDENT subset [ 0 ] [ i ] = False NEW_LINE DEDENT",
        "explain": "initialing 1 st row except zero position to 0"
    },
    {
        "py": "for i in range ( 1 , r + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE DEDENT",
        "explain": "loop to find whether the number is semiperfect"
    },
    {
        "py": "if ( j < v [ i - 1 ] ) : NEW_LINE INDENT subset [ i ] [ j ] = subset [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT subset [ i ] [ j ] = ( subset [ i - 1 ] [ j ] or subset [ i - 1 ] [ j - v [ i - 1 ] ] ) NEW_LINE DEDENT",
        "explain": "calculation to check if the number can be made by summation of divisors"
    },
    {
        "py": "if ( ( subset [ r ] [ n ] ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "if not possible to make the number by any combination of divisors"
    },
    {
        "py": "def checkweird ( n ) : NEW_LINE INDENT if ( checkAbundant ( n ) == True and checkSemiPerfect ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check for weird or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 70 NEW_LINE if ( checkweird ( n ) ) : NEW_LINE INDENT print ( \" Weird \u2581 Number \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Weird \u2581 Number \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxSubArraySumRepeated ( a , n , k ) : NEW_LINE INDENT max_so_far = - 2147483648 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( n * k ) : NEW_LINE DEDENT",
        "explain": "Returns sum of maximum sum subarray created after concatenating a [ 0. . n - 1 ] k times ."
    },
    {
        "py": "max_ending_here = max_ending_here + a [ i % n ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT return max_so_far NEW_LINE",
        "explain": "This is where it differs from Kadane 's  algorithm. We use  modular arithmetic to  find next element."
    },
    {
        "py": "a = [ 10 , 20 , - 30 , - 1 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( \" Maximum \u2581 contiguous \u2581 sum \u2581 is \u2581 \" , maxSubArraySumRepeated ( a , n , k ) ) NEW_LINE",
        "explain": "Driver program to test maxSubArraySum"
    },
    {
        "py": "def longOddEvenIncSeq ( arr , n ) : NEW_LINE",
        "explain": "function to find the longest increasing odd even subsequence"
    },
    {
        "py": "lioes = list ( ) NEW_LINE",
        "explain": "lioes [ i ] stores longest increasing odd even subsequence ending at arr [ i ]"
    },
    {
        "py": "maxLen = 0 NEW_LINE",
        "explain": "to store the length of longest increasing odd even subsequence"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT lioes . append ( 1 ) NEW_LINE DEDENT",
        "explain": "Initialize LIOES values for all indexes"
    },
    {
        "py": "i = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( arr [ i ] + arr [ j ] ) % 2 != 0 and lioes [ i ] < lioes [ j ] + 1 ) : NEW_LINE INDENT lioes [ i ] = lioes [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Compute optimized LIOES values in bottom up manner"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if maxLen < lioes [ i ] : NEW_LINE INDENT maxLen = lioes [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Pick maximum of all LIOES values"
    },
    {
        "py": "return maxLen NEW_LINE",
        "explain": "required maximum length"
    },
    {
        "py": "arr = [ 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Longest \u2581 Increasing \u2581 Odd \u2581 Even \u2581 \" + \" Subsequence : \u2581 \" , longOddEvenIncSeq ( arr , n ) ) NEW_LINE",
        "explain": "Driver to test above"
    },
    {
        "py": "def isOperator ( op ) : NEW_LINE INDENT return ( op == ' + ' or op == ' * ' ) NEW_LINE DEDENT",
        "explain": "Utility method to check whether a character is operator or not"
    },
    {
        "py": "def printMinAndMaxValueOfExp ( exp ) : NEW_LINE INDENT num = [ ] NEW_LINE opr = [ ] NEW_LINE tmp = \" \" NEW_LINE DEDENT",
        "explain": "method prints minimum and maximum value obtainable from an expression"
    },
    {
        "py": "for i in range ( len ( exp ) ) : NEW_LINE INDENT if ( isOperator ( exp [ i ] ) ) : NEW_LINE INDENT opr . append ( exp [ i ] ) NEW_LINE num . append ( int ( tmp ) ) NEW_LINE tmp = \" \" NEW_LINE DEDENT else : NEW_LINE INDENT tmp += exp [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "store operator and numbers in different vectors"
    },
    {
        "py": "num . append ( int ( tmp ) ) NEW_LINE llen = len ( num ) NEW_LINE minVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE maxVal = [ [ 0 for i in range ( llen ) ] for i in range ( llen ) ] NEW_LINE",
        "explain": "storing last number in vector"
    },
    {
        "py": "for i in range ( llen ) : NEW_LINE INDENT for j in range ( llen ) : NEW_LINE INDENT minVal [ i ] [ j ] = 10 ** 9 NEW_LINE maxVal [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT",
        "explain": "initializing minval and maxval 2D array"
    },
    {
        "py": "if ( i == j ) : NEW_LINE INDENT minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] NEW_LINE DEDENT",
        "explain": "initializing main diagonal by num values"
    },
    {
        "py": "for L in range ( 2 , llen + 1 ) : NEW_LINE INDENT for i in range ( llen - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT minTmp = 0 NEW_LINE maxTmp = 0 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "looping similar to matrix chain multiplication and updating both 2D arrays"
    },
    {
        "py": "if ( opr [ k ] == ' + ' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "if current operator is ' + ' , updating tmp variable by addition"
    },
    {
        "py": "elif ( opr [ k ] == ' * ' ) : NEW_LINE INDENT minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] NEW_LINE maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] NEW_LINE DEDENT",
        "explain": "if current operator is ' * ' , updating tmp variable by multiplication"
    },
    {
        "py": "if ( minTmp < minVal [ i ] [ j ] ) : NEW_LINE INDENT minVal [ i ] [ j ] = minTmp NEW_LINE DEDENT if ( maxTmp > maxVal [ i ] [ j ] ) : NEW_LINE INDENT maxVal [ i ] [ j ] = maxTmp NEW_LINE DEDENT",
        "explain": "updating array values by tmp variables"
    },
    {
        "py": "print ( \" Minimum \u2581 value \u2581 : \u2581 \" , minVal [ 0 ] [ llen - 1 ] , \" , \u2581 \\ \u2581 Maximum \u2581 value \u2581 : \u2581 \" , maxVal [ 0 ] [ llen - 1 ] ) NEW_LINE",
        "explain": "last element of first row will store the result"
    },
    {
        "py": "expression = \"1 + 2*3 + 4*5\" NEW_LINE printMinAndMaxValueOfExp ( expression ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "A naive recursive implementation that simply follows the above optimal substructure property"
    },
    {
        "py": "def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE DEDENT",
        "explain": "Matrix A [ i ] has dimension p [ i - 1 ] x p [ i ] for i = 1. . n"
    },
    {
        "py": "for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count NEW_LINE DEDENT DEDENT",
        "explain": "place parenthesis at different places between first and last matrix , recursively calculate count of multiplications for each parenthesis placement and return the minimum count"
    },
    {
        "py": "return _min NEW_LINE",
        "explain": "Return minimum count"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \u2581 \" , MatrixChainOrder ( arr , 1 , n - 1 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] NEW_LINE",
        "explain": "Python program using memoization"
    },
    {
        "py": "def matrixChainMemoised ( p , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def MatrixChainOrder ( p , n ) : NEW_LINE INDENT i = 1 NEW_LINE j = n - 1 NEW_LINE return matrixChainMemoised ( p , i , j ) NEW_LINE DEDENT",
        "explain": "Function for matrix chain multiplication"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 multiplications \u2581 is \" , MatrixChainOrder ( arr , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def flipBitsOfAandB ( A , B ) : NEW_LINE",
        "explain": "Function to flip bits of A and B which are set in both of them"
    },
    {
        "py": "A = A ^ ( A & B ) NEW_LINE",
        "explain": "Clear the bits of A which are set in both A and B"
    },
    {
        "py": "B = B ^ ( A & B ) NEW_LINE",
        "explain": "Clear the bits of B which are set in both A and B"
    },
    {
        "py": "print ( A , B ) NEW_LINE",
        "explain": "Print updated A and B"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 10 NEW_LINE B = 20 NEW_LINE flipBitsOfAandB ( A , B ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def TotalHammingDistance ( n ) : NEW_LINE INDENT i = 1 NEW_LINE sum = 0 NEW_LINE while ( n // i > 0 ) : NEW_LINE INDENT sum = sum + n // i NEW_LINE i = i * 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT",
        "explain": "Function to calculate and return the hamming distance between all consecutive numbers from 0 to N"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE print ( TotalHammingDistance ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE m = 1000000007 NEW_LINE",
        "explain": "Python3 Program to implement the above approach"
    },
    {
        "py": "def solve ( n ) : NEW_LINE",
        "explain": "Function to find the sum of all divisors of all numbers from 1 to N"
    },
    {
        "py": "s = 0 ; NEW_LINE l = 1 ; NEW_LINE while ( l < n + 1 ) : NEW_LINE",
        "explain": "Stores the sum"
    },
    {
        "py": "r = ( int ) ( n / math . floor ( n / l ) ) ; NEW_LINE x = ( ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ) ; NEW_LINE y = ( ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ) ; NEW_LINE p = ( int ) ( ( n / l ) % m ) ; NEW_LINE",
        "explain": "Marks the last poof occurence with same count"
    },
    {
        "py": "s = ( ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ) ; NEW_LINE s %= m ; NEW_LINE l = r + 1 ; NEW_LINE",
        "explain": "Calculate the sum"
    },
    {
        "py": "print ( int ( ( s + m ) % m ) ) ; NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find minimum time required to split a stick of N length into unit pieces"
    },
    {
        "py": "def min_time_to_cut ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the minimum time required to split stick of N into length into unit pieces"
    },
    {
        "py": "return int ( math . log2 ( N ) ) + 1 NEW_LINE",
        "explain": "Return the minimum unit of time required"
    },
    {
        "py": "N = 100 NEW_LINE print ( min_time_to_cut ( N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findDistinctSums ( n ) : NEW_LINE",
        "explain": "Function to find the distinct sums"
    },
    {
        "py": "s = set ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE DEDENT",
        "explain": "Set to store distinct sums"
    },
    {
        "py": "s . add ( i + j ) NEW_LINE",
        "explain": "Inserting every sum"
    },
    {
        "py": "return len ( s ) NEW_LINE",
        "explain": "Returning distinct sums"
    },
    {
        "py": "N = 3 NEW_LINE print ( findDistinctSums ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printPattern ( i , j , n ) : NEW_LINE",
        "explain": "Function to print pattern recursively"
    },
    {
        "py": "if ( j >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i >= n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if ( j == i or j == n - 1 - i ) : NEW_LINE",
        "explain": "Conditions to print slash"
    },
    {
        "py": "if ( i == n - 1 - j ) : NEW_LINE INDENT print ( \" / \" , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Condition to print forword slash"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" \\\\ \" , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Condition to print backward slash"
    },
    {
        "py": "' NEW_LINE INDENT else : NEW_LINE INDENT print ( \" * \" , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Else print '*"
    },
    {
        "py": "if ( printPattern ( i , j + 1 , n ) == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Recursive call for rows"
    },
    {
        "py": "return printPattern ( i + 1 , 0 , n ) NEW_LINE",
        "explain": "Recursive call for changing the rows"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 9 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "printPattern ( 0 , 0 , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import sys ; NEW_LINE",
        "explain": "Python3 implementation for pattern searching in an array using Z - Algorithm"
    },
    {
        "py": "def zArray ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE z = [ 0 ] * n ; NEW_LINE r = 0 ; NEW_LINE l = 0 ; NEW_LINE DEDENT",
        "explain": "Function to calculate Z - Array"
    },
    {
        "py": "for k in range ( 1 , n ) : NEW_LINE",
        "explain": "Loop to calculate Z - Array"
    },
    {
        "py": "if ( k > r ) : NEW_LINE INDENT r = l = k ; NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 ; NEW_LINE DEDENT z [ k ] = r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT",
        "explain": "Outside the Z - box"
    },
    {
        "py": "else : NEW_LINE INDENT k1 = k - l ; NEW_LINE if ( z [ k1 ] < r - k + 1 ) : NEW_LINE INDENT z [ k ] = z [ k1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT l = k ; NEW_LINE while ( r < n and arr [ r ] == arr [ r - l ] ) : NEW_LINE INDENT r += 1 ; NEW_LINE DEDENT z [ k ] = r - l ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT return z ; NEW_LINE",
        "explain": "Inside Z - box"
    },
    {
        "py": "def mergeArray ( A , B ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE m = len ( B ) ; NEW_LINE DEDENT",
        "explain": "Helper function to merge two arrays and create a single array"
    },
    {
        "py": "c = [ 0 ] * ( n + m + 1 ) ; NEW_LINE",
        "explain": "Array to store merged array"
    },
    {
        "py": "for i in range ( m ) : NEW_LINE INDENT c [ i ] = B [ i ] ; NEW_LINE DEDENT",
        "explain": "Copying array B"
    },
    {
        "py": "c [ m ] = sys . maxsize ; NEW_LINE",
        "explain": "Adding a separator"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT c [ m + i + 1 ] = A [ i ] ; NEW_LINE DEDENT",
        "explain": "Copying array A"
    },
    {
        "py": "z = zArray ( c ) ; NEW_LINE return z ; NEW_LINE",
        "explain": "Calling Z - function"
    },
    {
        "py": "def findZArray ( A , B , n ) : NEW_LINE INDENT flag = 0 ; NEW_LINE z = mergeArray ( A , B ) ; NEW_LINE DEDENT",
        "explain": "Function to help compute the Z array"
    },
    {
        "py": "for i in range ( len ( z ) ) : NEW_LINE INDENT if ( z [ i ] == n ) : NEW_LINE INDENT print ( i - n - 1 , end = \" \u2581 \" ) ; NEW_LINE flag = 1 ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( \" Not \u2581 Found \" ) ; NEW_LINE DEDENT",
        "explain": "Printing indexes where array B occur"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 2 , 3 , 2 ] ; NEW_LINE B = [ 2 , 3 ] ; NEW_LINE n = len ( B ) ; NEW_LINE findZArray ( A , B , n ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def getCount ( a , b ) : NEW_LINE",
        "explain": "Function to return the count of repetitions of string a to generate string b"
    },
    {
        "py": "if ( len ( b ) % len ( a ) != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT count = int ( len ( b ) / len ( a ) ) NEW_LINE",
        "explain": "If b cannot be generated by repeating a"
    },
    {
        "py": "a = a * count NEW_LINE if ( a == b ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 ; NEW_LINE",
        "explain": "Repeat a count number of times"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = ' geeks ' NEW_LINE b = ' geeksgeeks ' NEW_LINE print ( getCount ( a , b ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 program to Check if a given string can be formed from another string using given constraints"
    },
    {
        "py": "def check ( S1 , S2 ) : NEW_LINE",
        "explain": "Function to check if S2 can be formed of S1"
    },
    {
        "py": "n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE",
        "explain": "length of strings"
    },
    {
        "py": "mp = defaultdict ( lambda : 0 ) NEW_LINE",
        "explain": "hash - table to store count"
    },
    {
        "py": "for i in range ( 0 , n1 ) : NEW_LINE INDENT mp [ S1 [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "store count of each character"
    },
    {
        "py": "for i in range ( 0 , n2 ) : NEW_LINE",
        "explain": "traverse and check for every character"
    },
    {
        "py": "if mp [ S2 [ i ] ] : NEW_LINE INDENT mp [ S2 [ i ] ] -= 1 NEW_LINE DEDENT",
        "explain": "if the character of s2 is present in s1"
    },
    {
        "py": "elif ( mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] and mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] ) : NEW_LINE INDENT mp [ chr ( ord ( S2 [ i ] ) - 1 ) ] -= 1 NEW_LINE mp [ chr ( ord ( S2 [ i ] ) - 2 ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "if the character of s2 is not present in S1 , then check if previous two ASCII characters are present in S1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S1 = \" abbat \" NEW_LINE S2 = \" cat \" NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "if check ( S1 , S2 ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Calling function to check"
    },
    {
        "py": "def countPattern ( s ) : NEW_LINE INDENT length = len ( s ) NEW_LINE oneSeen = False NEW_LINE DEDENT",
        "explain": "Returns count of occurrences of \"1(0 + ) 1\""
    },
    {
        "py": "for i in range ( length ) : NEW_LINE",
        "explain": "count = 0 Initialize result"
    },
    {
        "py": "if ( s [ i ] == '1' and oneSeen ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Check if encountered '1' forms a valid pattern as specified"
    },
    {
        "py": "if ( s [ i ] == '1' and oneSeen == 0 ) : NEW_LINE INDENT oneSeen = True NEW_LINE DEDENT",
        "explain": "if 1 encountered for first time set oneSeen to 1"
    },
    {
        "py": "if ( s [ i ] != '0' and s [ i ] != '1' ) : NEW_LINE INDENT oneSeen = False NEW_LINE DEDENT return count NEW_LINE",
        "explain": "Check if there is any other character other than '0' or '1' . If so then set oneSeen to 0 to search again for new pattern"
    },
    {
        "py": "s = \"100001abc101\" NEW_LINE print countPattern ( s ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def checkIfPossible ( N , arr , T ) : NEW_LINE",
        "explain": "Function to check if it possible to make all the strings equal to the T"
    },
    {
        "py": "freqS = [ 0 ] * 256 NEW_LINE",
        "explain": "Stores the frequency of all the strings in the array arr [ ]"
    },
    {
        "py": "freqT = [ 0 ] * 256 NEW_LINE",
        "explain": "Stores the frequency of the T"
    },
    {
        "py": "for ch in T : NEW_LINE INDENT freqT [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Iterate over the characters of the T"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Iterate in the range [ 0 , N - 1 ]"
    },
    {
        "py": "for ch in arr [ i ] : NEW_LINE INDENT freqS [ ord ( ch ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 256 ) : NEW_LINE",
        "explain": "Iterate over the characters of the arr [ i ]"
    },
    {
        "py": "if ( freqT [ i ] == 0 and freqS [ i ] != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT",
        "explain": "If freqT [ i ] is 0 and freqS [ i ] is not 0"
    },
    {
        "py": "elif ( freqS [ i ] == 0 and freqT [ i ] != 0 ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT",
        "explain": "If freqS [ i ] is 0 and freqT [ i ] is not 0"
    },
    {
        "py": "elif ( freqT [ i ] != 0 and freqS [ i ] != ( freqT [ i ] * N ) ) : NEW_LINE INDENT return \" No \" NEW_LINE DEDENT",
        "explain": "If freqS [ i ] is not freqT [ i ] * N"
    },
    {
        "py": "return \" Yes \" NEW_LINE",
        "explain": "Otherwise , return \" Yes \""
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ \" abc \" , \" abb \" , \" acc \" ] NEW_LINE T = \" abc \" NEW_LINE N = len ( arr ) NEW_LINE print ( checkIfPossible ( N , arr , T ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def groupsOfOnes ( S , N ) : NEW_LINE",
        "explain": "Function to find the number of the groups of 1 s only in the binary string"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores number of groups of 1 s"
    },
    {
        "py": "st = [ ] NEW_LINE",
        "explain": "Initialization of the stack"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the string S"
    },
    {
        "py": "' NEW_LINE INDENT if ( S [ i ] == '1' ) : NEW_LINE INDENT st . append ( 1 ) NEW_LINE DEDENT DEDENT",
        "explain": "If S [ i ] is '1"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if ( len ( st ) > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT del st [ - 1 ] NEW_LINE DEDENT DEDENT",
        "explain": "If st is empty"
    },
    {
        "py": "if ( len ( st ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "If st is not empty"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "S = \"100110111\" NEW_LINE N = len ( S ) NEW_LINE",
        "explain": "Input"
    },
    {
        "py": "print ( groupsOfOnes ( S , N ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def generatePalindrome ( S ) : NEW_LINE",
        "explain": "Function to print all palindromic strings of length 3 that can be formed using characters of string S"
    },
    {
        "py": "Hash = { } NEW_LINE",
        "explain": "Stores the count of character"
    },
    {
        "py": "for ch in S : NEW_LINE INDENT Hash [ ch ] = Hash . get ( ch , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Traverse the string S"
    },
    {
        "py": "st = { } NEW_LINE",
        "explain": "Stores all palindromic strings"
    },
    {
        "py": "for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE",
        "explain": "Iterate over the charchaters over the range [ ' a ' , ' z ' ]"
    },
    {
        "py": "if ( chr ( i ) in Hash and Hash [ chr ( i ) ] == 2 ) : NEW_LINE",
        "explain": "If Hash [ ch ] is equal to 2"
    },
    {
        "py": "for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE",
        "explain": "Iterate over the characters over the range [ ' a ' , ' z ' ]"
    },
    {
        "py": "s = \" \" NEW_LINE if ( chr ( j ) in Hash and i != j ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE s += chr ( i ) NEW_LINE DEDENT",
        "explain": "Stores all the palindromic string"
    },
    {
        "py": "st [ s ] = 1 NEW_LINE",
        "explain": "Push the s into the set st"
    },
    {
        "py": "if ( ( chr ( i ) in Hash ) and Hash [ chr ( i ) ] >= 3 ) : NEW_LINE",
        "explain": "If Hash [ i ] is greater than or equal to 3"
    },
    {
        "py": "for j in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE",
        "explain": "Iterate over charchaters over the range [ ' a ' , ' z ' ]"
    },
    {
        "py": "s = \" \" NEW_LINE",
        "explain": "Stores all the palindromic string"
    },
    {
        "py": "if ( chr ( j ) in Hash ) : NEW_LINE INDENT s += chr ( i ) NEW_LINE s += chr ( j ) NEW_LINE s += chr ( i ) NEW_LINE DEDENT",
        "explain": "If Hash [ j ] is positive"
    },
    {
        "py": "st [ s ] = 1 NEW_LINE",
        "explain": "Push s into the set st"
    },
    {
        "py": "for ans in st : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT",
        "explain": "Iterate over the set"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" ddabdac \" NEW_LINE generatePalindrome ( S ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countOccurrences ( S , X , Y ) : NEW_LINE",
        "explain": "Function to count occurrences of the string Y in the string S for every occurrence of X in S"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the count of occurrences of X"
    },
    {
        "py": "N = len ( S ) NEW_LINE A = len ( X ) NEW_LINE B = len ( Y ) NEW_LINE",
        "explain": "Stores the lengths of the three strings"
    },
    {
        "py": "for i in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse the string S"
    },
    {
        "py": "if ( S [ i : i + B ] == Y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "If the current substring is Y , then increment the value of count by 1"
    },
    {
        "py": "if ( S [ i : i + A ] == X ) : NEW_LINE INDENT print ( count , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If the current substring is X , then print the count"
    },
    {
        "py": "S = \" abcdefdefabc \" NEW_LINE X = \" abc \" NEW_LINE Y = \" def \" NEW_LINE countOccurrences ( S , X , Y ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def DFA ( str , N ) : NEW_LINE",
        "explain": "Function to find whether the given is Accepted by the DFA"
    },
    {
        "py": "if ( N <= 1 ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If n <= 1 , then prNo"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "To count the matched characters"
    },
    {
        "py": "if ( str [ 0 ] == ' C ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Check if the first character is C"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE",
        "explain": "Traverse the rest of string"
    },
    {
        "py": "if ( str [ i ] == ' A ' or str [ i ] == ' B ' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If character is A or B , increment count by 1"
    },
    {
        "py": "print ( \" No \" ) NEW_LINE return NEW_LINE",
        "explain": "If the first character is not C , pr - 1"
    },
    {
        "py": "if ( count == N ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "If all characters matches"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" CAABBAAB \" NEW_LINE N = len ( str ) NEW_LINE DFA ( str , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minMaxDigits ( str , N ) : NEW_LINE",
        "explain": "Function to find the maximum and minimum number of digits to be removed to make str divisible by 3"
    },
    {
        "py": "arr = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT arr [ i ] = ( ord ( str [ i ] ) - ord ( '0' ) ) % 3 NEW_LINE DEDENT",
        "explain": "Convert the string into array of digits"
    },
    {
        "py": "zero = 0 NEW_LINE one = 0 NEW_LINE two = 0 NEW_LINE",
        "explain": "Count of 0 s , 1 s , and 2 s"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT if ( arr [ i ] == 2 ) : NEW_LINE INDENT two += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum = ( sum + arr [ i ] ) % 3 NEW_LINE DEDENT",
        "explain": "Find the sum of digits % 3"
    },
    {
        "py": "if ( sum == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \u2581 \" ) NEW_LINE DEDENT if ( sum == 1 ) : NEW_LINE INDENT if ( one and N > 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( two > 1 and N > 2 ) : NEW_LINE INDENT print ( \"2\" , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT if ( sum == 2 ) : NEW_LINE INDENT if ( two and N > 1 ) : NEW_LINE INDENT print ( \"1\" , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( one > 1 and N > 2 ) : NEW_LINE INDENT print ( \"2\" , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Cases to find minimum number of digits to be removed"
    },
    {
        "py": "if ( zero > 0 ) : NEW_LINE INDENT print ( N - 1 , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( one > 0 and two > 0 ) : NEW_LINE INDENT print ( N - 2 , end = \" \u2581 \" ) NEW_LINE DEDENT elif ( one > 2 or two > 2 ) : NEW_LINE INDENT print ( N - 3 , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Cases to find maximum number of digits to be removed"
    },
    {
        "py": "str = \"12345\" NEW_LINE N = len ( str ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "minMaxDigits ( str , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def findMinimumChanges ( N , K , S ) : NEW_LINE",
        "explain": "Function to find the minimum number of changes to make the string K - periodic and palindrome"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Initialize ans with 0"
    },
    {
        "py": "for i in range ( ( K + 1 ) // 2 ) : NEW_LINE",
        "explain": "Iterate from 0 to ( K + 1 ) / 2"
    },
    {
        "py": "mp = { } NEW_LINE",
        "explain": "Store frequency of character"
    },
    {
        "py": "for j in range ( i , N , K ) : NEW_LINE",
        "explain": "Iterate through all indices , i , i + K , i + 2 k ... . and store the frequency of character"
    },
    {
        "py": "mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE",
        "explain": "Increase the frequency of current character"
    },
    {
        "py": "j = N - i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE",
        "explain": "Iterate through all indices K - i , 2 K - i , 3 K - i ... . and store the frequency of character"
    },
    {
        "py": "if ( ( K & 1 ) and ( i == K // 2 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If K is odd & i is samw as K / 2 , break the loop"
    },
    {
        "py": "mp [ S [ j ] ] = mp . get ( S [ j ] , 0 ) + 1 NEW_LINE j -= K NEW_LINE",
        "explain": "Increase the frequency of current character"
    },
    {
        "py": "curr_max = - sys . maxsize - 1 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT curr_max = max ( curr_max , value ) NEW_LINE DEDENT",
        "explain": "Find the maximum frequency of a character among all visited characters"
    },
    {
        "py": "if ( ( K & 1 ) and ( i == K // 2 ) ) : NEW_LINE INDENT ans += ( N // K - curr_max ) NEW_LINE DEDENT",
        "explain": "If K is odd and i is same as K / 2 then , only N / K characters is visited"
    },
    {
        "py": "else : NEW_LINE INDENT ans += ( N // K * 2 - curr_max ) NEW_LINE DEDENT",
        "explain": "Otherwise N / K * 2 characters has visited"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" aabbcbbcb \" NEW_LINE N = len ( S ) NEW_LINE K = 3 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( findMinimumChanges ( N , K , S ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def checkString ( s , K ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to check if any index contains more than K active characters"
    },
    {
        "py": "dict = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT dict [ s [ i ] ] = i ; NEW_LINE DEDENT",
        "explain": "Store the last occurrence of each character"
    },
    {
        "py": "st = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Stores the active characters"
    },
    {
        "py": "st . add ( s [ i ] ) NEW_LINE",
        "explain": "Insert the character"
    },
    {
        "py": "if len ( st ) > K : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If the size of set exceeds K"
    },
    {
        "py": "if dict [ s [ i ] ] == i : NEW_LINE INDENT st . remove ( s [ i ] ) NEW_LINE DEDENT print ( \" No \" ) NEW_LINE",
        "explain": "Remove the character from set if i is the last index of the current character"
    },
    {
        "py": "s = \" aabbcdca \" NEW_LINE K = 2 NEW_LINE checkString ( s , K ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def distinct ( S , M ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Function to count the strings whose distinct characters count is less than M"
    },
    {
        "py": "for i in range ( len ( S ) ) : NEW_LINE",
        "explain": "Loop to iterate over all the strings of the array"
    },
    {
        "py": "c = len ( set ( [ d for d in S [ i ] ] ) ) NEW_LINE",
        "explain": "Distinct characters in the String with the help of set"
    },
    {
        "py": "if ( c <= M ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT print ( count ) NEW_LINE",
        "explain": "Checking if its less than or equal to M"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = [ \" HERBIVORES \" , \" AEROPLANE \" , \" GEEKSFORGEEKS \" ] NEW_LINE M = 7 NEW_LINE distinct ( S , M ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def removeOddFrequencyCharacters ( s ) : NEW_LINE",
        "explain": "Function to remove the characters which have odd frequencies in the string"
    },
    {
        "py": "m = dict ( ) NEW_LINE for i in s : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Create a map to store the frequency of each character"
    },
    {
        "py": "new_s = \" \" NEW_LINE",
        "explain": "To store the new string"
    },
    {
        "py": "for i in s : NEW_LINE",
        "explain": "Remove the characters which have odd frequencies"
    },
    {
        "py": "if ( m [ i ] & 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "If the character has odd frequency then skip"
    },
    {
        "py": "new_s += i NEW_LINE",
        "explain": "Else concatenate the character to the new string"
    },
    {
        "py": "return new_s NEW_LINE",
        "explain": "Return the modified string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeksforgeeks \" NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "str = removeOddFrequencyCharacters ( str ) NEW_LINE print ( str ) NEW_LINE",
        "explain": "Remove the characters which have odd frequencies"
    },
    {
        "py": "def productAtKthLevel ( tree , k , i , level ) : NEW_LINE INDENT if ( tree [ i [ 0 ] ] == ' ( ' ) : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Recursive Function to find product of elements at k - th level"
    },
    {
        "py": "if ( tree [ i [ 0 ] ] == ' ) ' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT product = 1 NEW_LINE",
        "explain": "if subtree is null , just like if root == NULL"
    },
    {
        "py": "if ( level == k ) : NEW_LINE INDENT product = int ( tree [ i [ 0 ] ] ) NEW_LINE DEDENT",
        "explain": "Consider only level k node to be part of the product"
    },
    {
        "py": "i [ 0 ] += 1 NEW_LINE leftproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE",
        "explain": "Recur for Left Subtree"
    },
    {
        "py": "i [ 0 ] += 1 NEW_LINE rightproduct = productAtKthLevel ( tree , k , i , level + 1 ) NEW_LINE",
        "explain": "Recur for Right Subtree"
    },
    {
        "py": "i [ 0 ] += 1 NEW_LINE return product * leftproduct * rightproduct NEW_LINE",
        "explain": "Taking care of ' ) ' after left and right subtree"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT tree = \" ( 0(5(6 ( ) ( ) ) ( 4 ( ) (9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) \" NEW_LINE k = 2 NEW_LINE i = [ 0 ] NEW_LINE print ( productAtKthLevel ( tree , k , i , 0 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findMostOccurringChar ( string ) : NEW_LINE",
        "explain": "Function to print the most occurring character"
    },
    {
        "py": "hash = [ 0 ] * 26 ; NEW_LINE",
        "explain": "Creating a hash of size 26"
    },
    {
        "py": "for i in range ( len ( string ) ) : NEW_LINE",
        "explain": "For loop to iterate through every string of the array"
    },
    {
        "py": "for j in range ( len ( string [ i ] ) ) : NEW_LINE",
        "explain": "For loop to iterate through every character of the string"
    },
    {
        "py": "hash [ ord ( string [ i ] [ j ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE",
        "explain": "Incrementing the count of the character in the hash"
    },
    {
        "py": "max = 0 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT max = i if hash [ i ] > hash [ max ] else max ; NEW_LINE DEDENT print ( ( chr ) ( max + 97 ) ) ; NEW_LINE",
        "explain": "Finding the character with the maximum count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "string = [ ] ; NEW_LINE string . append ( \" animal \" ) ; NEW_LINE string . append ( \" zebra \" ) ; NEW_LINE string . append ( \" lion \" ) ; NEW_LINE string . append ( \" giraffe \" ) ; NEW_LINE findMostOccurringChar ( string ) ; NEW_LINE",
        "explain": "Declaring Vector of String type"
    },
    {
        "py": "def isPalindrome ( num ) : NEW_LINE",
        "explain": "Function that returns true if num is palindrome"
    },
    {
        "py": "s = str ( num ) NEW_LINE",
        "explain": "Convert the given floating point number into a string"
    },
    {
        "py": "low = 0 NEW_LINE high = len ( s ) - 1 NEW_LINE while ( low < high ) : NEW_LINE",
        "explain": "Pointers pointing to the first and the last character of the string"
    },
    {
        "py": "if ( s [ low ] != s [ high ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Not a palindrome"
    },
    {
        "py": "low += 1 NEW_LINE high -= 1 NEW_LINE return True NEW_LINE",
        "explain": "Update the pointers"
    },
    {
        "py": "n = 123.321 NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE MAX = 26 ; NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def maxSubStr ( str1 , len1 , str2 , len2 ) : NEW_LINE",
        "explain": "Function to return the maximum number of times str1 can appear as a non - overlapping substring bin str2"
    },
    {
        "py": "if ( len1 > len2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "str1 cannot never be substring of str2"
    },
    {
        "py": "freq1 = [ 0 ] * MAX ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT",
        "explain": "Store the frequency of the characters of str1"
    },
    {
        "py": "freq2 = [ 0 ] * MAX ; NEW_LINE for i in range ( len2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT",
        "explain": "Store the frequency of the characters of str2"
    },
    {
        "py": "minPoss = sys . maxsize ; NEW_LINE for i in range ( MAX ) : NEW_LINE",
        "explain": "To store the required count of substrings"
    },
    {
        "py": "if ( freq1 [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT",
        "explain": "Current character doesn 't appear  in str1"
    },
    {
        "py": "if ( freq1 [ i ] > freq2 [ i ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Frequency of the current character in str1 is greater than its frequency in str2"
    },
    {
        "py": "minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; NEW_LINE return int ( minPoss ) ; NEW_LINE",
        "explain": "Update the count of possible substrings"
    },
    {
        "py": "str1 = \" geeks \" ; str2 = \" gskefrgoekees \" ; NEW_LINE len1 = len ( str1 ) ; NEW_LINE len2 = len ( str2 ) ; NEW_LINE print ( maxSubStr ( str1 , len1 , str2 , len2 ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT",
        "explain": "Function to return the number of ways to insert the bracket pairs"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" ab \" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( cntWays ( string , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "uSet = set ( ) ; NEW_LINE",
        "explain": "Set to store all the strings from the given array"
    },
    {
        "py": "minCnt = sys . maxsize ; NEW_LINE",
        "explain": "To store the required count"
    },
    {
        "py": "def findSubStr ( string , cnt , start ) : NEW_LINE INDENT global minCnt ; NEW_LINE DEDENT",
        "explain": "Recursive function to find the count of substrings that can be splitted starting from the index start such that all the substrings are present in the map"
    },
    {
        "py": "if ( start == len ( string ) ) : NEW_LINE",
        "explain": "All the chosen substrings are present in the map"
    },
    {
        "py": "minCnt = min ( cnt , minCnt ) ; NEW_LINE",
        "explain": "Update the minimum count of substrings"
    },
    {
        "py": "for length in range ( 1 , len ( string ) - start + 1 ) : NEW_LINE",
        "explain": "Starting from the substrings of length 1 that start with the given index"
    },
    {
        "py": "subStr = string [ start : start + length ] ; NEW_LINE",
        "explain": "Get the substring"
    },
    {
        "py": "if subStr in uSet : NEW_LINE",
        "explain": "If the substring is present in the set"
    },
    {
        "py": "findSubStr ( string , cnt + 1 , start + length ) ; NEW_LINE",
        "explain": "Recursive call for the rest of the string"
    },
    {
        "py": "def findMinSubStr ( arr , n , string ) : NEW_LINE",
        "explain": "Function that inserts all the strings from the given array in a set and calls the recursive function to find the minimum count of substrings str can be splitted into that satisfy the given condition"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT uSet . add ( arr [ i ] ) ; NEW_LINE DEDENT",
        "explain": "Insert all the strings from the given array in a set"
    },
    {
        "py": "findSubStr ( string , 0 , 0 ) ; NEW_LINE",
        "explain": "Find the required count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \"123456\" ; NEW_LINE arr = [ \"1\" , \"12345\" , \"2345\" , \"56\" , \"23\" , \"456\" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMinSubStr ( arr , n , string ) ; NEW_LINE print ( minCnt ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countSubStr ( s , n ) : NEW_LINE INDENT c1 = 0 ; c2 = 0 ; NEW_LINE DEDENT",
        "explain": "Function to return the count of required substrings"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "For every index of the string"
    },
    {
        "py": "if ( s [ i : i + 5 ] == \" geeks \" ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT",
        "explain": "If the substring starting at the current index is \" geeks \""
    },
    {
        "py": "if ( s [ i : i + 3 ] == \" for \" ) : NEW_LINE INDENT c2 = c2 + c1 ; NEW_LINE DEDENT return c2 ; NEW_LINE",
        "explain": "If the substring is \" for \""
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeksisforgeeks \" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( countSubStr ( s , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "string = \" { [ ( ) ] } [ ] \" NEW_LINE",
        "explain": "Defining the string"
    },
    {
        "py": "lst1 = [ ' { ' , ' ( ' , ' [ ' ] NEW_LINE",
        "explain": "Storing opening braces in list lst1"
    },
    {
        "py": "lst2 = [ ' } ' , ' ) ' , ' ] ' ] NEW_LINE",
        "explain": "Storing closing braces in list lst2"
    },
    {
        "py": "lst = [ ] NEW_LINE",
        "explain": "Creating an empty list lst"
    },
    {
        "py": "Dict = { ' ) ' : ' ( ' , ' } ' : ' { ' , ' ] ' : ' [ ' } NEW_LINE a = b = c = 0 NEW_LINE",
        "explain": "Creating dictionary to map closing braces to opening ones"
    },
    {
        "py": "if string [ 0 ] in lst2 : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If first position of string contain any closing braces return 1"
    },
    {
        "py": "for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT if string [ i ] in lst1 : NEW_LINE INDENT lst . append ( string [ i ] ) NEW_LINE k = i + 2 NEW_LINE DEDENT else : NEW_LINE DEDENT",
        "explain": "If characters of string are opening braces then append them in a list"
    },
    {
        "py": "if len ( lst ) == 0 and ( string [ i ] in lst2 ) : NEW_LINE INDENT print ( i + 1 ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE",
        "explain": "When size of list is 0 and new closing braces is encountered then print its index starting from 1"
    },
    {
        "py": "if Dict [ string [ i ] ] == lst [ len ( lst ) - 1 ] : NEW_LINE INDENT lst . pop ( ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "As we encounter closing braces we map them with theircorresponding opening braces using dictionary and check if it is same as last opened braces ( last element in list ) if yes then we delete that elememt from list"
    },
    {
        "py": "print ( i + 1 ) NEW_LINE a = 1 NEW_LINE break NEW_LINE",
        "explain": "Otherwise we return the index ( starting from 1 ) at which nesting is found wrong"
    },
    {
        "py": "if len ( lst ) == 0 and c == 0 : NEW_LINE INDENT print ( 0 ) NEW_LINE b = 1 NEW_LINE DEDENT if a == 0 and b == 0 and c == 0 : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT",
        "explain": "At end if the list is empty it means the string is perfectly nested"
    },
    {
        "py": "MAX = 26 NEW_LINE",
        "explain": "Python3 implementation of the above approach :"
    },
    {
        "py": "def encryptstrr ( strr , n , x ) : NEW_LINE",
        "explain": "Function to return the encrypted string"
    },
    {
        "py": "x = x % MAX NEW_LINE arr = list ( strr ) NEW_LINE",
        "explain": "Reduce x because rotation of length 26 is unnecessary"
    },
    {
        "py": "freq = [ 0 ] * MAX NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( arr [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE",
        "explain": "calculate the frequency of characters"
    },
    {
        "py": "if ( freq [ ord ( arr [ i ] ) - ord ( ' a ' ) ] % 2 == 0 ) : NEW_LINE INDENT pos = ( ord ( arr [ i ] ) - ord ( ' a ' ) + x ) % MAX NEW_LINE arr [ i ] = chr ( pos + ord ( ' a ' ) ) NEW_LINE DEDENT",
        "explain": "If the frequency of current character is even then increment it by x"
    },
    {
        "py": "else : NEW_LINE INDENT pos = ( ord ( arr [ i ] ) - ord ( ' a ' ) - x ) NEW_LINE if ( pos < 0 ) : NEW_LINE INDENT pos += MAX NEW_LINE DEDENT arr [ i ] = chr ( pos + ord ( ' a ' ) ) NEW_LINE DEDENT",
        "explain": "Else decrement it by x"
    },
    {
        "py": "return \" \" . join ( arr ) NEW_LINE",
        "explain": "Return the count"
    },
    {
        "py": "s = \" abcda \" NEW_LINE n = len ( s ) NEW_LINE x = 3 NEW_LINE print ( encryptstrr ( s , n , x ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isPossible ( Str ) : NEW_LINE",
        "explain": "Function that returns true if it is possible to rearrange the characters of the String such that no two consecutive characters are same"
    },
    {
        "py": "freq = dict ( ) NEW_LINE",
        "explain": "To store the frequency of each of the character"
    },
    {
        "py": "max_freq = 0 NEW_LINE for j in range ( len ( Str ) ) : NEW_LINE INDENT freq [ Str [ j ] ] = freq . get ( Str [ j ] , 0 ) + 1 NEW_LINE if ( freq [ Str [ j ] ] > max_freq ) : NEW_LINE INDENT max_freq = freq [ Str [ j ] ] NEW_LINE DEDENT DEDENT",
        "explain": "To store the maximum frequency so far"
    },
    {
        "py": "if ( max_freq <= ( len ( Str ) - max_freq + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If possible"
    },
    {
        "py": "Str = \" geeksforgeeks \" NEW_LINE if ( isPossible ( Str ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printUncommon ( str1 , str2 ) : NEW_LINE INDENT a1 = 0 ; a2 = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE DEDENT",
        "explain": "Function to print the uncommon characters in the given string in sorted order"
    },
    {
        "py": "ch = ord ( str1 [ i ] ) - ord ( ' a ' ) ; NEW_LINE",
        "explain": "Converting character to ASCII code"
    },
    {
        "py": "a1 = a1 | ( 1 << ch ) ; NEW_LINE for i in range ( len ( str2 ) ) : NEW_LINE",
        "explain": "Bit operation"
    },
    {
        "py": "ch = ord ( str2 [ i ] ) - ord ( ' a ' ) ; NEW_LINE",
        "explain": "Converting character to ASCII code"
    },
    {
        "py": "a2 = a2 | ( 1 << ch ) ; NEW_LINE",
        "explain": "Bit operation"
    },
    {
        "py": "ans = a1 ^ a2 ; NEW_LINE i = 0 ; NEW_LINE while ( i < 26 ) : NEW_LINE INDENT if ( ans % 2 == 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = \" \" ) ; NEW_LINE DEDENT ans = ans // 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT",
        "explain": "XOR operation leaves only uncommon characters in the ans variable"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" geeksforgeeks \" ; NEW_LINE str2 = \" geeksquiz \" ; NEW_LINE printUncommon ( str1 , str2 ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countMinReversals ( expr ) : NEW_LINE INDENT length = len ( expr ) NEW_LINE DEDENT",
        "explain": "Returns count of minimum reversals for making expr balanced . Returns - 1 if expr cannot be balanced ."
    },
    {
        "py": "if length % 2 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "length of expression must be even to make it balanced by using reversals ."
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "To store number of reversals required ."
    },
    {
        "py": "open = 0 NEW_LINE",
        "explain": "To store number of unbalanced opening brackets ."
    },
    {
        "py": "close = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE",
        "explain": "To store number of unbalanced closing brackets ."
    },
    {
        "py": "if expr [ i ] == \" \" : NEW_LINE INDENT open += 1 NEW_LINE DEDENT",
        "explain": "If current bracket is open then increment open count ."
    },
    {
        "py": "else : NEW_LINE INDENT if not open : NEW_LINE INDENT close += 1 NEW_LINE DEDENT else : NEW_LINE INDENT open -= 1 NEW_LINE DEDENT DEDENT ans = ( close // 2 ) + ( open // 2 ) NEW_LINE",
        "explain": "If current bracket is close , check if it balances opening bracket . If yes then decrement count of unbalanced opening bracket else increment count of closing bracket ."
    },
    {
        "py": "close %= 2 NEW_LINE open %= 2 NEW_LINE if close > 0 : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "For the case : \" \" or when one closing and one opening bracket remains for pairing , then both need to be reversed ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT expr = \" } } { { \" NEW_LINE print ( countMinReversals ( expr ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def totalPairs ( s1 , s2 ) : NEW_LINE INDENT a1 = 0 ; b1 = 0 ; NEW_LINE DEDENT",
        "explain": "Function to return the total number of valid pairs"
    },
    {
        "py": "for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( ord ( s1 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT b1 += 1 ; NEW_LINE DEDENT DEDENT a2 = 0 ; b2 = 0 ; NEW_LINE",
        "explain": "Count total number of even and odd ascii values for string s1"
    },
    {
        "py": "for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( ord ( s2 [ i ] ) % 2 != 0 ) : NEW_LINE INDENT a2 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT b2 += 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Count total number of even and odd ascii values for string s2"
    },
    {
        "py": "return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; NEW_LINE",
        "explain": "Return total valid pairs"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeks \" ; NEW_LINE s2 = \" for \" ; NEW_LINE print ( totalPairs ( s1 , s2 ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def prefixOccurrences ( str1 ) : NEW_LINE INDENT c = str1 [ 0 ] NEW_LINE countc = 0 NEW_LINE DEDENT",
        "explain": "Function to return the count of the required prefix"
    },
    {
        "py": "for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] == c ) : NEW_LINE INDENT countc += 1 NEW_LINE DEDENT DEDENT return countc NEW_LINE",
        "explain": "Find the frequency of first character of str1ing"
    },
    {
        "py": "str1 = \" abbcdabbcd \" NEW_LINE print ( prefixOccurrences ( str1 ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def minOperations ( s , t , n ) : NEW_LINE INDENT ct0 = 0 NEW_LINE ct1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "Function to return the minimum operations of the given type required to convert string s to string t"
    },
    {
        "py": "if ( s [ i ] == t [ i ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Characters are already equal"
    },
    {
        "py": "if ( s [ i ] == '0' ) : NEW_LINE INDENT ct0 += 1 NEW_LINE DEDENT",
        "explain": "Increment count of 0 s"
    },
    {
        "py": "else : NEW_LINE INDENT ct1 += 1 NEW_LINE DEDENT return max ( ct0 , ct1 ) NEW_LINE",
        "explain": "Increment count of 1 s"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"010\" NEW_LINE t = \"101\" NEW_LINE n = len ( s ) NEW_LINE print ( minOperations ( s , t , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def decryptString ( str , n ) : NEW_LINE",
        "explain": "Function to return the decrypted string"
    },
    {
        "py": "i = 0 NEW_LINE jump = 1 NEW_LINE decryptedStr = \" \" NEW_LINE while ( i < n ) : NEW_LINE INDENT decryptedStr += str [ i ] ; NEW_LINE i += jump NEW_LINE DEDENT",
        "explain": "Initial jump will be 1"
    },
    {
        "py": "jump += 1 NEW_LINE return decryptedStr NEW_LINE",
        "explain": "Increment jump by 1 with every character"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeeeekkkksssss \" NEW_LINE n = len ( str ) NEW_LINE print ( decryptString ( str , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def bitToBeFlipped ( s ) : NEW_LINE",
        "explain": "Function to check which bit is to be flipped"
    },
    {
        "py": "last = s [ len ( s ) - 1 ] NEW_LINE first = s [ 0 ] NEW_LINE",
        "explain": "variable to store first and last character of string"
    },
    {
        "py": "if ( last == first ) : NEW_LINE INDENT if ( last == '0' ) : NEW_LINE INDENT return '1' NEW_LINE DEDENT else : NEW_LINE INDENT return '0' NEW_LINE DEDENT DEDENT",
        "explain": "Check if first and last characters are equal , if yes , then return the character which is not at last"
    },
    {
        "py": "elif ( last != first ) : NEW_LINE INDENT return last NEW_LINE DEDENT",
        "explain": "else return last"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"1101011000\" NEW_LINE print ( bitToBeFlipped ( s ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def SieveofEratosthenes ( prime , p_size ) : NEW_LINE",
        "explain": "Function to create Sieve to check primes"
    },
    {
        "py": "prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , p_size + 1 ) : NEW_LINE",
        "explain": "false here indicates that it is not prime"
    },
    {
        "py": "if prime [ p ] : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT",
        "explain": "Update all multiples of p , set them to non - prime"
    },
    {
        "py": "def sumProdOfPrimeFreq ( s ) : NEW_LINE INDENT prime = [ True ] * ( len ( s ) + 2 ) NEW_LINE SieveofEratosthenes ( prime , len ( s ) + 1 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE DEDENT",
        "explain": "Function to find the sum of prime frequencies of the characters of the given string"
    },
    {
        "py": "m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] = ( m [ s [ i ] ] + 1 ) if s [ i ] in m else 1 NEW_LINE DEDENT s = 0 NEW_LINE product = 1 NEW_LINE",
        "explain": "map is used to store character frequencies"
    },
    {
        "py": "for it in m : NEW_LINE",
        "explain": "Traverse the map"
    },
    {
        "py": "if prime [ m [ it ] ] : NEW_LINE INDENT s += m [ it ] NEW_LINE product *= m [ it ] NEW_LINE DEDENT print ( \" Sum \u2581 = \" , s ) NEW_LINE print ( \" Product \u2581 = \" , product ) NEW_LINE",
        "explain": "If the frequency is prime"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \" geeksforgeeks \" NEW_LINE sumProdOfPrimeFreq ( s ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 implementation of above approach"
    },
    {
        "py": "def multipleOrFactor ( s1 , s2 ) : NEW_LINE",
        "explain": "Function that checks if the frequency of character are a factor or multiple of each other"
    },
    {
        "py": "m1 = defaultdict ( lambda : 0 ) NEW_LINE m2 = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , len ( s1 ) ) : NEW_LINE INDENT m1 [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( s2 ) ) : NEW_LINE INDENT m2 [ s2 [ i ] ] += 1 NEW_LINE DEDENT for it in m1 : NEW_LINE",
        "explain": "map store frequency of each character"
    },
    {
        "py": "if it not in m2 : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "if any frequency is 0 , then continue as condition is satisfied"
    },
    {
        "py": "if ( m2 [ it ] % m1 [ it ] == 0 or m1 [ it ] % m2 [ it ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "if factor or multiple , then condition satisfied"
    },
    {
        "py": "else : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "if condition not satisfied"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s1 = \" geeksforgeeks \" NEW_LINE s2 = \" geeks \" NEW_LINE if multipleOrFactor ( s1 , s2 ) : print ( \" YES \" ) NEW_LINE else : print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def solve ( s ) : NEW_LINE",
        "explain": "Function that removes the characters which have even frequencies in the string"
    },
    {
        "py": "m = dict ( ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] = m [ s [ i ] ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "create a map to store the frequency of each character"
    },
    {
        "py": "new_string = \" \" NEW_LINE",
        "explain": "to store the new string"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "remove the characters which have even frequencies"
    },
    {
        "py": "if m [ s [ i ] ] % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "if the character has even frequency then skip"
    },
    {
        "py": "new_string = new_string + s [ i ] NEW_LINE",
        "explain": "else concatenate the character to the new string"
    },
    {
        "py": "print ( new_string ) NEW_LINE",
        "explain": "display the modified string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" aabbbddeeecc \" NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "solve ( s ) NEW_LINE",
        "explain": "remove the characters which have even frequencies"
    },
    {
        "py": "def isPalindrome ( string ) : NEW_LINE INDENT i = 0 ; j = len ( string ) - 1 ; NEW_LINE DEDENT",
        "explain": "function to check if ' str ' is palindrome"
    },
    {
        "py": "while ( i < j ) : NEW_LINE",
        "explain": "traversing from both the ends"
    },
    {
        "py": "if ( string [ i ] != string [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE",
        "explain": "not palindrome"
    },
    {
        "py": "return True ; NEW_LINE",
        "explain": "palindrome"
    },
    {
        "py": "def removePalinWords ( string ) : NEW_LINE",
        "explain": "function to remove all the palindromic words from the given sentence"
    },
    {
        "py": "' NEW_LINE INDENT final_str = \" \" ; word = \" \" ; NEW_LINE DEDENT",
        "explain": "' final _ str ' to store the final string and ' word ' to one by one store each word of 'str"
    },
    {
        "py": "' NEW_LINE INDENT string = string + \" \u2581 \" ; NEW_LINE n = len ( string ) ; NEW_LINE DEDENT",
        "explain": "add space at the end of 'str"
    },
    {
        "py": "' NEW_LINE INDENT for i in range ( n ) : NEW_LINE DEDENT",
        "explain": "traversing 'str"
    },
    {
        "py": "if ( string [ i ] != ' \u2581 ' ) : NEW_LINE INDENT word = word + string [ i ] ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "accumulating characters of the current word"
    },
    {
        "py": "' NEW_LINE INDENT if ( not ( isPalindrome ( word ) ) ) : NEW_LINE INDENT final_str += word + \" \u2581 \" ; NEW_LINE DEDENT DEDENT",
        "explain": "if ' word ' is not palindrome then a add it to 'final_str"
    },
    {
        "py": "word = \" \" ; NEW_LINE",
        "explain": "reset"
    },
    {
        "py": "return final_str ; NEW_LINE",
        "explain": "required final string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" Text \u2581 contains \u2581 malayalam \u2581 and \u2581 level \u2581 words \" ; NEW_LINE print ( removePalinWords ( string ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findSubSequence ( s , num ) : NEW_LINE",
        "explain": "Returns numeric value of a subsequence of s . The subsequence to be picked is decided using bit pattern of num ( We pick all thosedigits for which there is a set bit in num )"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Initialize the result"
    },
    {
        "py": "i = 0 NEW_LINE while ( num ) : NEW_LINE",
        "explain": "till n != 0"
    },
    {
        "py": "if ( num & 1 ) : NEW_LINE INDENT res += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "if i - th bit is set then add this number"
    },
    {
        "py": "num = num >> 1 NEW_LINE return res NEW_LINE",
        "explain": "right shift i"
    },
    {
        "py": "def combinedSum ( s ) : NEW_LINE",
        "explain": "function to find combined sum of all individual subsequence sum"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "length of string"
    },
    {
        "py": "c_sum = 0 NEW_LINE",
        "explain": "stores the combined"
    },
    {
        "py": "ran = ( 1 << n ) - 1 NEW_LINE",
        "explain": "2 ^ n - 1 subsequences"
    },
    {
        "py": "for i in range ( ran + 1 ) : NEW_LINE INDENT c_sum += findSubSequence ( s , i ) NEW_LINE DEDENT",
        "explain": "loop for all subsequences"
    },
    {
        "py": "return c_sum NEW_LINE",
        "explain": "returns the combined sum"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT s = \"123\" NEW_LINE print ( combinedSum ( s ) ) NEW_LINE DEDENT",
        "explain": "driver code"
    },
    {
        "py": "MAX_CHAR = 26 NEW_LINE",
        "explain": "Python Program to find the subsequence with each character occurring at least k times in string s"
    },
    {
        "py": "def findSubsequence ( stri , k ) : NEW_LINE",
        "explain": "Function to find the subsequence"
    },
    {
        "py": "a = [ 0 ] * MAX_CHAR ; NEW_LINE",
        "explain": "Taking an extra array to keep record for character count in s"
    },
    {
        "py": "for i in range ( len ( stri ) ) : NEW_LINE INDENT a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Counting occurrences of all characters in str [ ]"
    },
    {
        "py": "for i in range ( len ( stri ) ) : NEW_LINE INDENT if a [ ord ( stri [ i ] ) - ord ( ' a ' ) ] >= k : NEW_LINE INDENT print ( stri [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT",
        "explain": "Printing characters with count >= k in same order as they appear in str ."
    },
    {
        "py": "k = 2 NEW_LINE findSubsequence ( \" geeksforgeeks \" , k ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def convert ( str ) : NEW_LINE",
        "explain": "Python3 program to convert a sentence to gOOGLE cASE ."
    },
    {
        "py": "w = \" \" NEW_LINE z = \" \" ; NEW_LINE",
        "explain": "empty strings"
    },
    {
        "py": "str = str . upper ( ) + \" \u2581 \" ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE",
        "explain": "convert input string to upper case"
    },
    {
        "py": "ch = str [ i ] ; NEW_LINE if ( ch != ' \u2581 ' ) : NEW_LINE INDENT w = w + ch ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "checki if character is not a space and adding it to string w"
    },
    {
        "py": "z = ( z + ( w [ 0 ] ) . lower ( ) + w [ 1 : len ( w ) ] + \" \u2581 \" ) ; NEW_LINE w = \" \" ; NEW_LINE return z ; NEW_LINE",
        "explain": "converting first character to lower case and subsequent initial letter of another word to lower case"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" I \u2581 got \u2581 intern \u2581 at \u2581 geeksforgeeks \" ; NEW_LINE print ( convert ( str ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT",
        "explain": "isVowel ( ) is a function that returns true for a vowel and false otherwise ."
    },
    {
        "py": "def encryptString ( s , n , k ) : NEW_LINE",
        "explain": "function to Encrypt the string"
    },
    {
        "py": "cv = [ 0 for i in range ( n ) ] NEW_LINE cc = [ 0 for i in range ( n ) ] NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT cv [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc [ 0 ] = 1 NEW_LINE DEDENT",
        "explain": "cv to count vowel cc to count consonants"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE INDENT cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) NEW_LINE cc [ i ] = cc [ i - 1 ] + ( isVowel ( s [ i ] ) == False ) NEW_LINE DEDENT ans = \" \" NEW_LINE prod = 0 NEW_LINE prod = cc [ k - 1 ] * cv [ k - 1 ] NEW_LINE ans += str ( prod ) NEW_LINE",
        "explain": "Counting prefix count of vowel and prefix count of consonants"
    },
    {
        "py": "for i in range ( k , len ( s ) ) : NEW_LINE INDENT prod = ( ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ) NEW_LINE ans += str ( prod ) NEW_LINE DEDENT return ans NEW_LINE",
        "explain": "generating the encrypted string ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hello \" NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countOccurrences ( str , word ) : NEW_LINE",
        "explain": "Python program to count the number of occurrence of a word in the given string"
    },
    {
        "py": "a = str . split ( \" \u2581 \" ) NEW_LINE",
        "explain": "split the string by spaces in a"
    },
    {
        "py": "count = 0 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE",
        "explain": "search for pattern in a"
    },
    {
        "py": "if ( word == a [ i ] ) : NEW_LINE count = count + 1 NEW_LINE return count NEW_LINE",
        "explain": "if match found increase count"
    },
    {
        "py": "str = \" GeeksforGeeks \u2581 A \u2581 computer \u2581 science \u2581 portal \u2581 for \u2581 geeks \u2581 \" NEW_LINE word = \" portal \" NEW_LINE print ( countOccurrences ( str , word ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printInitials ( name ) : NEW_LINE INDENT if ( len ( name ) == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT",
        "explain": "Python3 program to print initials of a name"
    },
    {
        "py": "words = name . split ( \" \u2581 \" ) NEW_LINE for word in words : NEW_LINE INDENT print ( word [ 0 ] . upper ( ) , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Split the string using ' space ' and print the first character of every word"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT name = \" prabhat \u2581 kumar \u2581 singh \" NEW_LINE printInitials ( name ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def permute ( inp ) : NEW_LINE INDENT n = len ( inp ) NEW_LINE DEDENT",
        "explain": "Function to generate permutations"
    },
    {
        "py": "mx = 1 << n NEW_LINE",
        "explain": "Number of permutations is 2 ^ n"
    },
    {
        "py": "inp = inp . lower ( ) NEW_LINE",
        "explain": "Converting string to lower case"
    },
    {
        "py": "for i in range ( mx ) : NEW_LINE",
        "explain": "Using all subsequences and permuting them"
    },
    {
        "py": "combination = [ k for k in inp ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( ( i >> j ) & 1 ) == 1 ) : NEW_LINE INDENT combination [ j ] = inp [ j ] . upper ( ) NEW_LINE DEDENT DEDENT temp = \" \" NEW_LINE",
        "explain": "If j - th bit is set , we convert it to upper case"
    },
    {
        "py": "for i in combination : NEW_LINE INDENT temp += i NEW_LINE DEDENT print temp , NEW_LINE",
        "explain": "Printing current combination"
    },
    {
        "py": "permute ( \" ABC \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printString ( str , ch , count ) : NEW_LINE INDENT occ , i = 0 , 0 NEW_LINE DEDENT",
        "explain": "Function to print the string"
    },
    {
        "py": "if ( count == 0 ) : NEW_LINE INDENT print ( str ) NEW_LINE DEDENT",
        "explain": "If given count is 0 print the given string and return"
    },
    {
        "py": "for i in range ( len ( str ) ) : NEW_LINE",
        "explain": "Start traversing the string"
    },
    {
        "py": "if ( str [ i ] == ch ) : NEW_LINE INDENT occ += 1 NEW_LINE DEDENT",
        "explain": "Increment occ if current char is equal to given character"
    },
    {
        "py": "if ( occ == count ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "Break the loop if given character has been occurred given no . of times"
    },
    {
        "py": "if ( i < len ( str ) - 1 ) : NEW_LINE INDENT print ( str [ i + 1 : len ( str ) - i + 2 ] ) NEW_LINE DEDENT",
        "explain": "Print the string after the occurrence of given character given no . of times"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Empty \u2581 string \" ) NEW_LINE DEDENT",
        "explain": "Otherwise string is empty"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" geeks \u2581 for \u2581 geeks \" NEW_LINE printString ( str , ' e ' , 2 ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' A ' or c == ' e ' or c == ' E ' or c == ' i ' or c == ' I ' or c == ' o ' or c == ' O ' or c == ' u ' or c == ' U ' ) NEW_LINE DEDENT",
        "explain": "utility function to check for vowel"
    },
    {
        "py": "def reverseVowel ( str ) : NEW_LINE",
        "explain": "Function to reverse order of vowels"
    },
    {
        "py": "i = 0 NEW_LINE j = len ( str ) - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT if not isVowel ( str [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE continue NEW_LINE DEDENT if ( not isVowel ( str [ j ] ) ) : NEW_LINE INDENT j -= 1 NEW_LINE continue NEW_LINE DEDENT DEDENT",
        "explain": "Start two indexes from two corners and move toward each other"
    },
    {
        "py": "str [ i ] , str [ j ] = str [ j ] , str [ i ] NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE return str NEW_LINE",
        "explain": "swapping"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str = \" hello \u2581 world \" NEW_LINE print ( * reverseVowel ( list ( str ) ) , sep = \" \" ) NEW_LINE DEDENT",
        "explain": "Driver function"
    },
    {
        "py": "def isPalindrome ( str ) : NEW_LINE",
        "explain": "A function to check if a string str is palindrome"
    },
    {
        "py": "l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE",
        "explain": "Start from leftmost and rightmost corners of str"
    },
    {
        "py": "while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE",
        "explain": "Keep comparing characters while they are same"
    },
    {
        "py": "def minRemovals ( str ) : NEW_LINE",
        "explain": "Returns count of minimum palindromic subseuqnces to be removed to make string empty"
    },
    {
        "py": "if ( str [ 0 ] == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If string is empty"
    },
    {
        "py": "if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If string is palindrome"
    },
    {
        "py": "return 2 NEW_LINE",
        "explain": "If string is not palindrome"
    },
    {
        "py": "print ( minRemovals ( \"010010\" ) ) NEW_LINE print ( minRemovals ( \"0100101\" ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def power ( x , y , p ) : NEW_LINE",
        "explain": "Iterative function to calculate ( x ^ y ) % p in O ( log y )"
    },
    {
        "py": "res = 1 ; NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE",
        "explain": "Update x if it is >= p"
    },
    {
        "py": "if ( y and 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT",
        "explain": "If y is odd , multiply x with result"
    },
    {
        "py": "y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE return res ; NEW_LINE",
        "explain": "y must be even now y = y 2"
    },
    {
        "py": "def findModuloByM ( X , N , M ) : NEW_LINE",
        "explain": "Function to return XXX ... . . ( N times ) % M"
    },
    {
        "py": "if ( N < 6 ) : NEW_LINE",
        "explain": "Return the mod by M of smaller numbers"
    },
    {
        "py": "temp = chr ( 48 + X ) * N NEW_LINE",
        "explain": "Creating a string of N X 's"
    },
    {
        "py": "res = int ( temp ) % M ; NEW_LINE return res ; NEW_LINE",
        "explain": "Converting the string to int and calculating the modulo"
    },
    {
        "py": "if ( N % 2 == 0 ) : NEW_LINE",
        "explain": "Checking the parity of N"
    },
    {
        "py": "half = findModuloByM ( X , N // 2 , M ) % M ; NEW_LINE",
        "explain": "Dividing the number into equal half"
    },
    {
        "py": "res = ( half * power ( 10 , N // 2 , M ) + half ) % M ; NEW_LINE return res ; NEW_LINE else : NEW_LINE",
        "explain": "Utilizing the formula for even N"
    },
    {
        "py": "half = findModuloByM ( X , N // 2 , M ) % M ; NEW_LINE",
        "explain": "Dividing the number into equal half"
    },
    {
        "py": "res = ( half * power ( 10 , N // 2 + 1 , M ) + half * 10 + X ) % M ; NEW_LINE return res ; NEW_LINE",
        "explain": "Utilizing the formula for odd N"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT X = 6 ; N = 14 ; M = 9 ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( findModuloByM ( X , N , M ) ) ; NEW_LINE",
        "explain": "Print XXX ... ( N times ) % M"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "class circle : NEW_LINE INDENT def __init__ ( self , a , b , c ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE self . r = c NEW_LINE DEDENT DEDENT",
        "explain": "Structure of the circle"
    },
    {
        "py": "def check ( C ) : NEW_LINE",
        "explain": "Utility function to check if given circles satisfy required criteria"
    },
    {
        "py": "C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) NEW_LINE",
        "explain": "Stores the distance between the centres of C1 and C2"
    },
    {
        "py": "flag = 0 NEW_LINE",
        "explain": "Stores the status if the given given criteria is satisfied or not"
    },
    {
        "py": "if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) : NEW_LINE",
        "explain": "If C1C2 is less than the sum of the radii of the first 2 circles"
    },
    {
        "py": "if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x and ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) : NEW_LINE",
        "explain": "If C3 is the midpoint of the centres at C1 and C2"
    },
    {
        "py": "flag = 1 NEW_LINE",
        "explain": "Mark flag true"
    },
    {
        "py": "return flag NEW_LINE",
        "explain": "Return flag"
    },
    {
        "py": "def IsFairTriplet ( c ) : NEW_LINE INDENT f = False NEW_LINE DEDENT",
        "explain": "Function to check if the given circles satisfy required criteria"
    },
    {
        "py": "f |= check ( c ) NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT c [ 0 ] , c [ 2 ] = c [ 2 ] , c [ 0 ] NEW_LINE DEDENT",
        "explain": "Check for the current combination of circles"
    },
    {
        "py": "f |= check ( c ) NEW_LINE return f NEW_LINE",
        "explain": "Check for the next combination"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT C = [ circle ( 0 , 0 , 0 ) for i in range ( 3 ) ] NEW_LINE C [ 0 ] = circle ( 0 , 0 , 8 ) NEW_LINE C [ 1 ] = circle ( 0 , 10 , 6 ) NEW_LINE C [ 2 ] = circle ( 0 , 5 , 5 ) NEW_LINE if ( IsFairTriplet ( C ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def eccHyperbola ( A , B ) : NEW_LINE",
        "explain": "Function to find the eccentricity of a hyperbola"
    },
    {
        "py": "r = B * B / A * A NEW_LINE",
        "explain": "Stores the squared ratio of major axis to minor axis"
    },
    {
        "py": "r += 1 NEW_LINE",
        "explain": "Increment r by 1"
    },
    {
        "py": "return math . sqrt ( r ) NEW_LINE",
        "explain": "Return the square root of r"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 3.0 NEW_LINE B = 2.0 NEW_LINE print ( eccHyperbola ( A , B ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def calculateArea ( A , B , C , D ) : NEW_LINE",
        "explain": "Function to find the area of cyclic quadrilateral"
    },
    {
        "py": "S = ( A + B + C + D ) // 2 NEW_LINE",
        "explain": "Stores the value of half of the perimeter"
    },
    {
        "py": "area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) NEW_LINE",
        "explain": "Stores area of cyclic quadrilateral"
    },
    {
        "py": "return area NEW_LINE",
        "explain": "Return the resultant area"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 10 NEW_LINE B = 15 NEW_LINE C = 20 NEW_LINE D = 25 NEW_LINE print ( round ( calculateArea ( A , B , C , D ) , 3 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def triangleArea ( a , b ) : NEW_LINE",
        "explain": "Function to calculate ratio of a triangle inscribed in an ellipse to the triangle on the auxiliary circle"
    },
    {
        "py": "ratio = b / a NEW_LINE",
        "explain": "Stores the ratio of the semi - major to semi - minor axes"
    },
    {
        "py": "print ( ratio ) NEW_LINE",
        "explain": "Print the ratio"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 1 NEW_LINE b = 2 NEW_LINE triangleArea ( a , b ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def distance ( m , n , p , q ) : NEW_LINE INDENT return ( sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ) NEW_LINE DEDENT",
        "explain": "Function to calculate the distance between a pair of points"
    },
    {
        "py": "def Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE",
        "explain": "Function to calculate the coordinates of the excenters of a triangle"
    },
    {
        "py": "a = distance ( x2 , x3 , y2 , y3 ) NEW_LINE b = distance ( x3 , x1 , y3 , y1 ) NEW_LINE c = distance ( x1 , x2 , y1 , y2 ) NEW_LINE",
        "explain": "Length of the sides of the triangle"
    },
    {
        "py": "excenter = [ [ 0 , 0 ] for i in range ( 4 ) ] NEW_LINE",
        "explain": "Stores the coordinates of the excenters of the triangle"
    },
    {
        "py": "excenter [ 1 ] [ 0 ] = ( ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) // ( - a + b + c ) ) NEW_LINE excenter [ 1 ] [ 1 ] = ( ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) // ( - a + b + c ) ) NEW_LINE",
        "explain": "For I1"
    },
    {
        "py": "excenter [ 2 ] [ 0 ] = ( ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) // ( a - b + c ) ) NEW_LINE excenter [ 2 ] [ 1 ] = ( ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) // ( a - b + c ) ) NEW_LINE",
        "explain": "For I2"
    },
    {
        "py": "excenter [ 3 ] [ 0 ] = ( ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) // ( a + b - c ) ) NEW_LINE excenter [ 3 ] [ 1 ] = ( ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) // ( a + b - c ) ) NEW_LINE",
        "explain": "For I3"
    },
    {
        "py": "for i in range ( 1 , 4 ) : NEW_LINE INDENT print ( int ( excenter [ i ] [ 0 ] ) , int ( excenter [ i ] [ 1 ] ) ) NEW_LINE DEDENT",
        "explain": "Print the excenters of the triangle"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE x2 = 3 NEW_LINE x3 = 0 NEW_LINE y1 = 0 NEW_LINE y2 = 0 NEW_LINE y3 = 4 NEW_LINE Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def findHeight ( p1 , p2 , b , c ) : NEW_LINE INDENT a = max ( p1 , p2 ) - min ( p1 , p2 ) NEW_LINE DEDENT",
        "explain": "Function to calculate height of the trapezoid"
    },
    {
        "py": "s = ( a + b + c ) // 2 NEW_LINE",
        "explain": "Apply Heron 's formula"
    },
    {
        "py": "area = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE",
        "explain": "Calculate the area"
    },
    {
        "py": "height = ( area * 2 ) / a NEW_LINE",
        "explain": "Calculate height of trapezoid"
    },
    {
        "py": "print ( \" Height \u2581 is : \u2581 \" , height ) NEW_LINE",
        "explain": "Prthe height"
    },
    {
        "py": "p1 = 25 NEW_LINE p2 = 10 NEW_LINE a = 14 NEW_LINE b = 13 NEW_LINE findHeight ( p1 , p2 , a , b ) NEW_LINE",
        "explain": "Given a , b , p1 and p2"
    },
    {
        "py": "def Icositetragonal_num ( n ) : NEW_LINE",
        "explain": "Function to find Icositetragonal number"
    },
    {
        "py": "return ( 22 * n * n - 20 * n ) / 2 NEW_LINE",
        "explain": "Formula to calculate nth Icositetragonal number"
    },
    {
        "py": "n = 3 NEW_LINE print ( int ( Icositetragonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Icositetragonal_num ( n ) ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def area_of_circle ( m , n ) : NEW_LINE",
        "explain": "Function to find area of circle inscribed in a trapezoid having non - parallel sides m , n"
    },
    {
        "py": "square_of_radius = ( m * n ) / 4 NEW_LINE area = ( 3.141 * square_of_radius ) NEW_LINE return area NEW_LINE",
        "explain": "radius of circle by the formula i . e . root ( m * n ) / 2 area of circle = ( 3.141 ) * ( R * * 2 )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE m = 30 NEW_LINE print ( area_of_circle ( m , n ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def area ( R ) : NEW_LINE",
        "explain": "Function to find the area of equilateral triangle inscribed in a circle of radius R"
    },
    {
        "py": "base = 1.732 * R NEW_LINE height = ( 3 / 2 ) * R NEW_LINE",
        "explain": "Base and Height of equilateral triangle"
    },
    {
        "py": "area = ( ( 1 / 2 ) * base * height ) NEW_LINE return area NEW_LINE",
        "explain": "Area using Base and Height"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT R = 7 NEW_LINE print ( area ( R ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def circlearea ( R ) : NEW_LINE",
        "explain": "Function to find the area of the circle"
    },
    {
        "py": "if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT",
        "explain": "Radius cannot be negative"
    },
    {
        "py": "a = ( 3.14 * R * R ) / 4 ; NEW_LINE return a ; NEW_LINE",
        "explain": "Area of the largest circle"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT R = 2 ; NEW_LINE print ( circlearea ( R ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countPairs ( P , Q , N , M ) : NEW_LINE",
        "explain": "Count number of pairs of lines having eger ersection po"
    },
    {
        "py": "A = [ 0 ] * 2 NEW_LINE B = [ 0 ] * 2 NEW_LINE",
        "explain": "Initialize arrays to store counts"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT A [ P [ i ] % 2 ] += 1 NEW_LINE DEDENT",
        "explain": "Count number of odd and even Pi"
    },
    {
        "py": "for i in range ( M ) : NEW_LINE INDENT B [ Q [ i ] % 2 ] += 1 NEW_LINE DEDENT",
        "explain": "Count number of odd and even Qi"
    },
    {
        "py": "return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) NEW_LINE",
        "explain": "Return the count of pairs"
    },
    {
        "py": "P = [ 1 , 3 , 2 ] NEW_LINE Q = [ 3 , 0 ] NEW_LINE N = len ( P ) NEW_LINE M = len ( Q ) NEW_LINE print ( countPairs ( P , Q , N , M ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countIntersections ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT",
        "explain": "Function to count maximum number of intersections possible"
    },
    {
        "py": "n = 3 NEW_LINE print ( countIntersections ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE PI = 3.14159 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def areaOfTriangle ( d ) : NEW_LINE",
        "explain": "Function to return the area of triangle BCD"
    },
    {
        "py": "c = 1.618 * d NEW_LINE s = ( d + c + c ) / 2 NEW_LINE",
        "explain": "Using Golden ratio"
    },
    {
        "py": "area = math . sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) NEW_LINE",
        "explain": "Calculate area of triangle BCD"
    },
    {
        "py": "return 5 * area NEW_LINE",
        "explain": "Return area of all 5 triangles are the same"
    },
    {
        "py": "def areaOfRegPentagon ( d ) : NEW_LINE INDENT global PI NEW_LINE DEDENT",
        "explain": "Function to return the area of regular pentagon"
    },
    {
        "py": "cal = 4 * math . tan ( PI / 5 ) NEW_LINE area = ( 5 * d * d ) / cal NEW_LINE",
        "explain": "Calculate the area of regular pentagon using above formula"
    },
    {
        "py": "return area NEW_LINE",
        "explain": "Return area of regular pentagon"
    },
    {
        "py": "def areaOfPentagram ( d ) : NEW_LINE",
        "explain": "Function to return the area of pentagram"
    },
    {
        "py": "return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) NEW_LINE",
        "explain": "Area of a pentagram is equal to the area of regular pentagon and five times the area of Triangle"
    },
    {
        "py": "d = 5 NEW_LINE print ( areaOfPentagram ( d ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def anglequichord ( z ) : NEW_LINE INDENT print ( \" The \u2581 angle \u2581 is \u2581 \" , z , \" \u2581 degrees \" ) NEW_LINE DEDENT",
        "explain": "Python 3 program to find the angle subtended by the chord to the centre of the circle when the angle subtended by another equal chord of a congruent circle is given"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT z = 48 NEW_LINE anglequichord ( z ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def convertToASCII ( N ) : NEW_LINE INDENT num = str ( N ) NEW_LINE i = 0 NEW_LINE for ch in num : NEW_LINE INDENT print ( ch , \" ( \" , ord ( ch ) , \" ) \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to convert digits of N to respective ASCII values"
    },
    {
        "py": "N = 36 NEW_LINE convertToASCII ( N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python 3 program for the above approach"
    },
    {
        "py": "def productExceptSelf ( arr , N ) : NEW_LINE",
        "explain": "Function to form product array with O ( n ) time and O ( 1 ) space"
    },
    {
        "py": "product = 1 NEW_LINE",
        "explain": "Stores the product of array"
    },
    {
        "py": "z = 0 NEW_LINE",
        "explain": "Stores the count of zeros"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( arr [ i ] != 0 ) : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT",
        "explain": "If arr [ i ] is not zero"
    },
    {
        "py": "if ( arr [ i ] == 0 ) : NEW_LINE INDENT z += 1 NEW_LINE DEDENT",
        "explain": "If arr [ i ] is zero then increment count of z by 1"
    },
    {
        "py": "a = abs ( product ) NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "Stores the absolute value of the product"
    },
    {
        "py": "if ( z == 1 ) : NEW_LINE",
        "explain": "If Z is equal to 1"
    },
    {
        "py": "if ( arr [ i ] != 0 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT",
        "explain": "If arr [ i ] is not zero"
    },
    {
        "py": "else : NEW_LINE INDENT arr [ i ] = product NEW_LINE DEDENT continue NEW_LINE",
        "explain": "Else"
    },
    {
        "py": "elif ( z > 1 ) : NEW_LINE",
        "explain": "If count of 0 s at least 2"
    },
    {
        "py": "arr [ i ] = 0 NEW_LINE continue NEW_LINE",
        "explain": "Assign arr [ i ] = 0"
    },
    {
        "py": "b = abs ( arr [ i ] ) NEW_LINE",
        "explain": "Store absolute value of arr [ i ]"
    },
    {
        "py": "curr = round ( math . exp ( math . log ( a ) - math . log ( b ) ) ) NEW_LINE",
        "explain": "Find the value of a / b"
    },
    {
        "py": "if ( arr [ i ] < 0 and product < 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT",
        "explain": "If arr [ i ] and product both are less than zero"
    },
    {
        "py": "elif ( arr [ i ] > 0 and product > 0 ) : NEW_LINE INDENT arr [ i ] = curr NEW_LINE DEDENT",
        "explain": "If arr [ i ] and product both are greater than zero"
    },
    {
        "py": "else : NEW_LINE INDENT arr [ i ] = - 1 * curr NEW_LINE DEDENT",
        "explain": "Else"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "productExceptSelf ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def singleDigitSubarrayCount ( arr , N ) : NEW_LINE",
        "explain": "Function to count of subarrays made up of single digit integers only"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores count of subarrays"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the count of consecutive single digit numbers in the array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] <= 9 ) : NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "count += 1 NEW_LINE",
        "explain": "Increment size of block by 1"
    },
    {
        "py": "res += count NEW_LINE else : NEW_LINE",
        "explain": "Increment res by count"
    },
    {
        "py": "count = 0 NEW_LINE print ( res ) NEW_LINE",
        "explain": "Assign count = 0"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 0 , 1 , 14 , 2 , 5 ] NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "N = len ( arr ) NEW_LINE singleDigitSubarrayCount ( arr , N ) NEW_LINE",
        "explain": "Size of the array"
    },
    {
        "py": "def isPossible ( N ) : NEW_LINE INDENT return ( ( N & ( N - 1 ) ) and N ) NEW_LINE DEDENT",
        "explain": "Function to check if the number N can be expressed as sum of 2 or more consecutive numbers or not"
    },
    {
        "py": "def countElements ( N ) : NEW_LINE",
        "explain": "Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers"
    },
    {
        "py": "count = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isPossible ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE",
        "explain": "Stores the required count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE countElements ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countElements ( N ) : NEW_LINE INDENT Cur_Ele = 1 NEW_LINE Count = 0 NEW_LINE DEDENT",
        "explain": "Function to count integers in the range [ 1 , N ] that can be expressed as sum of 2 or more consecutive numbers"
    },
    {
        "py": "while ( Cur_Ele <= N ) : NEW_LINE",
        "explain": "Count powers of 2 up to N"
    },
    {
        "py": "Count += 1 NEW_LINE",
        "explain": "Increment count"
    },
    {
        "py": "Cur_Ele = Cur_Ele * 2 NEW_LINE print ( N - Count ) NEW_LINE",
        "explain": "Update current power of 2"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE countElements ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python 3 program for the above approach"
    },
    {
        "py": "def maxAdjacent ( arr , N ) : NEW_LINE INDENT res = [ ] NEW_LINE arr_max = - sys . maxsize - 1 NEW_LINE DEDENT",
        "explain": "Function to calculate maximum difference between adjacent elements excluding every array element once"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT for i in range ( 1 , N - 1 ) : NEW_LINE INDENT curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) NEW_LINE DEDENT",
        "explain": "Compute maximum adjacent difference for whole array"
    },
    {
        "py": "ans = max ( curr_max , arr_max ) NEW_LINE",
        "explain": "Store the maximum between arr_max and curr_max"
    },
    {
        "py": "res . append ( ans ) NEW_LINE",
        "explain": "Append the result into a vector"
    },
    {
        "py": "for x in res : NEW_LINE INDENT print ( x , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 7 , 8 ] NEW_LINE N = len ( arr ) NEW_LINE maxAdjacent ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def minimumIncrement ( arr , N ) : NEW_LINE",
        "explain": "Function to find min operations to make even and odd count equal"
    },
    {
        "py": "if ( N % 2 != 0 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "Odd size will never make odd and even counts equal"
    },
    {
        "py": "cntEven = 0 NEW_LINE",
        "explain": "Stores the count of even numbers in the array arr [ ]"
    },
    {
        "py": "cntOdd = 0 NEW_LINE",
        "explain": "Stores count of odd numbers in the array arr [ ]"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if ( arr [ i ] % 2 == 0 ) : NEW_LINE",
        "explain": "If arr [ i ] is an even number"
    },
    {
        "py": "cntEven += 1 NEW_LINE",
        "explain": "Update cntEven"
    },
    {
        "py": "cntOdd = N - cntEven NEW_LINE",
        "explain": "Odd numbers in arr [ ]"
    },
    {
        "py": "return abs ( cntEven - cntOdd ) // 2 NEW_LINE",
        "explain": "Return absolute difference divided by 2"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 4 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( minimumIncrement ( arr , N ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def cntWaysConsArray ( A , N ) : NEW_LINE",
        "explain": "Function to find count the ways to construct an array , B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1 and product of elements of B [ ] is even"
    },
    {
        "py": "total = 1 ; NEW_LINE",
        "explain": "Stores count of arrays B [ ] such that abs ( A [ i ] - B [ i ] ) <= 1"
    },
    {
        "py": "oddArray = 1 ; NEW_LINE",
        "explain": "Stores count of arrays B [ ] whose product of elements is not even"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "total = total * 3 ; NEW_LINE",
        "explain": "Update total"
    },
    {
        "py": "if ( A [ i ] % 2 == 0 ) : NEW_LINE",
        "explain": "If A [ i ] is an even number"
    },
    {
        "py": "oddArray *= 2 ; NEW_LINE",
        "explain": "Update oddArray"
    },
    {
        "py": "print ( total - oddArray ) ; NEW_LINE",
        "explain": "Print 3 ^ N - 2 ^ X"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 2 , 4 ] ; NEW_LINE N = len ( A ) ; NEW_LINE cntWaysConsArray ( A , N ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countNumberHavingKthBitSet ( N , K ) : NEW_LINE",
        "explain": "Function to count the numbers in the range [ 1 , N ] whose rightmost set bit is K"
    },
    {
        "py": "numbers_rightmost_setbit_K = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE",
        "explain": "Stores the number whose rightmost set bit is K"
    },
    {
        "py": "numbers_rightmost_bit_i = ( N + 1 ) // 2 NEW_LINE",
        "explain": "Numbers whose rightmost set bit is i"
    },
    {
        "py": "N -= numbers_rightmost_bit_i NEW_LINE",
        "explain": "Subtracting the number whose rightmost set bit is i , from N"
    },
    {
        "py": "if ( i == K ) : NEW_LINE INDENT numbers_rightmost_setbit_K = numbers_rightmost_bit_i NEW_LINE DEDENT print ( numbers_rightmost_setbit_K ) NEW_LINE",
        "explain": "Since i = k , then the number whose rightmost set bit is K is stored"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE K = 2 NEW_LINE countNumberHavingKthBitSet ( N , K ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countSetBits ( N : int ) -> int : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Function to count set bits in binary representation of number N"
    },
    {
        "py": "while ( N ) : NEW_LINE INDENT N = N & ( N - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "Count set bits in N"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the final count"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 4 NEW_LINE bits = countSetBits ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( \" Odd \u2581 : \u2581 { } \" . format ( pow ( 2 , bits ) ) ) NEW_LINE",
        "explain": "Print odd Binomial coefficients"
    },
    {
        "py": "print ( \" Even \u2581 : \u2581 { } \" . format ( N + 1 - pow ( 2 , bits ) ) ) NEW_LINE",
        "explain": "Print even Binomial coefficients"
    },
    {
        "py": "def minMoves ( arr , N ) : NEW_LINE",
        "explain": "Function to find the minimum number of replacements required to make all array elements even"
    },
    {
        "py": "odd_element_cnt = 0 ; NEW_LINE",
        "explain": "Stores the count of odd elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT odd_element_cnt += 1 ; NEW_LINE DEDENT",
        "explain": "Increase count of odd elements"
    },
    {
        "py": "moves = ( odd_element_cnt ) // 2 ; NEW_LINE",
        "explain": "Store number of replacements required"
    },
    {
        "py": "if ( odd_element_cnt % 2 != 0 ) : NEW_LINE INDENT moves += 2 ; NEW_LINE DEDENT",
        "explain": "Two extra moves will be required to make the last odd element even"
    },
    {
        "py": "print ( moves ) ; NEW_LINE",
        "explain": "Prthe minimum replacements"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 3 , 7 , 20 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "minMoves ( arr , N ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def minimumSubsetDifference ( N ) : NEW_LINE",
        "explain": "Function to partition squares of N natural number in two subset"
    },
    {
        "py": "blockOfSize8 = N // 8 NEW_LINE",
        "explain": "Store the count of blocks of size 8"
    },
    {
        "py": "str = \" ABBABAAB \" NEW_LINE",
        "explain": "Partition of block of 8 element"
    },
    {
        "py": "subsetDifference = 0 NEW_LINE",
        "explain": "Store the minimum subset difference"
    },
    {
        "py": "partition = \" \" NEW_LINE while blockOfSize8 != 0 : NEW_LINE INDENT partition = partition + str NEW_LINE blockOfSize8 = blockOfSize8 - 1 NEW_LINE DEDENT",
        "explain": "Partition of N elements to minimize their subset sum difference"
    },
    {
        "py": "A = [ ] NEW_LINE B = [ ] NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "Store elements of subset A and B"
    },
    {
        "py": "if partition [ i ] == ' A ' : NEW_LINE INDENT A . append ( ( i + 1 ) * ( i + 1 ) ) NEW_LINE DEDENT",
        "explain": "If element is of type A"
    },
    {
        "py": "else : NEW_LINE INDENT B . append ( ( i + 1 ) * ( i + 1 ) ) NEW_LINE DEDENT",
        "explain": "If the element is of type B"
    },
    {
        "py": "print ( subsetDifference ) NEW_LINE",
        "explain": "Print the minimum subset difference"
    },
    {
        "py": "for i in A : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Print the first subset"
    },
    {
        "py": "for i in B : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the second subset"
    },
    {
        "py": "N = 8 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "minimumSubsetDifference ( N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "from collections import defaultdict NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def findTheGreatestX ( P , Q ) : NEW_LINE",
        "explain": "Function to find the largest number X such that it divides P but is not divisible by Q"
    },
    {
        "py": "divisiors = defaultdict ( int ) NEW_LINE i = 2 NEW_LINE while i * i <= Q : NEW_LINE INDENT while ( Q % i == 0 and Q > 1 ) : NEW_LINE INDENT Q //= i NEW_LINE DEDENT DEDENT",
        "explain": "Stores the frequency count of of all Prime Factors"
    },
    {
        "py": "divisiors [ i ] += 1 NEW_LINE i += 1 NEW_LINE",
        "explain": "Increment the frequency of the current prime factor"
    },
    {
        "py": "if ( Q > 1 ) : NEW_LINE INDENT divisiors [ Q ] += 1 NEW_LINE DEDENT",
        "explain": "If Q is a prime factor"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the desired result"
    },
    {
        "py": "for i in divisiors : NEW_LINE INDENT frequency = divisiors [ i ] NEW_LINE temp = P NEW_LINE DEDENT",
        "explain": "Iterate through all divisors of Q"
    },
    {
        "py": "cur = 0 NEW_LINE while ( temp % i == 0 ) : NEW_LINE INDENT temp //= i NEW_LINE DEDENT",
        "explain": "Stores the frequency count of current prime divisor on dividing P"
    },
    {
        "py": "cur += 1 NEW_LINE",
        "explain": "Count the frequency of the current prime factor"
    },
    {
        "py": "if ( cur < frequency ) : NEW_LINE INDENT ans = P NEW_LINE break NEW_LINE DEDENT temp = P NEW_LINE",
        "explain": "If cur is less than frequency then P is the final result"
    },
    {
        "py": "for j in range ( cur , frequency - 1 , - 1 ) : NEW_LINE INDENT temp //= i NEW_LINE DEDENT",
        "explain": "Iterate to get temporary answer"
    },
    {
        "py": "ans = max ( temp , ans ) NEW_LINE",
        "explain": "Update current answer"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the desired result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "P = 10 NEW_LINE Q = 4 NEW_LINE",
        "explain": "Given P and Q"
    },
    {
        "py": "findTheGreatestX ( P , Q ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def checkRearrangements ( mat , N , M ) : NEW_LINE",
        "explain": "Function to check if there is any row where number of unique elements are greater than 1"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT DEDENT DEDENT return \" No \" NEW_LINE",
        "explain": "Iterate over the matrix"
    },
    {
        "py": "def nonZeroXor ( mat , N , M ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT",
        "explain": "Function to check if it is possible to rearrange mat [ ] [ ] such that XOR of its first column is non - zero"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT res = res ^ mat [ i ] [ 0 ] NEW_LINE DEDENT",
        "explain": "Find bitwise XOR of the first column of mat [ ] [ ]"
    },
    {
        "py": "if ( res != 0 ) : NEW_LINE INDENT return \" Yes \" NEW_LINE DEDENT",
        "explain": "If bitwise XOR of the first column of mat [ ] [ ] is non - zero"
    },
    {
        "py": "else : NEW_LINE INDENT return checkRearrangements ( mat , N , M ) NEW_LINE DEDENT",
        "explain": "Otherwise check rearrangements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "mat = [ [ 1 , 1 , 2 ] , [ 2 , 2 , 2 ] , [ 3 , 3 , 3 ] ] NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE",
        "explain": "Given Matrix mat [ ] [ ]"
    },
    {
        "py": "print ( nonZeroXor ( mat , N , M ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def functionMax ( arr , n ) : NEW_LINE",
        "explain": "Function to maximize the value for the given function and the array elements"
    },
    {
        "py": "setBit = [ [ ] for i in range ( 32 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE DEDENT",
        "explain": "Vector array to maintain which bit is set for which integer in the given array by saving index of that integer"
    },
    {
        "py": "if ( arr [ i ] & ( 1 << j ) ) : NEW_LINE",
        "explain": "Check if j - th bit is set for i - th integer"
    },
    {
        "py": "setBit [ j ] . append ( i ) NEW_LINE",
        "explain": "Push the index of that integer in setBit [ j ]"
    },
    {
        "py": "i = 31 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( len ( setBit [ i ] ) == 1 ) : NEW_LINE DEDENT",
        "explain": "Find the element having highest significant set bit unset in other elements"
    },
    {
        "py": "temp = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ setBit [ i ] [ 0 ] ] NEW_LINE arr [ setBit [ i ] [ 0 ] ] = temp NEW_LINE break NEW_LINE i -= 1 NEW_LINE",
        "explain": "Place that integer at 0 - th index"
    },
    {
        "py": "maxAnd = arr [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT maxAnd = ( maxAnd & ( ~ arr [ i ] ) ) NEW_LINE DEDENT",
        "explain": "Store the maximum AND value"
    },
    {
        "py": "return maxAnd NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( functionMax ( arr , n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def nCr ( n , r ) : NEW_LINE",
        "explain": "Function returns nCr i . e . Binomial Coefficient"
    },
    {
        "py": "res = 1 NEW_LINE",
        "explain": "Initialize res with 1"
    },
    {
        "py": "if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT",
        "explain": "Since C ( n , r ) = C ( n , n - r )"
    },
    {
        "py": "for i in range ( r ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res ; NEW_LINE",
        "explain": "Evaluating expression"
    },
    {
        "py": "def solve ( n , m , k ) : NEW_LINE",
        "explain": "Function to calculate and return the sum of the products"
    },
    {
        "py": "sum = 0 ; NEW_LINE",
        "explain": "Initialize sum to 0"
    },
    {
        "py": "for i in range ( k + 1 ) : NEW_LINE INDENT sum += nCr ( n , i ) * nCr ( m , k - i ) NEW_LINE DEDENT return int ( sum ) NEW_LINE",
        "explain": "Traverse from 0 to k"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 2 NEW_LINE k = 2 ; NEW_LINE print ( solve ( n , m , k ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def powerOptimised ( a , n ) : NEW_LINE",
        "explain": "Function to return a ^ n"
    },
    {
        "py": "ans = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT last_bit = ( n & 1 ) NEW_LINE DEDENT",
        "explain": "Stores final answer"
    },
    {
        "py": "if ( last_bit ) : NEW_LINE INDENT ans = ans * a NEW_LINE DEDENT a = a * a NEW_LINE",
        "explain": "Check if current LSB is set"
    },
    {
        "py": "n = n >> 1 NEW_LINE return ans NEW_LINE",
        "explain": "Right shift"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE n = 5 NEW_LINE print ( powerOptimised ( a , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findMaximumGcd ( n ) : NEW_LINE",
        "explain": "Function to find the integer M such that gcd ( N , M ) is maximum"
    },
    {
        "py": "max_gcd = 1 NEW_LINE i = 1 NEW_LINE",
        "explain": "Initialize variables"
    },
    {
        "py": "while ( i * i <= n ) : NEW_LINE",
        "explain": "Find all the divisors of N and return the maximum divisor"
    },
    {
        "py": "if n % i == 0 : NEW_LINE",
        "explain": "Check if i is divisible by N"
    },
    {
        "py": "if ( i > max_gcd ) : NEW_LINE INDENT max_gcd = i NEW_LINE DEDENT if ( ( n / i != i ) and ( n / i != n ) and ( ( n / i ) > max_gcd ) ) : NEW_LINE INDENT max_gcd = n / i NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "Update max_gcd"
    },
    {
        "py": "return ( int ( max_gcd ) ) NEW_LINE",
        "explain": "Return the maximum value"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = 10 NEW_LINE",
        "explain": "Given number"
    },
    {
        "py": "print ( findMaximumGcd ( n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "x = 2000021 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "v = [ 0 ] * x NEW_LINE",
        "explain": "For storing smallest prime factor"
    },
    {
        "py": "def sieve ( ) : NEW_LINE INDENT v [ 1 ] = 1 NEW_LINE DEDENT",
        "explain": "Function construct smallest prime factor array"
    },
    {
        "py": "for i in range ( 2 , x ) : NEW_LINE INDENT v [ i ] = i NEW_LINE DEDENT",
        "explain": "Mark smallest prime factor for every number to be itself"
    },
    {
        "py": "for i in range ( 4 , x , 2 ) : NEW_LINE INDENT v [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < x ) : NEW_LINE",
        "explain": "separately mark spf for every even number as 2"
    },
    {
        "py": "if ( v [ i ] == i ) : NEW_LINE",
        "explain": "Check if i is prime"
    },
    {
        "py": "for j in range ( i * i , x , i ) : NEW_LINE",
        "explain": "Mark SPF for all numbers divisible by i"
    },
    {
        "py": "if ( v [ j ] == j ) : NEW_LINE INDENT v [ j ] = i NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "Mark spf [ i ] if it is not previously marked"
    },
    {
        "py": "def prime_factors ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE while ( n != 1 ) : NEW_LINE INDENT s . add ( v [ n ] ) NEW_LINE n = n // v [ n ] NEW_LINE DEDENT return len ( s ) NEW_LINE DEDENT",
        "explain": "Function for counts total number of prime factors"
    },
    {
        "py": "def distinctPrimes ( m , k ) : NEW_LINE",
        "explain": "Function to print elements of sets of K consecutive elements having K prime factors"
    },
    {
        "py": "result = [ ] NEW_LINE for i in range ( 14 , m + k ) : NEW_LINE",
        "explain": "To store the result"
    },
    {
        "py": "count = prime_factors ( i ) NEW_LINE",
        "explain": "Count number of prime factors of number"
    },
    {
        "py": "if ( count == k ) : NEW_LINE INDENT result . append ( i ) NEW_LINE DEDENT p = len ( result ) NEW_LINE for index in range ( p - 1 ) : NEW_LINE element = result [ index ] NEW_LINE count = 1 NEW_LINE z = index NEW_LINE",
        "explain": "If number has exactly K factors puch in result [ ]"
    },
    {
        "py": "while ( z < p - 1 and count <= k and result [ z ] + 1 == result [ z + 1 ] ) : NEW_LINE",
        "explain": "Iterate till we get K consecutive elements in result [ ]"
    },
    {
        "py": "count += 1 NEW_LINE z += 1 NEW_LINE",
        "explain": "Count sequence until K"
    },
    {
        "py": "if ( count >= k ) : NEW_LINE INDENT print ( element , end = ' \u2581 ' ) NEW_LINE DEDENT",
        "explain": "Print the element if count >= K"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "sieve ( ) NEW_LINE",
        "explain": "To construct spf [ ]"
    },
    {
        "py": "N = 1000 NEW_LINE K = 3 NEW_LINE",
        "explain": "Given N and K"
    },
    {
        "py": "distinctPrimes ( N , K ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def print_product ( a , b , c , d ) : NEW_LINE",
        "explain": "Function to multiply Complex Numbers with just three multiplications"
    },
    {
        "py": "prod1 = a * c NEW_LINE prod2 = b * d NEW_LINE prod3 = ( a + b ) * ( c + d ) NEW_LINE",
        "explain": "Find value of prod1 , prod2 and prod3"
    },
    {
        "py": "real = prod1 - prod2 NEW_LINE",
        "explain": "Real part"
    },
    {
        "py": "imag = prod3 - ( prod1 + prod2 ) NEW_LINE",
        "explain": "Imaginary part"
    },
    {
        "py": "print ( real , \" \u2581 + \u2581 \" , imag , \" i \" ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "a = 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE d = 5 NEW_LINE",
        "explain": "Given four numbers"
    },
    {
        "py": "print_product ( a , b , c , d ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def isInsolite ( n ) : NEW_LINE INDENT N = n ; NEW_LINE DEDENT",
        "explain": "Function to check if a number is an Insolite numbers"
    },
    {
        "py": "sum = 0 ; NEW_LINE",
        "explain": "To store sum of squares of digits"
    },
    {
        "py": "product = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE",
        "explain": "To store product of squares of digits"
    },
    {
        "py": "r = n % 10 ; NEW_LINE sum = sum + r * r ; NEW_LINE product = product * r * r ; NEW_LINE n = n // 10 ; NEW_LINE return ( ( N % sum == 0 ) and ( N % product == 0 ) ) ; NEW_LINE",
        "explain": "extracting digit"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 111 ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "if ( isInsolite ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "explain": "Function Call"
    },
    {
        "py": "def sigma ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to calculate the sum of all divisors of a given number"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Sum of divisors"
    },
    {
        "py": "' NEW_LINE INDENT for i in range ( 2 , pow ( n , 1 // 2 ) ) : NEW_LINE DEDENT",
        "explain": "Find all divisors which divides 'num"
    },
    {
        "py": "' NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT",
        "explain": "If ' i ' is divisor of 'n"
    },
    {
        "py": "if ( i == ( n / i ) ) : NEW_LINE INDENT result += i NEW_LINE DEDENT else : NEW_LINE INDENT result += ( i + n / i ) NEW_LINE DEDENT",
        "explain": "If both divisors are same then add it once else add both"
    },
    {
        "py": "return ( result + n + 1 ) NEW_LINE",
        "explain": "Add 1 and n to result as above loop considers proper divisors greater than 1."
    },
    {
        "py": "def isSuperabundant ( N ) : NEW_LINE",
        "explain": "Function to check if N is a superabundant number"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT x = sigma ( ( int ) ( i ) ) / i NEW_LINE y = sigma ( ( int ) ( N ) ) / ( N * 1.0 ) NEW_LINE if ( x > y ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "To check all numbers from 1 to N"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE if ( isSuperabundant ( N ) != True ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation for the above approach"
    },
    {
        "py": "def isDNum ( n ) : NEW_LINE",
        "explain": "Function to find the N - th icosikaipentagon number"
    },
    {
        "py": "if n < 4 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "number should be greater than 3"
    },
    {
        "py": "for k in range ( 2 , n ) : NEW_LINE INDENT numerator = pow ( k , n - 2 ) - k NEW_LINE hcf = math . gcd ( n , k ) NEW_LINE DEDENT",
        "explain": "Check every k in range 2 to n - 1"
    },
    {
        "py": "if ( hcf == 1 and ( numerator % n ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE",
        "explain": "condition for D - Number"
    },
    {
        "py": "n = 15 NEW_LINE if isDNum ( n ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE DEDENT",
        "explain": "Function to find prime divisors of all numbers from 1 to N"
    },
    {
        "py": "if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE",
        "explain": "If the number is prime"
    },
    {
        "py": "for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE",
        "explain": "Add this prime to all it 's multiples"
    },
    {
        "py": "def RuthAaronNumber ( n ) : NEW_LINE INDENT if ( Sum ( n ) == Sum ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Function to check Ruth - Aaron number"
    },
    {
        "py": "N = 714 NEW_LINE if ( RuthAaronNumber ( N ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxAdjacentDifference ( N , K ) : NEW_LINE",
        "explain": "Function for maximising the sum"
    },
    {
        "py": "if ( N == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "Difference is 0 when only one element is present in array"
    },
    {
        "py": "if ( N == 2 ) : NEW_LINE INDENT return K ; NEW_LINE DEDENT",
        "explain": "Difference is K when two elements are present in array"
    },
    {
        "py": "return 2 * K ; NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "N = 6 ; NEW_LINE K = 11 ; NEW_LINE print ( maxAdjacentDifference ( N , K ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "mod = 1000000007 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def linearSum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) // 2 % mod NEW_LINE DEDENT",
        "explain": "Functions returns sum of numbers from 1 to n"
    },
    {
        "py": "def rangeSum ( b , a ) : NEW_LINE INDENT return ( linearSum ( b ) - ( linearSum ( a ) ) ) % mod NEW_LINE DEDENT",
        "explain": "Functions returns sum of numbers from a + 1 to b"
    },
    {
        "py": "def totalSum ( n ) : NEW_LINE",
        "explain": "Function returns total sum of divisors"
    },
    {
        "py": "result = 0 NEW_LINE i = 1 NEW_LINE",
        "explain": "Stores total sum"
    },
    {
        "py": "while True : NEW_LINE",
        "explain": "Finding numbers and its occurence"
    },
    {
        "py": "result += rangeSum ( n // i , n // ( i + 1 ) ) * ( i % mod ) % mod ; NEW_LINE result %= mod ; NEW_LINE if i == n : NEW_LINE INDENT break NEW_LINE DEDENT i = n // ( n // ( i + 1 ) ) NEW_LINE return result NEW_LINE",
        "explain": "Sum of product of each number and its occurence"
    },
    {
        "py": "N = 4 NEW_LINE print ( totalSum ( N ) ) NEW_LINE N = 12 NEW_LINE print ( totalSum ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isDouble ( num ) : NEW_LINE INDENT s = str ( num ) NEW_LINE l = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to check if a string is double string or not"
    },
    {
        "py": "if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "a and b should not be equal"
    },
    {
        "py": "if ( l % 2 == 1 ) : NEW_LINE INDENT s = s + s [ 1 ] NEW_LINE l += 1 NEW_LINE DEDENT",
        "explain": "Condition to check if length is odd make length even"
    },
    {
        "py": "s1 = s [ : l // 2 ] NEW_LINE",
        "explain": "First half of s"
    },
    {
        "py": "s2 = s [ l // 2 : ] NEW_LINE",
        "explain": "Second half of s"
    },
    {
        "py": "return s1 == s2 NEW_LINE",
        "explain": "Double string if first and last half are equal"
    },
    {
        "py": "def isNontrivialUndulant ( N ) : NEW_LINE INDENT return N > 100 and isDouble ( N ) NEW_LINE DEDENT",
        "explain": "Function to check if N is an Nontrivial undulant number"
    },
    {
        "py": "n = 121 NEW_LINE if ( isNontrivialUndulant ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def MegagonNum ( n ) : NEW_LINE INDENT return ( 999998 * n * n - 999996 * n ) // 2 ; NEW_LINE DEDENT",
        "explain": "Function to find the nth Megagon Number"
    },
    {
        "py": "n = 3 ; NEW_LINE print ( MegagonNum ( n ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "mod = 1000000007 ; NEW_LINE",
        "explain": "Python3 implementation to find the product of all the pairs from the given array"
    },
    {
        "py": "def productPairs ( arr , n ) : NEW_LINE",
        "explain": "Function to return the product of the elements of all possible pairs from the array"
    },
    {
        "py": "product = 1 ; NEW_LINE",
        "explain": "To store the required product"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE DEDENT",
        "explain": "Nested loop to calculate all possible pairs"
    },
    {
        "py": "product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; NEW_LINE product = product % mod ; NEW_LINE",
        "explain": "Multiply the product of the elements of the current pair"
    },
    {
        "py": "return product % mod ; NEW_LINE",
        "explain": "Return the final result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( productPairs ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "mod = 1000000007 NEW_LINE",
        "explain": "Python3 implementation to Find the product of all the pairs from the given array"
    },
    {
        "py": "def power ( x , y ) : NEW_LINE INDENT p = 1000000007 NEW_LINE DEDENT",
        "explain": "Function to calculate ( x ^ y ) % 1000000007"
    },
    {
        "py": "res = 1 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE",
        "explain": "Update x if it is more than or equal to p"
    },
    {
        "py": "if ( ( y & 1 ) != 0 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE",
        "explain": "If y is odd , multiply x with result"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the final result"
    },
    {
        "py": "def productPairs ( arr , n ) : NEW_LINE",
        "explain": "Function to return the product of the elements of all possible pairs from the array"
    },
    {
        "py": "product = 1 NEW_LINE",
        "explain": "To store the required product"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate for every element of the array"
    },
    {
        "py": "product = ( product % mod * ( int ) ( power ( arr [ i ] , ( 2 * n ) ) ) % mod ) % mod NEW_LINE return ( product % mod ) NEW_LINE",
        "explain": "Each element appears ( 2 * n ) times"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( productPairs ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def constructArray ( N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE DEDENT",
        "explain": "Function to create and print the array"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT arr [ i - 1 ] = i ; NEW_LINE DEDENT",
        "explain": "Initialise the array of size N"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = \" , \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the array"
    },
    {
        "py": "N = 6 ; NEW_LINE constructArray ( N ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT",
        "explain": "Function to check whether a number is prime or not"
    },
    {
        "py": "def countSubsequences ( arr , n ) : NEW_LINE",
        "explain": "Function to find number of subsequences whose product is a composite number"
    },
    {
        "py": "totalSubsequence = ( int ) ( pow ( 2 , n ) - 1 ) ; NEW_LINE countPrime = 0 ; NEW_LINE countOnes = 0 ; NEW_LINE",
        "explain": "Find total non empty subsequence"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT countOnes += 1 ; NEW_LINE DEDENT elif ( isPrime ( arr [ i ] ) ) : NEW_LINE INDENT countPrime += 1 ; NEW_LINE DEDENT DEDENT compositeSubsequence = 0 ; NEW_LINE",
        "explain": "Find count of prime number and ones"
    },
    {
        "py": "onesSequence = ( int ) ( pow ( 2 , countOnes ) - 1 ) ; NEW_LINE",
        "explain": "Calculate the non empty one subsequence"
    },
    {
        "py": "compositeSubsequence = ( totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ) ; NEW_LINE return compositeSubsequence ; NEW_LINE",
        "explain": "Find count of composite subsequence"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countSubsequences ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def checksum ( n , k ) : NEW_LINE",
        "explain": "Function to check if a number can be expressed as the sum of k consecutive"
    },
    {
        "py": "first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 NEW_LINE",
        "explain": "Finding the first term of AP"
    },
    {
        "py": "if ( first_term - int ( first_term ) == 0 ) : NEW_LINE",
        "explain": "Checking if first term is an integer"
    },
    {
        "py": "for i in range ( int ( first_term ) , int ( first_term ) + k ) : NEW_LINE INDENT print ( i , end = ' \u2581 ' ) NEW_LINE DEDENT else : NEW_LINE print ( ' - 1' ) NEW_LINE",
        "explain": "Loop to print the K consecutive integers"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( n , k ) = ( 33 , 6 ) NEW_LINE checksum ( n , k ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def sumEvenNumbers ( N , K ) : NEW_LINE INDENT check = N - 2 * ( K - 1 ) NEW_LINE DEDENT",
        "explain": "Function to print the representation"
    },
    {
        "py": "if ( check > 0 and check % 2 == 0 ) : NEW_LINE INDENT for i in range ( K - 1 ) : NEW_LINE INDENT print ( \"2 \u2581 \" , end = \" \" ) NEW_LINE DEDENT print ( check ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "N must be greater than equal to 2 * K and must be even"
    },
    {
        "py": "N = 8 NEW_LINE K = 2 NEW_LINE sumEvenNumbers ( N , K ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def calculateWays ( N ) : NEW_LINE INDENT x = 0 ; NEW_LINE v = [ ] ; NEW_LINE DEDENT",
        "explain": "Function to find the number of subarrays including the element at every index of the array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT v . append ( 0 ) ; NEW_LINE DEDENT",
        "explain": "Creating an array of size N"
    },
    {
        "py": "for i in range ( N // 2 + 1 ) : NEW_LINE",
        "explain": "The loop is iterated till half the length of the array"
    },
    {
        "py": "if ( N % 2 == 0 and i == N // 2 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT",
        "explain": "Condition to avoid overwriting the middle element for the array with even length ."
    },
    {
        "py": "x = N * ( i + 1 ) - ( i + 1 ) * i ; NEW_LINE",
        "explain": "Computing the number of subarrays"
    },
    {
        "py": "v [ i ] = x ; NEW_LINE v [ N - i - 1 ] = x ; NEW_LINE return v ; NEW_LINE",
        "explain": "The ith element from the beginning and the ending have the same number of possible subarrays"
    },
    {
        "py": "def printArray ( v ) : NEW_LINE INDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the vector"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT v = calculateWays ( 4 ) ; NEW_LINE printArray ( v ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "MAXN = 10000000 NEW_LINE",
        "explain": "Python3 program to find the smallest number greater than or equal to X and divisible by Y"
    },
    {
        "py": "def sumOfDigits ( n ) : NEW_LINE",
        "explain": "Function that returns the sum of digits of a number"
    },
    {
        "py": "sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE",
        "explain": "Initialize variable to store the sum"
    },
    {
        "py": "sum += n % 10 NEW_LINE",
        "explain": "Add the last digit of the number"
    },
    {
        "py": "n //= 10 NEW_LINE return sum NEW_LINE",
        "explain": "Remove the last digit from the number"
    },
    {
        "py": "def smallestNum ( X , Y ) : NEW_LINE",
        "explain": "Function that returns the smallest number greater than or equal to X and divisible by Y"
    },
    {
        "py": "res = - 1 ; NEW_LINE",
        "explain": "Initialize result variable"
    },
    {
        "py": "for i in range ( X , MAXN ) : NEW_LINE",
        "explain": "Loop through numbers greater than equal to X"
    },
    {
        "py": "sum_of_digit = sumOfDigits ( i ) NEW_LINE",
        "explain": "Calculate sum of digits"
    },
    {
        "py": "if sum_of_digit % Y == 0 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Check if sum of digits is divisible by Y"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ( X , Y ) = ( 5923 , 13 ) NEW_LINE print ( smallestNum ( X , Y ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countValues ( N ) : NEW_LINE INDENT div = [ ] NEW_LINE i = 2 NEW_LINE DEDENT",
        "explain": "Function to count the numbers which can convert N to 1 using the given operation"
    },
    {
        "py": "while ( ( i * i ) <= N ) : NEW_LINE",
        "explain": "Store all the divisors of N"
    },
    {
        "py": "if ( N % i == 0 ) : NEW_LINE INDENT div . append ( i ) NEW_LINE DEDENT",
        "explain": "If i is a divisor"
    },
    {
        "py": "if ( N != i * i ) : NEW_LINE INDENT div . append ( N // i ) NEW_LINE DEDENT i += 1 NEW_LINE answer = 0 NEW_LINE i = 1 NEW_LINE",
        "explain": "If i is not equal to N / i"
    },
    {
        "py": "while ( ( i * i ) <= N - 1 ) : NEW_LINE",
        "explain": "Iterate through all the divisors of N - 1 and count them in answer"
    },
    {
        "py": "if ( ( N - 1 ) % i == 0 ) : NEW_LINE INDENT if ( i * i == N - 1 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE",
        "explain": "Check if N - 1 is a divisor or not"
    },
    {
        "py": "for d in div : NEW_LINE INDENT K = N NEW_LINE while ( K % d == 0 ) : NEW_LINE INDENT K //= d NEW_LINE DEDENT if ( ( K - 1 ) % d == 0 ) : NEW_LINE INDENT answer += 1 NEW_LINE DEDENT DEDENT return answer NEW_LINE",
        "explain": "Iterate through all divisors and check for N mod d = 1 or ( N - 1 ) mod d = 0"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 6 NEW_LINE print ( countValues ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findMaxPrimeDivisor ( n ) : NEW_LINE INDENT max_possible_prime = 0 NEW_LINE DEDENT",
        "explain": "Function to find the maximum possible prime divisors of a number can have with N divisors"
    },
    {
        "py": "while ( n % 2 == 0 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT",
        "explain": "Number of time number divided by 2"
    },
    {
        "py": "i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE n = n // i NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT",
        "explain": "Divide by other prime numbers"
    },
    {
        "py": "if ( n > 2 ) : NEW_LINE INDENT max_possible_prime += 1 NEW_LINE DEDENT print ( max_possible_prime ) NEW_LINE",
        "explain": "If the last number of also prime then also include it"
    },
    {
        "py": "n = 4 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "findMaxPrimeDivisor ( n ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def CountWays ( n ) : NEW_LINE INDENT ans = ( n - 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT",
        "explain": "Function returns the count of ways express a number as sum of two numbers ."
    },
    {
        "py": "N = 8 NEW_LINE print ( CountWays ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def Solve ( arr , size , n ) : NEW_LINE INDENT v = [ 0 ] * ( n + 1 ) ; NEW_LINE DEDENT",
        "explain": "Function to find the max - size to which an array can be divided into 2 equal parts"
    },
    {
        "py": "for i in range ( size ) : NEW_LINE INDENT v [ arr [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "Vector to find the frequency of each element of list"
    },
    {
        "py": "max1 = max ( set ( arr ) , key = v . count ) NEW_LINE",
        "explain": "Find the maximum frequency element present in list arr"
    },
    {
        "py": "diff1 = n + 1 - v . count ( 0 ) NEW_LINE",
        "explain": "Find total unique elements present in list arr"
    },
    {
        "py": "max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) NEW_LINE print ( \" Maximum \u2581 size \u2581 is \u2581 : \" , max_size ) NEW_LINE",
        "explain": "Find the Max - Size to which an array arr [ ] can be splitted"
    },
    {
        "py": "print ( \" The \u2581 First \u2581 Array \u2581 Is \u2581 : \u2581 \" ) NEW_LINE for i in range ( max_size ) : NEW_LINE INDENT print ( max1 , end = \" \u2581 \" ) NEW_LINE v [ max1 ] -= 1 NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Find the first array containing same elements"
    },
    {
        "py": "print ( \" The \u2581 Second \u2581 Array \u2581 Is \u2581 : \u2581 \" ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( v [ i ] > 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE max_size -= 1 NEW_LINE DEDENT if ( max_size < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE",
        "explain": "Find the second array containing unique elements"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "n = 7 NEW_LINE",
        "explain": "Initialise n"
    },
    {
        "py": "arr = [ 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 ] NEW_LINE",
        "explain": "Array declaration"
    },
    {
        "py": "size = len ( arr ) NEW_LINE Solve ( arr , size , n ) NEW_LINE",
        "explain": "Size of array"
    },
    {
        "py": "def power ( x , y , p ) : NEW_LINE",
        "explain": "Iterative Function to calculate ( x ^ y ) % p in O ( log y )"
    },
    {
        "py": "res = 1 NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE",
        "explain": "Update x if it is more than or equal to p"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT",
        "explain": "If y is odd , multiply x with result"
    },
    {
        "py": "x = ( x * x ) % p NEW_LINE return res NEW_LINE",
        "explain": "y must be even now y = y >> 1 y = y / 2"
    },
    {
        "py": "def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT",
        "explain": "Returns n ^ ( - 1 ) mod p"
    },
    {
        "py": "def nCrModPFermat ( n , r , p ) : NEW_LINE",
        "explain": "Returns nCr % p using Fermat 's little theorem."
    },
    {
        "py": "if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "fac = [ 0 ] * ( n + 1 ) NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE",
        "explain": "Fill factorial array so that we can find all factorial of r , n and n - r"
    },
    {
        "py": "def SumOfXor ( a , n ) : NEW_LINE INDENT mod = 10037 NEW_LINE answer = 0 NEW_LINE DEDENT",
        "explain": "Function returns sum of xor of all unordered triplets of the array"
    },
    {
        "py": "for k in range ( 32 ) : NEW_LINE",
        "explain": "Iterating over the bits"
    },
    {
        "py": "x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Number of elements whith k 'th bit  1 and 0 respectively"
    },
    {
        "py": "if ( a [ i ] & ( 1 << k ) ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT",
        "explain": "Checking if k 'th bit is 1"
    },
    {
        "py": "answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod NEW_LINE return answer NEW_LINE",
        "explain": "Adding this bit 's part to the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE A = [ 3 , 5 , 2 , 18 , 7 ] NEW_LINE print ( SumOfXor ( A , n ) ) NEW_LINE DEDENT",
        "explain": "Drivers code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 implementation to find the probability of not getting two consecutive heads together when N coins are tossed"
    },
    {
        "py": "def probability ( N ) : NEW_LINE",
        "explain": "Function to compute the N - th Fibonacci number in the sequence where a = 2 and b = 3"
    },
    {
        "py": "a = 2 NEW_LINE b = 3 NEW_LINE",
        "explain": "The first two numbers in the sequence are initialized"
    },
    {
        "py": "if N == 1 : NEW_LINE INDENT return a NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Base cases"
    },
    {
        "py": "for i in range ( 3 , N + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE",
        "explain": "Loop to compute the fibonacci sequence based on the first two initialized numbers"
    },
    {
        "py": "def operations ( N ) : NEW_LINE",
        "explain": "Function to find the probability of not getting two consecutive heads when N coins are tossed"
    },
    {
        "py": "x = probability ( N ) NEW_LINE",
        "explain": "Computing the number of favourable cases"
    },
    {
        "py": "y = math . pow ( 2 , N ) NEW_LINE return round ( x / y , 2 ) NEW_LINE",
        "explain": "Computing the number of all possible outcomes for N tosses"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( operations ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isPerfectCube ( x ) : NEW_LINE INDENT x = abs ( x ) NEW_LINE return int ( round ( x ** ( 1. / 3 ) ) ) ** 3 == x NEW_LINE DEDENT",
        "explain": "Function to check if a number is a perfect Cube or not"
    },
    {
        "py": "def checkCube ( a , b ) : NEW_LINE",
        "explain": "Function to check if concatenation of two numbers is a perfect cube or not"
    },
    {
        "py": "s1 = str ( a ) NEW_LINE s2 = str ( b ) NEW_LINE",
        "explain": "Convert numbers to string using to_string ( )"
    },
    {
        "py": "c = int ( s1 + s2 ) NEW_LINE",
        "explain": "Concatenate the numbers and convert it into integer"
    },
    {
        "py": "if ( isPerfectCube ( c ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Check if concatenated value is perfect cube or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 6 NEW_LINE b = 4 NEW_LINE checkCube ( a , b ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def largest_sum ( arr , n ) : NEW_LINE",
        "explain": "Function to return the largest sum"
    },
    {
        "py": "maximum = - 1 NEW_LINE",
        "explain": "Variable to store the largest sum"
    },
    {
        "py": "m = dict ( ) NEW_LINE",
        "explain": "Map to store the frequencies of each element"
    },
    {
        "py": "for i in arr : NEW_LINE INDENT m [ i ] = m . get ( i , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Store the Frequencies"
    },
    {
        "py": "for j in list ( m ) : NEW_LINE",
        "explain": "Loop to combine duplicate elements and update the sum in the map"
    },
    {
        "py": "if ( ( j in m ) and m [ j ] > 1 ) : NEW_LINE",
        "explain": "If j is a duplicate element"
    },
    {
        "py": "x , y = 0 , 0 NEW_LINE if 2 * j in m : NEW_LINE INDENT m [ 2 * j ] = m [ 2 * j ] + m [ j ] // 2 NEW_LINE DEDENT else : NEW_LINE INDENT m [ 2 * j ] = m [ j ] // 2 NEW_LINE DEDENT",
        "explain": "Update the frequency of 2 * j"
    },
    {
        "py": "if ( 2 * j > maximum ) : NEW_LINE INDENT maximum = 2 * j NEW_LINE DEDENT",
        "explain": "If the new sum is greater than maximum value , Update the maximum"
    },
    {
        "py": "return maximum NEW_LINE",
        "explain": "Returns the largest sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 4 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( largest_sum ( arr , n ) ) NEW_LINE",
        "explain": "Function Calling"
    },
    {
        "py": "def canBeReduced ( x , y ) : NEW_LINE INDENT maxi = max ( x , y ) NEW_LINE mini = min ( x , y ) NEW_LINE DEDENT",
        "explain": "Function to check if it is possible to make x and y can become 0 at same time"
    },
    {
        "py": "if ( ( ( x + y ) % 3 ) == 0 and maxi <= 2 * mini ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Check the given conditions"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 6 NEW_LINE y = 9 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "canBeReduced ( x , y ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to check if the given number is prime using Wheel Factorization Method"
    },
    {
        "py": "def isPrime ( N ) : NEW_LINE INDENT isPrime = True ; NEW_LINE DEDENT",
        "explain": "Function to check if a given number x is prime or not"
    },
    {
        "py": "arr = [ 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 ] NEW_LINE",
        "explain": "The Wheel for checking prime number"
    },
    {
        "py": "if ( N < 2 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if ( N % 2 == 0 or N % 3 == 0 or N % 5 == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE DEDENT",
        "explain": "Check for the number taken as basis"
    },
    {
        "py": "for i in range ( 0 , int ( math . sqrt ( N ) ) , 30 ) : NEW_LINE",
        "explain": "Check for Wheel Here i , acts as the layer of the wheel"
    },
    {
        "py": "for c in arr : NEW_LINE",
        "explain": "Check for the list of Sieve in arr [ ]"
    },
    {
        "py": "if ( c > int ( math . sqrt ( N ) ) ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If number is greater than sqrt ( N ) break"
    },
    {
        "py": "else : NEW_LINE INDENT if ( N % ( c + i ) == 0 ) : NEW_LINE INDENT isPrime = False NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Check if N is a multiple of prime number in the wheel"
    },
    {
        "py": "if ( not isPrime ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( isPrime ) : NEW_LINE print ( \" Prime \u2581 Number \" ) NEW_LINE else : NEW_LINE print ( \" Not \u2581 a \u2581 Prime \u2581 Number \" ) NEW_LINE",
        "explain": "If at any iteration isPrime is false , break from the loop"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 121 NEW_LINE DEDENT",
        "explain": "Driver 's Code"
    },
    {
        "py": "isPrime ( N ) NEW_LINE",
        "explain": "Function call for primality check"
    },
    {
        "py": "def printPairs ( arr , n ) : NEW_LINE",
        "explain": "Function to prall possible pairs from the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( \" ( \" , arr [ i ] , \" , \" , arr [ j ] , \" ) \" , end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Nested loop for all possible pairs"
    },
    {
        "py": "arr = [ 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printPairs ( arr , n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "mod = int ( 1e9 ) + 7 ; NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def power ( p ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 ; NEW_LINE res %= mod ; NEW_LINE DEDENT return res % mod ; NEW_LINE DEDENT",
        "explain": "Function to return ( 2 ^ P % mod )"
    },
    {
        "py": "def subset_cube_sum ( A ) : NEW_LINE INDENT n = len ( A ) ; NEW_LINE ans = 0 ; NEW_LINE DEDENT",
        "explain": "Function to return the sum of cubes of subsets"
    },
    {
        "py": "for i in A : NEW_LINE INDENT ans += ( i * i * i ) % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT return ( ans * power ( n - 1 ) ) % mod ; NEW_LINE",
        "explain": "cubing the elements and adding it to ans"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 ] ; NEW_LINE print ( subset_cube_sum ( A ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ** ( .5 ) NEW_LINE if ( distSq + r2 == r1 ) : NEW_LINE INDENT print ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 with \u2581 \" \" touching \u2581 each \u2581 other \u2581 \" \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \u2581 \" ) NEW_LINE DEDENT elif ( distSq + r2 < r1 ) : NEW_LINE INDENT print ( \" The \u2581 smaller \u2581 circle \u2581 lies \u2581 completely \" \" \u2581 inside \u2581 the \u2581 bigger \u2581 circle \u2581 without \" \" \u2581 touching \u2581 each \u2581 other \u2581 \" \" at \u2581 a \u2581 point \u2581 of \u2581 circumference . \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The \u2581 smaller \u2581 does \u2581 not \u2581 lies \u2581 inside \" \" \u2581 the \u2581 bigger \u2581 circle \u2581 completely . \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Python3 program to check if one circle lies inside another circle or not ."
    },
    {
        "py": "x1 , y1 = 10 , 8 NEW_LINE x2 , y2 = 1 , 2 NEW_LINE r1 , r2 = 30 , 10 NEW_LINE circle ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \u2581 common \u2581 tangent \u2581 is \u2581 \" , ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT",
        "explain": "Function to find the length of the direct common tangent"
    },
    {
        "py": "r1 = 4 ; r2 = 6 ; d = 3 ; NEW_LINE lengtang ( r1 , r2 , d ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def rad ( d , h ) : NEW_LINE INDENT print ( \" The \u2581 radius \u2581 of \u2581 the \u2581 circle \u2581 is \" , ( ( d * d ) / ( 8 * h ) + h / 2 ) ) NEW_LINE DEDENT",
        "explain": "Function to find the radius"
    },
    {
        "py": "d = 4 ; h = 1 ; NEW_LINE rad ( d , h ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def shortdis ( r , d ) : NEW_LINE INDENT print ( \" The \u2581 shortest \u2581 distance \u2581 \" , end = \" \" ) ; NEW_LINE print ( \" from \u2581 the \u2581 chord \u2581 to \u2581 centre \u2581 \" , end = \" \" ) ; NEW_LINE print ( ( ( r * r ) - ( ( d * d ) / 4 ) ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT",
        "explain": "Function to find the shortest distance"
    },
    {
        "py": "r = 4 ; NEW_LINE d = 3 ; NEW_LINE shortdis ( r , d ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find the length of the direct common tangent between two circles which do not touch each other"
    },
    {
        "py": "def lengtang ( r1 , r2 , d ) : NEW_LINE INDENT print ( \" The \u2581 length \u2581 of \u2581 the \u2581 direct \u2581 common \u2581 tangent \u2581 is \" , ( ( ( d ** 2 ) - ( ( r1 - r2 ) ** 2 ) ) ** ( 1 / 2 ) ) ) ; NEW_LINE DEDENT",
        "explain": "Function to find the length of the direct common tangent"
    },
    {
        "py": "r1 = 4 ; r2 = 6 ; d = 12 ; NEW_LINE lengtang ( r1 , r2 , d ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def square ( a ) : NEW_LINE",
        "explain": "Function to find the side of the square"
    },
    {
        "py": "if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "the side cannot be negative"
    },
    {
        "py": "x = 0.464 * a NEW_LINE return x NEW_LINE",
        "explain": "side of the square"
    },
    {
        "py": "a = 5 NEW_LINE print ( square ( a ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import tan NEW_LINE",
        "explain": "Python 3 Program to find the apothem of a regular polygon with given side length"
    },
    {
        "py": "def polyapothem ( n , a ) : NEW_LINE",
        "explain": "Function to find the apothem of a regular polygon"
    },
    {
        "py": "if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Side and side length cannot be negative"
    },
    {
        "py": "return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE",
        "explain": "Degree converted to radians"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyapothem ( n , a ) ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import tan NEW_LINE",
        "explain": "Python 3 Program to find the area of a regular polygon with given side length"
    },
    {
        "py": "def polyarea ( n , a ) : NEW_LINE",
        "explain": "Function to find the area of a regular polygon"
    },
    {
        "py": "if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Side and side length cannot be negative"
    },
    {
        "py": "A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) NEW_LINE return A NEW_LINE",
        "explain": "Area degree converted to radians"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( polyarea ( n , a ) ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import sin NEW_LINE",
        "explain": "Python 3 implementation of the approach"
    },
    {
        "py": "def calculateSide ( n , r ) : NEW_LINE INDENT theta = 360 / n NEW_LINE theta_in_radians = theta * 3.14 / 180 NEW_LINE return 2 * r * sin ( theta_in_radians / 2 ) NEW_LINE DEDENT",
        "explain": "Function to calculate the side of the polygon circumscribed in a circle"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = 3 NEW_LINE",
        "explain": "Total sides of the polygon"
    },
    {
        "py": "r = 5 NEW_LINE print ( ' { 0 : . 5 } ' . format ( calculateSide ( n , r ) ) ) NEW_LINE",
        "explain": "Radius of the circumscribing circle"
    },
    {
        "py": "def cyl ( r , R , h ) : NEW_LINE",
        "explain": "Function to find the biggest right circular cylinder"
    },
    {
        "py": "if ( h < 0 and r < 0 and R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "radii and height cannot be negative"
    },
    {
        "py": "r1 = r NEW_LINE",
        "explain": "radius of right circular cylinder"
    },
    {
        "py": "h1 = h NEW_LINE",
        "explain": "height of right circular cylinder"
    },
    {
        "py": "V = 3.14 * pow ( r1 , 2 ) * h1 NEW_LINE return round ( V , 2 ) NEW_LINE",
        "explain": "volume of right circular cylinder"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT r , R , h = 7 , 11 , 6 NEW_LINE print ( cyl ( r , R , h ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Perimeter ( s , n ) : NEW_LINE INDENT perimeter = 1 NEW_LINE DEDENT",
        "explain": "Function to calculate the perimeter"
    },
    {
        "py": "perimeter = n * s NEW_LINE return perimeter NEW_LINE",
        "explain": "Calculate Perimeter"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "driver code"
    },
    {
        "py": "n = 5 NEW_LINE",
        "explain": "Get the number of sides"
    },
    {
        "py": "s = 2.5 NEW_LINE",
        "explain": "Get the length of side"
    },
    {
        "py": "peri = Perimeter ( s , n ) NEW_LINE print ( \" Perimeter \u2581 of \u2581 Regular \u2581 Polygon \u2581 with \" , n , \" sides \u2581 of \u2581 length \" , s , \" = \" , peri ) NEW_LINE",
        "explain": "find perimeter"
    },
    {
        "py": "def rhombusarea ( l , b ) : NEW_LINE",
        "explain": "Function to find the area of the biggest rhombus"
    },
    {
        "py": "if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "the length and breadth cannot be negative"
    },
    {
        "py": "return ( l * b ) / 2 NEW_LINE",
        "explain": "area of the rhombus"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 16 NEW_LINE b = 6 NEW_LINE print ( rhombusarea ( l , b ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT if ( x > x1 and x < x2 and y > y1 and y < y2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "function to find if given point lies inside a given rectangle or not ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "x1 , y1 , x2 , y2 = 0 , 0 , 10 , 8 NEW_LINE",
        "explain": "bottom - left and top - right corners of rectangle . use multiple assignment"
    },
    {
        "py": "x , y = 1 , 5 NEW_LINE",
        "explain": "given point"
    },
    {
        "py": "if FindPoint ( x1 , y1 , x2 , y2 , x , y ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "function call"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program to find the Perpendicular ( shortest ) distance between a point and a Plane in 3 D ."
    },
    {
        "py": "def shortest_distance ( x1 , y1 , z1 , a , b , c , d ) : NEW_LINE INDENT d = abs ( ( a * x1 + b * y1 + c * z1 + d ) ) NEW_LINE e = ( math . sqrt ( a * a + b * b + c * c ) ) NEW_LINE print ( \" Perpendicular \u2581 distance \u2581 is \" , d / e ) NEW_LINE DEDENT",
        "explain": "Function to find distance"
    },
    {
        "py": "x1 = 4 NEW_LINE y1 = - 4 NEW_LINE z1 = 3 NEW_LINE a = 2 NEW_LINE b = - 2 NEW_LINE c = 5 NEW_LINE d = 8 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "shortest_distance ( x1 , y1 , z1 , a , b , c , d ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def findVolume ( l , b , h ) : NEW_LINE",
        "explain": "function to find the Volume of triangular prism"
    },
    {
        "py": "return ( ( l * b * h ) / 2 ) NEW_LINE",
        "explain": "formula to find Volume"
    },
    {
        "py": "l = 18 NEW_LINE b = 12 NEW_LINE h = 9 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( \" Volume \u2581 of \u2581 triangular \u2581 prism : \u2581 \" , findVolume ( l , b , h ) ) NEW_LINE",
        "explain": "function calling"
    },
    {
        "py": "def isRectangle ( a , b , c , d ) : NEW_LINE",
        "explain": "Function to check if the given integers value make a rectangle"
    },
    {
        "py": "if ( a == b and d == c ) or ( a == c and b == d ) or ( a == d and b == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "check all sides of rectangle combinations"
    },
    {
        "py": "a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE print ( \" Yes \" if isRectangle ( a , b , c , d ) else \" No \" ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def midpoint ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( ( x1 + x2 ) // 2 , \" \u2581 , \u2581 \" , ( y1 + y2 ) // 2 ) NEW_LINE DEDENT",
        "explain": "Function to find the midpoint of a line"
    },
    {
        "py": "x1 , y1 , x2 , y2 = - 1 , 2 , 3 , - 6 NEW_LINE midpoint ( x1 , x2 , y1 , y2 ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 code to calculate length of an arc"
    },
    {
        "py": "def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( \" Angle \u2581 cannot \u2581 be \u2581 formed \" ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT",
        "explain": "function to calculate arc length"
    },
    {
        "py": "diameter = 25.0 NEW_LINE angle = 45.0 NEW_LINE arc_len = arcLength ( diameter , angle ) NEW_LINE print ( arc_len ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE def checkCollision ( a , b , c , x , y , radius ) : NEW_LINE",
        "explain": "python program to check if a line touches or intersects or outside a circle ."
    },
    {
        "py": "dist = ( ( abs ( a * x + b * y + c ) ) / math . sqrt ( a * a + b * b ) ) NEW_LINE",
        "explain": "Finding the distance of line from center ."
    },
    {
        "py": "if ( radius == dist ) : NEW_LINE INDENT print ( \" Touch \" ) NEW_LINE DEDENT elif ( radius > dist ) : NEW_LINE INDENT print ( \" Intersect \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) NEW_LINE DEDENT",
        "explain": "Checking if the distance is less than , greater than or equal to radius ."
    },
    {
        "py": "radius = 5 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE a = 3 NEW_LINE b = 4 NEW_LINE c = 25 NEW_LINE checkCollision ( a , b , c , x , y , radius ) NEW_LINE",
        "explain": "Driven Program"
    },
    {
        "py": "def lineFromPoints ( P , Q , a , b , c ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE return a , b , c NEW_LINE DEDENT",
        "explain": "Function to find the line given two points"
    },
    {
        "py": "def perpendicularBisectorFromLine ( P , Q , a , b , c ) : NEW_LINE INDENT mid_point = [ ( P [ 0 ] + Q [ 0 ] ) // 2 , ( P [ 1 ] + Q [ 1 ] ) // 2 ] NEW_LINE DEDENT",
        "explain": "Function which converts the input line to its perpendicular bisector . It also inputs the points whose mid - point lies on the bisector"
    },
    {
        "py": "c = - b * ( mid_point [ 0 ] ) + a * ( mid_point [ 1 ] ) NEW_LINE temp = a NEW_LINE a = - b NEW_LINE b = temp NEW_LINE return a , b , c NEW_LINE",
        "explain": "c = - bx + ay"
    },
    {
        "py": "def lineLineIntersection ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT determinant = a1 * b2 - a2 * b1 NEW_LINE if ( determinant == 0 ) : NEW_LINE DEDENT",
        "explain": "Returns the intersection point of two lines"
    },
    {
        "py": "return [ ( 10.0 ) ** 19 , ( 10.0 ) ** 19 ] NEW_LINE else : NEW_LINE x = ( b2 * c1 - b1 * c2 ) // determinant NEW_LINE y = ( a1 * c2 - a2 * c1 ) // determinant NEW_LINE return [ x , y ] NEW_LINE def findCircumCenter ( P , Q , R ) : NEW_LINE",
        "explain": "The lines are parallel . This is simplified by returning a pair of ( 10.0 ) * * 19"
    },
    {
        "py": "a , b , c = 0.0 , 0.0 , 0.0 NEW_LINE a , b , c = lineFromPoints ( P , Q , a , b , c ) NEW_LINE",
        "explain": "Line PQ is represented as ax + by = c"
    },
    {
        "py": "e , f , g = 0.0 , 0.0 , 0.0 NEW_LINE e , f , g = lineFromPoints ( Q , R , e , f , g ) NEW_LINE",
        "explain": "Line QR is represented as ex + fy = g"
    },
    {
        "py": "a , b , c = perpendicularBisectorFromLine ( P , Q , a , b , c ) NEW_LINE e , f , g = perpendicularBisectorFromLine ( Q , R , e , f , g ) NEW_LINE",
        "explain": "Converting lines PQ and QR to perpendicular vbisectors . After this , L = ax + by = c M = ex + fy = g"
    },
    {
        "py": "circumcenter = lineLineIntersection ( a , b , c , e , f , g ) NEW_LINE if ( circumcenter [ 0 ] == ( 10.0 ) ** 19 and circumcenter [ 1 ] == ( 10.0 ) ** 19 ) : NEW_LINE INDENT print ( \" The \u2581 two \u2581 perpendicular \u2581 bisectors \u2581 found \u2581 come \u2581 parallel \" ) NEW_LINE print ( \" Thus , \u2581 the \u2581 given \u2581 points \u2581 do \u2581 not \u2581 form \u2581 a \u2581 triangle \u2581 and \u2581 are \u2581 collinear \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" The \u2581 circumcenter \u2581 of \u2581 the \u2581 triangle \u2581 PQR \u2581 is : \u2581 \" , end = \" \" ) NEW_LINE print ( \" ( \" , circumcenter [ 0 ] , \" , \" , circumcenter [ 1 ] , \" ) \" ) NEW_LINE DEDENT",
        "explain": "The point of intersection of L and M gives the circumcenter"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ 6 , 0 ] NEW_LINE Q = [ 0 , 0 ] NEW_LINE R = [ 0 , 8 ] NEW_LINE findCircumCenter ( P , Q , R ) NEW_LINE DEDENT",
        "explain": "Driver code ."
    },
    {
        "py": "def polygonArea ( X , Y , n ) : NEW_LINE",
        "explain": "( X [ i ] , Y [ i ] ) are coordinates of i 'th point."
    },
    {
        "py": "area = 0.0 NEW_LINE",
        "explain": "Initialize area"
    },
    {
        "py": "j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area = area + ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT",
        "explain": "Calculate value of shoelace formula"
    },
    {
        "py": "return abs ( area // 2.0 ) NEW_LINE",
        "explain": "Return absolute value"
    },
    {
        "py": "X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def chk ( v ) : NEW_LINE",
        "explain": "Function top get LSB value of v"
    },
    {
        "py": "v = list ( bin ( v ) [ 2 : ] ) NEW_LINE v . reverse ( ) NEW_LINE if ( '1' in v ) : NEW_LINE INDENT v = v . index ( '1' ) NEW_LINE return ( 2 ** v ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Binary conversion"
    },
    {
        "py": "def sumOfLSB ( arr , N ) : NEW_LINE",
        "explain": "Function to find the sum of LSBs of all possible pairs of the given array"
    },
    {
        "py": "lsb_arr = [ ] NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "Stores the LSB of array elements"
    },
    {
        "py": "lsb_arr . append ( chk ( arr [ i ] ) ) NEW_LINE",
        "explain": "Storing the LSB values"
    },
    {
        "py": "lsb_arr . sort ( reverse = True ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N - 1 , 2 ) : NEW_LINE",
        "explain": "Sort the array lab_arr [ ]"
    },
    {
        "py": "ans += ( lsb_arr [ i + 1 ] ) NEW_LINE",
        "explain": "Taking pairwise sum to get the maximum sum of LSB"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "N = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "sumOfLSB ( arr , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def countSubsequences ( arr ) : NEW_LINE",
        "explain": "Function to find count of subsequences having odd bitwise AND value"
    },
    {
        "py": "odd = 0 NEW_LINE",
        "explain": "Stores count of odd elements"
    },
    {
        "py": "for x in arr : NEW_LINE",
        "explain": "Traverse the array arr [ ]"
    },
    {
        "py": "if ( x & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT",
        "explain": "If x is odd increment count"
    },
    {
        "py": "return ( 1 << odd ) - 1 NEW_LINE",
        "explain": "Return Answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 1 , 3 , 3 ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( countSubsequences ( arr ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def getPairsCount ( arr , n ) : NEW_LINE",
        "explain": "Function to find the number of pairs ( i , j ) such that abs ( a [ i ] - a [ j ] ) is at least the minimum of ( a [ i ] , a [ j ] )"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the resultant count of pairs"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , n ]"
    },
    {
        "py": "for j in range ( arr [ i ] - ( i % arr [ i ] ) , n , arr [ i ] ) : NEW_LINE",
        "explain": "Iterate from arr [ i ] - ( i % arr [ i ] ) till n with an increment of arr [ i ]"
    },
    {
        "py": "if ( i < j and abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "Count the possible pairs"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the total count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getPairsCount ( arr , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def check ( N ) : NEW_LINE INDENT twos = 0 NEW_LINE fives = 0 NEW_LINE DEDENT",
        "explain": "Function to check if N can be changed to 1 or not ."
    },
    {
        "py": "while ( N % 2 == 0 ) : NEW_LINE INDENT N /= 2 NEW_LINE twos += 1 NEW_LINE DEDENT",
        "explain": "Count the number of 2 in the prime factorisation of N"
    },
    {
        "py": "while ( N % 5 == 0 ) : NEW_LINE INDENT N /= 5 NEW_LINE fives += 1 NEW_LINE DEDENT if ( N == 1 and twos <= fives ) : NEW_LINE INDENT print ( 2 * fives - twos ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT",
        "explain": "Count the number of 5 in the prime factorisation of N"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 50 NEW_LINE check ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def rangeSum ( arr , N , L , R ) : NEW_LINE",
        "explain": "Function to find the sum of elements in a given range of an infinite array"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Stores the sum of array elements from L to R"
    },
    {
        "py": "for i in range ( L - 1 , R , 1 ) : NEW_LINE INDENT sum += arr [ i % N ] NEW_LINE DEDENT",
        "explain": "Traverse from L to R"
    },
    {
        "py": "print ( sum ) NEW_LINE",
        "explain": "Print the resultant sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 6 , 9 ] NEW_LINE L = 10 NEW_LINE R = 13 NEW_LINE N = len ( arr ) NEW_LINE rangeSum ( arr , N , L , R ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def rangeSum ( arr , N , L , R ) : NEW_LINE",
        "explain": "Function to find the sum of elements in a given range of an infinite array"
    },
    {
        "py": "prefix = [ 0 for i in range ( N + 1 ) ] NEW_LINE prefix [ 0 ] = 0 NEW_LINE",
        "explain": "Stores the prefix sum"
    },
    {
        "py": "for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] NEW_LINE DEDENT",
        "explain": "Calculate the prefix sum"
    },
    {
        "py": "leftsum = ( ( L - 1 ) // N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] NEW_LINE",
        "explain": "Stores the sum of elements from 1 to L - 1"
    },
    {
        "py": "rightsum = ( R // N ) * prefix [ N ] + prefix [ R % N ] NEW_LINE",
        "explain": "Stores the sum of elements from 1 to R"
    },
    {
        "py": "print ( rightsum - leftsum ) NEW_LINE",
        "explain": "Print the resultant sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 6 , 9 ] NEW_LINE L = 10 NEW_LINE R = 13 NEW_LINE N = len ( arr ) NEW_LINE rangeSum ( arr , N , L , R ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def ExpoFactorial ( N ) : NEW_LINE",
        "explain": "Function to find exponential factorial of a given number"
    },
    {
        "py": "res = 1 NEW_LINE mod = ( int ) ( 1000000007 ) NEW_LINE",
        "explain": "Stores the exponetial factor of N"
    },
    {
        "py": "for i in range ( 2 , N + 1 ) : NEW_LINE",
        "explain": "Iterare over the range [ 2 , N ]"
    },
    {
        "py": "res = pow ( i , res , mod ) NEW_LINE",
        "explain": "Update res"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return res"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Input"
    },
    {
        "py": "print ( ExpoFactorial ( N ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def maxSubArraySumRepeated ( arr , N , K ) : NEW_LINE",
        "explain": "Function to find contiguous subarray with maximum sum if array is repeated K times"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Store the sum of the array arr [ ]"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT curr = arr [ 0 ] NEW_LINE",
        "explain": "Traverse the array and find sum"
    },
    {
        "py": "ans = arr [ 0 ] NEW_LINE",
        "explain": "Store the answer"
    },
    {
        "py": "if ( K == 1 ) : NEW_LINE",
        "explain": "If K = 1"
    },
    {
        "py": "for i in range ( 1 , N , 1 ) : NEW_LINE INDENT curr = max ( arr [ i ] , curr + arr [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT",
        "explain": "Apply Kadane algorithm to find sum"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "V = [ ] NEW_LINE",
        "explain": "Stores the twice repeated array"
    },
    {
        "py": "for i in range ( 2 * N ) : NEW_LINE INDENT V . append ( arr [ i % N ] ) NEW_LINE DEDENT",
        "explain": "Traverse the range [ 0 , 2 * N ]"
    },
    {
        "py": "maxSuf = V [ 0 ] NEW_LINE",
        "explain": "Stores the maximum suffix sum"
    },
    {
        "py": "maxPref = V [ 2 * N - 1 ] NEW_LINE curr = V [ 0 ] NEW_LINE for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxPref = max ( maxPref , curr ) NEW_LINE DEDENT curr = V [ 2 * N - 1 ] NEW_LINE i = 2 * N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT curr += V [ i ] NEW_LINE maxSuf = max ( maxSuf , curr ) NEW_LINE i -= 1 NEW_LINE DEDENT curr = V [ 0 ] NEW_LINE",
        "explain": "Stores the maximum prefix sum"
    },
    {
        "py": "for i in range ( 1 , 2 * N , 1 ) : NEW_LINE INDENT curr = max ( V [ i ] , curr + V [ i ] ) NEW_LINE ans = max ( ans , curr ) NEW_LINE DEDENT",
        "explain": "Apply Kadane algorithm for 2 repetition of the array"
    },
    {
        "py": "if ( sum > 0 ) : NEW_LINE INDENT temp = sum * ( K - 2 ) NEW_LINE ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) NEW_LINE DEDENT",
        "explain": "If the sum of the array is greater than 0"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 10 , 20 , - 30 , - 1 , 40 ] NEW_LINE N = len ( arr ) NEW_LINE K = 10 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( maxSubArraySumRepeated ( arr , N , K ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def countSubarray ( arr , n ) : NEW_LINE",
        "explain": "Function to find count of subarrays which have max element greater than twice maximum of all other elements"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the count of subarrays"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n , 1 ) : NEW_LINE DEDENT",
        "explain": "Generate all possible subarrays"
    },
    {
        "py": "mxSubarray = 0 NEW_LINE",
        "explain": "Stores the maximum element of the subarray"
    },
    {
        "py": "mxOther = 0 NEW_LINE",
        "explain": "Stores the maximum of all other elements"
    },
    {
        "py": "for k in range ( i , j + 1 , 1 ) : NEW_LINE INDENT mxSubarray = max ( mxSubarray , arr [ k ] ) NEW_LINE DEDENT",
        "explain": "Find the maximum element in the subarray [ i , j ]"
    },
    {
        "py": "for k in range ( 0 , i , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT mxOther = max ( mxOther , arr [ k ] ) NEW_LINE DEDENT",
        "explain": "Find the maximum of all other elements"
    },
    {
        "py": "if ( mxSubarray > ( 2 * mxOther ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT",
        "explain": "If the maximum of subarray is greater than twice the maximum of other elements"
    },
    {
        "py": "print ( count ) NEW_LINE",
        "explain": "Print the maximum value obtained"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countSubarray ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countSubarray ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE L = 0 NEW_LINE R = 0 NEW_LINE DEDENT",
        "explain": "Function to find count of subarrays which have max element greater than twice maximum of all other elements"
    },
    {
        "py": "mx = max ( arr ) NEW_LINE",
        "explain": "Stores the maximum element of the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the given array"
    },
    {
        "py": "if ( arr [ i ] * 2 > mx ) : NEW_LINE",
        "explain": "If the value of 2 * arr [ i ] is greater than mx"
    },
    {
        "py": "L = i NEW_LINE break NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE",
        "explain": "Update the value of L and break out of loop"
    },
    {
        "py": "if ( arr [ i ] * 2 > mx ) : NEW_LINE",
        "explain": "If the value 2 * arr [ i ] is greater than mx"
    },
    {
        "py": "R = i NEW_LINE break NEW_LINE i -= 1 NEW_LINE",
        "explain": "Update the value of R and break out of loop"
    },
    {
        "py": "print ( ( L + 1 ) * ( n - R ) ) NEW_LINE",
        "explain": "Print the final answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 6 , 10 , 9 , 7 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE countSubarray ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def isPrime ( X ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( X ) ) + 1 , 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE DEDENT DEDENT",
        "explain": "Utility function to check for primality of a number X by checking whether X haACCs any factors other than 1 and itself ."
    },
    {
        "py": "return False NEW_LINE return True NEW_LINE",
        "explain": "Factor found"
    },
    {
        "py": "def printPrimes ( A , N ) : NEW_LINE",
        "explain": "Function to print primes just less than and just greater than of each element in an array"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "j = A [ i ] - 1 NEW_LINE while ( 1 ) : NEW_LINE",
        "explain": "Traverse for finding prime just less than A [ i ]"
    },
    {
        "py": "if ( isPrime ( j ) ) : NEW_LINE INDENT print ( j , end = \" \u2581 \" ) NEW_LINE break NEW_LINE DEDENT j -= 1 NEW_LINE",
        "explain": "Prime just less than A [ i ] found"
    },
    {
        "py": "j = A [ i ] + 1 NEW_LINE while ( 1 ) : NEW_LINE",
        "explain": "Traverse for finding prime just greater than A [ i ]"
    },
    {
        "py": "if ( isPrime ( j ) ) : NEW_LINE INDENT print ( j , end = \" \u2581 \" ) NEW_LINE break NEW_LINE DEDENT j += 1 NEW_LINE print ( \" \" , \u2581 end \u2581 = \u2581 \" \" ) NEW_LINE",
        "explain": "Prime just greater than A [ i ] found"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "A = [ 17 , 28 ] NEW_LINE N = len ( A ) NEW_LINE",
        "explain": "Input"
    },
    {
        "py": "printPrimes ( A , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def KthSmallest ( A , B , N , K ) : NEW_LINE INDENT M = 0 NEW_LINE DEDENT",
        "explain": "Function to find the Kth smallest element that contains A [ i ] exactly B [ i ] times"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT M = max ( A [ i ] , M ) NEW_LINE DEDENT",
        "explain": "Traverse the given array"
    },
    {
        "py": "freq = [ 0 ] * ( M + 1 ) NEW_LINE",
        "explain": "Stores the frequency of every elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT freq [ A [ i ] ] += B [ i ] NEW_LINE DEDENT",
        "explain": "Traverse the given array"
    },
    {
        "py": "sum = 0 NEW_LINE",
        "explain": "Initialize a variable to store the prefix sums"
    },
    {
        "py": "for i in range ( M + 1 ) : NEW_LINE",
        "explain": "Iterate over the range [ 0 , M ]"
    },
    {
        "py": "sum += freq [ i ] NEW_LINE",
        "explain": "Increment sum by freq [ i ]"
    },
    {
        "py": "if ( sum >= K ) : NEW_LINE",
        "explain": "If sum is greater than or equal to K"
    },
    {
        "py": "return i NEW_LINE",
        "explain": "Return the current element as answer"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "Return - 1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = [ 3 , 4 , 5 ] NEW_LINE B = [ 2 , 1 , 3 ] NEW_LINE N = len ( A ) NEW_LINE K = 4 NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "print ( KthSmallest ( A , B , N , K ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def findbitwiseOR ( a , n ) : NEW_LINE",
        "explain": "Function to find the Bitwise OR of Bitwise AND of all subarrays"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores the required result"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Generate all the subarrays"
    },
    {
        "py": "curr_sub_array = a [ i ] NEW_LINE",
        "explain": "Store the current element"
    },
    {
        "py": "res = res | curr_sub_array NEW_LINE for j in range ( i , n ) : NEW_LINE",
        "explain": "Find the Bitwise OR"
    },
    {
        "py": "curr_sub_array = curr_sub_array & a [ j ] NEW_LINE res = res | curr_sub_array NEW_LINE",
        "explain": "Update the result"
    },
    {
        "py": "print ( res ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE findbitwiseOR ( A , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findbitwiseOR ( a , n ) : NEW_LINE",
        "explain": "Function to find the Bitwise OR of Bitwise AND of all consecutive subsets of the array"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Stores the required result"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT res = res | a [ i ] NEW_LINE DEDENT",
        "explain": "Traverse the given array"
    },
    {
        "py": "print ( res ) NEW_LINE",
        "explain": "Print the result"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE findbitwiseOR ( A , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def check ( n ) : NEW_LINE",
        "explain": "Function to check if the sum of the digits of N is strictly greater than the product of the digits of N or not"
    },
    {
        "py": "sumOfDigit = 0 NEW_LINE prodOfDigit = 1 NEW_LINE while n > 0 : NEW_LINE",
        "explain": "Stores the sum and the product of the digits of N"
    },
    {
        "py": "rem = n % 10 NEW_LINE",
        "explain": "Stores the last digit if N"
    },
    {
        "py": "sumOfDigit += rem NEW_LINE",
        "explain": "Increment the value of sumOfDigits"
    },
    {
        "py": "prodOfDigit *= rem NEW_LINE",
        "explain": "Update the prodOfDigit"
    },
    {
        "py": "n = n // 10 NEW_LINE",
        "explain": "Divide N by 10"
    },
    {
        "py": "if sumOfDigit > prodOfDigit : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Print the result"
    },
    {
        "py": "N = 1234 NEW_LINE check ( N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def evenOddBitwiseXOR ( N ) : NEW_LINE INDENT print ( \" Even : \u2581 \" , 0 , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print all distinct even & odd prefix Bitwise XORs from 1 to N"
    },
    {
        "py": "for i in range ( 4 , N + 1 , 4 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE print ( \" Odd : \u2581 \" , 1 , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print the even number"
    },
    {
        "py": "for i in range ( 4 , N + 1 , 4 ) : NEW_LINE INDENT print ( i - 1 , end = \" \u2581 \" ) NEW_LINE DEDENT if ( N % 4 == 2 ) : NEW_LINE INDENT print ( N + 1 ) NEW_LINE DEDENT elif ( N % 4 == 3 ) : NEW_LINE INDENT print ( N ) NEW_LINE DEDENT",
        "explain": "Print the odd number"
    },
    {
        "py": "N = 6 NEW_LINE evenOddBitwiseXOR ( N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def findPermutation ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE i = N - 2 NEW_LINE DEDENT",
        "explain": "Function to lexicographic largest permutation possible by a swap that is smaller than given array"
    },
    {
        "py": "while ( i >= 0 and arr [ i ] <= arr [ i + 1 ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT",
        "explain": "Find the index of first element such that arr [ i ] > arr [ i + 1 ]"
    },
    {
        "py": "if ( i == - 1 ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT j = N - 1 NEW_LINE",
        "explain": "If the array is sorted in increasing order"
    },
    {
        "py": "while ( j > i and arr [ j ] >= arr [ i ] ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT",
        "explain": "Find the index of first element which is smaller than arr [ i ]"
    },
    {
        "py": "while ( j > i and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE",
        "explain": "If arr [ j ] = = arr [ j - 1 ]"
    },
    {
        "py": "j -= 1 NEW_LINE",
        "explain": "Decrement j"
    },
    {
        "py": "temp = arr [ i ] ; NEW_LINE arr [ i ] = arr [ j ] ; NEW_LINE arr [ j ] = temp ; NEW_LINE",
        "explain": "Swap the element"
    },
    {
        "py": "for it in arr : NEW_LINE INDENT print ( it , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Pr the array arr [ ]"
    },
    {
        "py": "arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE findPermutation ( arr ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def sieveOfEratosthenes ( N , s ) : NEW_LINE",
        "explain": "Function to find the smallest prime factor of all the numbers using Sieve Of Eratosthenes"
    },
    {
        "py": "prime = [ False ] * ( N + 1 ) NEW_LINE",
        "explain": "Stores whether any number is prime or not"
    },
    {
        "py": "for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT",
        "explain": "Initialize smallest factor as 2 for all the even numbers"
    },
    {
        "py": "for i in range ( 3 , N , 2 ) : NEW_LINE",
        "explain": "Iterate over the range [ 3 , N ]"
    },
    {
        "py": "if ( prime [ i ] == False ) : NEW_LINE INDENT s [ i ] = i NEW_LINE DEDENT",
        "explain": "If i is prime"
    },
    {
        "py": "for j in range ( i , N , 2 ) : NEW_LINE INDENT if j * i > N : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT",
        "explain": "Iterate all multiples of i"
    },
    {
        "py": "if ( not prime [ i * j ] ) : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT",
        "explain": "i is the smallest prime factor of i * j"
    },
    {
        "py": "def findDifference ( N ) : NEW_LINE",
        "explain": "Function to find the absolute difference between the count of odd and even factors of N"
    },
    {
        "py": "s = [ 0 ] * ( N + 1 ) NEW_LINE",
        "explain": "Stores the smallest prime factor of i"
    },
    {
        "py": "sieveOfEratosthenes ( N , s ) NEW_LINE",
        "explain": "Fill values in s [ ] using sieve of eratosthenes"
    },
    {
        "py": "total , odd , even = 1 , 1 , 0 NEW_LINE",
        "explain": "Stores the total number of factors and the total number of odd and even factors"
    },
    {
        "py": "curr = s [ N ] NEW_LINE",
        "explain": "Store the current prime factor of the number N"
    },
    {
        "py": "cnt = 1 NEW_LINE",
        "explain": "Store the power of current prime factor"
    },
    {
        "py": "while ( N > 1 ) : NEW_LINE INDENT N //= s [ N ] NEW_LINE DEDENT",
        "explain": "Loop while N is greater than 1"
    },
    {
        "py": "if ( curr == s [ N ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE continue NEW_LINE DEDENT",
        "explain": "If N also has smallest prime factor as curr , then increment cnt by 1"
    },
    {
        "py": "if ( curr == 2 ) : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE DEDENT",
        "explain": "Update only total number of factors if curr is 2"
    },
    {
        "py": "else : NEW_LINE INDENT total = total * ( cnt + 1 ) NEW_LINE odd = odd * ( cnt + 1 ) NEW_LINE DEDENT",
        "explain": "Update total number of factors and total number of odd factors"
    },
    {
        "py": "curr = s [ N ] NEW_LINE cnt = 1 NEW_LINE",
        "explain": "Update current prime factor as s [ N ] and count as 1"
    },
    {
        "py": "even = total - odd NEW_LINE",
        "explain": "Calculate the number of even factors"
    },
    {
        "py": "print ( abs ( even - odd ) ) NEW_LINE",
        "explain": "Print the difference"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE findDifference ( N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findMedian ( Mean , Mode ) : NEW_LINE",
        "explain": "Function to find the median of a group of data with given mean and mode"
    },
    {
        "py": "Median = ( 2 * Mean + Mode ) // 3 NEW_LINE",
        "explain": "Calculate the median"
    },
    {
        "py": "print ( Median ) NEW_LINE",
        "explain": "Print the median"
    },
    {
        "py": "Mode = 6 NEW_LINE Mean = 3 NEW_LINE findMedian ( Mean , Mode ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def vectorMagnitude ( x , y , z ) : NEW_LINE",
        "explain": "Function to calculate magnitude of a 3 dimensional vector"
    },
    {
        "py": "sum = x * x + y * y + z * z NEW_LINE",
        "explain": "Stores the sum of squares of coordinates of a vector"
    },
    {
        "py": "return sqrt ( sum ) NEW_LINE",
        "explain": "Return the magnitude"
    },
    {
        "py": "x = 1 NEW_LINE y = 2 NEW_LINE z = 3 NEW_LINE print ( vectorMagnitude ( x , y , z ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def multiplyByMersenne ( N , M ) : NEW_LINE",
        "explain": "Function to find prodcut of a Mersenne number with another number"
    },
    {
        "py": "x = int ( math . log2 ( M + 1 ) ) NEW_LINE",
        "explain": "Stores the power of 2 of integer M + 1"
    },
    {
        "py": "return ( ( N << x ) - N ) NEW_LINE",
        "explain": "Return the product"
    },
    {
        "py": "N = 4 NEW_LINE M = 15 NEW_LINE print ( multiplyByMersenne ( N , M ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "from math import sqrt , log2 , pow NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def perfectSquare ( num ) : NEW_LINE",
        "explain": "Function to find nearest perfect square of num"
    },
    {
        "py": "sr = int ( sqrt ( num ) ) NEW_LINE",
        "explain": "Calculate square root of num"
    },
    {
        "py": "a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE",
        "explain": "Calculate perfect square"
    },
    {
        "py": "if ( ( num - a ) < ( b - num ) ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT",
        "explain": "Find the nearest perfect square"
    },
    {
        "py": "def powerOfTwo ( num ) : NEW_LINE",
        "explain": "Function to find the power of 2 nearest to the number num"
    },
    {
        "py": "lg = int ( log2 ( num ) ) NEW_LINE",
        "explain": "Calculate log base 2 of num"
    },
    {
        "py": "p = int ( pow ( 2 , lg ) ) NEW_LINE return p NEW_LINE",
        "explain": "Highest power of 2 which is <= num"
    },
    {
        "py": "def uniqueElement ( arr , N ) : NEW_LINE INDENT ans = True NEW_LINE DEDENT",
        "explain": "Function to find the nearest perfect square and the nearest power of 2 of every array element whose occurrence is 1"
    },
    {
        "py": "freq = { } NEW_LINE",
        "explain": "Stores frequency of array elements"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] in freq ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the array and update frequency of current array element"
    },
    {
        "py": "res = [ ] NEW_LINE for key , value in freq . items ( ) : NEW_LINE",
        "explain": "Traverse the map freq"
    },
    {
        "py": "if ( value == 1 ) : NEW_LINE INDENT ans = False NEW_LINE DEDENT",
        "explain": "If the frequency is 1"
    },
    {
        "py": "ps = perfectSquare ( key ) NEW_LINE",
        "explain": "Find nearest perfect square"
    },
    {
        "py": "res . append ( powerOfTwo ( ps ) ) NEW_LINE res . sort ( reverse = False ) NEW_LINE for x in res : NEW_LINE print ( x , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print the nearest power of 2"
    },
    {
        "py": "if ( ans ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "If the any does not contain any non - repeating elements"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 11 , 4 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE uniqueElement ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def partitionArray ( a , n ) : NEW_LINE",
        "explain": "Function to partition the array into two non - empty subarrays which satisfies the given condition"
    },
    {
        "py": "INDENT Min = [ 0 ] * n NEW_LINE DEDENT",
        "explain": "Stores the suffix Min array"
    },
    {
        "py": "INDENT Mini = sys . maxsize NEW_LINE DEDENT",
        "explain": "Stores the Minimum of a suffix"
    },
    {
        "py": "INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE DEDENT",
        "explain": "Traverse the array in reverse"
    },
    {
        "py": "Mini = min ( Mini , a [ i ] ) NEW_LINE",
        "explain": "Update Minimum"
    },
    {
        "py": "Min [ i ] = Mini NEW_LINE",
        "explain": "Store the Minimum"
    },
    {
        "py": "INDENT Maxi = - sys . maxsize - 1 NEW_LINE DEDENT",
        "explain": "Stores the Maximum value of a prefix"
    },
    {
        "py": "INDENT ind = - 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE DEDENT",
        "explain": "Stores the index of the partition"
    },
    {
        "py": "Maxi = max ( Maxi , a [ i ] ) NEW_LINE",
        "explain": "Update Max"
    },
    {
        "py": "if ( Maxi < Min [ i + 1 ] ) : NEW_LINE",
        "explain": "If Max is less than Min [ i + 1 ]"
    },
    {
        "py": "ind = i NEW_LINE",
        "explain": "Store the index of partition"
    },
    {
        "py": "break NEW_LINE",
        "explain": "break"
    },
    {
        "py": "INDENT if ( ind != - 1 ) : NEW_LINE DEDENT",
        "explain": "If ind is not - 1"
    },
    {
        "py": "for i in range ( ind + 1 ) : NEW_LINE print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE print ( ) NEW_LINE",
        "explain": "Print first subarray"
    },
    {
        "py": "for i in range ( ind + 1 , n , 1 ) : NEW_LINE print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print second subarray"
    },
    {
        "py": "INDENT else : NEW_LINE INDENT print ( \" Impossible \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "arr = [ 5 , 3 , 2 , 7 , 9 ] NEW_LINE N = 5 NEW_LINE partitionArray ( arr , N ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE DEDENT",
        "explain": "Function to count all prime factors of a given number"
    },
    {
        "py": "while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "Count the number of 2 s that divides n"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) , 2 ) : NEW_LINE",
        "explain": "Since n is odd at this point , skip one element"
    },
    {
        "py": "while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE count += 1 NEW_LINE DEDENT",
        "explain": "While i divides n , count i and divide n"
    },
    {
        "py": "if ( n > 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return ( count ) NEW_LINE",
        "explain": "If n is a prime number greater than 2"
    },
    {
        "py": "def findSum ( n ) : NEW_LINE",
        "explain": "Function to find the sum of first n nearly prime numbers"
    },
    {
        "py": "sum = 0 NEW_LINE i = 1 NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE",
        "explain": "Store the required sum"
    },
    {
        "py": "if ( countPrimeFactors ( num ) == 2 ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT",
        "explain": "Add this number if it is satisfies the condition"
    },
    {
        "py": "i += 1 NEW_LINE num += 1 NEW_LINE return sum NEW_LINE",
        "explain": "Increment count of nearly prime numbers"
    },
    {
        "py": "def check ( n , k ) : NEW_LINE",
        "explain": "Function to check if N can be represented as sum of K different positive integers out of which at least K - 1 of them are nearly prime"
    },
    {
        "py": "s = findSum ( k - 1 ) NEW_LINE",
        "explain": "Store the sum of first K - 1 nearly prime numbers"
    },
    {
        "py": "if ( s >= n ) : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "If sum is great than or equal to n"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT",
        "explain": "Otherwise , prYes"
    },
    {
        "py": "n = 100 NEW_LINE k = 6 NEW_LINE check ( n , k ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE",
        "explain": "Function to calculate GCD of a and b using Euclidean Algorithm"
    },
    {
        "py": "while ( b > 0 ) : NEW_LINE INDENT rem = a % b NEW_LINE a = b NEW_LINE b = rem NEW_LINE DEDENT",
        "explain": "Iterate until b is non - zero"
    },
    {
        "py": "return a NEW_LINE",
        "explain": "Return the GCD"
    },
    {
        "py": "def countNumberOfWays ( n ) : NEW_LINE",
        "explain": "Function to count the number of ways N can be expressed as x ^ y"
    },
    {
        "py": "if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "g = 0 NEW_LINE power = 0 NEW_LINE",
        "explain": "Stores the gcd of powers"
    },
    {
        "py": "while ( n % 2 == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n //= 2 NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE",
        "explain": "Calculate the degree of 2 in N"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE DEDENT",
        "explain": "Calculate the degree of prime numbers in N"
    },
    {
        "py": "while ( n % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE n //= i NEW_LINE DEDENT g = gcd ( g , power ) NEW_LINE",
        "explain": "Calculate the degree of prime ' i ' in N"
    },
    {
        "py": "if ( n > 2 ) : NEW_LINE INDENT g = gcd ( g , 1 ) NEW_LINE DEDENT",
        "explain": "If N is a prime , g becomes 1."
    },
    {
        "py": "ways = 1 NEW_LINE",
        "explain": "Stores the number of ways to represent N as x ^ y"
    },
    {
        "py": "power = 0 NEW_LINE while ( g % 2 == 0 ) : NEW_LINE INDENT g //= 2 NEW_LINE power += 1 NEW_LINE DEDENT",
        "explain": "Find the number of Factors of g"
    },
    {
        "py": "ways *= ( power + 1 ) NEW_LINE",
        "explain": "Update the count of ways"
    },
    {
        "py": "for i in range ( 3 , int ( math . sqrt ( g ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE DEDENT",
        "explain": "Iterate to find rest of the prime numbers"
    },
    {
        "py": "while ( g % i == 0 ) : NEW_LINE INDENT power += 1 NEW_LINE g /= i NEW_LINE DEDENT",
        "explain": "Find the power of i"
    },
    {
        "py": "ways *= ( power + 1 ) NEW_LINE",
        "explain": "Update the count of ways"
    },
    {
        "py": "if ( g > 2 ) : NEW_LINE INDENT ways *= 2 NEW_LINE DEDENT",
        "explain": "If g is prime"
    },
    {
        "py": "return ways NEW_LINE",
        "explain": "Return the total number of ways"
    },
    {
        "py": "N = 64 NEW_LINE print ( countNumberOfWays ( N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "from math import floor , ceil , log2 NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def powOfPositive ( n ) : NEW_LINE",
        "explain": "Function to return the lowest power of 2 close to given positive number"
    },
    {
        "py": "pos = floor ( log2 ( n ) ) ; NEW_LINE return 2 ** pos ; NEW_LINE",
        "explain": "Floor function is used to determine the value close to the number"
    },
    {
        "py": "def powOfNegative ( n ) : NEW_LINE",
        "explain": "Function to return the lowest power of 2 close to given negative number"
    },
    {
        "py": "pos = ceil ( log2 ( n ) ) ; NEW_LINE return ( - 1 * pow ( 2 , pos ) ) ; NEW_LINE",
        "explain": "Ceil function is used for negative numbers as - 1 > - 4. It would be opposite to positive numbers where 1 < 4"
    },
    {
        "py": "def highestPowerOf2 ( n ) : NEW_LINE",
        "explain": "Function to find the highest power of 2"
    },
    {
        "py": "if ( n > 0 ) : NEW_LINE INDENT print ( powOfPositive ( n ) ) ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "To check if the given number is positive or negative"
    },
    {
        "py": "n = - n ; NEW_LINE print ( powOfNegative ( n ) ) ; NEW_LINE",
        "explain": "If the number is negative , then the ceil of the positive number is calculated and negative sign is added"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = - 24 ; NEW_LINE highestPowerOf2 ( n ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def noOfCards ( n ) : NEW_LINE INDENT return n * ( 3 * n + 1 ) // 2 NEW_LINE DEDENT",
        "explain": "Function to find number of cards needed"
    },
    {
        "py": "n = 3 NEW_LINE print ( noOfCards ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def smallestPoss ( s , n ) : NEW_LINE",
        "explain": "Function for finding the smallest possible number after swapping the digits any number of times"
    },
    {
        "py": "ans = \" \" ; NEW_LINE",
        "explain": "Variable to store the final answer"
    },
    {
        "py": "arr = [ 0 ] * 10 ; NEW_LINE",
        "explain": "Array to store the count of occurrence of each digit"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT arr [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT",
        "explain": "Loop to calculate the number of occurrences of every digit"
    },
    {
        "py": "for i in range ( 10 ) : NEW_LINE INDENT for j in range ( arr [ i ] ) : NEW_LINE INDENT ans = ans + str ( i ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Loop to get smallest number"
    },
    {
        "py": "return ans ; NEW_LINE",
        "explain": "Returning the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 ; NEW_LINE K = \"325343273113434\" ; NEW_LINE print ( smallestPoss ( K , N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Count_subarray ( arr , n ) : NEW_LINE INDENT subarray_sum , remaining_sum , count = 0 , 0 , 0 ; NEW_LINE DEDENT",
        "explain": "Function to count the number of sub - arrays with sum strictly greater than the remaining elements of array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "For loop for beginning point of a subarray"
    },
    {
        "py": "for j in range ( i , n ) : NEW_LINE",
        "explain": "For loop for ending point of the subarray"
    },
    {
        "py": "subarray_sum = 0 ; NEW_LINE remaining_sum = 0 ; NEW_LINE",
        "explain": "Initialise subarray_sum and remaining_sum to 0"
    },
    {
        "py": "for k in range ( i , j + 1 ) : NEW_LINE INDENT subarray_sum += arr [ k ] ; NEW_LINE DEDENT",
        "explain": "For loop to calculate the sum of generated subarray"
    },
    {
        "py": "for l in range ( i ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT for l in range ( j + 1 , n ) : NEW_LINE INDENT remaining_sum += arr [ l ] ; NEW_LINE DEDENT",
        "explain": "For loop to calculate the sum remaining array element"
    },
    {
        "py": "if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE",
        "explain": "Checking for condition when subarray sum is strictly greater than remaining sum of array element"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 ; NEW_LINE count = 0 ; NEW_LINE DEDENT",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] ; NEW_LINE DEDENT",
        "explain": "Calculating total sum of given array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "For loop for beginning point of a subarray"
    },
    {
        "py": "subarray_sum = 0 ; NEW_LINE",
        "explain": "initialise subarray_sum to 0"
    },
    {
        "py": "for j in range ( i , n ) : NEW_LINE",
        "explain": "For loop for calculating subarray_sum and remaining_sum"
    },
    {
        "py": "subarray_sum += arr [ j ] ; NEW_LINE remaining_sum = total_sum - subarray_sum ; NEW_LINE",
        "explain": "Calculating subarray_sum and corresponding remaining_sum"
    },
    {
        "py": "if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE",
        "explain": "Checking for the condition when subarray sum is strictly greater than the remaining sum of the array element"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def maxXOR ( arr , n ) : NEW_LINE",
        "explain": "Function to return the maximized XOR after removing an element from the array"
    },
    {
        "py": "xorArr = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT xorArr ^= arr [ i ] NEW_LINE DEDENT",
        "explain": "Find XOR of the complete array"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "To store the final answer"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , ( xorArr ^ arr [ i ] ) ) NEW_LINE DEDENT",
        "explain": "Iterating through the array to find the final answer"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the final answer"
    },
    {
        "py": "arr = [ 1 , 1 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxXOR ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def digitDividesK ( num , k ) : NEW_LINE INDENT while ( num ) : NEW_LINE DEDENT",
        "explain": "Function that returns true if num contains at least one digit that divides k"
    },
    {
        "py": "d = num % 10 NEW_LINE",
        "explain": "Get the last digit"
    },
    {
        "py": "if ( d != 0 and k % d == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "If the digit is non - zero and it divides k"
    },
    {
        "py": "num = num // 10 NEW_LINE",
        "explain": "Remove the last digit"
    },
    {
        "py": "return False NEW_LINE",
        "explain": "There is no digit in num that divides k"
    },
    {
        "py": "def findCount ( l , r , k ) : NEW_LINE",
        "explain": "Function to return the required count of elements from the given range which contain at least one digit that divides k"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "To store the result"
    },
    {
        "py": "for i in range ( l , r + 1 ) : NEW_LINE",
        "explain": "For every number from the range"
    },
    {
        "py": "if ( digitDividesK ( i , k ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "If any digit of the current number divides k"
    },
    {
        "py": "l = 20 NEW_LINE r = 35 NEW_LINE k = 45 NEW_LINE print ( findCount ( l , r , k ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isFactorial ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n //= i ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if the given number is a factorial of any number"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 24 ; NEW_LINE ans = isFactorial ( n ) ; NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "from math import gcd NEW_LINE",
        "explain": "Python3 implementation of the above approach"
    },
    {
        "py": "def lcm ( a , b ) : NEW_LINE INDENT GCD = gcd ( a , b ) ; NEW_LINE return ( a * b ) // GCD ; NEW_LINE DEDENT",
        "explain": "Function to return the LCM of two numbers"
    },
    {
        "py": "def MinLCM ( a , n ) : NEW_LINE",
        "explain": "Function to return the minimum LCM after removing a single element from the given array"
    },
    {
        "py": "Prefix = [ 0 ] * ( n + 2 ) ; NEW_LINE Suffix = [ 0 ] * ( n + 2 ) ; NEW_LINE",
        "explain": "Prefix and Suffix arrays"
    },
    {
        "py": "Prefix [ 1 ] = a [ 0 ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; NEW_LINE DEDENT",
        "explain": "Single state dynamic programming relation for storing LCM of first i elements from the left in Prefix [ i ]"
    },
    {
        "py": "Suffix [ n ] = a [ n - 1 ] ; NEW_LINE",
        "explain": "Initializing Suffix array"
    },
    {
        "py": "for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; NEW_LINE DEDENT",
        "explain": "Single state dynamic programming relation for storing LCM of all the elements having index greater than or equal to i in Suffix [ i ]"
    },
    {
        "py": "ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; NEW_LINE",
        "explain": "If first or last element of the array has to be removed"
    },
    {
        "py": "for i in range ( 2 , n ) : NEW_LINE INDENT ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; NEW_LINE DEDENT",
        "explain": "If any other element is replaced"
    },
    {
        "py": "return ans ; NEW_LINE",
        "explain": "Return the minimum LCM"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 5 , 15 , 9 , 36 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( MinLCM ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def count ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) // 2 ; NEW_LINE DEDENT",
        "explain": "Function to return the count of coloured 0 s in an n - level hexagon"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 3 ; NEW_LINE print ( count ( n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def findMinValue ( arr , n ) : NEW_LINE",
        "explain": "Function to return the minimum required value"
    },
    {
        "py": "sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Find the sum of the array elements"
    },
    {
        "py": "return ( sum // n ) + 1 NEW_LINE",
        "explain": "Return the required value"
    },
    {
        "py": "arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MOD = 1000000007 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def modFact ( n , m ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT result = ( result * i ) % MOD NEW_LINE DEDENT return result NEW_LINE DEDENT",
        "explain": "Function to return ( m ! % MOD )"
    },
    {
        "py": "n = 3 NEW_LINE m = 2 NEW_LINE print ( modFact ( n , m ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "mod = 10 ** 9 + 7 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def power ( p ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , p + 1 ) : NEW_LINE INDENT res *= 2 NEW_LINE res %= mod NEW_LINE DEDENT return res % mod NEW_LINE DEDENT",
        "explain": "Function to return ( 2 ^ P % mod )"
    },
    {
        "py": "def subset_square_sum ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE DEDENT",
        "explain": "Function to return the sum of squares of subsets"
    },
    {
        "py": "for i in A : NEW_LINE INDENT ans += i * i % mod NEW_LINE ans %= mod NEW_LINE DEDENT return ans * power ( n - 1 ) % mod NEW_LINE",
        "explain": "Squaring the elements and adding it to ans"
    },
    {
        "py": "A = [ 3 , 7 ] NEW_LINE print ( subset_square_sum ( A ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "N = 100050 NEW_LINE lpf = [ 0 for i in range ( N ) ] NEW_LINE mobius = [ 0 for i in range ( N ) ] NEW_LINE",
        "explain": "Python3 program to find the number of pairs such that gcd equals to 1"
    },
    {
        "py": "def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE DEDENT",
        "explain": "Function to calculate least prime factor of each number"
    },
    {
        "py": "if ( lpf [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE DEDENT",
        "explain": "If it is a prime number"
    },
    {
        "py": "if ( lpf [ j ] == 0 ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT",
        "explain": "For all multiples which are not visited yet ."
    },
    {
        "py": "def Mobius ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE DEDENT",
        "explain": "Function to find the value of Mobius function for all the numbers from 1 to n"
    },
    {
        "py": "if ( i == 1 ) : NEW_LINE INDENT mobius [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If number is one"
    },
    {
        "py": "if ( lpf [ ( i // lpf [ i ] ) ] == lpf [ i ] ) : NEW_LINE INDENT mobius [ i ] = 0 NEW_LINE DEDENT",
        "explain": "If number has a squared prime factor"
    },
    {
        "py": "else : NEW_LINE INDENT mobius [ i ] = - 1 * mobius [ i // lpf [ i ] ] NEW_LINE DEDENT",
        "explain": "Multiply - 1 with the previous number"
    },
    {
        "py": "def gcd_pairs ( a , n ) : NEW_LINE",
        "explain": "Function to find the number of pairs such that gcd equals to 1"
    },
    {
        "py": "maxi = 0 NEW_LINE",
        "explain": "To store maximum number"
    },
    {
        "py": "fre = [ 0 for i in range ( N ) ] NEW_LINE",
        "explain": "To store frequency of each number"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT fre [ a [ i ] ] += 1 NEW_LINE maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT least_prime_factor ( ) NEW_LINE Mobius ( ) NEW_LINE",
        "explain": "Find frequency and maximum number"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "To store number of pairs with gcd equals to 1"
    },
    {
        "py": "for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if ( mobius [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT temp = 0 NEW_LINE for j in range ( i , maxi + 1 , i ) : NEW_LINE INDENT temp += fre [ j ] NEW_LINE DEDENT ans += temp * ( temp - 1 ) // 2 * mobius [ i ] NEW_LINE DEDENT",
        "explain": "Traverse through the all possible elements"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the number of pairs"
    },
    {
        "py": "a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( gcd_pairs ( a , n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "from math import log NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "def compareVal ( x , y ) : NEW_LINE",
        "explain": "Function to compare x ^ y and y ^ x"
    },
    {
        "py": "a = y * log ( x ) ; NEW_LINE b = x * log ( y ) ; NEW_LINE",
        "explain": "Storing values OF x ^ y AND y ^ x"
    },
    {
        "py": "if ( a > b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" > \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT elif ( a < b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" < \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT elif ( a == b ) : NEW_LINE INDENT print ( x , \" ^ \" , y , \" = \" , y , \" ^ \" , x ) ; NEW_LINE DEDENT",
        "explain": "Comparing values"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT x = 4 ; y = 5 ; NEW_LINE compareVal ( x , y ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def ZigZag ( n ) : NEW_LINE",
        "explain": "Function to prfirst n zigzag numbers"
    },
    {
        "py": "fact = [ 0 for i in range ( n + 1 ) ] NEW_LINE zig = [ 0 for i in range ( n + 1 ) ] NEW_LINE",
        "explain": "To store factorial and n 'th zig zag number"
    },
    {
        "py": "fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT",
        "explain": "Initialize factorial upto n"
    },
    {
        "py": "zig [ 0 ] = 1 NEW_LINE zig [ 1 ] = 1 NEW_LINE print ( \" zig \u2581 zag \u2581 numbers : \u2581 \" , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Set first two zig zag numbers"
    },
    {
        "py": "print ( zig [ 0 ] , zig [ 1 ] , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print first two zig zag number"
    },
    {
        "py": "for i in range ( 2 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , i ) : NEW_LINE DEDENT",
        "explain": "Print the rest zig zag numbers"
    },
    {
        "py": "sum += ( ( fact [ i - 1 ] // ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ) NEW_LINE",
        "explain": "Binomial ( n , k ) * a ( k ) * a ( n - k )"
    },
    {
        "py": "zig [ i ] = sum // 2 NEW_LINE",
        "explain": "Store the value"
    },
    {
        "py": "print ( sum // 2 , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print the number"
    },
    {
        "py": "n = 10 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "ZigZag ( n ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def find_count ( ele ) : NEW_LINE",
        "explain": "if the sequence is a ( 1 ) a ( 2 ) a ( 3 ) . . a ( n - 1 ) check if the sequence can be represented as x * ( y ^ k ) find the largest value of k"
    },
    {
        "py": "count = 0 NEW_LINE for i in range ( len ( ele ) ) : NEW_LINE",
        "explain": "count"
    },
    {
        "py": "p = [ ] NEW_LINE",
        "explain": "pattern of elements of size i from the end of sequence"
    },
    {
        "py": "c = 0 NEW_LINE j = len ( ele ) - 1 NEW_LINE",
        "explain": "count"
    },
    {
        "py": "while j >= ( len ( ele ) - 1 - i ) and j >= 0 : NEW_LINE INDENT p . append ( ele [ j ] ) NEW_LINE j -= 1 NEW_LINE DEDENT j = len ( ele ) - 1 NEW_LINE k = 0 NEW_LINE",
        "explain": "extract the pattern in a reverse order"
    },
    {
        "py": "while j >= 0 : NEW_LINE",
        "explain": "check how many times the pattern is repeated"
    },
    {
        "py": "if ele [ j ] != p [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE",
        "explain": "if the element dosent match"
    },
    {
        "py": "if k == len ( p ) : NEW_LINE INDENT c += 1 NEW_LINE k = 0 NEW_LINE DEDENT count = max ( count , c ) NEW_LINE",
        "explain": "if the end of pattern is reached set value of k = 0 and increase the count"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "return the max count"
    },
    {
        "py": "def solve ( n ) : NEW_LINE",
        "explain": "print first n terms of Gijswijt 's sequence"
    },
    {
        "py": "count = 1 NEW_LINE",
        "explain": "set the count"
    },
    {
        "py": "ele = [ ] NEW_LINE",
        "explain": "stoes the element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( count , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "print the first n terms of the sequence"
    },
    {
        "py": "ele . append ( count ) NEW_LINE",
        "explain": "push the element"
    },
    {
        "py": "count = find_count ( ele ) NEW_LINE",
        "explain": "find the count for next number"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 10 NEW_LINE solve ( n ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "store = dict ( ) NEW_LINE",
        "explain": "Stores the Wedderburn Etherington numbers"
    },
    {
        "py": "def Wedderburn ( n ) : NEW_LINE",
        "explain": "Function to return the nth Wedderburn Etherington numbers"
    },
    {
        "py": "if ( n <= 2 ) : NEW_LINE INDENT return store [ n ] NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "elif ( n % 2 == 0 ) : NEW_LINE",
        "explain": "If n is even n = 2 x"
    },
    {
        "py": "x = n // 2 NEW_LINE ans = 0 NEW_LINE",
        "explain": "get x"
    },
    {
        "py": "for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT",
        "explain": "a ( 2 x ) = a ( 1 ) a ( 2 x - 1 ) + a ( 2 ) a ( 2 x - 2 ) + ... + a ( x - 1 ) a ( x + 1 )"
    },
    {
        "py": "ans += ( store [ x ] * ( store [ x ] + 1 ) ) // 2 NEW_LINE",
        "explain": "a ( x ) ( a ( x ) + 1 ) / 2"
    },
    {
        "py": "store [ n ] = ans NEW_LINE",
        "explain": "Store the ans"
    },
    {
        "py": "return ans NEW_LINE else : NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "x = ( n + 1 ) // 2 NEW_LINE ans = 0 NEW_LINE",
        "explain": "If n is odd"
    },
    {
        "py": "for i in range ( 1 , x ) : NEW_LINE INDENT ans += store [ i ] * store [ n - i ] NEW_LINE DEDENT",
        "explain": "a ( 2 x - 1 ) = a ( 1 ) a ( 2 x - 2 ) + a ( 2 ) a ( 2 x - 3 ) + ... + a ( x - 1 ) a ( x ) ,"
    },
    {
        "py": "store [ n ] = ans NEW_LINE",
        "explain": "Store the ans"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the required answer"
    },
    {
        "py": "def Wedderburn_Etherington ( n ) : NEW_LINE",
        "explain": "Function to prfirst N Wedderburn Etherington numbers"
    },
    {
        "py": "store [ 0 ] = 0 NEW_LINE store [ 1 ] = 1 NEW_LINE store [ 2 ] = 1 NEW_LINE",
        "explain": "Store first 3 numbers"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT print ( Wedderburn ( i ) , end = \" \" ) NEW_LINE if ( i != n - 1 ) : NEW_LINE INDENT print ( end = \" , \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "PrN terms"
    },
    {
        "py": "n = 10 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "Wedderburn_Etherington ( n ) NEW_LINE",
        "explain": "function call"
    },
    {
        "py": "def Max_sum ( a , n ) : NEW_LINE",
        "explain": "Function to maximum value after merging all elements in the array"
    },
    {
        "py": "pos = 0 NEW_LINE neg = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "To check if positive and negative elements present or not"
    },
    {
        "py": "if ( a [ i ] > 0 ) : NEW_LINE INDENT pos = 1 NEW_LINE DEDENT",
        "explain": "Check for positive integer"
    },
    {
        "py": "elif ( a [ i ] < 0 ) : NEW_LINE INDENT neg = 1 NEW_LINE DEDENT",
        "explain": "Check for negative integer"
    },
    {
        "py": "if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT",
        "explain": "If both positive and negative elements are present"
    },
    {
        "py": "sum = 0 NEW_LINE if ( pos == 1 and neg == 1 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum += abs ( a [ i ] ) NEW_LINE DEDENT DEDENT elif ( pos == 1 ) : NEW_LINE",
        "explain": "To store maximum value possible"
    },
    {
        "py": "mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT",
        "explain": "To find minimum value"
    },
    {
        "py": "sum -= 2 * mini NEW_LINE elif ( neg == 1 ) : NEW_LINE",
        "explain": "Remove minimum element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT a [ i ] = abs ( a [ i ] ) NEW_LINE DEDENT",
        "explain": "Replace with absolute values"
    },
    {
        "py": "mini = a [ 0 ] NEW_LINE sum = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mini = min ( mini , a [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT",
        "explain": "To find minimum value"
    },
    {
        "py": "sum -= 2 * mini NEW_LINE",
        "explain": "Remove minimum element"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "Return the required sum"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 5 , - 2 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "print ( Max_sum ( a , n ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def decimalToBinary ( n ) : NEW_LINE",
        "explain": "Recursive function to convert n to its binary equivalent"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT print ( \"0\" , end = \" \" ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "decimalToBinary ( n // 2 ) ; NEW_LINE print ( n % 2 , end = \" \" ) ; NEW_LINE",
        "explain": "Recursive call"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13 ; NEW_LINE decimalToBinary ( n ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def MinimumValue ( x , y ) : NEW_LINE",
        "explain": "Function to find A , B and C"
    },
    {
        "py": "if ( x > y ) : NEW_LINE INDENT x , y = y , x NEW_LINE DEDENT",
        "explain": "Keep minimum number in x"
    },
    {
        "py": "a = 1 NEW_LINE b = x - 1 NEW_LINE c = y - b NEW_LINE print ( a , b , c ) NEW_LINE",
        "explain": "Find the numbers"
    },
    {
        "py": "x = 123 NEW_LINE y = 13 NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MinimumValue ( x , y ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def canConvert ( a , b ) : NEW_LINE INDENT while ( b > a ) : NEW_LINE DEDENT",
        "explain": "Function that returns true if A can be converted to B with the given operations"
    },
    {
        "py": "if ( b % 10 == 1 ) : NEW_LINE INDENT b //= 10 ; NEW_LINE continue ; NEW_LINE DEDENT",
        "explain": "If the current number ends with 1"
    },
    {
        "py": "if ( b % 2 == 0 ) : NEW_LINE INDENT b /= 2 ; NEW_LINE continue ; NEW_LINE DEDENT",
        "explain": "If the current number is divisible by 2"
    },
    {
        "py": "return false ; NEW_LINE",
        "explain": "If the above two conditions fail"
    },
    {
        "py": "if ( b == a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE",
        "explain": "If it is possible to convert A to B"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = 2 ; B = 82 ; NEW_LINE if ( canConvert ( A , B ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def count ( N ) : NEW_LINE INDENT a = 0 ; NEW_LINE a = ( N * ( N + 1 ) ) / 2 ; NEW_LINE return int ( a ) ; NEW_LINE DEDENT",
        "explain": "Function to return the count of distinct rectangles"
    },
    {
        "py": "N = 4 ; NEW_LINE print ( count ( N ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def numberOfDays ( a , b , n ) : NEW_LINE INDENT Days = b * ( n + a ) // ( a + b ) NEW_LINE return Days NEW_LINE DEDENT",
        "explain": "Function to return the number of days required"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 10 NEW_LINE b = 20 NEW_LINE n = 5 NEW_LINE print ( numberOfDays ( a , b , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def getAverage ( x , y ) : NEW_LINE",
        "explain": "Function to return the average of x and y using bit operations"
    },
    {
        "py": "avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; NEW_LINE return avg NEW_LINE",
        "explain": "Calculate the average Floor value of ( x + y ) / 2"
    },
    {
        "py": "x = 10 NEW_LINE y = 9 NEW_LINE print ( getAverage ( x , y ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def smallestIndex ( a , n ) : NEW_LINE",
        "explain": "Function to find the smallest index such that there are no 0 or 1 to its right"
    },
    {
        "py": "right1 = 0 NEW_LINE right0 = 0 NEW_LINE",
        "explain": "Initially"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse in the array"
    },
    {
        "py": "if ( a [ i ] == 1 ) : NEW_LINE INDENT right1 = i NEW_LINE DEDENT",
        "explain": "Check if array element is 1"
    },
    {
        "py": "else : NEW_LINE INDENT right0 = i NEW_LINE DEDENT",
        "explain": "a [ i ] = 0"
    },
    {
        "py": "return min ( right1 , right0 ) NEW_LINE",
        "explain": "Return minimum of both"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( smallestIndex ( a , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countSquares ( r , c , m ) : NEW_LINE",
        "explain": "Function to return the count of squares that can be visited by king in m moves"
    },
    {
        "py": "squares = 0 NEW_LINE",
        "explain": "To store the count of squares"
    },
    {
        "py": "for i in range ( 1 , 9 ) : NEW_LINE INDENT for j in range ( 1 , 9 ) : NEW_LINE DEDENT",
        "explain": "Check all squares of the chessboard"
    },
    {
        "py": "if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) : NEW_LINE INDENT squares = squares + 1 NEW_LINE DEDENT",
        "explain": "Check if square ( i , j ) is at a distance <= m units from king 's current position"
    },
    {
        "py": "return squares NEW_LINE",
        "explain": "Return count of squares"
    },
    {
        "py": "r = 4 NEW_LINE c = 4 NEW_LINE m = 1 NEW_LINE print ( countSquares ( r , c , m ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countQuadruples ( a , n ) : NEW_LINE",
        "explain": "Function to return the count of quadruples"
    },
    {
        "py": "mpp = dict . fromkeys ( a , 0 ) ; NEW_LINE",
        "explain": "Hash table to count the number of occurrences"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT mpp [ a [ i ] ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE",
        "explain": "Traverse and increment the count"
    },
    {
        "py": "for j in range ( n ) : NEW_LINE INDENT for k in range ( n ) : NEW_LINE DEDENT",
        "explain": "Run two nested loop for second and third element"
    },
    {
        "py": "if ( j == k ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT",
        "explain": "If they are same"
    },
    {
        "py": "mpp [ a [ j ] ] -= 1 ; NEW_LINE mpp [ a [ k ] ] -= 1 ; NEW_LINE",
        "explain": "Initially decrease the count"
    },
    {
        "py": "first = a [ j ] - ( a [ k ] - a [ j ] ) ; NEW_LINE if first not in mpp : NEW_LINE INDENT mpp [ first ] = 0 ; NEW_LINE DEDENT",
        "explain": "Find the first element using common difference"
    },
    {
        "py": "fourth = ( a [ k ] * a [ k ] ) // a [ j ] ; NEW_LINE if fourth not in mpp : NEW_LINE INDENT mpp [ fourth ] = 0 ; NEW_LINE DEDENT",
        "explain": "Find the fourth element using GP y ^ 2 = x * z property"
    },
    {
        "py": "if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) : NEW_LINE",
        "explain": "If it is an integer"
    },
    {
        "py": "if ( a [ j ] != a [ k ] ) : NEW_LINE INDENT count += mpp [ first ] * mpp [ fourth ] ; NEW_LINE DEDENT",
        "explain": "If not equal"
    },
    {
        "py": "else : NEW_LINE INDENT count += ( mpp [ first ] * ( mpp [ fourth ] - 1 ) ) ; NEW_LINE DEDENT",
        "explain": "Same elements"
    },
    {
        "py": "mpp [ a [ j ] ] += 1 ; NEW_LINE mpp [ a [ k ] ] += 1 ; NEW_LINE return count ; NEW_LINE",
        "explain": "Later increase the value for future calculations"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 2 , 6 , 4 , 9 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( countQuadruples ( a , n ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countNumbers ( L , R , K ) : NEW_LINE INDENT if ( K == 9 ) : NEW_LINE INDENT K = 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the count of required numbers"
    },
    {
        "py": "totalnumbers = R - L + 1 NEW_LINE",
        "explain": "Count of numbers present in given range"
    },
    {
        "py": "factor9 = totalnumbers // 9 NEW_LINE",
        "explain": "Number of groups of 9 elements starting from L"
    },
    {
        "py": "rem = totalnumbers % 9 NEW_LINE",
        "explain": "Left over elements not covered in factor 9"
    },
    {
        "py": "ans = factor9 NEW_LINE",
        "explain": "One Number in each group of 9"
    },
    {
        "py": "for i in range ( R , R - rem , - 1 ) : NEW_LINE INDENT rem1 = i % 9 NEW_LINE if ( rem1 == K ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE",
        "explain": "To check if any number in rem satisfy the property"
    },
    {
        "py": "L = 10 NEW_LINE R = 22 NEW_LINE K = 3 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def EvenSum ( A , index , value ) : NEW_LINE",
        "explain": "Function to return the sum of even elements after updating value at given index"
    },
    {
        "py": "A [ index ] = A [ index ] + value NEW_LINE",
        "explain": "Add given value to A [ index ]"
    },
    {
        "py": "sum = 0 NEW_LINE for i in A : NEW_LINE",
        "explain": "To store the sum of even elements"
    },
    {
        "py": "if ( i % 2 == 0 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE",
        "explain": "If current element is even"
    },
    {
        "py": "def BalanceArray ( A , Q ) : NEW_LINE",
        "explain": "Function to print result for every query"
    },
    {
        "py": "ANS = [ ] NEW_LINE i , sum = 0 , 0 NEW_LINE for i in range ( len ( Q ) ) : NEW_LINE INDENT index = Q [ i ] [ 0 ] NEW_LINE value = Q [ i ] [ 1 ] NEW_LINE DEDENT",
        "explain": "Resultant vector that stores the result for every query"
    },
    {
        "py": "sum = EvenSum ( A , index , value ) NEW_LINE",
        "explain": "Get sum of even elements after updating value at given index"
    },
    {
        "py": "ANS . append ( sum ) NEW_LINE",
        "explain": "Store sum for each query"
    },
    {
        "py": "for i in ANS : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the result for every query"
    },
    {
        "py": "A = [ 1 , 2 , 3 , 4 ] NEW_LINE Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] NEW_LINE BalanceArray ( A , Q ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def BalanceArray ( A , Q ) : NEW_LINE INDENT ANS = [ ] NEW_LINE sum = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE DEDENT",
        "explain": "Function to print the result for every query"
    },
    {
        "py": "if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ i ] ; NEW_LINE DEDENT for i in range ( len ( Q ) ) : NEW_LINE index = Q [ i ] [ 0 ] ; NEW_LINE value = Q [ i ] [ 1 ] ; NEW_LINE",
        "explain": "If current element is even"
    },
    {
        "py": "if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum -= A [ index ] ; NEW_LINE DEDENT A [ index ] += value ; NEW_LINE",
        "explain": "If element is even then remove it from sum"
    },
    {
        "py": "if ( A [ index ] % 2 == 0 ) : NEW_LINE INDENT sum += A [ index ] ; NEW_LINE DEDENT",
        "explain": "If the value becomes even after updating"
    },
    {
        "py": "ANS . append ( sum ) ; NEW_LINE",
        "explain": "Store sum for each query"
    },
    {
        "py": "for i in range ( len ( ANS ) ) : NEW_LINE INDENT print ( ANS [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Print the result for every query"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 ] ; NEW_LINE Q = [ [ 0 , 1 ] , [ 1 , - 3 ] , [ 0 , - 4 ] , [ 3 , 2 ] ] ; NEW_LINE BalanceArray ( A , Q ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "Python3 program for implementation of the above program"
    },
    {
        "py": "def Cycles ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE result = N - 1 NEW_LINE DEDENT",
        "explain": "Function that calculates number of Hamiltonian cycle"
    },
    {
        "py": "i = result NEW_LINE while ( i > 0 ) : NEW_LINE INDENT fact = fact * i NEW_LINE i -= 1 NEW_LINE DEDENT return fact // 2 NEW_LINE",
        "explain": "Calculating factorial"
    },
    {
        "py": "N = 5 NEW_LINE Number = Cycles ( N ) NEW_LINE print ( \" Hamiltonian \u2581 cycles \u2581 = \u2581 \" , Number ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def digitWell ( n , m , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == m ) : NEW_LINE INDENT cnt = cnt + 1 ; NEW_LINE DEDENT n = ( int ) ( n / 10 ) ; NEW_LINE DEDENT return cnt == k ; NEW_LINE DEDENT",
        "explain": "Function that returns true if n contains digit m exactly k times"
    },
    {
        "py": "def findInt ( n , m , k ) : NEW_LINE INDENT i = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( digitWell ( i , m , k ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the smallest integer > n with digit m occurring exactly k times"
    },
    {
        "py": "n = 111 ; m = 2 ; k = 2 ; NEW_LINE print ( findInt ( n , m , k ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countOdd ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count of odd numbers in the array"
    },
    {
        "py": "odd = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE",
        "explain": "Variable to count odd numbers"
    },
    {
        "py": "if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd = odd + 1 ; NEW_LINE DEDENT return odd ; NEW_LINE",
        "explain": "Odd number"
    },
    {
        "py": "def countValidPairs ( arr , n ) : NEW_LINE INDENT odd = countOdd ( arr , n ) ; NEW_LINE return ( odd * ( odd - 1 ) ) / 2 ; NEW_LINE DEDENT",
        "explain": "Function to return the count of valid pairs"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( int ( countValidPairs ( arr , n ) ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to return the gcd of two numbers"
    },
    {
        "py": "def lcmOfArray ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT lcm = arr [ 0 ] NEW_LINE DEDENT",
        "explain": "Function to return the lcm of all the elements of the array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) // gcd ( lcm , arr [ i ] ) ; NEW_LINE DEDENT",
        "explain": "To calculate lcm of two numbers multiply them and divide the result by gcd of both the numbers"
    },
    {
        "py": "return lcm NEW_LINE",
        "explain": "Return the LCM of the array elements"
    },
    {
        "py": "def minPerfectCube ( arr , n ) : NEW_LINE",
        "explain": "Function to return the smallest perfect cube divisible by all the elements of arr [ ]"
    },
    {
        "py": "lcm = lcmOfArray ( arr , n ) NEW_LINE minPerfectCube = lcm NEW_LINE cnt = 0 NEW_LINE while ( lcm > 1 and lcm % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= 2 NEW_LINE DEDENT",
        "explain": "LCM of all the elements of arr [ ]"
    },
    {
        "py": "if ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= 2 NEW_LINE DEDENT elif ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= 4 NEW_LINE DEDENT i = 3 NEW_LINE",
        "explain": "If 2 divides lcm cnt number of times"
    },
    {
        "py": "while ( lcm > 1 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( lcm % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE lcm //= i NEW_LINE DEDENT if ( cnt % 3 == 1 ) : NEW_LINE INDENT minPerfectCube *= i * i NEW_LINE DEDENT elif ( cnt % 3 == 2 ) : NEW_LINE INDENT minPerfectCube *= i NEW_LINE DEDENT i += 2 NEW_LINE DEDENT",
        "explain": "Check all the numbers that divide lcm"
    },
    {
        "py": "return minPerfectCube NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 10 , 125 , 14 , 42 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minPerfectCube ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python 3 program to check if given number is strong prime"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Utility function to check if a number is prime or not"
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "This is checked so that we can skip middle five numbers in below loop"
    },
    {
        "py": "def isStrongPrime ( n ) : NEW_LINE",
        "explain": "Function that returns true if n is a strong prime"
    },
    {
        "py": "if ( isPrime ( n ) == False or n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If n is not a prime number or n is the first prime then return false"
    },
    {
        "py": "previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE",
        "explain": "Initialize previous_prime to n - 1 and next_prime to n + 1"
    },
    {
        "py": "while ( isPrime ( next_prime ) == False ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT",
        "explain": "Find next prime number"
    },
    {
        "py": "while ( isPrime ( previous_prime ) == False ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT",
        "explain": "Find previous prime number"
    },
    {
        "py": "mean = ( previous_prime + next_prime ) / 2 NEW_LINE",
        "explain": "Arithmetic mean"
    },
    {
        "py": "if ( n > mean ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If n is a strong prime"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 11 NEW_LINE if ( isStrongPrime ( n ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def countDigitsToBeRemoved ( N , K ) : NEW_LINE",
        "explain": "function to return the required number of digits to be removed"
    },
    {
        "py": "s = str ( N ) ; NEW_LINE",
        "explain": "Converting the given number into string"
    },
    {
        "py": "res = 0 ; NEW_LINE",
        "explain": "variable to store number of digits to be removed"
    },
    {
        "py": "f_zero = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT if ( s [ i ] == '0' ) : NEW_LINE DEDENT",
        "explain": "variable to denote if atleast one zero has been found"
    },
    {
        "py": "f_zero = 1 ; NEW_LINE K -= 1 ; NEW_LINE else : NEW_LINE res += 1 ; NEW_LINE",
        "explain": "zero found"
    },
    {
        "py": "if ( K == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT elif ( f_zero > 0 ) : NEW_LINE INDENT return len ( s ) - 1 ; NEW_LINE DEDENT return - 1 ; NEW_LINE",
        "explain": "return size - 1 if K is not zero and atleast one zero is present , otherwise result"
    },
    {
        "py": "N = 10904025 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 1000 ; NEW_LINE K = 5 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE N = 23985 ; NEW_LINE K = 2 ; NEW_LINE print ( countDigitsToBeRemoved ( N , K ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python 3 program to find the sum of the given series"
    },
    {
        "py": "def getSum ( a , n ) : NEW_LINE",
        "explain": "Function to return the sum of the series"
    },
    {
        "py": "sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "variable to store the answer"
    },
    {
        "py": "sum += ( i / math . pow ( a , i ) ) ; NEW_LINE return sum ; NEW_LINE",
        "explain": "Math . pow ( x , y ) returns x ^ y"
    },
    {
        "py": "a = 3 ; n = 3 ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( getSum ( a , n ) ) ; NEW_LINE",
        "explain": "Print the sum of the series"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python Program to check Unusual number"
    },
    {
        "py": "def largestPrimeFactor ( n ) : NEW_LINE",
        "explain": "Utility function to find largest prime factor of a number"
    },
    {
        "py": "max = - 1 NEW_LINE",
        "explain": "Initialize the maximum prime factor variable with the lowest one"
    },
    {
        "py": "while n % 2 == 0 : NEW_LINE INDENT max = 2 ; NEW_LINE DEDENT",
        "explain": "Print the number of 2 s that divide n"
    },
    {
        "py": "for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT max = i ; NEW_LINE n = n / i ; NEW_LINE DEDENT DEDENT",
        "explain": "n must be odd at this point , thus skip the even numbers and iterate only for odd integers"
    },
    {
        "py": "if n > 2 : NEW_LINE INDENT max = n NEW_LINE DEDENT return max NEW_LINE",
        "explain": "This condition is to handle the case when n is a prime number greater than 2"
    },
    {
        "py": "def checkUnusual ( n ) : NEW_LINE",
        "explain": "Function to check Unusual number"
    },
    {
        "py": "factor = largestPrimeFactor ( n ) NEW_LINE",
        "explain": "Get the largest Prime Factor of the number"
    },
    {
        "py": "if factor > sqrt ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check if largest prime factor is greater than sqrt ( n )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 14 NEW_LINE if checkUnusual ( n ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def isHalfReducible ( arr , n , m ) : NEW_LINE INDENT frequencyHash = [ 0 ] * ( m + 1 ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT frequencyHash [ ( arr [ i ] % ( m + 1 ) ) ] += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT i = 0 ; NEW_LINE while ( i <= m ) : NEW_LINE INDENT if ( frequencyHash [ i ] >= ( n / 2 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( i <= m ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the desired result after computation"
    },
    {
        "py": "arr = [ 8 , 16 , 32 , 3 , 12 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE m = 7 ; NEW_LINE isHalfReducible ( arr , n , m ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ ] NEW_LINE",
        "explain": "Python3 program to check if the given number is Ore number"
    },
    {
        "py": "def generateDivisors ( n ) : NEW_LINE",
        "explain": "Function that returns harmonic mean"
    },
    {
        "py": "for i in range ( 1 , int ( n ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE DEDENT",
        "explain": "Note that this loop runs till square root"
    },
    {
        "py": "' NEW_LINE INDENT if n // i == i : NEW_LINE INDENT arr . append ( i ) NEW_LINE DEDENT DEDENT",
        "explain": "If divisors are equal , store 'i"
    },
    {
        "py": "else : NEW_LINE INDENT arr . append ( i ) NEW_LINE arr . append ( n // i ) NEW_LINE DEDENT",
        "explain": "Otherwise store ' i ' and ' n / i ' both"
    },
    {
        "py": "def harmonicMean ( n ) : NEW_LINE INDENT generateDivisors ( n ) NEW_LINE DEDENT",
        "explain": "Utility function to calculate harmonic mean of the divisors"
    },
    {
        "py": "Sum = 0 NEW_LINE length = len ( arr ) NEW_LINE",
        "explain": "Declare sum variables and initialize with zero ."
    },
    {
        "py": "for i in range ( 0 , length ) : NEW_LINE INDENT Sum = Sum + ( n / arr [ i ] ) NEW_LINE DEDENT Sum = Sum / n NEW_LINE",
        "explain": "calculate denominator"
    },
    {
        "py": "return length / Sum NEW_LINE",
        "explain": "Calculate harmonic mean and return"
    },
    {
        "py": "def isOreNumber ( n ) : NEW_LINE",
        "explain": "Function to check if a number is ore number"
    },
    {
        "py": "mean = harmonicMean ( n ) NEW_LINE",
        "explain": "Calculate Harmonic mean of divisors of n"
    },
    {
        "py": "if mean - int ( mean ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check if harmonic mean is an integer or not"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 28 NEW_LINE if isOreNumber ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "MAX = 10000 NEW_LINE s = set ( ) NEW_LINE",
        "explain": "Python3 program to check Euclid Number"
    },
    {
        "py": "def SieveOfEratosthenes ( ) : NEW_LINE",
        "explain": "Function to generate the Prime numbers and store their products"
    },
    {
        "py": "prime = [ True ] * ( MAX ) NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , 100 ) : NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true ."
    },
    {
        "py": "if prime [ p ] == True : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT",
        "explain": "Update all multiples of p"
    },
    {
        "py": "' NEW_LINE INDENT product = 1 NEW_LINE for p in range ( 2 , MAX ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE DEDENT DEDENT",
        "explain": "store prefix product of prime numbers to unordered_set 's"
    },
    {
        "py": "product = product * p NEW_LINE",
        "explain": "update product by multiplying next prime"
    },
    {
        "py": "s . add ( product + 1 ) NEW_LINE",
        "explain": "insert ' produc + 1' to set"
    },
    {
        "py": "def isEuclid ( n ) : NEW_LINE",
        "explain": "Function to check the number for Euclid Number"
    },
    {
        "py": "if n in s : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Check if number exist in unordered set or not If exist , return true"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "SieveOfEratosthenes ( ) NEW_LINE",
        "explain": "Get the prime numbers"
    },
    {
        "py": "n = 31 NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Check if n is Euclid Number"
    },
    {
        "py": "n = 42 NEW_LINE",
        "explain": "Get n"
    },
    {
        "py": "if isEuclid ( n ) == True : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Check if n is Euclid Number"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Utility function to check if a number is prime or not"
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE",
        "explain": "This is checked so that we can skip middle five numbers in below loop"
    },
    {
        "py": "def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT",
        "explain": "Utility function to Check power of two"
    },
    {
        "py": "n = 43 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "if ( isPrime ( n ) and isPowerOfTwo ( n * 3 - 1 ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Check if number is prime and of the form ( 2 ^ q + 1 ) / 3"
    },
    {
        "py": "from math import pow , sqrt NEW_LINE",
        "explain": "Python 3 Program to find the area of the square inscribed within the circle which in turn is inscribed in a hexagon"
    },
    {
        "py": "def area ( a ) : NEW_LINE",
        "explain": "Function to find the area of the square"
    },
    {
        "py": "if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "side of hexagon cannot be negative"
    },
    {
        "py": "area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) NEW_LINE return area NEW_LINE",
        "explain": "area of the square"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( \" { 0 : . 3 } \" . format ( area ( a ) ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) - 4 * n + 2 NEW_LINE DEDENT",
        "explain": "calculate Nth term of series"
    },
    {
        "py": "N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + pow ( ( n * ( n + 1 ) // 2 ) , 2 ) ) NEW_LINE DEDENT",
        "explain": "Function to calculate the sum"
    },
    {
        "py": "n = 3 NEW_LINE",
        "explain": "number of terms to be included in the sum"
    },
    {
        "py": "print ( \" Sum \u2581 = \u2581 \" , calculateSum ( n ) ) NEW_LINE",
        "explain": "find the Sum"
    },
    {
        "py": "def arePermutations ( a , b , n , m ) : NEW_LINE INDENT sum1 , sum2 , mul1 , mul2 = 0 , 0 , 1 , 1 NEW_LINE DEDENT",
        "explain": "Function to check if arrays are permutations of each other"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE mul1 *= a [ i ] NEW_LINE DEDENT",
        "explain": "Calculating sum and multiply of first array"
    },
    {
        "py": "for i in range ( m ) : NEW_LINE INDENT sum2 += b [ i ] NEW_LINE mul2 *= b [ i ] NEW_LINE DEDENT",
        "explain": "Calculating sum and multiply of second array"
    },
    {
        "py": "return ( ( sum1 == sum2 ) and ( mul1 == mul2 ) ) NEW_LINE",
        "explain": "If sum and mul of both arrays are equal , return true , else return false ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = [ 1 , 3 , 2 ] NEW_LINE b = [ 3 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if arePermutations ( a , b , n , m ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Race ( B , C ) : NEW_LINE INDENT result = 0 ; NEW_LINE DEDENT",
        "explain": "Function to find the B start to C"
    },
    {
        "py": "result = ( ( C * 100 ) // B ) NEW_LINE return 100 - result NEW_LINE",
        "explain": "When B completed it 's 100 meter  then Completed meters by C is"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT B = 10 NEW_LINE C = 28 NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "B = 100 - B ; NEW_LINE C = 100 - C ; NEW_LINE print ( str ( Race ( B , C ) ) + \" \u2581 meters \" ) NEW_LINE",
        "explain": "When A completed it 's 100 meter  Then completed meters of B and C is"
    },
    {
        "py": "def Time ( arr , n , Emptypipe ) : NEW_LINE INDENT fill = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT fill += ( 1 / arr [ i ] ) NEW_LINE DEDENT fill = fill - ( 1 / float ( Emptypipe ) ) NEW_LINE return int ( 1 / fill ) NEW_LINE DEDENT",
        "explain": "Function to calculate the time"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 14 ] NEW_LINE Emptypipe = 30 NEW_LINE n = len ( arr ) NEW_LINE print ( ( Time ( arr , n , Emptypipe ) ) , \" Hours \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def check ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE DEDENT",
        "explain": "Function to check Divisibility"
    },
    {
        "py": "while n != 0 : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT",
        "explain": "Sum of all individual digits"
    },
    {
        "py": "if sum % 7 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Condition"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = 25 NEW_LINE print ( ( \" YES \" ) if check ( n ) == 1 else print ( \" NO \" ) ) NEW_LINE",
        "explain": "Octal number"
    },
    {
        "py": "N = 1000005 NEW_LINE",
        "explain": "Python 3 program to find sum of prime divisors of N"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "Function to check if the number is prime or not ."
    },
    {
        "py": "if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE",
        "explain": "This is checked so that we can skip middle five numbers in below loop"
    },
    {
        "py": "def SumOfPrimeDivisors ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT",
        "explain": "function to find sum of prime divisors of N"
    },
    {
        "py": "n = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \u2581 divisors \u2581 of \u2581 60 \u2581 is \u2581 \" + str ( SumOfPrimeDivisors ( n ) ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def Sum ( N ) : NEW_LINE INDENT SumOfPrimeDivisors = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE DEDENT",
        "explain": "function to find prime divisors of all numbers from 1 to n"
    },
    {
        "py": "if ( SumOfPrimeDivisors [ i ] == 0 ) : NEW_LINE",
        "explain": "if the number is prime"
    },
    {
        "py": "for j in range ( i , N + 1 , i ) : NEW_LINE INDENT SumOfPrimeDivisors [ j ] += i NEW_LINE DEDENT return SumOfPrimeDivisors [ N ] NEW_LINE",
        "explain": "add this prime to all it 's multiples"
    },
    {
        "py": "N = 60 NEW_LINE print ( \" Sum \u2581 of \u2581 prime \" , \" divisors \u2581 of \u2581 60 \u2581 is \" , Sum ( N ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def power ( x , y , p ) : NEW_LINE",
        "explain": "Function to find power"
    },
    {
        "py": "x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE",
        "explain": "Update x if it is more than or equal to p"
    },
    {
        "py": "if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT",
        "explain": "If y is odd , multiply x with the result"
    },
    {
        "py": "x = ( x * x ) % p NEW_LINE return res NEW_LINE",
        "explain": "y must be even now y = y >> 1 y = y / 2"
    },
    {
        "py": "a = 3 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "b = \"100000000000000000000000000\" NEW_LINE remainderB = 0 NEW_LINE MOD = 1000000007 NEW_LINE",
        "explain": "String input as b is very large"
    },
    {
        "py": "for i in range ( len ( b ) ) : NEW_LINE INDENT remainderB = ( ( remainderB * 10 + ord ( b [ i ] ) - 48 ) % ( MOD - 1 ) ) NEW_LINE DEDENT print ( power ( a , remainderB , MOD ) ) NEW_LINE",
        "explain": "Reduce the number B to a small number using Fermat Little"
    },
    {
        "py": "def find_Square_369 ( num ) : NEW_LINE",
        "explain": "Function to find the square of 333. . .333 , 666. . .666 and 999. . .999"
    },
    {
        "py": "if ( num [ 0 ] == '3' ) : NEW_LINE INDENT a = '1' NEW_LINE b = '0' NEW_LINE c = '8' NEW_LINE d = '9' NEW_LINE DEDENT",
        "explain": "if the number is 333. . .333"
    },
    {
        "py": "elif ( num [ 0 ] == '6' ) : NEW_LINE INDENT a = '4' NEW_LINE b = '3' NEW_LINE c = '5' NEW_LINE d = '6' NEW_LINE DEDENT",
        "explain": "if the number is 666. . .666"
    },
    {
        "py": "else : NEW_LINE INDENT a = '9' NEW_LINE b = '8' NEW_LINE c = '0' NEW_LINE d = '1' NEW_LINE DEDENT",
        "explain": "if the number is 999. . .999"
    },
    {
        "py": "result = \" \" NEW_LINE",
        "explain": "variable for hold result"
    },
    {
        "py": "size = len ( num ) NEW_LINE",
        "explain": "find the no of digit"
    },
    {
        "py": "for i in range ( 1 , size ) : NEW_LINE INDENT result += a NEW_LINE DEDENT",
        "explain": "add size - 1 time a in result"
    },
    {
        "py": "result += b NEW_LINE",
        "explain": "add one time b in result"
    },
    {
        "py": "for i in range ( 1 , size ) : NEW_LINE INDENT result += c NEW_LINE DEDENT",
        "explain": "add size - 1 time c in result"
    },
    {
        "py": "result += d NEW_LINE",
        "explain": "add one time d in result"
    },
    {
        "py": "return result NEW_LINE",
        "explain": "return result"
    },
    {
        "py": "num_3 = \"3333\" NEW_LINE num_6 = \"6666\" NEW_LINE num_9 = \"9999\" NEW_LINE result = \" \" NEW_LINE",
        "explain": "Drivers code Your Python 3 Code"
    },
    {
        "py": "result = find_Square_369 ( num_3 ) NEW_LINE print ( \" Square \u2581 of \u2581 \" + num_3 + \" \u2581 is \u2581 : \u2581 \" + result ) ; NEW_LINE",
        "explain": "find square of 33. .33"
    },
    {
        "py": "result = find_Square_369 ( num_6 ) NEW_LINE print ( \" Square \u2581 of \u2581 \" + num_6 + \" \u2581 is \u2581 : \u2581 \" + result ) ; NEW_LINE",
        "explain": "find square of 66. .66"
    },
    {
        "py": "result = find_Square_369 ( num_9 ) NEW_LINE print ( \" Square \u2581 of \u2581 \" + num_9 + \" \u2581 is \u2581 : \u2581 \" + result ) ; NEW_LINE",
        "explain": "find square of 66. .66"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Python3 program to implement the above approach To run this code , we need to copy modular inverse from below post . https : www . geeksforgeeks . org / multiplicative - inverse - under - modulo - m /"
    },
    {
        "py": "naive_answer = ( ( ( 55555 * 55554 * 55553 * 55552 * 55551 ) // 120 ) % 1000000007 ) NEW_LINE ans = 1 NEW_LINE",
        "explain": "naive method - calculating the result in a single line"
    },
    {
        "py": "i = modular_inverse ( 120 , 10000007 ) NEW_LINE",
        "explain": "modular_inverse ( ) is a user defined function that calculates inverse of a number"
    },
    {
        "py": "for i in range ( 5 ) : NEW_LINE INDENT ans = ( ( ans * ( 55555 - i ) ) % 1000000007 ) NEW_LINE DEDENT ans = ( ans * i ) % 1000000007 NEW_LINE print ( \" Answer \u2581 using \u2581 naive \u2581 method : \" , naive_answer ) NEW_LINE print ( \" Answer \u2581 using \u2581 multiplicative \" + \" modular \u2581 inverse \u2581 concept : \" , ans ) NEW_LINE",
        "explain": "it will use extended Eucledian algorithm or Fermat 's Little  Theorem for calculation.  MMI of 120 under division by  1000000007 will be 808333339"
    },
    {
        "py": "def fact ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans * i ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT",
        "explain": "Function to find the required factorial"
    },
    {
        "py": "def nCr ( n , r ) : NEW_LINE INDENT Nr = n ; Dr = 1 ; ans = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans = int ( ( ans * Nr ) / ( Dr ) ) ; NEW_LINE Nr = Nr - 1 ; NEW_LINE Dr = Dr + 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT",
        "explain": "Function to find nCr"
    },
    {
        "py": "def solve ( n ) : NEW_LINE INDENT N = 2 * n - 2 ; NEW_LINE R = n - 1 ; NEW_LINE return ( nCr ( N , R ) * fact ( n - 1 ) ) ; NEW_LINE DEDENT",
        "explain": "function to find the number of ways"
    },
    {
        "py": "n = 6 ; NEW_LINE print ( solve ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def pythagoreanTriplet ( n ) : NEW_LINE",
        "explain": "Python3 program to find Pythagorean Triplet of given sum ."
    },
    {
        "py": "for i in range ( 1 , int ( n / 3 ) + 1 ) : NEW_LINE",
        "explain": "Considering triplets in sorted order . The value of first element in sorted triplet can be at - most n / 3."
    },
    {
        "py": "for j in range ( i + 1 , int ( n / 2 ) + 1 ) : NEW_LINE INDENT k = n - i - j NEW_LINE if ( i * i + j * j == k * k ) : NEW_LINE INDENT print ( i , \" , \u2581 \" , j , \" , \u2581 \" , k , sep = \" \" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( \" No \u2581 Triplet \" ) NEW_LINE",
        "explain": "The value of second element must be less than equal to n / 2"
    },
    {
        "py": "n = 12 NEW_LINE pythagoreanTriplet ( n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def factorial ( n ) : NEW_LINE INDENT f = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f *= i NEW_LINE DEDENT return f NEW_LINE DEDENT",
        "explain": "function to calculate factorial of a number"
    },
    {
        "py": "def series ( A , X , n ) : NEW_LINE",
        "explain": "Function to print the series"
    },
    {
        "py": "nFact = factorial ( n ) NEW_LINE",
        "explain": "calculating the value of n !"
    },
    {
        "py": "for i in range ( 0 , n + 1 ) : NEW_LINE",
        "explain": "loop to display the series"
    },
    {
        "py": "niFact = factorial ( n - i ) NEW_LINE iFact = factorial ( i ) NEW_LINE",
        "explain": "For calculating the value of nCr"
    },
    {
        "py": "aPow = pow ( A , n - i ) NEW_LINE xPow = pow ( X , i ) NEW_LINE",
        "explain": "calculating the value of A to the power k and X to the power k"
    },
    {
        "py": "print ( int ( ( nFact * aPow * xPow ) / ( niFact * iFact ) ) , end = \" \u2581 \" ) NEW_LINE",
        "explain": "display the series"
    },
    {
        "py": "A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def seiresSum ( n , a ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res += a [ i ] * a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT res -= a [ i ] * a [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT",
        "explain": "Function to calculate series sum"
    },
    {
        "py": "n = 2 NEW_LINE a = [ 1 , 2 , 3 , 4 ] NEW_LINE print ( seiresSum ( n , a ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def power ( n , r ) : NEW_LINE",
        "explain": "Function to return power of a no . ' r ' in factorial of n"
    },
    {
        "py": "count = 0 ; i = r NEW_LINE while ( ( n / i ) >= 1 ) : NEW_LINE INDENT count += n / i NEW_LINE i = i * r NEW_LINE DEDENT return int ( count ) NEW_LINE",
        "explain": "Keep dividing n by powers of ' r ' and update count"
    },
    {
        "py": "n = 6 ; r = 3 NEW_LINE print ( power ( n , r ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def avg_of_odd_num ( n ) : NEW_LINE",
        "explain": "Returns the Avg of first n odd numbers"
    },
    {
        "py": "sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 2 * i + 1 ) NEW_LINE DEDENT",
        "explain": "sum of first n odd number"
    },
    {
        "py": "return sm // n NEW_LINE",
        "explain": "Average of first n odd numbers"
    },
    {
        "py": "n = 20 NEW_LINE print ( avg_of_odd_num ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def avg_of_odd_num ( n ) : NEW_LINE INDENT return n NEW_LINE DEDENT",
        "explain": "Return the average of sum of first n odd numbers"
    },
    {
        "py": "n = 8 NEW_LINE print ( avg_of_odd_num ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def fib ( f , N ) : NEW_LINE",
        "explain": "function to fill Fibonacci Numbers in f [ ]"
    },
    {
        "py": "f [ 1 ] = 1 NEW_LINE f [ 2 ] = 1 NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE",
        "explain": "1 st and 2 nd number of the series are 1 and 1"
    },
    {
        "py": "f [ i ] = f [ i - 1 ] + f [ i - 2 ] NEW_LINE def fiboTriangle ( n ) : NEW_LINE",
        "explain": "Add the previous 2 numbers in the series and store it"
    },
    {
        "py": "N = n * ( n + 1 ) // 2 NEW_LINE f = [ 0 ] * ( N + 1 ) NEW_LINE fib ( f , N ) NEW_LINE",
        "explain": "Fill Fibonacci numbers in f [ ] using fib ( ) . We need N = n * ( n + 1 ) / 2 Fibonacci numbers to make a triangle of height n"
    },
    {
        "py": "fiboNum = 1 NEW_LINE",
        "explain": "To store next Fibonacci Number to print"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "for loop to keep track of number of lines"
    },
    {
        "py": "for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( f [ fiboNum ] , \" \u2581 \" , end = \" \" ) NEW_LINE fiboNum = fiboNum + 1 NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "For loop to keep track of numbers in each line"
    },
    {
        "py": "n = 5 NEW_LINE fiboTriangle ( n ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 1 ) : NEW_LINE DEDENT",
        "explain": "Function to calculate the average of odd numbers"
    },
    {
        "py": "count = count + 1 NEW_LINE",
        "explain": "count odd numbers"
    },
    {
        "py": "sm = sm + n NEW_LINE n = n - 2 NEW_LINE return sm // count NEW_LINE",
        "explain": "store the sum of odd numbers"
    },
    {
        "py": "n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE",
        "explain": "Driver function"
    },
    {
        "py": "def averageOdd ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 1 ) // 2 NEW_LINE DEDENT",
        "explain": "Function to calculate the average of odd numbers"
    },
    {
        "py": "n = 15 NEW_LINE print ( averageOdd ( n ) ) NEW_LINE",
        "explain": "driver function"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program to find max between two Rational numbers"
    },
    {
        "py": "def lcm ( a , b ) : NEW_LINE INDENT return ( a * b ) // ( math . gcd ( a , b ) ) NEW_LINE DEDENT",
        "explain": "Get lcm of two number 's"
    },
    {
        "py": "def maxRational ( first , sec ) : NEW_LINE",
        "explain": "Get max rational number"
    },
    {
        "py": "k = lcm ( first [ 1 ] , sec [ 1 ] ) NEW_LINE",
        "explain": "Find the LCM of first -> denominator and sec -> denominator"
    },
    {
        "py": "nume1 = first [ 0 ] NEW_LINE nume2 = sec [ 0 ] NEW_LINE nume1 *= k // ( first [ 1 ] ) NEW_LINE nume2 *= k // ( sec [ 1 ] ) NEW_LINE return first if ( nume2 < nume1 ) else sec NEW_LINE",
        "explain": "Declare nume1 and nume2 for get the value of first numerator and second numerator"
    },
    {
        "py": "first = [ 3 , 2 ] NEW_LINE sec = [ 3 , 4 ] NEW_LINE res = maxRational ( first , sec ) NEW_LINE print ( res [ 0 ] , \" / \" , res [ 1 ] , sep = \" \" ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def TrinomialValue ( n , k ) : NEW_LINE",
        "explain": "Function to find the trinomial triangle value ."
    },
    {
        "py": "if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "base cas"
    },
    {
        "py": "return ( TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ) NEW_LINE",
        "explain": "recursive step ."
    },
    {
        "py": "def printTrinomial ( n ) : NEW_LINE",
        "explain": "Function to print Trinomial Triangle of height n ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "printing n rows ."
    },
    {
        "py": "for j in range ( - i , 1 ) : NEW_LINE INDENT print ( TrinomialValue ( i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "printing first half of triangle"
    },
    {
        "py": "for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( TrinomialValue ( i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE",
        "explain": "printing second half of triangle ."
    },
    {
        "py": "n = 4 NEW_LINE printTrinomial ( n ) NEW_LINE",
        "explain": "Driven Code"
    },
    {
        "py": "def TrinomialValue ( dp , n , k ) : NEW_LINE",
        "explain": "Function to find the trinomial triangle value ."
    },
    {
        "py": "if k < 0 : NEW_LINE INDENT k = - k NEW_LINE DEDENT",
        "explain": "Using property of trinomial triangle ."
    },
    {
        "py": "if dp [ n ] [ k ] != 0 : NEW_LINE INDENT return dp [ n ] [ k ] NEW_LINE DEDENT",
        "explain": "If value already calculated , return that ."
    },
    {
        "py": "if n == 0 and k == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "if k < - n or k > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "return ( TrinomialValue ( dp , n - 1 , k - 1 ) + TrinomialValue ( dp , n - 1 , k ) + TrinomialValue ( dp , n - 1 , k + 1 ) ) NEW_LINE",
        "explain": "recursive step and storing the value ."
    },
    {
        "py": "def printTrinomial ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * 10 ] * 10 NEW_LINE DEDENT",
        "explain": "Function to print Trinomial Triangle of height n ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "printing n rows ."
    },
    {
        "py": "for j in range ( - i , 1 ) : NEW_LINE INDENT print ( TrinomialValue ( dp , i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "printing first half of triangle"
    },
    {
        "py": "for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( TrinomialValue ( dp , i , j ) , end = \" \u2581 \" ) NEW_LINE DEDENT print ( \" \" , end = ' ' ) NEW_LINE",
        "explain": "printing second half of triangle ."
    },
    {
        "py": "n = 4 NEW_LINE printTrinomial ( n ) NEW_LINE",
        "explain": "Driven Program"
    },
    {
        "py": "def sumOfLargePrimeFactor ( n ) : NEW_LINE",
        "explain": "function to find sum of largest prime factor of each number less than equal to n"
    },
    {
        "py": "prime = [ 0 ] * ( n + 1 ) NEW_LINE sum = 0 NEW_LINE max = int ( n / 2 ) NEW_LINE for p in range ( 2 , max + 1 ) : NEW_LINE",
        "explain": "Create an integer array \" prime [ 0 . . n ] \" and initialize all entries of it as 0. A value in prime [ i ] will finally be 0 if ' i ' is a prime , else it will contain the largest prime factor of ' i ' ."
    },
    {
        "py": "if prime [ p ] == 0 : NEW_LINE",
        "explain": "If prime [ p ] is '0' , then it is a prime number"
    },
    {
        "py": "for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = p NEW_LINE DEDENT",
        "explain": "Update all multiples of p"
    },
    {
        "py": "for p in range ( 2 , n + 1 ) : NEW_LINE",
        "explain": "Sum up the largest prime factor of all the numbers"
    },
    {
        "py": "if prime [ p ] : NEW_LINE INDENT sum += prime [ p ] NEW_LINE DEDENT",
        "explain": "if ' p ' is a non - prime number then prime [ p ] gives its largesr prime factor"
    },
    {
        "py": "else : NEW_LINE INDENT sum += p NEW_LINE DEDENT",
        "explain": "' p ' is a prime number"
    },
    {
        "py": "return sum NEW_LINE",
        "explain": "required sum"
    },
    {
        "py": "n = 12 NEW_LINE print ( \" Sum \u2581 = \" , sumOfLargePrimeFactor ( n ) ) NEW_LINE",
        "explain": "Driver code to test above function"
    },
    {
        "py": "def calculate_sum ( a , N ) : NEW_LINE",
        "explain": "Calculates sum of multiples of a number upto N"
    },
    {
        "py": "m = N / a NEW_LINE",
        "explain": "Number of multiples"
    },
    {
        "py": "sum = m * ( m + 1 ) / 2 NEW_LINE",
        "explain": "sum of first m natural numbers"
    },
    {
        "py": "ans = a * sum NEW_LINE print ( \" Sum \u2581 of \u2581 multiples \u2581 of \u2581 \" , a , \" \u2581 up \u2581 to \u2581 \" , N , \" \u2581 = \u2581 \" , ans ) NEW_LINE",
        "explain": "sum of multiples"
    },
    {
        "py": "calculate_sum ( 7 , 49 ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isPowerOf2 ( sttr ) : NEW_LINE INDENT len_str = len ( sttr ) ; NEW_LINE sttr = list ( sttr ) ; NEW_LINE DEDENT",
        "explain": "returns 1 when str is power of 2 return 0 when str is not a power of 2"
    },
    {
        "py": "num = 0 ; NEW_LINE",
        "explain": "sum stores the intermediate dividend while dividing ."
    },
    {
        "py": "if ( len_str == 1 and sttr [ len_str - 1 ] == '1' ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "if the input is \"1\" then return 0 because 2 ^ k = 1 where k >= 1 and here k = 0"
    },
    {
        "py": "while ( len_str != 1 or sttr [ len_str - 1 ] != '1' ) : NEW_LINE",
        "explain": "Divide the number until it gets reduced to 1 if we are successfully able to reduce the number to 1 it means input string is power of two if in between an odd number appears at the end it means string is not divisible by two hence not a power of 2."
    },
    {
        "py": "if ( ( ord ( sttr [ len_str - 1 ] ) - ord ( '0' ) ) % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "if the last digit is odd then string is not divisible by 2 hence not a power of two return 0."
    },
    {
        "py": "j = 0 ; NEW_LINE for i in range ( len_str ) : NEW_LINE INDENT num = num * 10 + ( ord ( sttr [ i ] ) - ord ( '0' ) ) ; NEW_LINE DEDENT",
        "explain": "divide the whole string by 2. i is used to track index in current number . j is used to track index for next iteration ."
    },
    {
        "py": "if ( num < 2 ) : NEW_LINE",
        "explain": "if num < 2 then we have to take another digit to the right of A [ i ] to make it bigger than A [ i ] . E . g . 214 / 2 -- > 107"
    },
    {
        "py": "if ( i != 0 ) : NEW_LINE INDENT sttr [ j ] = '0' ; NEW_LINE j += 1 ; NEW_LINE DEDENT",
        "explain": "if it 's not the first index. E.g 214  then we have to include 0."
    },
    {
        "py": "continue ; NEW_LINE sttr [ j ] = chr ( ( num // 2 ) + ord ( '0' ) ) ; NEW_LINE j += 1 ; NEW_LINE num = ( num ) - ( num // 2 ) * 2 ; NEW_LINE",
        "explain": "for eg . \"124\" we will not write 064 so if it is the first index just ignore"
    },
    {
        "py": "len_str = j ; NEW_LINE",
        "explain": "After every division by 2 the length of string is changed ."
    },
    {
        "py": "return 1 ; NEW_LINE",
        "explain": "if the string reaches to 1 then the str is a power of 2."
    },
    {
        "py": "str1 = \"124684622466842024680246842024662202000002\" ; NEW_LINE str2 = \"1\" ; NEW_LINE str3 = \"128\" ; NEW_LINE print ( \" \" , isPowerOf2 ( str1 ) ,   \" \" , isPowerOf2 ( str2 ) ,   \" \" , isPowerOf2 ( str3 ) ) ; NEW_LINE",
        "explain": "Driver code ."
    },
    {
        "py": "def ispowerof2 ( num ) : NEW_LINE INDENT if ( ( num & ( num - 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT",
        "explain": "Function to check whether a number is power of 2 or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 549755813888 NEW_LINE print ( ispowerof2 ( num ) ) NEW_LINE DEDENT",
        "explain": "Driver function"
    },
    {
        "py": "def counDivisors ( X ) : NEW_LINE",
        "explain": "To count number of factors in a number"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Initialize count with 0"
    },
    {
        "py": "for i in range ( 1 , X + 1 ) : NEW_LINE INDENT if ( X % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Increment count for every factor of the given number X ."
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return number of factors"
    },
    {
        "py": "def countDivisorsMult ( arr , n ) : NEW_LINE",
        "explain": "Returns number of divisors in array multiplication"
    },
    {
        "py": "mul = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mul *= arr [ i ] NEW_LINE DEDENT",
        "explain": "Multipliying all elements of the given array ."
    },
    {
        "py": "return counDivisors ( mul ) NEW_LINE",
        "explain": "Calling function which count number of factors of the number"
    },
    {
        "py": "arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDivisorsMult ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from collections import defaultdict NEW_LINE def SieveOfEratosthenes ( largest , prime ) : NEW_LINE",
        "explain": "Python 3 program to count divisors in array multiplication ."
    },
    {
        "py": "isPrime = [ True ] * ( largest + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= largest : NEW_LINE",
        "explain": "Create a boolean array \" isPrime [ 0 . . n ] \" and initialize all entries it as true . A value in isPrime [ i ] will finally be false if i is Not a isPrime , else true ."
    },
    {
        "py": "if ( isPrime [ p ] == True ) : NEW_LINE",
        "explain": "If isPrime [ p ] is not changed , then it is a isPrime"
    },
    {
        "py": "for i in range ( p * 2 , largest + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "for p in range ( 2 , largest + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE DEDENT DEDENT",
        "explain": "Print all isPrime numbers"
    },
    {
        "py": "def countDivisorsMult ( arr , n ) : NEW_LINE",
        "explain": "Returns number of divisors in array multiplication"
    },
    {
        "py": "largest = max ( arr ) NEW_LINE prime = [ ] NEW_LINE SieveOfEratosthenes ( largest , prime ) NEW_LINE",
        "explain": "Find all prime numbers smaller than the largest element ."
    },
    {
        "py": "mp = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( len ( prime ) ) : NEW_LINE INDENT while ( arr [ i ] > 1 and arr [ i ] % prime [ j ] == 0 ) : NEW_LINE INDENT arr [ i ] //= prime [ j ] NEW_LINE mp [ prime [ j ] ] += 1 NEW_LINE DEDENT DEDENT if ( arr [ i ] != 1 ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Find counts of occurrences of each prime factor"
    },
    {
        "py": "res = 1 NEW_LINE for it in mp . values ( ) : NEW_LINE INDENT res *= ( it + 1 ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "Compute count of all divisors using counts prime factors ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDivisorsMult ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def findPrimeNos ( L , R , M ) : NEW_LINE",
        "explain": "Function to generate prime numbers in the given range [ L , R ]"
    },
    {
        "py": "for i in range ( L , R + 1 ) : NEW_LINE INDENT M [ i ] = M . get ( i , 0 ) + 1 NEW_LINE DEDENT",
        "explain": "Store all value in the range"
    },
    {
        "py": "if ( 1 in M ) : NEW_LINE INDENT M . pop ( 1 ) NEW_LINE DEDENT",
        "explain": "Erase 1 as its non - prime"
    },
    {
        "py": "for i in range ( 2 , int ( sqrt ( R ) ) + 1 , 1 ) : NEW_LINE INDENT multiple = 2 NEW_LINE while ( ( i * multiple ) <= R ) : NEW_LINE DEDENT",
        "explain": "Perform Sieve of Eratosthenes"
    },
    {
        "py": "if ( ( i * multiple ) in M ) : NEW_LINE",
        "explain": "Find current multiple"
    },
    {
        "py": "M . pop ( i * multiple ) NEW_LINE",
        "explain": "Erase as it is a non - prime"
    },
    {
        "py": "multiple += 1 NEW_LINE",
        "explain": "Increment multiple"
    },
    {
        "py": "def getPrimePairs ( L , R , K ) : NEW_LINE INDENT M = { } NEW_LINE DEDENT",
        "explain": "Function to print all the prime pairs in the given range that differs by K"
    },
    {
        "py": "findPrimeNos ( L , R , M ) NEW_LINE",
        "explain": "Generate all prime number"
    },
    {
        "py": "for key , values in M . items ( ) : NEW_LINE",
        "explain": "Traverse the Map M"
    },
    {
        "py": "if ( ( key + K ) in M ) : NEW_LINE INDENT print ( \" ( \" , key , \" , \" , key + K , \" ) \" , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "If it . first & ( it . first + K ) is prime then print this pair"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "L = 1 NEW_LINE R = 19 NEW_LINE",
        "explain": "Given range"
    },
    {
        "py": "K = 6 NEW_LINE",
        "explain": "Given K"
    },
    {
        "py": "getPrimePairs ( L , R , K ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def EnneacontahexagonNum ( n ) : NEW_LINE INDENT return ( 94 * n * n - 92 * n ) // 2 ; NEW_LINE DEDENT",
        "explain": "Function to find the Nth Enneacontahexagon Number"
    },
    {
        "py": "n = 3 ; NEW_LINE print ( EnneacontahexagonNum ( n ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def find_composite_nos ( n ) : NEW_LINE INDENT print ( 9 * n , 8 * n ) ; NEW_LINE DEDENT",
        "explain": "Function to find the two composite numbers"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 4 ; NEW_LINE find_composite_nos ( n ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def freqPairs ( arr , n ) : NEW_LINE",
        "explain": "Function to find number of unordered pairs"
    },
    {
        "py": "max = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Maximum element from the array"
    },
    {
        "py": "freq = [ 0 for i in range ( max + 1 ) ] NEW_LINE",
        "explain": "Array to store the frequency of each element"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores the number of unordered pairs"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT",
        "explain": "Store the frequency of each element"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 * arr [ i ] , max + 1 , arr [ i ] ) : NEW_LINE DEDENT",
        "explain": "Find the number of unordered pairs"
    },
    {
        "py": "if ( freq [ j ] >= 1 ) : NEW_LINE INDENT count += freq [ j ] NEW_LINE DEDENT",
        "explain": "If the number j divisible by ith element is present in the array"
    },
    {
        "py": "if ( freq [ arr [ i ] ] > 1 ) : NEW_LINE INDENT count += freq [ arr [ i ] ] - 1 NEW_LINE freq [ arr [ i ] ] -= 1 NEW_LINE DEDENT return count NEW_LINE",
        "explain": "If the ith element of the array has frequency more than one"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 4 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( freqPairs ( arr , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def Nth_Term ( n ) : NEW_LINE INDENT return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) // 6 NEW_LINE DEDENT",
        "explain": "calculate Nth term of given series"
    },
    {
        "py": "N = 8 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def printNthElement ( n ) : NEW_LINE",
        "explain": "Return n - th number in series made of 3 and 5"
    },
    {
        "py": "arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 3 NEW_LINE arr [ 2 ] = 5 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE",
        "explain": "create an array of size ( n + 1 )"
    },
    {
        "py": "if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 3 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 5 NEW_LINE DEDENT return arr [ n ] NEW_LINE",
        "explain": "If i is odd"
    },
    {
        "py": "n = 6 NEW_LINE print ( printNthElement ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def nthTerm ( N ) : NEW_LINE",
        "explain": "function to calculate Nth term of series"
    },
    {
        "py": "return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEW_LINE",
        "explain": "By using above formula"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE DEDENT",
        "explain": "get the value of N"
    },
    {
        "py": "print ( \" Nth \u2581 term \u2581 for \u2581 N \u2581 = \u2581 \" , N , \" \u2581 : \u2581 \" , nthTerm ( N ) ) NEW_LINE",
        "explain": "Calculate and print the Nth term"
    },
    {
        "py": "def series ( A , X , n ) : NEW_LINE",
        "explain": "Function to print the series"
    },
    {
        "py": "term = pow ( A , n ) NEW_LINE print ( term , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Calculating and printing first term"
    },
    {
        "py": "for i in range ( 1 , n + 1 ) : NEW_LINE",
        "explain": "Computing and printing remaining terms"
    },
    {
        "py": "term = int ( term * X * ( n - i + 1 ) / ( i * A ) ) NEW_LINE print ( term , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Find current term using previous terms We increment power of X by 1 , decrement power of A by 1 and compute nCi using previous term by multiplying previous term with ( n - i + 1 ) / i"
    },
    {
        "py": "A = 3 ; X = 4 ; n = 5 NEW_LINE series ( A , X , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python program to check whether the number is divisible by 8 or not using bitwise operator"
    },
    {
        "py": "def Div_by_8 ( n ) : NEW_LINE INDENT return ( ( ( n >> 3 ) << 3 ) == n ) NEW_LINE DEDENT",
        "explain": "function to check number is div by 8 or not using bitwise operator"
    },
    {
        "py": "n = 16 NEW_LINE if ( Div_by_8 ( n ) ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "driver code"
    },
    {
        "py": "def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT sm = 0 NEW_LINE count = 0 NEW_LINE while ( n >= 2 ) : NEW_LINE DEDENT",
        "explain": "Function to calculate the average of even numbers"
    },
    {
        "py": "count = count + 1 NEW_LINE",
        "explain": "count even numbers"
    },
    {
        "py": "sm = sm + n NEW_LINE n = n - 2 NEW_LINE return sm // count NEW_LINE",
        "explain": "store the sum of even numbers"
    },
    {
        "py": "n = 16 NEW_LINE print ( averageEven ( n ) ) NEW_LINE",
        "explain": "driver function"
    },
    {
        "py": "def averageEven ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( \" Invalid \u2581 Input \" ) NEW_LINE return - 1 NEW_LINE DEDENT return ( n + 2 ) // 2 NEW_LINE DEDENT",
        "explain": "Function to calculate the average of even numbers"
    },
    {
        "py": "n = 16 NEW_LINE print ( averageEven ( n ) ) NEW_LINE",
        "explain": "Driver function"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE",
        "explain": "Recursive function to return gcd of a and b"
    },
    {
        "py": "if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Everything divides 0"
    },
    {
        "py": "if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT",
        "explain": "base case"
    },
    {
        "py": "if a > b : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE",
        "explain": "a is greater"
    },
    {
        "py": "def cpFact ( x , y ) : NEW_LINE INDENT while gcd ( x , y ) != 1 : NEW_LINE INDENT x = x / gcd ( x , y ) NEW_LINE DEDENT return int ( x ) NEW_LINE DEDENT",
        "explain": "function to find largest coprime divisor"
    },
    {
        "py": "x = 15 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 14 NEW_LINE y = 28 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 7 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE",
        "explain": "divisor code"
    },
    {
        "py": "def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( i % 10 == k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT",
        "explain": "Returns count of numbers with k as last digit ."
    },
    {
        "py": "low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE",
        "explain": "Driver Program"
    },
    {
        "py": "import math NEW_LINE def printTaxicab2 ( N ) : NEW_LINE",
        "explain": "Python3 implementation to print first N Taxicab ( 2 ) numbers"
    },
    {
        "py": "i , count = 1 , 0 NEW_LINE while ( count < N ) : NEW_LINE INDENT int_count = 0 NEW_LINE DEDENT",
        "explain": "Starting from 1 , check every number if it is Taxicab until count reaches N ."
    },
    {
        "py": "for j in range ( 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT for k in range ( j + 1 , math . ceil ( pow ( i , 1.0 / 3 ) ) + 1 ) : NEW_LINE INDENT if ( j * j * j + k * k * k == i ) : NEW_LINE INDENT int_count += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Try all possible pairs ( j , k ) whose cube sums can be i ."
    },
    {
        "py": "if ( int_count == 2 ) : NEW_LINE INDENT count += 1 NEW_LINE print ( count , \" \u2581 \" , i ) NEW_LINE DEDENT i += 1 NEW_LINE",
        "explain": "Taxicab ( 2 ) found"
    },
    {
        "py": "N = 5 NEW_LINE printTaxicab2 ( N ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def isComposite ( n ) : NEW_LINE",
        "explain": "A optimized school method based Python program to check if a number is composite ."
    },
    {
        "py": "if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE",
        "explain": "This is checked so that we can skip middle five numbers in below loop"
    },
    {
        "py": "print ( \" true \" ) if ( isComposite ( 11 ) ) else print ( \" false \" ) NEW_LINE print ( \" true \" ) if ( isComposite ( 15 ) ) else print ( \" false \" ) NEW_LINE",
        "explain": "Driver Program to test above function"
    },
    {
        "py": "def isPrime ( n ) : NEW_LINE",
        "explain": "function to check if a number is prime or not"
    },
    {
        "py": "if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "Corner case"
    },
    {
        "py": "for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "Check from 2 to n - 1"
    },
    {
        "py": "def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE DEDENT",
        "explain": "Find prime number greater than a number"
    },
    {
        "py": "while ( num ) : NEW_LINE",
        "explain": "find prime greater than n"
    },
    {
        "py": "if isPrime ( num ) : NEW_LINE INDENT return num NEW_LINE DEDENT",
        "explain": "check if num is prime"
    },
    {
        "py": "num += 1 NEW_LINE return 0 NEW_LINE",
        "explain": "Increment num"
    },
    {
        "py": "def minNumber ( arr ) : NEW_LINE INDENT s = 0 NEW_LINE DEDENT",
        "explain": "To find number to be added so sum of array is prime"
    },
    {
        "py": "for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT",
        "explain": "To find sum of array elements"
    },
    {
        "py": "if isPrime ( s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If sum is already prime return 0"
    },
    {
        "py": "num = findPrime ( s ) NEW_LINE",
        "explain": "To find prime number greater than sum"
    },
    {
        "py": "return num - s NEW_LINE",
        "explain": "Return difference of sum and num"
    },
    {
        "py": "arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT",
        "explain": "function to calculate factorial"
    },
    {
        "py": "def div ( x ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , x + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT",
        "explain": "function to calculate sum of divisor"
    },
    {
        "py": "def sumFactDiv ( n ) : NEW_LINE INDENT return div ( fact ( n ) ) NEW_LINE DEDENT",
        "explain": "Returns sum of divisors of n !"
    },
    {
        "py": "n = 4 NEW_LINE print ( sumFactDiv ( n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "allPrimes = [ ] ; NEW_LINE",
        "explain": "allPrimes [ ] stores all prime numbers less than or equal to n ."
    },
    {
        "py": "def sieve ( n ) : NEW_LINE",
        "explain": "Fills above vector allPrimes [ ] for a given n"
    },
    {
        "py": "prime = [ True ] * ( n + 1 ) ; NEW_LINE",
        "explain": "Create a boolean array \" prime [ 0 . . n ] \" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true ."
    },
    {
        "py": "p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE",
        "explain": "Loop to update prime [ ]"
    },
    {
        "py": "if ( prime [ p ] == True ) : NEW_LINE",
        "explain": "If prime [ p ] is not changed , then it is a prime"
    },
    {
        "py": "for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT p += 1 ; NEW_LINE",
        "explain": "Update all multiples of p"
    },
    {
        "py": "for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Store primes in the vector allPrimes"
    },
    {
        "py": "def factorialDivisors ( n ) : NEW_LINE",
        "explain": "Function to find all result of factorial number"
    },
    {
        "py": "result = 1 ; NEW_LINE",
        "explain": "Initialize result"
    },
    {
        "py": "for i in range ( len ( allPrimes ) ) : NEW_LINE",
        "explain": "find exponents of all primes which divides n and less than n"
    },
    {
        "py": "p = allPrimes [ i ] ; NEW_LINE",
        "explain": "Current divisor"
    },
    {
        "py": "exp = 0 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n / p ) ; NEW_LINE p = p * allPrimes [ i ] ; NEW_LINE DEDENT",
        "explain": "Find the highest power ( stored in exp ) ' \u2581 \u2581 of \u2581 allPrimes [ i ] \u2581 that \u2581 divides \u2581 n \u2581 using \u2581 \u2581 Legendre ' s formula ."
    },
    {
        "py": "result = int ( result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ) ; NEW_LINE",
        "explain": "Using the divisor function to calculate the sum"
    },
    {
        "py": "return result ; NEW_LINE",
        "explain": "return total divisors"
    },
    {
        "py": "print ( factorialDivisors ( 4 ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def checkPandigital ( b , n ) : NEW_LINE",
        "explain": "Return true if n is pandigit else return false ."
    },
    {
        "py": "if ( len ( n ) < b ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT hash = [ 0 ] * b ; NEW_LINE",
        "explain": "Checking length is less than base"
    },
    {
        "py": "for i in range ( len ( n ) ) : NEW_LINE",
        "explain": "Traversing each digit of the number ."
    },
    {
        "py": "if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 ; NEW_LINE DEDENT",
        "explain": "If digit is integer"
    },
    {
        "py": "elif ( ord ( n [ i ] ) - ord ( ' A ' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; NEW_LINE DEDENT",
        "explain": "If digit is alphabet"
    },
    {
        "py": "for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE",
        "explain": "Checking hash array , if any index is unmarked ."
    },
    {
        "py": "b = 13 ; NEW_LINE n = \"1298450376ABC \" ; NEW_LINE if ( checkPandigital ( b , n ) ) : NEW_LINE INDENT print ( \" Yes \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def conver ( m , n ) : NEW_LINE INDENT if ( m == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function to find minimum number of given operations to convert m to n"
    },
    {
        "py": "if ( m > n ) : NEW_LINE INDENT return m - n NEW_LINE DEDENT",
        "explain": "only way is to do - 1 ( m - n ) : times"
    },
    {
        "py": "if ( m <= 0 and n > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "not possible"
    },
    {
        "py": "if ( n % 2 == 1 ) : NEW_LINE",
        "explain": "n is greater and n is odd"
    },
    {
        "py": "return 1 + conver ( m , n + 1 ) NEW_LINE",
        "explain": "perform ' - 1' on m ( or + 1 on n ) :"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "n is even"
    },
    {
        "py": "return 1 + conver ( m , n / 2 ) NEW_LINE",
        "explain": "perform ' * 2' on m ( or n / 2 on n ) :"
    },
    {
        "py": "m = 3 NEW_LINE n = 11 NEW_LINE print ( \" Minimum \u2581 number \u2581 of \u2581 operations \u2581 : \" , conver ( m , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 10000 ; NEW_LINE prodDig = [ 0 ] * MAX ; NEW_LINE",
        "explain": "Python3 program to find Seed of a number"
    },
    {
        "py": "def getDigitProduct ( x ) : NEW_LINE",
        "explain": "Stores product of digits of x in prodDig [ x ]"
    },
    {
        "py": "if ( x < 10 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT",
        "explain": "If x has single digit"
    },
    {
        "py": "if ( prodDig [ x ] != 0 ) : NEW_LINE INDENT return prodDig [ x ] ; NEW_LINE DEDENT",
        "explain": "If digit product is already computed"
    },
    {
        "py": "prod = ( int ( x % 10 ) * getDigitProduct ( int ( x / 10 ) ) ) ; NEW_LINE prodDig [ x ] = prod ; NEW_LINE return prod ; NEW_LINE",
        "explain": "If digit product is not computed before ."
    },
    {
        "py": "def findSeed ( n ) : NEW_LINE",
        "explain": "Prints all seeds of n"
    },
    {
        "py": "res = [ ] ; NEW_LINE for i in range ( 1 , int ( n / 2 + 2 ) ) : NEW_LINE INDENT if ( i * getDigitProduct ( i ) == n ) : NEW_LINE INDENT res . append ( i ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Find all seeds using prodDig [ ]"
    },
    {
        "py": "if ( len ( res ) == 0 ) : NEW_LINE INDENT print ( \" NO \u2581 seed \u2581 exists \" ) ; NEW_LINE return ; NEW_LINE DEDENT",
        "explain": "If there was no seed"
    },
    {
        "py": "for i in range ( len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = \" \u2581 \" ) ; NEW_LINE DEDENT",
        "explain": "Print seeds"
    },
    {
        "py": "n = 138 ; NEW_LINE findSeed ( n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "from math import sqrt NEW_LINE",
        "explain": "Python 3 program to find integer having maximum number of prime factor in first N natural numbers ."
    },
    {
        "py": "def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 5 ) ] NEW_LINE DEDENT",
        "explain": "Return smallest number having maximum prime factors ."
    },
    {
        "py": "for i in range ( 2 , int ( sqrt ( N ) ) + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 NEW_LINE DEDENT DEDENT arr [ i ] = 1 NEW_LINE DEDENT maxval = 0 NEW_LINE maxint = 1 NEW_LINE",
        "explain": "Sieve of eratosthenes method to count number of prime factors ."
    },
    {
        "py": "for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxval ) : NEW_LINE INDENT maxval = arr [ i ] NEW_LINE maxint = i NEW_LINE DEDENT DEDENT return maxint NEW_LINE",
        "explain": "Finding number having maximum number of prime factor ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 40 NEW_LINE print ( maxPrimefactorNum ( N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def SubArraySum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT",
        "explain": "function compute sum all sub - array"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) NEW_LINE DEDENT",
        "explain": "computing sum of subarray using formula"
    },
    {
        "py": "return result NEW_LINE",
        "explain": "return all subarray sum"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( \" Sum \u2581 of \u2581 SubArray \u2581 : \u2581 \" , SubArraySum ( arr , n ) ) NEW_LINE",
        "explain": "driver program"
    },
    {
        "py": "def highestPowerof2 ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE DEDENT",
        "explain": "Python3 program to find highest power of 2 smaller than or equal to n ."
    },
    {
        "py": "if ( ( i & ( i - 1 ) ) == 0 ) : NEW_LINE INDENT res = i ; NEW_LINE break ; NEW_LINE DEDENT return res ; NEW_LINE",
        "explain": "If i is a power of 2"
    },
    {
        "py": "n = 10 ; NEW_LINE print ( highestPowerof2 ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find pairs that can represent the given number as sum of two cubes"
    },
    {
        "py": "def findPairs ( n ) : NEW_LINE",
        "explain": "Function to find pairs that can represent the given number as sum of two cubes"
    },
    {
        "py": "cubeRoot = int ( math . pow ( n , 1.0 / 3.0 ) ) ; NEW_LINE",
        "explain": "find cube root of n"
    },
    {
        "py": "' NEW_LINE INDENT cube = [ 0 ] * ( cubeRoot + 1 ) ; NEW_LINE DEDENT",
        "explain": "create a array of size of size 'cubeRoot"
    },
    {
        "py": "for i in range ( 1 , cubeRoot + 1 ) : NEW_LINE INDENT cube [ i ] = i * i * i ; NEW_LINE DEDENT",
        "explain": "for index i , cube [ i ] will contain i ^ 3"
    },
    {
        "py": "l = 1 ; NEW_LINE r = cubeRoot ; NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( cube [ l ] + cube [ r ] < n ) : NEW_LINE INDENT l += 1 ; NEW_LINE DEDENT elif ( cube [ l ] + cube [ r ] > n ) : NEW_LINE INDENT r -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" ( \" , l , \" , \u2581 \" , math . floor ( r ) , \" ) \" , end = \" \" ) ; NEW_LINE print ( ) ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT DEDENT",
        "explain": "Find all pairs in above sorted array cube [ ] whose sum is equal to n"
    },
    {
        "py": "n = 20683 ; NEW_LINE findPairs ( n ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findPairs ( n ) : NEW_LINE",
        "explain": "Function to find pairs that can represent the given number as sum of two cubes"
    },
    {
        "py": "cubeRoot = pow ( n , 1.0 / 3.0 ) ; NEW_LINE",
        "explain": "Find cube root of n"
    },
    {
        "py": "s = { } NEW_LINE",
        "explain": "Create an empty map"
    },
    {
        "py": "for x in range ( int ( cubeRoot ) ) : NEW_LINE INDENT for y in range ( x + 1 , int ( cubeRoot ) + 1 ) : NEW_LINE DEDENT",
        "explain": "Consider all pairs such with values less than cuberoot"
    },
    {
        "py": "sum = x * x * x + y * y * y ; NEW_LINE",
        "explain": "Find sum of current pair ( x , y )"
    },
    {
        "py": "if ( sum != n ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT",
        "explain": "Do nothing if sum is not equal to given number"
    },
    {
        "py": "if sum in s . keys ( ) : NEW_LINE INDENT print ( \" ( \" + str ( s [ sum ] [ 0 ] ) + \" , \u2581 \" + str ( s [ sum ] [ 1 ] ) + \" ) \u2581 and \u2581 ( \" + str ( x ) + \" , \u2581 \" + str ( y ) + \" ) \" +   \" \" ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If sum is seen before , we found two pairs"
    },
    {
        "py": "s [ sum ] = [ x , y ] NEW_LINE",
        "explain": "If sum is seen for the first time"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT n = 13832 NEW_LINE findPairs ( n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "import math as mt NEW_LINE",
        "explain": "python3 program to find the minimum difference between any two terms of two tables"
    },
    {
        "py": "def gcd ( a , b ) : NEW_LINE INDENT while ( b != 0 ) : NEW_LINE INDENT t = b NEW_LINE b = a % b NEW_LINE a = t NEW_LINE DEDENT return a NEW_LINE DEDENT",
        "explain": "Utility function to find GCD of a and b"
    },
    {
        "py": "def findMinDiff ( a , b , x , y ) : NEW_LINE",
        "explain": "Returns minimum difference between any two terms of shifted tables of ' a ' and ' b ' . ' x ' is shift in table of ' a ' and ' y ' is shift in table of ' b ' ."
    },
    {
        "py": "g = gcd ( a , b ) NEW_LINE",
        "explain": "Calculate gcd of a nd b"
    },
    {
        "py": "diff = abs ( x - y ) % g NEW_LINE return min ( diff , g - diff ) NEW_LINE",
        "explain": "Calculate difference between x and y"
    },
    {
        "py": "a , b , x , y = 20 , 52 , 5 , 7 NEW_LINE print ( findMinDiff ( a , b , x , y ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "A O ( sqrt ( n ) ) java program that prints all divisors in sorted order"
    },
    {
        "py": "def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE DEDENT",
        "explain": "Method to print the divisors"
    },
    {
        "py": "for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT",
        "explain": "List to store half of the divisors"
    },
    {
        "py": "if ( n / i == i ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Check if divisors are equal"
    },
    {
        "py": "print ( i , end = \" \u2581 \" ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE",
        "explain": "Otherwise print both"
    },
    {
        "py": "for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "The list will be printed in reverse"
    },
    {
        "py": "print ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) NEW_LINE printDivisors ( 100 ) NEW_LINE",
        "explain": "Driver method"
    },
    {
        "py": "from math import * NEW_LINE",
        "explain": "A O ( sqrt ( n ) ) program that prints all divisors in sorted order"
    },
    {
        "py": "def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while ( i * i < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( int ( sqrt ( n ) ) , 0 , - 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print ( n // i , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Function to print the divisors"
    },
    {
        "py": "print ( \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" ) NEW_LINE printDivisors ( 100 ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printDivisors ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT",
        "explain": "method to print the divisors"
    },
    {
        "py": "print \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" NEW_LINE printDivisors ( 100 ) NEW_LINE",
        "explain": "Driver method"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "A Better ( than Naive ) Solution to find all divisiors"
    },
    {
        "py": "def printDivisors ( n ) : NEW_LINE",
        "explain": "method to print the divisors"
    },
    {
        "py": "i = 1 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE DEDENT",
        "explain": "Note that this loop runs till square root"
    },
    {
        "py": "if ( n / i == i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT else : NEW_LINE",
        "explain": "If divisors are equal , print only one"
    },
    {
        "py": "print i , n / i , NEW_LINE i = i + 1 NEW_LINE",
        "explain": "Otherwise print both"
    },
    {
        "py": "print \" The \u2581 divisors \u2581 of \u2581 100 \u2581 are : \u2581 \" NEW_LINE printDivisors ( 100 ) NEW_LINE",
        "explain": "Driver method"
    },
    {
        "py": "def SieveOfAtkin ( limit ) : NEW_LINE",
        "explain": "Python 3 program for implementation of Sieve of Atkin"
    },
    {
        "py": "if ( limit > 2 ) : NEW_LINE INDENT print ( 2 , end = \" \u2581 \" ) NEW_LINE DEDENT if ( limit > 3 ) : NEW_LINE INDENT print ( 3 , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "2 and 3 are known to be prime"
    },
    {
        "py": "sieve = [ False ] * limit NEW_LINE for i in range ( 0 , limit ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT",
        "explain": "Initialise the sieve array with False values"
    },
    {
        "py": "x = 1 NEW_LINE while ( x * x < limit ) : NEW_LINE INDENT y = 1 NEW_LINE while ( y * y < limit ) : NEW_LINE DEDENT",
        "explain": "Mark sieve [ n ] is True if one of the following is True : a ) n = ( 4 * x * x ) + ( y * y ) has odd number of solutions , i . e . , there exist odd number of distinct pairs ( x , y ) that satisfy the equation and n % 12 = 1 or n % 12 = 5. b ) n = ( 3 * x * x ) + ( y * y ) has odd number of solutions and n % 12 = 7 c ) n = ( 3 * x * x ) - ( y * y ) has odd number of solutions , x > y and n % 12 = 11"
    },
    {
        "py": "n = ( 4 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and ( n % 12 == 1 or n % 12 == 5 ) ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) + ( y * y ) NEW_LINE if ( n <= limit and n % 12 == 7 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT n = ( 3 * x * x ) - ( y * y ) NEW_LINE if ( x > y and n <= limit and n % 12 == 11 ) : NEW_LINE INDENT sieve [ n ] ^= True NEW_LINE DEDENT y += 1 NEW_LINE x += 1 NEW_LINE",
        "explain": "Main part of Sieve of Atkin"
    },
    {
        "py": "r = 5 NEW_LINE while ( r * r < limit ) : NEW_LINE INDENT if ( sieve [ r ] ) : NEW_LINE INDENT for i in range ( r * r , limit , r * r ) : NEW_LINE INDENT sieve [ i ] = False NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Mark all multiples of squares as non - prime"
    },
    {
        "py": "for a in range ( 5 , limit ) : NEW_LINE INDENT if ( sieve [ a ] ) : NEW_LINE INDENT print ( a , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Print primes using sieve [ ]"
    },
    {
        "py": "limit = 20 NEW_LINE SieveOfAtkin ( limit ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isInside ( circle_x , circle_y , rad , x , y ) : NEW_LINE",
        "explain": "Python3 program to check if a point lies inside a circle or not"
    },
    {
        "py": "if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT",
        "explain": "Compare radius of circle with distance of its center from given point"
    },
    {
        "py": "x = 1 ; NEW_LINE y = 1 ; NEW_LINE circle_x = 0 ; NEW_LINE circle_y = 1 ; NEW_LINE rad = 2 ; NEW_LINE if ( isInside ( circle_x , circle_y , rad , x , y ) ) : NEW_LINE INDENT print ( \" Inside \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Outside \" ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def eval ( a , op , b ) : NEW_LINE INDENT if op == ' + ' : return a + b NEW_LINE if op == ' - ' : return a - b NEW_LINE if op == ' * ' : return a * b NEW_LINE DEDENT",
        "explain": "Utility function to evaluate a simple expression with one operator only ."
    },
    {
        "py": "def evaluateAll ( expr , low , high ) : NEW_LINE",
        "explain": "This function evaluates all possible values and returns a list of evaluated values ."
    },
    {
        "py": "res = [ ] NEW_LINE",
        "explain": "To store result ( all possible evaluations of given expression ' expr ' )"
    },
    {
        "py": "if low == high : NEW_LINE INDENT res . append ( int ( expr [ low ] ) ) NEW_LINE return res NEW_LINE DEDENT",
        "explain": "If there is only one character , it must be a digit ( or operand ) , return it ."
    },
    {
        "py": "if low == ( high - 2 ) : NEW_LINE INDENT num = eval ( int ( expr [ low ] ) , expr [ low + 1 ] , int ( expr [ low + 2 ] ) ) NEW_LINE res . append ( num ) NEW_LINE return res NEW_LINE DEDENT",
        "explain": "If there are only three characters , middle one must be operator and corner ones must be operand"
    },
    {
        "py": "for i in range ( low + 1 , high + 1 , 2 ) : NEW_LINE",
        "explain": "every i refers to an operator"
    },
    {
        "py": "' NEW_LINE INDENT l = evaluateAll ( expr , low , i - 1 ) NEW_LINE DEDENT",
        "explain": "l refers to all the possible values in the left of operator 'expr[i]"
    },
    {
        "py": "' NEW_LINE INDENT r = evaluateAll ( expr , i + 1 , high ) NEW_LINE DEDENT",
        "explain": "r refers to all the possible values in the right of operator 'expr[i]"
    },
    {
        "py": "' NEW_LINE INDENT for s1 in range ( 0 , len ( l ) ) : NEW_LINE DEDENT",
        "explain": "Take above evaluated all possible values in left side of 'i"
    },
    {
        "py": "' NEW_LINE INDENT for s2 in range ( 0 , len ( r ) ) : NEW_LINE DEDENT",
        "explain": "Take above evaluated all possible values in right side of 'i"
    },
    {
        "py": "val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) NEW_LINE res . append ( val ) NEW_LINE return res NEW_LINE",
        "explain": "Calculate value for every pair and add the value to result ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT expr = \"1*2 + 3*4\" NEW_LINE length = len ( expr ) NEW_LINE ans = evaluateAll ( expr , 0 , length - 1 ) NEW_LINE for i in range ( 0 , len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "python program to check if a given number is lucky"
    },
    {
        "py": "def isLucky ( n ) : NEW_LINE",
        "explain": "This function returns true if n is lucky"
    },
    {
        "py": "ar = [ 0 ] * 10 NEW_LINE",
        "explain": "Create an array of size 10 and initialize all elements as false . This array is used to check if a digit is already seen or not ."
    },
    {
        "py": "while ( n > 0 ) : NEW_LINE",
        "explain": "Traverse through all digits of given number"
    },
    {
        "py": "digit = math . floor ( n % 10 ) NEW_LINE",
        "explain": "Find the last digit"
    },
    {
        "py": "if ( ar [ digit ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If digit is already seen , return false"
    },
    {
        "py": "ar [ digit ] = 1 NEW_LINE",
        "explain": "Mark this digit as seen"
    },
    {
        "py": "n = n / 10 NEW_LINE return 1 NEW_LINE",
        "explain": "REmove the last digit from number"
    },
    {
        "py": "arr = [ 1291 , 897 , 4566 , 1232 , 80 , 700 ] NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT k = arr [ i ] NEW_LINE if ( isLucky ( k ) ) : NEW_LINE INDENT print ( k , \" \u2581 is \u2581 Lucky \u2581 \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( k , \" \u2581 is \u2581 not \u2581 Lucky \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver program to test above function ."
    },
    {
        "py": "def printSquares ( n ) : NEW_LINE",
        "explain": "Python3 program to print squares of first ' n ' natural numbers wothout using * , / and -"
    },
    {
        "py": "square = 0 NEW_LINE odd = 1 NEW_LINE",
        "explain": "Initialize ' square ' and first odd number"
    },
    {
        "py": "for x in range ( 0 , n ) : NEW_LINE",
        "explain": "Calculate and print squares"
    },
    {
        "py": "print ( square , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Print square"
    },
    {
        "py": "' NEW_LINE INDENT square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT",
        "explain": "Update ' square ' and 'odd"
    },
    {
        "py": "n = 5 ; NEW_LINE printSquares ( n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "rev_num = 0 NEW_LINE base_pos = 1 NEW_LINE",
        "explain": "Python 3 program to reverse digits of a number"
    },
    {
        "py": "def reversDigits ( num ) : NEW_LINE INDENT global rev_num NEW_LINE global base_pos NEW_LINE if ( num > 0 ) : NEW_LINE INDENT reversDigits ( ( int ) ( num / 10 ) ) NEW_LINE rev_num += ( num % 10 ) * base_pos NEW_LINE base_pos *= 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT",
        "explain": "Recursive function to reverse digits of num"
    },
    {
        "py": "num = 4562 NEW_LINE print ( \" Reverse \u2581 of \u2581 no . \u2581 is \u2581 \" , reversDigits ( num ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def RecursiveFunction ( ref , bit ) : NEW_LINE",
        "explain": "Recursive function that find the minimum value after exclusive - OR"
    },
    {
        "py": "if ( len ( ref ) == 0 or bit < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT curr_on = [ ] NEW_LINE curr_off = [ ] NEW_LINE for i in range ( len ( ref ) ) : NEW_LINE",
        "explain": "Condition if ref size is zero or bit is negative then return 0"
    },
    {
        "py": "if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) : NEW_LINE INDENT curr_off . append ( ref [ i ] ) NEW_LINE DEDENT",
        "explain": "Condition if current bit is off then push current value in curr_off vector"
    },
    {
        "py": "else : NEW_LINE INDENT curr_on . append ( ref [ i ] ) NEW_LINE DEDENT",
        "explain": "Condition if current bit is on then push current value in curr_on vector"
    },
    {
        "py": "if ( len ( curr_off ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_on , bit - 1 ) NEW_LINE DEDENT",
        "explain": "Condition if curr_off is empty then call recursive function on curr_on vector"
    },
    {
        "py": "if ( len ( curr_on ) == 0 ) : NEW_LINE INDENT return RecursiveFunction ( curr_off , bit - 1 ) NEW_LINE DEDENT",
        "explain": "Condition if curr_on is empty then call recursive function on curr_off vector"
    },
    {
        "py": "return ( min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ) NEW_LINE",
        "explain": "Return the minimum of curr_off and curr_on and add power of 2 of current bit"
    },
    {
        "py": "def PrintMinimum ( a , n ) : NEW_LINE INDENT v = [ ] NEW_LINE DEDENT",
        "explain": "Function that print the minimum value after exclusive - OR"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT v . append ( a [ i ] ) NEW_LINE DEDENT",
        "explain": "Pushing values in vector"
    },
    {
        "py": "print ( RecursiveFunction ( v , 30 ) ) NEW_LINE",
        "explain": "Printing answer"
    },
    {
        "py": "arr = [ 3 , 2 , 1 ] NEW_LINE size = len ( arr ) NEW_LINE PrintMinimum ( arr , size ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def cntElements ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count of elements which are equal to the XOR of the next two elements"
    },
    {
        "py": "cnt = 0 NEW_LINE",
        "explain": "To store the required count"
    },
    {
        "py": "for i in range ( n - 2 ) : NEW_LINE",
        "explain": "For every element of the array such that it has at least two elements appearing after it in the array"
    },
    {
        "py": "if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE",
        "explain": "If current element is equal to the XOR of the next two elements in the array"
    },
    {
        "py": "arr = [ 4 , 2 , 1 , 3 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( cntElements ( arr , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def xor_triplet ( arr , n ) : NEW_LINE",
        "explain": "Function to return the count"
    },
    {
        "py": "ans = 0 ; NEW_LINE",
        "explain": "Initialise result"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Pick 1 st element of the triplet"
    },
    {
        "py": "for j in range ( i + 1 , n ) : NEW_LINE",
        "explain": "Pick 2 nd element of the triplet"
    },
    {
        "py": "for k in range ( j , n ) : NEW_LINE INDENT xor1 = 0 ; xor2 = 0 ; NEW_LINE DEDENT",
        "explain": "Pick 3 rd element of the triplet"
    },
    {
        "py": "for x in range ( i , j ) : NEW_LINE INDENT xor1 ^= arr [ x ] ; NEW_LINE DEDENT",
        "explain": "Taking xor in the first subarray"
    },
    {
        "py": "for x in range ( j , k + 1 ) : NEW_LINE INDENT xor2 ^= arr [ x ] ; NEW_LINE DEDENT",
        "explain": "Taking xor in the second subarray"
    },
    {
        "py": "if ( xor1 == xor2 ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT return ans ; NEW_LINE",
        "explain": "If both xor is equal"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( xor_triplet ( arr , n ) ) ; NEW_LINE",
        "explain": "Function Calling"
    },
    {
        "py": "N = 100005 NEW_LINE Ideal_pair = 0 NEW_LINE",
        "explain": "Python3 implementation of the approach"
    },
    {
        "py": "al = [ [ ] for i in range ( 100005 ) ] NEW_LINE bit = [ 0 for i in range ( N ) ] NEW_LINE root_node = [ 0 for i in range ( N ) ] NEW_LINE",
        "explain": "Adjacency list"
    },
    {
        "py": "def bit_q ( i , j ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( j > 0 ) : NEW_LINE INDENT sum += bit [ j ] NEW_LINE j -= ( j & ( j * - 1 ) ) NEW_LINE DEDENT i -= 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum -= bit [ i ] NEW_LINE i -= ( i & ( i * - 1 ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT",
        "explain": "bit : bit array i and j are starting and ending index INCLUSIVE"
    },
    {
        "py": "def bit_up ( i , diff ) : NEW_LINE INDENT while ( i <= n ) : NEW_LINE INDENT bit [ i ] += diff NEW_LINE i += i & - i NEW_LINE DEDENT DEDENT",
        "explain": "bit : bit array n : size of bit array i is the index to be updated diff is ( new_val - old_val )"
    },
    {
        "py": "def dfs ( node , x ) : NEW_LINE INDENT Ideal_pair = x NEW_LINE Ideal_pair += bit_q ( max ( 1 , node - k ) , min ( n , node + k ) ) NEW_LINE bit_up ( node , 1 ) NEW_LINE for i in range ( len ( al [ node ] ) ) : NEW_LINE INDENT Ideal_pair = dfs ( al [ node ] [ i ] , Ideal_pair ) NEW_LINE DEDENT bit_up ( node , - 1 ) NEW_LINE return Ideal_pair NEW_LINE DEDENT",
        "explain": "DFS function to find ideal pairs"
    },
    {
        "py": "def initialise ( ) : NEW_LINE INDENT Ideal_pair = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT root_node [ i ] = True NEW_LINE bit [ i ] = 0 NEW_LINE DEDENT DEDENT",
        "explain": "Function for initialisation"
    },
    {
        "py": "def Add_Edge ( x , y ) : NEW_LINE INDENT al [ x ] . append ( y ) NEW_LINE root_node [ y ] = False NEW_LINE DEDENT",
        "explain": "Function to add an edge"
    },
    {
        "py": "def Idealpairs ( ) : NEW_LINE",
        "explain": "Function to find number of ideal pairs"
    },
    {
        "py": "r = - 1 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT if ( root_node [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT Ideal_pair = dfs ( r , 0 ) NEW_LINE return Ideal_pair NEW_LINE",
        "explain": "Find root of the tree"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 3 NEW_LINE initialise ( ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "Add_Edge ( 1 , 2 ) NEW_LINE Add_Edge ( 1 , 3 ) NEW_LINE Add_Edge ( 3 , 4 ) NEW_LINE Add_Edge ( 3 , 5 ) NEW_LINE Add_Edge ( 3 , 6 ) NEW_LINE",
        "explain": "Add edges"
    },
    {
        "py": "print ( Idealpairs ( ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def printSubsets ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( i != 0 ) : NEW_LINE INDENT print ( i , end = \" \u2581 \" ) NEW_LINE i = ( i - 1 ) & n NEW_LINE DEDENT print ( \"0\" ) NEW_LINE DEDENT",
        "explain": "function to find bitwise subsets Efficient approach"
    },
    {
        "py": "n = 9 NEW_LINE printSubsets ( n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isDivisibleby17 ( n ) : NEW_LINE",
        "explain": "function to check recursively if the number is divisible by 17 or not"
    },
    {
        "py": "if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "if n = 0 or n = 17 then yes"
    },
    {
        "py": "if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "if n is less then 17 , not divisible by 17"
    },
    {
        "py": "return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE",
        "explain": "reducing the number by floor ( n / 16 ) - n % 16"
    },
    {
        "py": "n = 35 NEW_LINE if ( isDivisibleby17 ( n ) ) : NEW_LINE INDENT print ( n , \" is \u2581 divisible \u2581 by \u2581 17\" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , \" is \u2581 not \u2581 divisible \u2581 by \u2581 17\" ) NEW_LINE DEDENT",
        "explain": "driver code to check the above function"
    },
    {
        "py": "import math NEW_LINE",
        "explain": "Python3 program to find largest number smaller than equal to n with m set bits then m - 1 0 bits ."
    },
    {
        "py": "def answer ( n ) : NEW_LINE",
        "explain": "Returns largest number with m set bits then m - 1 0 bits ."
    },
    {
        "py": "m = 2 ; NEW_LINE",
        "explain": "Start with 2 bits ."
    },
    {
        "py": "ans = 1 ; NEW_LINE r = 1 ; NEW_LINE",
        "explain": "initial answer is 1 which meets the given condition"
    },
    {
        "py": "while r < n : NEW_LINE",
        "explain": "check for all numbers"
    },
    {
        "py": "r = ( int ) ( ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ) ; NEW_LINE",
        "explain": "compute the number"
    },
    {
        "py": "if r < n : NEW_LINE INDENT ans = r ; NEW_LINE DEDENT",
        "explain": "if less then N"
    },
    {
        "py": "m = m + 1 ; NEW_LINE return ans ; NEW_LINE",
        "explain": "increment m to get the next number"
    },
    {
        "py": "print ( answer ( 7 ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def setBitNumber ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT msb = 0 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = int ( n / 2 ) ; NEW_LINE msb += 1 ; NEW_LINE DEDENT return ( 1 << msb ) ; NEW_LINE DEDENT",
        "explain": "Simple Python3 program to find MSB number for given n ."
    },
    {
        "py": "n = 0 ; NEW_LINE print ( setBitNumber ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def setBitNumber ( n ) : NEW_LINE",
        "explain": "Python program to find MSB number for given n ."
    },
    {
        "py": "n |= n >> 1 NEW_LINE",
        "explain": "Suppose n is 273 ( binary is 100010001 ) . It does following 100010001 | 010001000 = 110011001"
    },
    {
        "py": "n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE",
        "explain": "This makes sure 4 bits ( From MSB and including MSB ) are set . It does following 110011001 | 001100110 = 111111111"
    },
    {
        "py": "n = n + 1 NEW_LINE",
        "explain": "Increment n by 1 so that there is only one set bit which is just before original MSB . n now becomes 1000000000"
    },
    {
        "py": "return ( n >> 1 ) NEW_LINE",
        "explain": "Return original MSB after shifting . n now becomes 100000000"
    },
    {
        "py": "n = 273 NEW_LINE print ( setBitNumber ( n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countTrailingZero ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( ( x & 1 ) == 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "explain": "Python 3 code for counting trailing zeros in binary representation of a number"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( countTrailingZero ( 11 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countTrailingZero ( x ) : NEW_LINE",
        "explain": "Python3 code for counting trailing zeros in binary representation of a number"
    },
    {
        "py": "lookup = [ 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 ] NEW_LINE",
        "explain": "Map a bit value mod 37 to its position"
    },
    {
        "py": "return lookup [ ( - x & x ) % 37 ] NEW_LINE",
        "explain": "Only difference between ( x and - x ) is the value of signed magnitude ( leftmostbit ) negative numbers signed bit is 1"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT print ( countTrailingZero ( 48 ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def multiplyBySevenByEight ( n ) : NEW_LINE",
        "explain": "Python program to evaluate ceil ( 7 n / 8 ) without using * and /"
    },
    {
        "py": "' NEW_LINE INDENT return ( n - ( n >> 3 ) ) NEW_LINE DEDENT",
        "explain": "Note the inner bracket here . This is needed because precedence of ' - ' operator is higher than '<<"
    },
    {
        "py": "n = 9 NEW_LINE print ( multiplyBySevenByEight ( n ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def multiplyBySevenByEight ( n ) : NEW_LINE",
        "explain": "Python3 program to evaluate 7 n / 8 without using * and /"
    },
    {
        "py": "return ( ( n << 3 ) - n ) >> 3 ; NEW_LINE",
        "explain": "Step 1 ) First multiply number by 7 i . e . 7 n = ( n << 3 ) - n Step 2 ) Divide result by 8"
    },
    {
        "py": "n = 15 ; NEW_LINE print ( multiplyBySevenByEight ( n ) ) ; NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def countNumbers ( L , R , K ) : NEW_LINE",
        "explain": "Function to find the maximum size of group of palindrome numbers having difference between maximum and minimum element at most K"
    },
    {
        "py": "list = [ ] NEW_LINE",
        "explain": "Stores the all the palindromic numbers in the range [ L , R ]"
    },
    {
        "py": "for i in range ( L , R + 1 ) : NEW_LINE",
        "explain": "Traverse over the range [ L , R ]"
    },
    {
        "py": "if ( isPalindrome ( i ) ) : NEW_LINE",
        "explain": "If i is a palindrome"
    },
    {
        "py": "list . append ( i ) NEW_LINE",
        "explain": "Append the number in the list"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Stores count of maximum palindromic numbers"
    },
    {
        "py": "for i in range ( len ( list ) ) : NEW_LINE",
        "explain": "Iterate each element in the list"
    },
    {
        "py": "right_index = search ( list , list [ i ] + K - 1 ) NEW_LINE",
        "explain": "Calculate rightmost index in the list < current element + K"
    },
    {
        "py": "if ( right_index != - 1 ) : NEW_LINE INDENT count = max ( count , right_index - i + 1 ) NEW_LINE DEDENT",
        "explain": "Check if there is rightmost index from the current index"
    },
    {
        "py": "return count NEW_LINE",
        "explain": "Return the count"
    },
    {
        "py": "def search ( list , num ) : NEW_LINE INDENT low , high = 0 , len ( list ) - 1 NEW_LINE DEDENT",
        "explain": "Function to search the rightmost index of given number"
    },
    {
        "py": "ans = - 1 NEW_LINE while ( low <= high ) : NEW_LINE",
        "explain": "Store the rightmost index"
    },
    {
        "py": "mid = low + ( high - low ) // 2 NEW_LINE",
        "explain": "Calculate the mid"
    },
    {
        "py": "if ( list [ mid ] <= num ) : NEW_LINE",
        "explain": "If given number <= num"
    },
    {
        "py": "ans = mid NEW_LINE",
        "explain": "Assign ans = mid"
    },
    {
        "py": "low = mid + 1 NEW_LINE else : NEW_LINE",
        "explain": "Update low"
    },
    {
        "py": "high = mid - 1 NEW_LINE",
        "explain": "Update high"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "return ans"
    },
    {
        "py": "def isPalindrome ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE temp = n NEW_LINE DEDENT",
        "explain": "Function to check if the given number is palindrome or not"
    },
    {
        "py": "while ( n > 0 ) : NEW_LINE INDENT rev = rev * 10 + n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT",
        "explain": "Generate reverse of the given number"
    },
    {
        "py": "return rev == temp NEW_LINE",
        "explain": "If n is a palindrome"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 98 , 112 NEW_LINE K = 13 NEW_LINE print ( countNumbers ( L , R , K ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findMaximumSum ( a , n ) : NEW_LINE",
        "explain": "Function to find the maximum sum by subtracting same value from all elements of a Subarray"
    },
    {
        "py": "prev_smaller = findPrevious ( a , n ) NEW_LINE",
        "explain": "Stores previous smaller element"
    },
    {
        "py": "next_smaller = findNext ( a , n ) NEW_LINE max_value = 0 NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Stores next smaller element"
    },
    {
        "py": "max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) NEW_LINE",
        "explain": "Calculate contribution of each element"
    },
    {
        "py": "return max_value NEW_LINE",
        "explain": "Return answer"
    },
    {
        "py": "def findPrevious ( a , n ) : NEW_LINE INDENT ps = [ 0 ] * n NEW_LINE DEDENT",
        "explain": "Function to generate previous smaller element for each array element"
    },
    {
        "py": "ps [ 0 ] = - 1 NEW_LINE",
        "explain": "The first element has no previous smaller"
    },
    {
        "py": "stack = [ ] NEW_LINE",
        "explain": "Stack to keep track of elements that have occurred previously"
    },
    {
        "py": "stack . append ( 0 ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE",
        "explain": "Push the first index"
    },
    {
        "py": "while len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT",
        "explain": "Pop all the elements until the previous element is smaller than current element"
    },
    {
        "py": "ps [ i ] = stack [ - 1 ] if len ( stack ) > 0 else - 1 NEW_LINE",
        "explain": "Store the previous smaller element"
    },
    {
        "py": "stack . append ( i ) NEW_LINE",
        "explain": "Push the index of the current element"
    },
    {
        "py": "return ps NEW_LINE",
        "explain": "Return the array"
    },
    {
        "py": "def findNext ( a , n ) : NEW_LINE INDENT ns = [ 0 ] * n NEW_LINE ns [ n - 1 ] = n NEW_LINE DEDENT",
        "explain": "Function to generate next smaller element for each array element"
    },
    {
        "py": "stack = [ ] NEW_LINE stack . append ( n - 1 ) NEW_LINE",
        "explain": "Stack to keep track of elements that have occurring next"
    },
    {
        "py": "for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE",
        "explain": "Iterate in reverse order for calculating next smaller"
    },
    {
        "py": "while ( len ( stack ) > 0 and a [ stack [ - 1 ] ] >= a [ i ] ) : NEW_LINE INDENT stack . pop ( ) NEW_LINE DEDENT",
        "explain": "Pop all the elements until the next element is smaller than current element"
    },
    {
        "py": "ns [ i ] = stack [ - 1 ] if len ( stack ) > 0 else n NEW_LINE",
        "explain": "Store the next smaller element"
    },
    {
        "py": "stack . append ( i ) NEW_LINE",
        "explain": "Push the index of the current element"
    },
    {
        "py": "return ns NEW_LINE",
        "explain": "Return the array"
    },
    {
        "py": "n = 3 NEW_LINE a = [ 80 , 48 , 82 ] NEW_LINE print ( findMaximumSum ( a , n ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "MAX = 256 NEW_LINE def compare ( arr1 , arr2 ) : NEW_LINE INDENT global MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT",
        "explain": "''This function returns true if contents of arr1[] and arr2[] are same, otherwise false."
    },
    {
        "py": "def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE DEDENT",
        "explain": "This function search for all permutations of pat [ ] in txt [ ]"
    },
    {
        "py": "countP = [ 0 for i in range ( MAX ) ] NEW_LINE countTW = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT countP [ ord ( pat [ i ] ) ] += 1 NEW_LINE countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE DEDENT",
        "explain": "countP [ ] : Store count of all characters of pattern countTW [ ] : Store count of current window of text"
    },
    {
        "py": "for i in range ( M , N ) : NEW_LINE",
        "explain": "Traverse through remaining characters of pattern"
    },
    {
        "py": "if ( compare ( countP , countTW ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT",
        "explain": "Compare counts of current window of text with counts of pattern [ ]"
    },
    {
        "py": "countTW [ ord ( txt [ i ] ) ] += 1 NEW_LINE",
        "explain": "Add current character to current window"
    },
    {
        "py": "countTW [ ord ( txt [ i - M ] ) ] -= 1 NEW_LINE",
        "explain": "Remove the first character of previous window"
    },
    {
        "py": "if ( compare ( countP , countTW ) ) : NEW_LINE INDENT return True NEW_LINE return False NEW_LINE DEDENT",
        "explain": "Check for the last window in text"
    },
    {
        "py": "txt = \" BACDGABCDA \" NEW_LINE pat = \" ABCD \" NEW_LINE if ( search ( pat , txt ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def getMaxMedian ( arr , n , k ) : NEW_LINE INDENT size = n + k NEW_LINE DEDENT",
        "explain": "Function to return the maximized median"
    },
    {
        "py": "arr . sort ( reverse = False ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "if ( size % 2 == 0 ) : NEW_LINE INDENT median = ( arr [ int ( size / 2 ) - 1 ] + arr [ int ( size / 2 ) ] ) / 2 NEW_LINE return median NEW_LINE DEDENT",
        "explain": "If size is even"
    },
    {
        "py": "median = arr [ int ( size / 2 ) ] NEW_LINE return median NEW_LINE",
        "explain": "If size is odd"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( getMaxMedian ( arr , n , k ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printSorted ( a , b , c ) : NEW_LINE",
        "explain": "Python3 program to print three numbers in sorted order using max function"
    },
    {
        "py": "get_max = max ( a , max ( b , c ) ) NEW_LINE",
        "explain": "Find maximum element"
    },
    {
        "py": "get_min = - max ( - a , max ( - b , - c ) ) NEW_LINE get_mid = ( a + b + c ) - ( get_max + get_min ) NEW_LINE print ( get_min , \" \u2581 \" , get_mid , \" \u2581 \" , get_max ) NEW_LINE",
        "explain": "Find minimum element"
    },
    {
        "py": "a , b , c = 4 , 1 , 9 NEW_LINE printSorted ( a , b , c ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def binarySearch ( a , item , low , high ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( item == a [ mid ] ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT elif ( item > a [ mid ] ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT",
        "explain": "iterative implementation"
    },
    {
        "py": "' NEW_LINE def insertionSort ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = i - 1 NEW_LINE selected = a [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Function to sort an array a [ ] of size 'n"
    },
    {
        "py": "loc = binarySearch ( a , selected , 0 , j ) NEW_LINE",
        "explain": "find location where selected should be inseretd"
    },
    {
        "py": "while ( j >= loc ) : NEW_LINE INDENT a [ j + 1 ] = a [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT a [ j + 1 ] = selected NEW_LINE",
        "explain": "Move all elements after location to create space"
    },
    {
        "py": "a = [ 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 ] NEW_LINE n = len ( a ) NEW_LINE insertionSort ( a , n ) NEW_LINE print ( \" Sorted \u2581 array : \u2581 \" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def insertionSort ( arr ) : NEW_LINE INDENT for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT key = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Function to do insertion sort"
    },
    {
        "py": "j = i - 1 NEW_LINE while j >= 0 and key < arr [ j ] : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = key NEW_LINE",
        "explain": "Move elements of arr [ 0. . i - 1 ] , that are greater than key , to one position ahead of their current position"
    },
    {
        "py": "arr = [ 12 , 11 , 13 , 5 , 6 ] NEW_LINE insertionSort ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( \" % \u2581 d \" % arr [ i ] ) NEW_LINE DEDENT",
        "explain": "Driver code to test above"
    },
    {
        "py": "def validPermutations ( str ) : NEW_LINE INDENT m = { } NEW_LINE DEDENT",
        "explain": "Function to calculate total number of valid permutations"
    },
    {
        "py": "count = len ( str ) NEW_LINE ans = 0 NEW_LINE",
        "explain": "Creating count which is equal to the Total number of characters present and ans that will store the number of unique permutations"
    },
    {
        "py": "for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] in m ) : NEW_LINE INDENT m [ str [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ str [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( len ( str ) ) : NEW_LINE",
        "explain": "Storing frequency of each character present in the string"
    },
    {
        "py": "ans += count - m [ str [ i ] ] NEW_LINE",
        "explain": "Adding count of characters by excluding characters equal to current char"
    },
    {
        "py": "m [ str [ i ] ] -= 1 NEW_LINE count -= 1 NEW_LINE",
        "explain": "Reduce the frequency of the current character and count by 1 , so that it cannot interfere with the calculations of the same elements present to the right of it ."
    },
    {
        "py": "return ans + 1 NEW_LINE",
        "explain": "Return ans + 1 ( Because the given string is also a unique permutation )"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = \" sstt \" NEW_LINE print ( validPermutations ( str ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def countPaths ( n , m ) : NEW_LINE",
        "explain": "Recursive function to count number of paths"
    },
    {
        "py": "if ( n == 0 or m == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If we reach bottom or top left , we are have only one way to reach ( 0 , 0 )"
    },
    {
        "py": "return ( countPaths ( n - 1 , m ) + countPaths ( n , m - 1 ) ) NEW_LINE",
        "explain": "Else count sum of both ways"
    },
    {
        "py": "n = 3 NEW_LINE m = 2 NEW_LINE print ( \" Number \u2581 of \u2581 Paths \" , countPaths ( n , m ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def count ( S , m , n ) : NEW_LINE",
        "explain": "Returns the count of ways we can sum S [ 0. . . m - 1 ] coins to get sum n"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "If n is 0 then there is 1 solution ( do not include any coin )"
    },
    {
        "py": "if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "If n is less than 0 then no solution exists"
    },
    {
        "py": "if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "If there are no coins and n is greater than 0 , then no solution exist"
    },
    {
        "py": "return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE",
        "explain": "count is sum of solutions ( i ) including S [ m - 1 ] ( ii ) excluding S [ m - 1 ]"
    },
    {
        "py": "arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE",
        "explain": "Driver program to test above function"
    },
    {
        "py": "def equalIgnoreCase ( str1 , str2 ) : NEW_LINE",
        "explain": "Function to compare two strings ignoring their cases"
    },
    {
        "py": "str1 = str1 . upper ( ) ; NEW_LINE str2 = str2 . upper ( ) ; NEW_LINE",
        "explain": "Convert to uppercase"
    },
    {
        "py": "x = str1 == str2 ; NEW_LINE return x ; NEW_LINE",
        "explain": "if strings are equal , return true otherwise false"
    },
    {
        "py": "def equalIgnoreCaseUtil ( str1 , str2 ) : NEW_LINE INDENT res = equalIgnoreCase ( str1 , str2 ) ; NEW_LINE if ( res == True ) : NEW_LINE INDENT print ( \" Same \" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Same \" ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the same or not same if strings are equal or not equal"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT str1 = \" Geeks \" ; NEW_LINE str2 = \" geeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE str1 = \" Geek \" ; NEW_LINE str2 = \" geeksforgeeks \" ; NEW_LINE equalIgnoreCaseUtil ( str1 , str2 ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def replaceConsonants ( string ) : NEW_LINE",
        "explain": "Function to return the converted string after replacing every consonant sequence with its length"
    },
    {
        "py": "res = \" \" ; NEW_LINE i = 0 ; count = 0 ; NEW_LINE",
        "explain": "To store the resultant string"
    },
    {
        "py": "while ( i < len ( string ) ) : NEW_LINE",
        "explain": "Checking each character for consonant sequence"
    },
    {
        "py": "if ( string [ i ] != ' a ' and string [ i ] != ' e ' and string [ i ] != ' i ' and string [ i ] != ' o ' and string [ i ] != ' u ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Count the length of consonants sequence"
    },
    {
        "py": "if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT",
        "explain": "Add the length in the string"
    },
    {
        "py": "res += string [ i ] ; NEW_LINE i += 1 NEW_LINE count = 0 ; NEW_LINE",
        "explain": "Add the vowel"
    },
    {
        "py": "if ( count > 0 ) : NEW_LINE INDENT res += str ( count ) ; NEW_LINE DEDENT",
        "explain": "Check for the last consonant sequence in the string"
    },
    {
        "py": "return res ; NEW_LINE",
        "explain": "Return the resultant string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" abcdeiop \" ; NEW_LINE print ( replaceConsonants ( string ) ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT",
        "explain": "isVowel ( ) is a function that returns true for a vowel and false otherwise ."
    },
    {
        "py": "def encryptString ( s , n , k ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE ans = \" \" NEW_LINE DEDENT",
        "explain": "function to Encrypt the dtring"
    },
    {
        "py": "for l in range ( n - k + 1 ) : NEW_LINE INDENT countVowels = 0 NEW_LINE countConsonants = 0 NEW_LINE DEDENT",
        "explain": "for each substring"
    },
    {
        "py": "for r in range ( l , l + k ) : NEW_LINE",
        "explain": "substring of size k"
    },
    {
        "py": "if ( isVowel ( s [ r ] ) == True ) : NEW_LINE INDENT countVowels += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countConsonants += 1 NEW_LINE DEDENT",
        "explain": "counting number of vowels and consonants"
    },
    {
        "py": "ans += ( str ) ( countVowels * countConsonants ) NEW_LINE return ans NEW_LINE",
        "explain": "append product to answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \" hello \" NEW_LINE n = len ( s ) NEW_LINE k = 2 NEW_LINE print ( encryptString ( s , n , k ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "charBuffer = [ ] NEW_LINE def processWords ( input ) : NEW_LINE",
        "explain": "An efficient Python3 implementation of above approach"
    },
    {
        "py": "s = input . split ( \" \u2581 \" ) NEW_LINE for values in s : NEW_LINE",
        "explain": "we are splitting the input based on spaces ( s ) + : this regular expression will handle scenarios where we have words separated by multiple spaces"
    },
    {
        "py": "charBuffer . append ( values [ 0 ] ) NEW_LINE return charBuffer NEW_LINE",
        "explain": "charAt ( 0 ) will pick only the first character from the string and append to buffer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = \" geeks \u2581 for \u2581 geeks \" NEW_LINE print ( * processWords ( input ) , sep = \" \" ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def generateAllStringsUtil ( K , str , n ) : NEW_LINE",
        "explain": "A utility function generate all string without consecutive 1 'sof size K"
    },
    {
        "py": "if ( n == K ) : NEW_LINE",
        "explain": "print binary string without consecutive 1 's"
    },
    {
        "py": "print ( * str [ : n ] , sep = \" \" , end = \" \u2581 \" ) NEW_LINE return NEW_LINE",
        "explain": "terminate binary string"
    },
    {
        "py": "if ( str [ n - 1 ] == '1' ) : NEW_LINE INDENT str [ n ] = '0' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE DEDENT",
        "explain": "if previous character is '1' then we put only 0 at end of string example str = \"01\" then new string be \"000\""
    },
    {
        "py": "if ( str [ n - 1 ] == '0' ) : NEW_LINE INDENT str [ n ] = '0' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE str [ n ] = '1' NEW_LINE generateAllStringsUtil ( K , str , n + 1 ) NEW_LINE DEDENT",
        "explain": "if previous character is '0' than we put both '1' and '0' at end of string example str = \"00\" then new string \"001\" and \"000\""
    },
    {
        "py": "def generateAllStrings ( K ) : NEW_LINE",
        "explain": "function generate all binary string without consecutive 1 's"
    },
    {
        "py": "if ( K <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT",
        "explain": "Base case"
    },
    {
        "py": "str = [ 0 ] * K NEW_LINE",
        "explain": "One by one stores every binary string of length K"
    },
    {
        "py": "' NEW_LINE INDENT str [ 0 ] = '0' NEW_LINE generateAllStringsUtil ( K , str , 1 ) NEW_LINE DEDENT",
        "explain": "Generate all Binary string starts with '0"
    },
    {
        "py": "' NEW_LINE INDENT str [ 0 ] = '1' NEW_LINE generateAllStringsUtil ( K , str , 1 ) NEW_LINE DEDENT",
        "explain": "Generate all Binary string starts with '1"
    },
    {
        "py": "K = 3 NEW_LINE generateAllStrings ( K ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findVolume ( a ) : NEW_LINE",
        "explain": "Function to find the biggest right circular cylinder"
    },
    {
        "py": "if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "side cannot be negative"
    },
    {
        "py": "r = a / 2 NEW_LINE",
        "explain": "radius of right circular cylinder"
    },
    {
        "py": "h = a NEW_LINE",
        "explain": "height of right circular cylinder"
    },
    {
        "py": "V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE",
        "explain": "volume of right circular cylinder"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT a = 5 NEW_LINE print ( findVolume ( a ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def volumeTriangular ( a , b , h ) : NEW_LINE INDENT return ( 0.1666 ) * a * b * h NEW_LINE DEDENT",
        "explain": "Function to calculate Volume of Triangular Pyramid"
    },
    {
        "py": "def volumeSquare ( b , h ) : NEW_LINE INDENT return ( 0.33 ) * b * b * h NEW_LINE DEDENT",
        "explain": "Function To calculate Volume of Square Pyramid"
    },
    {
        "py": "def volumePentagonal ( a , b , h ) : NEW_LINE INDENT return ( 0.83 ) * a * b * h NEW_LINE DEDENT",
        "explain": "Function To calculate Volume of Pentagonal Pyramid"
    },
    {
        "py": "def volumeHexagonal ( a , b , h ) : NEW_LINE INDENT return a * b * h NEW_LINE DEDENT",
        "explain": "Function To calculate Volume of Hexagonal Pyramid"
    },
    {
        "py": "b = float ( 4 ) NEW_LINE h = float ( 9 ) NEW_LINE a = float ( 4 ) NEW_LINE print ( \" Volume \u2581 of \u2581 triangular \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumeTriangular ( a , b , h ) ) NEW_LINE print ( \" Volume \u2581 of \u2581 square \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumeSquare ( b , h ) ) NEW_LINE print ( \" Volume \u2581 of \u2581 pentagonal \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumePentagonal ( a , b , h ) ) NEW_LINE print ( \" Volume \u2581 of \u2581 Hexagonal \u2581 base \u2581 pyramid \u2581 is \u2581 \" , volumeHexagonal ( a , b , h ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def Area ( b1 , b2 , h ) : NEW_LINE INDENT return ( ( b1 + b2 ) / 2 ) * h NEW_LINE DEDENT",
        "explain": "Function for the area"
    },
    {
        "py": "base1 = 8 ; base2 = 10 ; height = 6 NEW_LINE area = Area ( base1 , base2 , height ) NEW_LINE print ( \" Area \u2581 is : \" , area ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def numberOfDiagonals ( n ) : NEW_LINE INDENT return n * ( n - 3 ) / 2 NEW_LINE DEDENT",
        "explain": "''Python3 program to find number of diagonals in n sided convex polygon"
    },
    {
        "py": "def main ( ) : NEW_LINE INDENT n = 5 NEW_LINE print ( n , \" \u2581 sided \u2581 convex \u2581 polygon \u2581 have \u2581 \" ) NEW_LINE print ( numberOfDiagonals ( n ) , \" \u2581 diagonals \" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT",
        "explain": "''driver code to test above function"
    },
    {
        "py": "def maximumArea ( l , b , x , y ) : NEW_LINE",
        "explain": "Function to find the maximum area such that it does not contains any hole"
    },
    {
        "py": "left , right , above , below = 0 , 0 , 0 , 0 NEW_LINE left = x * b NEW_LINE right = ( l - x - 1 ) * b NEW_LINE above = l * y NEW_LINE below = ( b - y - 1 ) * l NEW_LINE",
        "explain": "Area for all the possible positions of the cut"
    },
    {
        "py": "print ( max ( max ( left , right ) , max ( above , below ) ) ) NEW_LINE",
        "explain": "Find the maximum area among the above rectangles"
    },
    {
        "py": "l = 8 NEW_LINE b = 8 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "maximumArea ( l , b , x , y ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def delCost ( s , cost ) : NEW_LINE",
        "explain": "Function to find the minimum cost of removing characters to make the string unique"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Store the minimum cost required"
    },
    {
        "py": "forMax = { } NEW_LINE",
        "explain": "Create a dictionary to store the maximum cost of removal a character"
    },
    {
        "py": "forTot = { } NEW_LINE",
        "explain": "Create a dictionary to store the total deletion cost of a character"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "Traverse the string , S"
    },
    {
        "py": "if s [ i ] not in forMax : NEW_LINE INDENT forMax [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Keep track of maximum cost of each character"
    },
    {
        "py": "forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) NEW_LINE",
        "explain": "Update the maximum deletion cost"
    },
    {
        "py": "if s [ i ] not in forTot : NEW_LINE INDENT forTot [ s [ i ] ] = cost [ i ] NEW_LINE DEDENT else : NEW_LINE",
        "explain": "Keep track of the total cost of each character"
    },
    {
        "py": "forTot [ s [ i ] ] += cost [ i ] NEW_LINE",
        "explain": "Update the total deletion cost"
    },
    {
        "py": "for i in forMax : NEW_LINE",
        "explain": "Traverse through all the unique characters"
    },
    {
        "py": "ans += forTot [ i ] - forMax [ i ] NEW_LINE",
        "explain": "Keep the maximum cost character and delete the rest"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return the answer"
    },
    {
        "py": "string = \" AAABBB \" NEW_LINE",
        "explain": "Given string"
    },
    {
        "py": "cost = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE",
        "explain": "Given cost array"
    },
    {
        "py": "print ( delCost ( string , cost ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "MAX = 10000 NEW_LINE divisors = [ [ ] for i in range ( MAX + 1 ) ] NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def computeDivisors ( ) : NEW_LINE INDENT global divisors NEW_LINE global MAX NEW_LINE for i in range ( 1 , MAX + 1 , 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 , i ) : NEW_LINE DEDENT DEDENT",
        "explain": "Stores divisors for all numbers in the vector divisors"
    },
    {
        "py": "divisors [ j ] . append ( i ) NEW_LINE",
        "explain": "i is the divisor and j is the multiple"
    },
    {
        "py": "def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to compare the closeness of the given target"
    },
    {
        "py": "def findClosest ( arr , n , target ) : NEW_LINE",
        "explain": "Function to find the element closest to target in divisors vector"
    },
    {
        "py": "if ( target <= arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( target >= arr [ n - 1 ] ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT",
        "explain": "Corner cases"
    },
    {
        "py": "i = 0 NEW_LINE j = n NEW_LINE mid = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = ( i + j ) // 2 NEW_LINE if ( arr [ mid ] == target ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT DEDENT",
        "explain": "Perform binary search"
    },
    {
        "py": "if ( target < arr [ mid ] ) : NEW_LINE",
        "explain": "Check if target is less than the array element then search in left half"
    },
    {
        "py": "if ( mid > 0 and target > arr [ mid - 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) NEW_LINE DEDENT",
        "explain": "Check if target is greater than previous to mid , return closest of two"
    },
    {
        "py": "j = mid NEW_LINE",
        "explain": "Repeat for left half"
    },
    {
        "py": "else : NEW_LINE INDENT if ( mid < n - 1 and target < arr [ mid + 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) NEW_LINE DEDENT DEDENT",
        "explain": "Check if target is greater than mid"
    },
    {
        "py": "i = mid + 1 NEW_LINE",
        "explain": "Update i"
    },
    {
        "py": "return arr [ mid ] NEW_LINE",
        "explain": "Only single element left after search"
    },
    {
        "py": "def printClosest ( N , X ) : NEW_LINE INDENT global divisors NEW_LINE DEDENT",
        "explain": "Function to print the divisor of N closest to X"
    },
    {
        "py": "computeDivisors ( ) NEW_LINE",
        "explain": "Function call to calculate and stores divisors of all numbers in a vector"
    },
    {
        "py": "ans = findClosest ( divisors [ N ] , len ( divisors [ N ] ) , X ) NEW_LINE",
        "explain": "Stores the closest value to target"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print the answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 16 NEW_LINE X = 5 NEW_LINE",
        "explain": "Given N & X"
    },
    {
        "py": "printClosest ( N , X ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def maxMatch ( A , B ) : NEW_LINE",
        "explain": "Function to count maximum matched elements from the arrays A [ ] and B [ ]"
    },
    {
        "py": "Aindex = { } NEW_LINE",
        "explain": "Stores position of elements of array A [ ] in the array B [ ]"
    },
    {
        "py": "diff = { } NEW_LINE",
        "explain": "Keep track of difference between the indices"
    },
    {
        "py": "for i in range ( len ( A ) ) : NEW_LINE INDENT Aindex [ A [ i ] ] = i NEW_LINE DEDENT",
        "explain": "Traverse the array A [ ]"
    },
    {
        "py": "for i in range ( len ( B ) ) : NEW_LINE",
        "explain": "Traverse the array B [ ]"
    },
    {
        "py": "if i - Aindex [ B [ i ] ] < 0 : NEW_LINE INDENT if len ( A ) + i - Aindex [ B [ i ] ] not in diff : NEW_LINE INDENT diff [ len ( A ) + i - Aindex [ B [ i ] ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff [ len ( A ) + i - Aindex [ B [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "If difference is negative , add N to it"
    },
    {
        "py": "else : NEW_LINE INDENT if i - Aindex [ B [ i ] ] not in diff : NEW_LINE INDENT diff [ i - Aindex [ B [ i ] ] ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT diff [ i - Aindex [ B [ i ] ] ] += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Keep track of the number of shifts required to place elements at same indices"
    },
    {
        "py": "return max ( diff . values ( ) ) NEW_LINE",
        "explain": "Return the max matches"
    },
    {
        "py": "A = [ 5 , 3 , 7 , 9 , 8 ] NEW_LINE B = [ 8 , 7 , 3 , 5 , 9 ] NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( maxMatch ( A , B ) ) NEW_LINE",
        "explain": "Returns the count of matched elements"
    },
    {
        "py": "def isinRange ( board ) : NEW_LINE INDENT N = 9 NEW_LINE DEDENT",
        "explain": "Function to check if all elements of the board [ ] [ ] array store value in the range [ 1 , 9 ]"
    },
    {
        "py": "INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE DEDENT DEDENT",
        "explain": "Traverse board [ ] [ ] array"
    },
    {
        "py": "def isValidSudoku ( board ) : NEW_LINE INDENT N = 9 NEW_LINE DEDENT",
        "explain": "Function to check if the solution of sudoku puzzle is valid or not"
    },
    {
        "py": "INDENT if ( isinRange ( board ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT",
        "explain": "Check if all elements of board [ ] [ ] stores value in the range [ 1 , 9 ]"
    },
    {
        "py": "INDENT unique = [ False ] * ( N + 1 ) NEW_LINE DEDENT",
        "explain": "Stores unique value from 1 to N"
    },
    {
        "py": "INDENT for i in range ( 0 , N ) : NEW_LINE DEDENT",
        "explain": "Traverse each row of the given array"
    },
    {
        "py": "for m in range ( 0 , N + 1 ) : NEW_LINE unique [ m ] = False NEW_LINE",
        "explain": "Initialize unique [ ] array to false"
    },
    {
        "py": "for j in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse each column of current row"
    },
    {
        "py": "Z = board [ i ] [ j ] NEW_LINE",
        "explain": "Stores the value of board [ i ] [ j ]"
    },
    {
        "py": "if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE",
        "explain": "Check if current row stores duplicate value"
    },
    {
        "py": "INDENT for i in range ( 0 , N ) : NEW_LINE DEDENT",
        "explain": "Traverse each column of the given array"
    },
    {
        "py": "for m in range ( 0 , N + 1 ) : NEW_LINE unique [ m ] = False NEW_LINE",
        "explain": "Initialize unique [ ] array to false"
    },
    {
        "py": "for j in range ( 0 , N ) : NEW_LINE",
        "explain": "Traverse each row of current column"
    },
    {
        "py": "Z = board [ j ] [ i ] NEW_LINE",
        "explain": "Stores the value of board [ j ] [ i ]"
    },
    {
        "py": "if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE",
        "explain": "Check if current column stores duplicate value"
    },
    {
        "py": "INDENT for i in range ( 0 , N - 2 , 3 ) : NEW_LINE DEDENT",
        "explain": "Traverse each block of size 3 * 3 in board [ ] [ ] array"
    },
    {
        "py": "for j in range ( 0 , N - 2 , 3 ) : NEW_LINE",
        "explain": "j stores first column of each 3 * 3 block"
    },
    {
        "py": "for m in range ( 0 , N + 1 ) : NEW_LINE INDENT unique [ m ] = False NEW_LINE DEDENT",
        "explain": "Initialize unique [ ] array to false"
    },
    {
        "py": "for k in range ( 0 , 3 ) : NEW_LINE INDENT for l in range ( 0 , 3 ) : NEW_LINE DEDENT",
        "explain": "Traverse current block"
    },
    {
        "py": "X = i + k NEW_LINE",
        "explain": "Stores row number of current block"
    },
    {
        "py": "Y = j + l NEW_LINE",
        "explain": "Stores column number of current block"
    },
    {
        "py": "Z = board [ X ] [ Y ] NEW_LINE",
        "explain": "Stores the value of board [ X ] [ Y ]"
    },
    {
        "py": "if ( unique [ Z ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT unique [ Z ] = True NEW_LINE",
        "explain": "Check if current block stores duplicate value"
    },
    {
        "py": "INDENT return True NEW_LINE DEDENT",
        "explain": "If all conditions satisfied"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT board = [ [ 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 ] , [ 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 ] , [ 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 ] , [ 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 ] , [ 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 ] , [ 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 ] , [ 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 ] , [ 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 ] , [ 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 ] ] NEW_LINE if ( isValidSudoku ( board ) ) : NEW_LINE INDENT print ( \" Valid \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Valid \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def palindrome ( a , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE DEDENT",
        "explain": "Function to check if a number is Palindrome or not here i is the starting index and j is the last index of the subarray"
    },
    {
        "py": "if ( a [ i ] != a [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT",
        "explain": "If the integer at i is not equal to j then the subarray is not palindrome"
    },
    {
        "py": "i += 1 NEW_LINE j -= 1 NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "return True NEW_LINE",
        "explain": "all a [ i ] is equal to a [ j ] then the subarray is palindrome"
    },
    {
        "py": "def findSubArray ( arr , k ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE DEDENT",
        "explain": "Function to find a subarray whose concatenation forms a palindrome and return its starting index"
    },
    {
        "py": "for i in range ( n - k + 1 ) : NEW_LINE INDENT if ( palindrome ( arr , i , i + k - 1 ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT",
        "explain": "Iterating over subarray of length k and checking if that subarray is palindrome"
    },
    {
        "py": "return - 1 NEW_LINE",
        "explain": "If no subarray is palindrome"
    },
    {
        "py": "arr = [ 2 , 3 , 5 , 1 , 3 ] NEW_LINE k = 4 NEW_LINE ans = findSubArray ( arr , k ) NEW_LINE if ( ans == - 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( ans , ans + k ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def isCrossed ( path ) : NEW_LINE INDENT if ( len ( path ) == 0 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to check if the man crosses previous visited coordinate or not"
    },
    {
        "py": "ans = bool ( False ) NEW_LINE",
        "explain": "Stores the count of crossed vertex"
    },
    {
        "py": "Set = set ( ) NEW_LINE",
        "explain": "Stores ( x , y ) coordinates"
    },
    {
        "py": "x , y = 0 , 0 NEW_LINE Set . add ( ( x , y ) ) NEW_LINE",
        "explain": "The coordinates for the origin"
    },
    {
        "py": "for i in range ( len ( path ) ) : NEW_LINE",
        "explain": "Iterate over the string"
    },
    {
        "py": "if ( path [ i ] == ' N ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y + 1 NEW_LINE DEDENT if ( path [ i ] == ' S ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE y = y - 1 NEW_LINE DEDENT if ( path [ i ] == ' E ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x + 1 NEW_LINE DEDENT if ( path [ i ] == ' W ' ) : NEW_LINE INDENT Set . add ( ( x , y ) ) NEW_LINE x = x - 1 NEW_LINE DEDENT",
        "explain": "Condition to increment X or Y co - ordinates respectively"
    },
    {
        "py": "if ( x , y ) in Set : NEW_LINE INDENT ans = bool ( True ) NEW_LINE break NEW_LINE DEDENT",
        "explain": "Check if ( x , y ) is already visited"
    },
    {
        "py": "if ( ans ) : NEW_LINE INDENT print ( \" Crossed \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Crossed \" ) NEW_LINE DEDENT",
        "explain": "Print the result"
    },
    {
        "py": "path = \" NESW \" NEW_LINE",
        "explain": "Given string"
    },
    {
        "py": "isCrossed ( path ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "from collections import deque NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def maxWidth ( N , M , cost , s ) : NEW_LINE",
        "explain": "Function to find the maximum width of . he tree using level order traversal"
    },
    {
        "py": "adj = [ [ ] for i in range ( N ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT adj [ s [ i ] [ 0 ] ] . append ( s [ i ] [ 1 ] ) NEW_LINE DEDENT",
        "explain": "Store the edges of the tree"
    },
    {
        "py": "result = 0 NEW_LINE",
        "explain": "Stores maximum width of the tree"
    },
    {
        "py": "q = deque ( ) NEW_LINE",
        "explain": "Stores the nodes of each level"
    },
    {
        "py": "q . append ( 0 ) NEW_LINE",
        "explain": "Insert root node"
    },
    {
        "py": "while ( len ( q ) > 0 ) : NEW_LINE",
        "explain": "Perform level order traversal on the tree"
    },
    {
        "py": "count = len ( q ) NEW_LINE",
        "explain": "Stores the size of the queue"
    },
    {
        "py": "result = max ( count , result ) NEW_LINE",
        "explain": "Update maximum width"
    },
    {
        "py": "while ( count > 0 ) : NEW_LINE",
        "explain": "Push the nodes of the next level and pop the elements of the current level"
    },
    {
        "py": "temp = q . popleft ( ) NEW_LINE",
        "explain": "Get element from the front the Queue"
    },
    {
        "py": "for i in adj [ temp ] : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT count -= 1 NEW_LINE",
        "explain": "Push all nodes of the next level ."
    },
    {
        "py": "return result NEW_LINE",
        "explain": "Return the result ."
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE M = 10 NEW_LINE edges = [ ] NEW_LINE edges . append ( [ 0 , 1 ] ) NEW_LINE edges . append ( [ 0 , 2 ] ) NEW_LINE edges . append ( [ 0 , 3 ] ) NEW_LINE edges . append ( [ 1 , 4 ] ) NEW_LINE edges . append ( [ 1 , 5 ] ) NEW_LINE edges . append ( [ 3 , 6 ] ) NEW_LINE edges . append ( [ 4 , 7 ] ) NEW_LINE edges . append ( [ 6 , 1 ] ) NEW_LINE edges . append ( [ 6 , 8 ] ) NEW_LINE edges . append ( [ 6 , 9 ] ) NEW_LINE cost = [ 1 , 2 , - 1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 ] NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "print ( maxWidth ( N , M , cost , edges ) ) NEW_LINE",
        "explain": "Constructed tree is : 1 / | \\ 2 - 1 3 / \\ \\ 4 5 8 / / | \\ 2 6 12 7"
    },
    {
        "py": "MAX = 10000000 NEW_LINE",
        "explain": "Pthon3 Program to implement the above approach"
    },
    {
        "py": "isPrime = [ True ] * ( MAX + 1 ) NEW_LINE",
        "explain": "Stores if an index is a prime / non - prime value"
    },
    {
        "py": "primes = [ ] NEW_LINE",
        "explain": "Stores the prime"
    },
    {
        "py": "def SieveOfEratosthenes ( ) : NEW_LINE INDENT global isPrime NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE DEDENT",
        "explain": "Function to generate all prime numbers"
    },
    {
        "py": "if ( isPrime [ p ] == True ) : NEW_LINE",
        "explain": "If current element is prime"
    },
    {
        "py": "for i in range ( p * p , MAX + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT p += 1 NEW_LINE",
        "explain": "Set all its multiples non - prime"
    },
    {
        "py": "for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( isPrime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT",
        "explain": "Store all prime numbers"
    },
    {
        "py": "def prime_search ( primes , diff ) : NEW_LINE",
        "explain": "Function to find the closest prime to a particular number"
    },
    {
        "py": "low = 0 NEW_LINE high = len ( primes ) - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE DEDENT",
        "explain": "Applying binary search on primes vector"
    },
    {
        "py": "if ( primes [ mid ] == diff ) : NEW_LINE",
        "explain": "If the prime added makes the elements equal"
    },
    {
        "py": "return primes [ mid ] NEW_LINE",
        "explain": "Return this as the closest prime"
    },
    {
        "py": "elif ( primes [ mid ] < diff ) : NEW_LINE",
        "explain": "If the array remains non - decreasing"
    },
    {
        "py": "low = mid + 1 NEW_LINE",
        "explain": "Search for a bigger prime number"
    },
    {
        "py": "else : NEW_LINE INDENT res = primes [ mid ] NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "high = mid - 1 NEW_LINE",
        "explain": "Check if a smaller prime can make array non - decreasing or not"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return closest number"
    },
    {
        "py": "def minCost ( arr , n ) : NEW_LINE",
        "explain": "Function to find the minimum cost"
    },
    {
        "py": "SieveOfEratosthenes ( ) NEW_LINE",
        "explain": "Find all primes"
    },
    {
        "py": "res = 0 NEW_LINE",
        "explain": "Store the result"
    },
    {
        "py": "for i in range ( 1 , n ) : NEW_LINE",
        "explain": "Iterate over the array"
    },
    {
        "py": "if ( arr [ i ] < arr [ i - 1 ] ) : NEW_LINE INDENT diff = arr [ i - 1 ] - arr [ i ] NEW_LINE DEDENT",
        "explain": "Current element is less than the previous element"
    },
    {
        "py": "closest_prime = prime_search ( primes , diff ) NEW_LINE",
        "explain": "Find the closest prime which makes the array non decreasing"
    },
    {
        "py": "res += closest_prime NEW_LINE",
        "explain": "Add to overall cost"
    },
    {
        "py": "arr [ i ] += closest_prime NEW_LINE",
        "explain": "Update current element"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return the minimum cost"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 2 , 1 , 5 , 4 , 3 ] NEW_LINE n = 5 NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "print ( minCost ( arr , n ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def count ( s ) : NEW_LINE",
        "explain": "Function to return ways to split a string into three parts with the equal number of 0"
    },
    {
        "py": "cnt = 0 NEW_LINE",
        "explain": "Store total count of 0 s"
    },
    {
        "py": "for c in s : NEW_LINE INDENT if c == '0' : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Count total no . of 0 s character in given string"
    },
    {
        "py": "if ( cnt % 3 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE k = cnt // 3 NEW_LINE sum = 0 NEW_LINE",
        "explain": "If total count of 0 character is not divisible by 3"
    },
    {
        "py": "mp = { } NEW_LINE",
        "explain": "Initialize map to store frequency of k"
    },
    {
        "py": "for i in range ( len ( s ) ) : NEW_LINE",
        "explain": "Traverse string to find ways to split string"
    },
    {
        "py": "if s [ i ] == '0' : NEW_LINE INDENT sum += 1 NEW_LINE DEDENT",
        "explain": "Increment count if 0 appears"
    },
    {
        "py": "if ( sum == 2 * k and k in mp and i < len ( s ) - 1 and i > 0 ) : NEW_LINE INDENT res += mp [ k ] NEW_LINE DEDENT",
        "explain": "Increment result if sum equal to 2 * k and k exists in map"
    },
    {
        "py": "if sum in mp : NEW_LINE INDENT mp [ sum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ sum ] = 1 NEW_LINE DEDENT",
        "explain": "Insert sum in map"
    },
    {
        "py": "return res NEW_LINE",
        "explain": "Return result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "st = \"01010\" NEW_LINE",
        "explain": "Given string"
    },
    {
        "py": "print ( count ( st ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def splitstring ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT",
        "explain": "Function to calculate the number of ways to split"
    },
    {
        "py": "zeros = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Calculating the total number of zeros"
    },
    {
        "py": "if zeros % 3 != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT",
        "explain": "Case1 If total count of zeros is not divisible by 3"
    },
    {
        "py": "if zeros == 0 : NEW_LINE INDENT return ( ( n - 1 ) * ( n - 2 ) ) // 2 NEW_LINE DEDENT",
        "explain": "Case2 if total count of zeros is zero"
    },
    {
        "py": "zerosInEachSubstring = zeros // 3 NEW_LINE",
        "explain": "Number of zeros in each substring"
    },
    {
        "py": "waysOfFirstCut , waysOfSecondCut = 0 , 0 NEW_LINE",
        "explain": "Initialising zero to the number of ways for first and second cut"
    },
    {
        "py": "count = 0 NEW_LINE",
        "explain": "Initializing the count"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traversing from the beginning"
    },
    {
        "py": "' NEW_LINE INDENT if s [ i ] == '0' : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Incrementing the count if the element is '0"
    },
    {
        "py": "if ( count == zerosInEachSubstring ) : NEW_LINE INDENT waysOfFirstCut += 1 NEW_LINE DEDENT",
        "explain": "Incrementing the ways for the 1 st cut if count is equal to zeros required in each substring"
    },
    {
        "py": "elif ( count == 2 * zerosInEachSubstring ) : NEW_LINE INDENT waysOfSecondCut += 1 NEW_LINE DEDENT",
        "explain": "Incrementing the ways for the 2 nd cut if count is equal to 2 * ( zeros required in each substring )"
    },
    {
        "py": "return waysOfFirstCut * waysOfSecondCut NEW_LINE",
        "explain": "Total number of ways to split is multiplication of ways for the 1 st and 2 nd cut"
    },
    {
        "py": "s = \"01010\" NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "print ( \" The \u2581 number \u2581 of \u2581 ways \u2581 to \u2581 split \u2581 is \" , splitstring ( s ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def canTransform ( str1 , str2 ) : NEW_LINE INDENT s1 = \" \" NEW_LINE s2 = \" \" NEW_LINE DEDENT",
        "explain": "Function to check if it is possible to transform start to end"
    },
    {
        "py": "for c in str1 : NEW_LINE INDENT if ( c != ' C ' ) : NEW_LINE INDENT s1 += c NEW_LINE DEDENT DEDENT for c in str2 : NEW_LINE INDENT if ( c != ' C ' ) : NEW_LINE INDENT s2 += c NEW_LINE DEDENT DEDENT",
        "explain": "Check the sequence of A , B in both strings str1 and str2"
    },
    {
        "py": "if ( s1 != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE n = len ( str1 ) NEW_LINE",
        "explain": "If both the strings are not equal"
    },
    {
        "py": "while ( i < n and j < n ) : NEW_LINE INDENT if ( str1 [ i ] == ' C ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( str2 [ j ] == ' C ' ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Traverse the strings"
    },
    {
        "py": "else : NEW_LINE INDENT if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE",
        "explain": "Check for indexes of A and B"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" BCCABCBCA \" NEW_LINE str2 = \" CBACCBBAC \" NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "if ( canTransform ( str1 , str2 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Function call"
    },
    {
        "py": "def maxsubstringLength ( S , N ) : NEW_LINE INDENT arr = [ 0 ] * N NEW_LINE DEDENT",
        "explain": "Function to return the length of the longest substring having equal number of vowel and consonant"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' a ' or S [ i ] == ' e ' or S [ i ] == ' i ' or S [ i ] == ' o ' or S [ i ] == ' u ' ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT DEDENT",
        "explain": "Generate the array"
    },
    {
        "py": "maxLen = 0 NEW_LINE",
        "explain": "Initialize variable to store result"
    },
    {
        "py": "curr_sum = 0 NEW_LINE",
        "explain": "Stores the sum of subarray"
    },
    {
        "py": "hash = { } NEW_LINE",
        "explain": "Map to store indices of the sum"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Loop through the array"
    },
    {
        "py": "if ( curr_sum == 0 ) : NEW_LINE",
        "explain": "If sum is 0"
    },
    {
        "py": "maxLen = max ( maxLen , i + 1 ) NEW_LINE",
        "explain": "Count of vowels and consonants are equal"
    },
    {
        "py": "if ( curr_sum in hash . keys ( ) ) : NEW_LINE INDENT maxLen = max ( maxLen , i - hash [ curr_sum ] ) NEW_LINE DEDENT",
        "explain": "Update the maximum length of substring in HashMap"
    },
    {
        "py": "else : NEW_LINE INDENT hash [ curr_sum ] = i NEW_LINE DEDENT",
        "explain": "Store the index of the sum"
    },
    {
        "py": "return maxLen NEW_LINE",
        "explain": "Return the maximum length of required substring"
    },
    {
        "py": "S = \" geeksforgeeks \" NEW_LINE n = len ( S ) NEW_LINE print ( maxsubstringLength ( S , n ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "mat = [ [ 0 for x in range ( 1001 ) ] for y in range ( 1001 ) ] NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "dx = [ 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 ] NEW_LINE dy = [ 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 ] NEW_LINE",
        "explain": "Stores the accessible directions"
    },
    {
        "py": "def FindMinimumDistance ( ) : NEW_LINE INDENT global x , y , r , c NEW_LINE DEDENT",
        "explain": "Function to find the minimum distance from a given cell to all other cells in the matrix"
    },
    {
        "py": "q = [ ] NEW_LINE",
        "explain": "Stores the accessible cells from current cell"
    },
    {
        "py": "q . append ( [ x , y ] ) NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE",
        "explain": "Insert pair ( x , y )"
    },
    {
        "py": "while ( len ( q ) != 0 ) : NEW_LINE",
        "explain": "Iterate untill queue is empty"
    },
    {
        "py": "x = q [ 0 ] [ 0 ] NEW_LINE y = q [ 0 ] [ 1 ] NEW_LINE",
        "explain": "Extract the pair"
    },
    {
        "py": "q . pop ( 0 ) NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT a = x + dx [ i ] NEW_LINE b = y + dy [ i ] NEW_LINE DEDENT",
        "explain": "Pop them"
    },
    {
        "py": "if ( a < 0 or a >= r or b >= c or b < 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT",
        "explain": "Checking boundary condition"
    },
    {
        "py": "if ( mat [ a ] [ b ] == 0 ) : NEW_LINE",
        "explain": "If the cell is not visited"
    },
    {
        "py": "mat [ a ] [ b ] = mat [ x ] [ y ] + 1 NEW_LINE",
        "explain": "Assign the minimum distance"
    },
    {
        "py": "q . append ( [ a , b ] ) NEW_LINE",
        "explain": "Insert the traversed neighbour into the queue"
    },
    {
        "py": "r = 5 NEW_LINE c = 5 NEW_LINE x = 1 NEW_LINE y = 1 NEW_LINE t = x NEW_LINE l = y NEW_LINE mat [ x ] [ y ] = 0 NEW_LINE FindMinimumDistance ( ) NEW_LINE mat [ t ] [ l ] = 0 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Print the required distances"
    },
    {
        "py": "def minOperations ( S , K ) : NEW_LINE",
        "explain": "Function that returns the minimum number of flips to convert the s into a concatenation of K - length sub - string"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the result"
    },
    {
        "py": "for i in range ( K ) : NEW_LINE",
        "explain": "Iterate through string index"
    },
    {
        "py": "zero , one = 0 , 0 NEW_LINE",
        "explain": "Stores count of 0 s & 1 s"
    },
    {
        "py": "for j in range ( i , len ( S ) , K ) : NEW_LINE",
        "explain": "Iterate making K jumps"
    },
    {
        "py": "if ( S [ j ] == '0' ) : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT",
        "explain": "Count 0 's"
    },
    {
        "py": "else : NEW_LINE INDENT one += 1 NEW_LINE DEDENT",
        "explain": "Count 1 's"
    },
    {
        "py": "ans += min ( zero , one ) NEW_LINE",
        "explain": "Add minimum flips for index i"
    },
    {
        "py": "return ans NEW_LINE",
        "explain": "Return minimum number of flips"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = \"110100101\" NEW_LINE K = 3 NEW_LINE print ( minOperations ( s , K ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def missingElement ( arr , n ) : NEW_LINE",
        "explain": "Function to get the missing element"
    },
    {
        "py": "max_ele = arr [ 0 ] NEW_LINE",
        "explain": "For maximum element in the array"
    },
    {
        "py": "min_ele = arr [ 0 ] NEW_LINE",
        "explain": "For minimum Element in the array"
    },
    {
        "py": "x = 0 NEW_LINE",
        "explain": "For xor of all elements"
    },
    {
        "py": "d = 0 NEW_LINE",
        "explain": "Common difference of AP series"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min_ele ) : NEW_LINE INDENT min_ele = arr [ i ] NEW_LINE DEDENT DEDENT",
        "explain": "Find maximum and minimum element"
    },
    {
        "py": "d = ( max_ele - min_ele ) // n NEW_LINE",
        "explain": "Calculating common difference"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT",
        "explain": "Calculate the XOR of all elements"
    },
    {
        "py": "for i in range ( n + 1 ) : NEW_LINE INDENT x = x ^ ( min_ele + ( i * d ) ) NEW_LINE DEDENT",
        "explain": "Perform XOR with actual AP series resultant x will be the ans"
    },
    {
        "py": "return x NEW_LINE",
        "explain": "Return the missing element"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "arr = [ 12 , 3 , 6 , 15 , 18 ] NEW_LINE n = len ( arr ) NEW_LINE",
        "explain": "Given array"
    },
    {
        "py": "element = missingElement ( arr , n ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "print ( element ) NEW_LINE",
        "explain": "Print the missing element"
    },
    {
        "py": "def Printksubstring ( str1 , n , k ) : NEW_LINE",
        "explain": "Function to prints kth sub - string"
    },
    {
        "py": "total = int ( ( n * ( n + 1 ) ) / 2 ) NEW_LINE",
        "explain": "Total sub - strings possible"
    },
    {
        "py": "if ( k > total ) : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE return NEW_LINE DEDENT",
        "explain": "If k is greater than total number of sub - strings"
    },
    {
        "py": "substring = [ 0 for i in range ( n + 1 ) ] NEW_LINE substring [ 0 ] = 0 NEW_LINE",
        "explain": "To store number of sub - strings starting with ith character of the string"
    },
    {
        "py": "temp = n NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE",
        "explain": "Compute the values"
    },
    {
        "py": "substring [ i ] = substring [ i - 1 ] + temp NEW_LINE temp -= 1 NEW_LINE",
        "explain": "substring [ i - 1 ] is added to store the cumulative sum"
    },
    {
        "py": "l = 1 NEW_LINE h = n NEW_LINE start = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = int ( ( l + h ) / 2 ) NEW_LINE if ( substring [ m ] > k ) : NEW_LINE INDENT start = m NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( substring [ m ] < k ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = m NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Binary search to find the starting index of the kth sub - string"
    },
    {
        "py": "end = n - ( substring [ start ] - k ) NEW_LINE",
        "explain": "To store the ending index of the kth sub - string"
    },
    {
        "py": "for i in range ( start - 1 , end ) : NEW_LINE INDENT print ( str1 [ i ] , end = \" \" ) NEW_LINE DEDENT",
        "explain": "Print the sub - string"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = \" abc \" NEW_LINE k = 4 NEW_LINE n = len ( str1 ) NEW_LINE Printksubstring ( str1 , n , k ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def LowerInsertionPoint ( arr , n , X ) : NEW_LINE",
        "explain": "Function to return the lower insertion point of an element in a sorted array"
    },
    {
        "py": "if ( X < arr [ 0 ] ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( X > arr [ n - 1 ] ) : NEW_LINE INDENT return n NEW_LINE DEDENT lowerPnt = 0 NEW_LINE i = 1 NEW_LINE while ( i < n and arr [ i ] < X ) : NEW_LINE INDENT lowerPnt = i NEW_LINE i = i * 2 NEW_LINE DEDENT",
        "explain": "Base cases"
    },
    {
        "py": "while ( lowerPnt < n and arr [ lowerPnt ] < X ) : NEW_LINE INDENT lowerPnt += 1 NEW_LINE DEDENT return lowerPnt NEW_LINE",
        "explain": "Final check for the remaining elements which are < X"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE X = 4 NEW_LINE print ( LowerInsertionPoint ( arr , n , X ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def getCount ( M , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT",
        "explain": "Returns count of required positions"
    },
    {
        "py": "if ( M == 1 ) : NEW_LINE INDENT return N ; NEW_LINE DEDENT",
        "explain": "horizontal 1D array"
    },
    {
        "py": "if ( N == 1 ) : NEW_LINE INDENT return M ; NEW_LINE DEDENT if ( N > M ) : NEW_LINE",
        "explain": "vertical 1D array"
    },
    {
        "py": "for i in range ( 1 , M + 1 ) : NEW_LINE INDENT numerator = N * i - N + M - i ; NEW_LINE denominator = M - 1 ; NEW_LINE DEDENT",
        "explain": "iterating for all possible i"
    },
    {
        "py": "if ( numerator % denominator == 0 ) : NEW_LINE INDENT j = numerator / denominator ; NEW_LINE DEDENT",
        "explain": "checking if j is integer"
    },
    {
        "py": "if ( j >= 1 and j <= N ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT else : NEW_LINE",
        "explain": "checking if j lies b / w 1 to N"
    },
    {
        "py": "for j in range ( 1 , N + 1 ) : NEW_LINE INDENT numerator = M * j - M + N - j ; NEW_LINE denominator = N - 1 ; NEW_LINE DEDENT",
        "explain": "iterating for all possible j"
    },
    {
        "py": "if ( numerator % denominator == 0 ) : NEW_LINE INDENT i = numerator / denominator ; NEW_LINE DEDENT",
        "explain": "checking if i is integer"
    },
    {
        "py": "if ( i >= 1 and i <= M ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE",
        "explain": "checking if i lies b / w 1 to M"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M , N = 3 , 5 ; NEW_LINE print ( getCount ( M , N ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program to make array sorted"
    },
    {
        "py": "def swapElement ( arr1 , arr2 , n ) : NEW_LINE",
        "explain": "Function to check whether there is any swappable element present to make the first array sorted"
    },
    {
        "py": "wrongIdx = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr1 [ i - 1 ] ) : NEW_LINE INDENT wrongIdx = i NEW_LINE DEDENT DEDENT maximum = - ( sys . maxsize - 1 ) NEW_LINE maxIdx = - 1 NEW_LINE res = False NEW_LINE",
        "explain": "wrongIdx is the index of the element which is making the first array unsorted"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( arr2 [ i ] > maximum and arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) : NEW_LINE INDENT if ( wrongIdx + 1 <= n - 1 and arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) : NEW_LINE INDENT maximum = arr2 [ i ] NEW_LINE maxIdx = i NEW_LINE res = True NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Find the maximum element which satisfies the above mentioned neighboring conditions"
    },
    {
        "py": "if ( res ) : NEW_LINE INDENT ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) = ( arr2 [ maxIdx ] , arr1 [ wrongIdx ] ) NEW_LINE DEDENT return res NEW_LINE",
        "explain": "if res is true then swap the element and make the first array sorted"
    },
    {
        "py": "def getSortedArray ( arr1 , arr2 , n ) : NEW_LINE INDENT if ( swapElement ( arr1 , arr2 , n ) ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr1 [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( \" Not \u2581 Possible \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to print the sorted array if elements are swapped ."
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr1 = [ 1 , 3 , 7 , 4 , 10 ] NEW_LINE arr2 = [ 2 , 1 , 6 , 8 , 9 ] NEW_LINE n = len ( arr1 ) NEW_LINE getSortedArray ( arr1 , arr2 , n ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def middleOfThree ( a , b , c ) : NEW_LINE",
        "explain": "Function to find the middle of three numbers"
    },
    {
        "py": "if a > b : NEW_LINE INDENT if ( b > c ) : NEW_LINE INDENT return b NEW_LINE DEDENT elif ( a > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return a NEW_LINE DEDENT DEDENT else : NEW_LINE",
        "explain": "Compare each three number to find middle number . Enter only if a > b"
    },
    {
        "py": "if ( a > c ) : NEW_LINE INDENT return a NEW_LINE DEDENT elif ( b > c ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT",
        "explain": "Decided a is not greater than b ."
    },
    {
        "py": "a = 20 NEW_LINE b = 30 NEW_LINE c = 40 NEW_LINE print ( middleOfThree ( a , b , c ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def transpose ( mat , row , col ) : NEW_LINE",
        "explain": "Function to find the transpose of the matrix mat [ ]"
    },
    {
        "py": "tr = [ [ 0 for i in range ( row ) ] for i in range ( col ) ] NEW_LINE",
        "explain": "Stores the transpose of matrix mat [ ] [ ]"
    },
    {
        "py": "for i in range ( row ) : NEW_LINE",
        "explain": "Traverse each row of the matrix"
    },
    {
        "py": "for j in range ( col ) : NEW_LINE",
        "explain": "Traverse each column of the matrix"
    },
    {
        "py": "tr [ j ] [ i ] = mat [ i ] [ j ] NEW_LINE return tr NEW_LINE",
        "explain": "Transpose matrix elements"
    },
    {
        "py": "def RowWiseSort ( B ) : NEW_LINE",
        "explain": "Function to sort the given matrix in row wise manner"
    },
    {
        "py": "for i in range ( len ( B ) ) : NEW_LINE",
        "explain": "Traverse the row"
    },
    {
        "py": "B [ i ] = sorted ( B [ i ] ) NEW_LINE return B NEW_LINE",
        "explain": "Row - Wise Sorting"
    },
    {
        "py": "def sortCol ( mat , N , M ) : NEW_LINE",
        "explain": "Function to print the matrix in column wise sorted manner"
    },
    {
        "py": "B = transpose ( mat , N , M ) NEW_LINE",
        "explain": "Function call to find transpose of the the matrix mat [ ] [ ]"
    },
    {
        "py": "B = RowWiseSort ( B ) NEW_LINE",
        "explain": "Sorting the matrix row - wise"
    },
    {
        "py": "mat = transpose ( B , M , N ) NEW_LINE",
        "explain": "Calculate transpose of B [ ] [ ]"
    },
    {
        "py": "for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT",
        "explain": "Print the matrix mat [ ] [ ]"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "mat = [ [ 1 , 6 , 10 ] , [ 8 , 5 , 9 ] , [ 9 , 4 , 15 ] , [ 7 , 3 , 60 ] ] NEW_LINE N = len ( mat ) NEW_LINE M = len ( mat [ 0 ] ) NEW_LINE",
        "explain": "Input"
    },
    {
        "py": "sortCol ( mat , N , M ) NEW_LINE",
        "explain": "Function call to print the matrix in column wise sorted manner"
    },
    {
        "py": "def largestArea ( N , M , H , V , h , v ) : NEW_LINE",
        "explain": "Function to find the largest area when a series of horizontal & vertical bars are removed"
    },
    {
        "py": "INDENT s1 = set ( [ ] ) ; NEW_LINE s2 = set ( [ ] ) ; NEW_LINE DEDENT",
        "explain": "Stores all bars"
    },
    {
        "py": "INDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT s1 . add ( i ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Insert horizontal bars"
    },
    {
        "py": "INDENT for i in range ( 1 , M + 2 ) : NEW_LINE INDENT s2 . add ( i ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Insert vertictal bars"
    },
    {
        "py": "INDENT for i in range ( h ) : NEW_LINE INDENT s1 . remove ( H [ i ] ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Remove horizontal separators from s1"
    },
    {
        "py": "INDENT for i in range ( v ) : NEW_LINE INDENT s2 . remove ( V [ i ] ) ; NEW_LINE DEDENT DEDENT",
        "explain": "Remove vertical separators from s2"
    },
    {
        "py": "INDENT list1 = [ 0 ] * len ( s1 ) NEW_LINE list2 = [ 0 ] * len ( s2 ) ; NEW_LINE i = 0 ; NEW_LINE for it1 in s1 : NEW_LINE INDENT list1 [ i ] = it1 ; NEW_LINE i += 1 NEW_LINE DEDENT i = 0 ; NEW_LINE for it2 in s2 : NEW_LINE INDENT list2 [ i ] = it2 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT",
        "explain": "Stores left out horizontal and vertical separators"
    },
    {
        "py": "INDENT list1 . sort ( ) ; NEW_LINE list2 . sort ( ) ; NEW_LINE maxH = 0 NEW_LINE p1 = 0 NEW_LINE maxV = 0 NEW_LINE p2 = 0 ; NEW_LINE DEDENT",
        "explain": "Sort both list in ascending order"
    },
    {
        "py": "INDENT for j in range ( len ( s1 ) ) : NEW_LINE INDENT maxH = max ( maxH , list1 [ j ] - p1 ) ; NEW_LINE p1 = list1 [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Find maximum difference of neighbors of list1"
    },
    {
        "py": "INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT maxV = max ( maxV , list2 [ j ] - p2 ) ; NEW_LINE p2 = list2 [ j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Find max difference of neighbors of list2"
    },
    {
        "py": "INDENT print ( ( maxV * maxH ) ) NEW_LINE DEDENT",
        "explain": "Print largest volume"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "INDENT N = 3 NEW_LINE M = 3 ; NEW_LINE DEDENT",
        "explain": "Given value of N & M"
    },
    {
        "py": "INDENT H = [ 2 ] NEW_LINE V = [ 2 ] ; NEW_LINE h = len ( H ) NEW_LINE v = len ( V ) ; NEW_LINE DEDENT",
        "explain": "Given arrays"
    },
    {
        "py": "INDENT largestArea ( N , M , H , V , h , v ) ; NEW_LINE DEDENT",
        "explain": "Function call to find the largest area when a series of horizontal & vertical bars are removed"
    },
    {
        "py": "def checkifSorted ( A , B , N ) : NEW_LINE",
        "explain": "Function to check if array , A [ ] can be converted into sorted array by swapping ( A [ i ] , A [ j ] ) if B [ i ] not equal to B [ j ]"
    },
    {
        "py": "INDENT flag = False NEW_LINE DEDENT",
        "explain": "Stores if array A [ ] is sorted in descending order or not"
    },
    {
        "py": "INDENT for i in range ( N - 1 ) : NEW_LINE DEDENT",
        "explain": "Traverse the array A [ ]"
    },
    {
        "py": "if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE",
        "explain": "If A [ i ] is greater than A [ i + 1 ]"
    },
    {
        "py": "flag = True NEW_LINE break NEW_LINE",
        "explain": "Update flag"
    },
    {
        "py": "INDENT if ( not flag ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT",
        "explain": "If array is sorted in ascending order"
    },
    {
        "py": "INDENT count = 0 NEW_LINE DEDENT",
        "explain": "count = 2 : Check if 0 s and 1 s both present in the B [ ]"
    },
    {
        "py": "INDENT for i in range ( N ) : NEW_LINE DEDENT",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( B [ i ] == 0 ) : NEW_LINE",
        "explain": "If current element is 0"
    },
    {
        "py": "count += 1 NEW_LINE break NEW_LINE",
        "explain": "Update count"
    },
    {
        "py": "INDENT for i in range ( N ) : NEW_LINE DEDENT",
        "explain": "Traverse the array B [ ]"
    },
    {
        "py": "if B [ i ] : NEW_LINE count += 1 NEW_LINE break NEW_LINE",
        "explain": "If current element is 1"
    },
    {
        "py": "INDENT if ( count == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT",
        "explain": "If both 0 s and 1 s are present in the array"
    },
    {
        "py": "A = [ 3 , 1 , 2 ] NEW_LINE",
        "explain": "Input array A [ ]"
    },
    {
        "py": "B = [ 0 , 1 , 1 ] NEW_LINE N = len ( A ) NEW_LINE",
        "explain": "Input array B [ ]"
    },
    {
        "py": "check = checkifSorted ( A , B , N ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "if ( check ) : NEW_LINE INDENT print ( \" YES \" ) NEW_LINE DEDENT",
        "explain": "If true , print YES"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" NO \" ) NEW_LINE DEDENT",
        "explain": "Else print NO"
    },
    {
        "py": "def minSteps ( A , B , M , N ) : NEW_LINE INDENT if ( A [ 0 ] > B [ 0 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B [ 0 ] > A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT",
        "explain": "Function to find the minimum number of steps to make A > B"
    },
    {
        "py": "if ( M <= N and A [ 0 ] == B [ 0 ] and A . count ( A [ 0 ] ) == M and B . count ( B [ 0 ] ) == N ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT",
        "explain": "If all character are same and M <= N"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] > B [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT",
        "explain": "If there lies any character in B which is greater than B [ 0 ]"
    },
    {
        "py": "for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] < A [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT",
        "explain": "If there lies any character in A which is smaller than A [ 0 ]"
    },
    {
        "py": "for i in range ( 1 , M ) : NEW_LINE INDENT if ( A [ i ] > A [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT",
        "explain": "If there lies a character which is in A and greater than A [ 0 ]"
    },
    {
        "py": "for i in range ( 1 , N ) : NEW_LINE INDENT if ( B [ i ] < B [ 0 ] ) : NEW_LINE INDENT A [ 0 ] , B [ i ] = B [ i ] , A [ 0 ] NEW_LINE A [ 0 ] , B [ 0 ] = B [ 0 ] , A [ 0 ] NEW_LINE return 2 NEW_LINE DEDENT DEDENT",
        "explain": "If there lies a character which is in B and less than B [ 0 ]"
    },
    {
        "py": "return 0 NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = \" adsfd \" NEW_LINE B = \" dffff \" NEW_LINE M = len ( A ) NEW_LINE N = len ( B ) NEW_LINE print ( minSteps ( A , B , M , N ) ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "maxN = 201 ; NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "n1 , n2 , n3 = 0 , 0 , 0 ; NEW_LINE",
        "explain": "Variables which represent the size of the array"
    },
    {
        "py": "dp = [ [ [ 0 for i in range ( maxN ) ] for j in range ( maxN ) ] for j in range ( maxN ) ] ; NEW_LINE",
        "explain": "Stores the results"
    },
    {
        "py": "def getMaxSum ( i , j , k , arr1 , arr2 , arr3 ) : NEW_LINE",
        "explain": "Function to return the maximum possible sum"
    },
    {
        "py": "cnt = 0 ; NEW_LINE if ( i >= n1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( j >= n2 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT if ( k >= n3 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT",
        "explain": "Stores the count of arrays processed"
    },
    {
        "py": "if ( cnt >= 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT",
        "explain": "If more than two arrays have been processed"
    },
    {
        "py": "if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] ; NEW_LINE DEDENT ans = 0 ; NEW_LINE",
        "explain": "If an already computed subproblem occurred"
    },
    {
        "py": "if ( i < n1 and j < n2 ) : NEW_LINE",
        "explain": "Explore all the possible pairs"
    },
    {
        "py": "ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; NEW_LINE if ( i < n1 and k < n3 ) : NEW_LINE ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; NEW_LINE if ( j < n2 and k < n3 ) : NEW_LINE ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; NEW_LINE",
        "explain": "Recursive function call"
    },
    {
        "py": "dp [ i ] [ j ] [ k ] = ans ; NEW_LINE",
        "explain": "Memoize the maximum"
    },
    {
        "py": "return dp [ i ] [ j ] [ k ] ; NEW_LINE def reverse ( tmp ) : NEW_LINE i , k , t = 0 , 0 , 0 ; NEW_LINE n = len ( tmp ) ; NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT t = tmp [ i ] ; NEW_LINE tmp [ i ] = tmp [ n - i - 1 ] ; NEW_LINE tmp [ n - i - 1 ] = t ; NEW_LINE DEDENT",
        "explain": "Returning the value"
    },
    {
        "py": "def maxProductSum ( arr1 , arr2 , arr3 ) : NEW_LINE",
        "explain": "Function to return the maximum sum of products of pairs possible"
    },
    {
        "py": "for i in range ( len ( dp ) ) : NEW_LINE INDENT for j in range ( len ( dp [ 0 ] ) ) : NEW_LINE INDENT for k in range ( len ( dp [ j ] [ 0 ] ) ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = - 1 ; NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Initialising the dp array to - 1"
    },
    {
        "py": "arr1 . sort ( ) ; NEW_LINE reverse ( arr1 ) ; NEW_LINE arr2 . sort ( ) ; NEW_LINE reverse ( arr2 ) ; NEW_LINE arr3 . sort ( ) ; NEW_LINE reverse ( arr3 ) ; NEW_LINE return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; NEW_LINE",
        "explain": "Sort the arrays in descending order"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 2 ; NEW_LINE arr1 = [ 3 , 5 ] ; NEW_LINE n2 = 2 ; NEW_LINE arr2 = [ 2 , 1 ] ; NEW_LINE n3 = 3 ; NEW_LINE arr3 = [ 4 , 3 , 5 ] ; NEW_LINE print ( maxProductSum ( arr1 , arr2 , arr3 ) ) ; NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def findTriplet ( arr , N ) : NEW_LINE",
        "explain": "Function to find lexicographically largest triplet that forms a triangle in the given array"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "i = N - 1 NEW_LINE while i - 2 >= 0 : NEW_LINE",
        "explain": "Iterate from the end of the array"
    },
    {
        "py": "if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE",
        "explain": "If the triplet forms a triangle"
    },
    {
        "py": "if ( flag ) : NEW_LINE",
        "explain": "If triplet found"
    },
    {
        "py": "print ( arr [ i - 2 ] , arr [ i - 1 ] , arr [ i ] ) NEW_LINE",
        "explain": "Print the triplet"
    },
    {
        "py": "else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT",
        "explain": "Otherwise"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 10 , 3 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE findTriplet ( arr , N ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def numberofpairs ( arr , N ) : NEW_LINE",
        "explain": "Function to return the count of all pairs having minimal absolute difference"
    },
    {
        "py": "answer = 0 NEW_LINE",
        "explain": "Stores the count of pairs"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the array"
    },
    {
        "py": "minDiff = 10000000 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE",
        "explain": "Stores the minimum difference between adjacent pairs"
    },
    {
        "py": "minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE if arr [ i + 1 ] - arr [ i ] == minDiff : NEW_LINE",
        "explain": "Update the minimum difference between pairs"
    },
    {
        "py": "answer += 1 NEW_LINE",
        "explain": "Increase count of pairs with difference equal to that of minimum difference"
    },
    {
        "py": "return answer NEW_LINE",
        "explain": "Return the final count"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "arr = [ 4 , 2 , 1 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE",
        "explain": "Given array arr [ ]"
    },
    {
        "py": "print ( numberofpairs ( arr , N ) ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "max_length = 0 NEW_LINE",
        "explain": "Initialise maximum possible length of subsequence"
    },
    {
        "py": "store = [ ] NEW_LINE",
        "explain": "Store elements to compare max_length with its size and change the value of max_length accordingly"
    },
    {
        "py": "ans = [ ] NEW_LINE",
        "explain": "Store the elements of the longest subsequence"
    },
    {
        "py": "def find_max_length ( arr , index , sum , k ) : NEW_LINE INDENT global max_length NEW_LINE sum = sum + arr [ index ] NEW_LINE store . append ( arr [ index ] ) NEW_LINE if ( sum == k ) : NEW_LINE INDENT if ( max_length < len ( store ) ) : NEW_LINE DEDENT DEDENT",
        "explain": "Function to find the length of longest subsequence"
    },
    {
        "py": "max_length = len ( store ) NEW_LINE",
        "explain": "Update max_length"
    },
    {
        "py": "ans = store NEW_LINE for i in range ( index + 1 , len ( arr ) ) : NEW_LINE if ( sum + arr [ i ] <= k ) : NEW_LINE",
        "explain": "Store the subsequence elements"
    },
    {
        "py": "find_max_length ( arr , i , sum , k ) NEW_LINE",
        "explain": "Recursively proceed with obtained sum"
    },
    {
        "py": "store . pop ( ) NEW_LINE",
        "explain": "poping elements from back of vector store"
    },
    {
        "py": "else : NEW_LINE INDENT return NEW_LINE DEDENT return NEW_LINE def longestSubsequence ( arr , n , k ) : NEW_LINE",
        "explain": "if sum > 0 then we don 't  required thatsubsequence  so return and continue  with earlier elements"
    },
    {
        "py": "arr . sort ( ) NEW_LINE",
        "explain": "Sort the given array"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( max_length >= n - i ) : NEW_LINE INDENT break NEW_LINE DEDENT store . clear ( ) NEW_LINE find_max_length ( arr , i , 0 , k ) NEW_LINE return max_length NEW_LINE",
        "explain": "If max_length is already greater than or equal than remaining length"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ - 3 , 0 , 1 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( longestSubsequence ( arr , n , k ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def sortArray ( A , N ) : NEW_LINE",
        "explain": "Function to sort array"
    },
    {
        "py": "if ( N % 4 == 0 or N % 4 == 1 ) : NEW_LINE",
        "explain": "Check if possible to sort array"
    },
    {
        "py": "for i in range ( N // 2 ) : NEW_LINE INDENT x = i NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT y = N - i - 2 NEW_LINE z = N - i - 1 NEW_LINE DEDENT DEDENT",
        "explain": "Swapping to bring element at required position Bringing at least one element at correct position"
    },
    {
        "py": "A [ z ] = A [ y ] NEW_LINE A [ y ] = A [ x ] NEW_LINE A [ x ] = x + 1 NEW_LINE",
        "explain": "Tracing changes in Array"
    },
    {
        "py": "print ( \" Sorted \u2581 Array : \u2581 \" , end = \" \" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Print the sorted array"
    },
    {
        "py": "else : NEW_LINE INDENT print ( \" - 1\" ) NEW_LINE DEDENT",
        "explain": "If not possible to sort"
    },
    {
        "py": "A = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE sortArray ( A , N ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def findK ( arr , size , N ) : NEW_LINE",
        "explain": "Function to return K such that changing all elements greater than K to K will make array sum N otherwise return - 1"
    },
    {
        "py": "arr = sorted ( arr ) NEW_LINE temp_sum = 0 NEW_LINE",
        "explain": "Sorting the array in increasing order"
    },
    {
        "py": "for i in range ( size ) : NEW_LINE INDENT temp_sum += arr [ i ] NEW_LINE DEDENT",
        "explain": "Loop through all the elements of the array"
    },
    {
        "py": "if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT return - 1 NEW_LINE",
        "explain": "Checking if sum of array equals N"
    },
    {
        "py": "arr = [ 3 , 1 , 10 , 4 , 8 ] NEW_LINE size = len ( arr ) NEW_LINE N = 16 NEW_LINE print ( findK ( arr , size , N ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def existsTriplet ( a , b , c , x , l1 , l2 , l3 ) : NEW_LINE",
        "explain": "Function that returns True if there exists a triplet with sum x"
    },
    {
        "py": "if ( l2 <= l1 and l2 <= l3 ) : NEW_LINE INDENT l1 , l2 = l2 , l1 NEW_LINE a , b = b , a NEW_LINE DEDENT elif ( l3 <= l1 and l3 <= l2 ) : NEW_LINE INDENT l1 , l3 = l3 , l1 NEW_LINE a , c = c , a NEW_LINE DEDENT",
        "explain": "Sorting arrays such that a represents smallest array"
    },
    {
        "py": "for i in range ( l1 ) : NEW_LINE",
        "explain": "Iterating the smallest array"
    },
    {
        "py": "j = 0 NEW_LINE k = l3 - 1 NEW_LINE while ( j < l2 and k >= 0 ) : NEW_LINE",
        "explain": "Two pointers on second and third array"
    },
    {
        "py": "if ( a [ i ] + b [ j ] + c [ k ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( a [ i ] + b [ j ] + c [ k ] < x ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT return False NEW_LINE",
        "explain": "If a valid triplet is found"
    },
    {
        "py": "a = [ 2 , 7 , 8 , 10 , 15 ] NEW_LINE b = [ 1 , 6 , 7 , 8 ] NEW_LINE c = [ 4 , 5 , 5 ] NEW_LINE l1 = len ( a ) NEW_LINE l2 = len ( b ) NEW_LINE l3 = len ( c ) NEW_LINE x = 14 NEW_LINE if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Utility function to print the contents of an array"
    },
    {
        "py": "def compare ( num1 , num2 ) : NEW_LINE",
        "explain": "A comparison function that return true if ' AB ' is smaller than ' BA ' when we concatenate two numbers ' A ' and ' B ' For example , it will return true if we pass 12 and 24 as arguments . This function will be used by sort ( ) function"
    },
    {
        "py": "A = str ( num1 ) NEW_LINE",
        "explain": "Convert first number to string format"
    },
    {
        "py": "B = str ( num2 ) NEW_LINE",
        "explain": "Convert second number to string format"
    },
    {
        "py": "return int ( A + B ) <= int ( B + A ) NEW_LINE",
        "explain": "Check if ' AB ' is smaller or ' BA ' and return bool value since comparison operator ' < = ' returns true or false"
    },
    {
        "py": "def printSmallest ( N , arr ) : NEW_LINE",
        "explain": "Function to print the arrangement with the smallest value"
    },
    {
        "py": "sort ( arr ) NEW_LINE",
        "explain": "If we pass the name of the comparison function it will sort the array according to the compare function"
    },
    {
        "py": "printArr ( arr , N ) NEW_LINE",
        "explain": "Print the sorted array"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT arr = [ 5 , 6 , 2 , 9 , 21 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE printSmallest ( N , arr ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def stableSelectionSort ( a , n ) : NEW_LINE",
        "explain": "Python3 program for modifying Selection Sort so that it becomes stable ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse through all array elements"
    },
    {
        "py": "min_idx = i NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ min_idx ] > a [ j ] : NEW_LINE INDENT min_idx = j NEW_LINE DEDENT DEDENT",
        "explain": "Find the minimum element in remaining unsorted array"
    },
    {
        "py": "key = a [ min_idx ] NEW_LINE while min_idx > i : NEW_LINE INDENT a [ min_idx ] = a [ min_idx - 1 ] NEW_LINE min_idx -= 1 NEW_LINE DEDENT a [ i ] = key NEW_LINE def printArray ( a , n ) : NEW_LINE for i in range ( n ) : NEW_LINE print ( \" % d \" % a [ i ] , end = \" \u2581 \" ) NEW_LINE",
        "explain": "Move minimum element at current i"
    },
    {
        "py": "a = [ 4 , 5 , 3 , 2 , 4 , 1 ] NEW_LINE n = len ( a ) NEW_LINE stableSelectionSort ( a , n ) NEW_LINE printArray ( a , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def isPossible ( a , b , n , k ) : NEW_LINE",
        "explain": "Check whether any permutation exists which satisfy the condition ."
    },
    {
        "py": "a . sort ( reverse = True ) NEW_LINE",
        "explain": "Sort the array a [ ] in decreasing order ."
    },
    {
        "py": "b . sort ( ) NEW_LINE",
        "explain": "Sort the array b [ ] in increasing order ."
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] + b [ i ] < k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE",
        "explain": "Checking condition on each index ."
    },
    {
        "py": "a = [ 2 , 1 , 3 ] NEW_LINE b = [ 7 , 8 , 9 ] NEW_LINE k = 10 NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , b , n , k ) ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def setBitCount ( num ) : NEW_LINE INDENT count = 0 NEW_LINE while ( num ) : NEW_LINE INDENT if ( num & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT",
        "explain": "Function to count setbits"
    },
    {
        "py": "def sortBySetBitCount ( arr , n ) : NEW_LINE INDENT count = [ ] NEW_LINE DEDENT",
        "explain": "Function to sort By SetBitCount"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE INDENT count . append ( [ ( - 1 ) * setBitCount ( arr [ i ] ) , arr [ i ] ] ) NEW_LINE DEDENT count . sort ( key = lambda x : x [ 0 ] ) NEW_LINE for i in range ( len ( count ) ) : NEW_LINE INDENT print ( count [ i ] [ 1 ] , end = \" \u2581 \" ) NEW_LINE DEDENT",
        "explain": "Iterate over all values and insert into multimap"
    },
    {
        "py": "arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE sortBySetBitCount ( arr , n ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def canReach ( s , L , R ) : NEW_LINE",
        "explain": "Function to check if it is possible to reach the end of the binary string using the given jumps"
    },
    {
        "py": "dp = [ 0 for _ in range ( len ( s ) ) ] NEW_LINE",
        "explain": "Stores the DP states"
    },
    {
        "py": "dp [ 0 ] = 1 NEW_LINE",
        "explain": "Initial state"
    },
    {
        "py": "pre = 0 NEW_LINE",
        "explain": "Stores count of indices from which it is possible to reach index i"
    },
    {
        "py": "for i in range ( 1 , len ( s ) ) : NEW_LINE",
        "explain": "Traverse the given string"
    },
    {
        "py": "if ( i >= L ) : NEW_LINE INDENT pre += dp [ i - L ] NEW_LINE DEDENT",
        "explain": "Update the values of pre accordingly"
    },
    {
        "py": "if ( i > R ) : NEW_LINE INDENT pre -= dp [ i - R - 1 ] NEW_LINE DEDENT dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) NEW_LINE",
        "explain": "If the jump size is out of the range [ L , R ]"
    },
    {
        "py": "return dp [ len ( s ) - 1 ] NEW_LINE",
        "explain": "Return answer"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT S = \"01101110\" NEW_LINE L = 2 NEW_LINE R = 3 NEW_LINE if canReach ( S , L , R ) : NEW_LINE INDENT print ( \" Yes \" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( \" No \" ) NEW_LINE DEDENT DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def maxXORUtil ( arr , N , xrr , orr ) : NEW_LINE",
        "explain": "Recursive function to find all the possible breaking of arrays o subarrays and find the maximum Bitwise XOR"
    },
    {
        "py": "if ( N == 0 ) : NEW_LINE INDENT return xrr ^ orr NEW_LINE DEDENT",
        "explain": "If the value of N is 0"
    },
    {
        "py": "x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) NEW_LINE",
        "explain": "Stores the result if the new group is formed with the first element as arr [ i ]"
    },
    {
        "py": "y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) NEW_LINE",
        "explain": "Stores if the result if the arr [ i ] is included in the last group"
    },
    {
        "py": "return max ( x , y ) NEW_LINE",
        "explain": "Returns the maximum of x and y"
    },
    {
        "py": "def maximumXOR ( arr , N ) : NEW_LINE",
        "explain": "Function to find the maximum possible Bitwise XOR of all possible values of the array after breaking the arrays o subarrays"
    },
    {
        "py": "return maxXORUtil ( arr , N , 0 , 0 ) NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "arr = 1 , 5 , 7 NEW_LINE N = len ( arr ) NEW_LINE print ( maximumXOR ( arr , N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 10 ** 5 + 5 NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "visited = [ 0 ] * N NEW_LINE",
        "explain": "Keep track of visited nodes"
    },
    {
        "py": "def construct_tree ( weights , n ) : NEW_LINE INDENT minimum = min ( weights ) NEW_LINE maximum = max ( weights ) NEW_LINE DEDENT",
        "explain": "Function to construct a tree such that there are no two adjacent nodes with the same weight"
    },
    {
        "py": "if ( minimum == maximum ) : NEW_LINE",
        "explain": "If minimum and maximum elements are equal , i . e . array contains one distinct element"
    },
    {
        "py": "print ( \" No \" ) NEW_LINE return NEW_LINE",
        "explain": "Tree cannot be constructed"
    },
    {
        "py": "else : NEW_LINE",
        "explain": "Otherwise"
    },
    {
        "py": "print ( \" Yes \" ) NEW_LINE",
        "explain": "Tree can be constructed"
    },
    {
        "py": "root = weights [ 0 ] NEW_LINE",
        "explain": "Choose weights [ 0 ] as root"
    },
    {
        "py": "visited [ 1 ] = 1 NEW_LINE",
        "explain": "First Node is visited"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Traverse the array"
    },
    {
        "py": "if ( weights [ i ] != root and visited [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( 1 , i + 1 ) NEW_LINE DEDENT",
        "explain": "Otherwise , make an edge"
    },
    {
        "py": "visited [ i + 1 ] = 1 NEW_LINE",
        "explain": "Mark this node as visited"
    },
    {
        "py": "notroot = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( weights [ i ] != root ) : NEW_LINE INDENT notroot = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT",
        "explain": "Find a weight not same as the root & make edges with that node"
    },
    {
        "py": "for i in range ( n ) : NEW_LINE",
        "explain": "Join non - roots with remaining nodes"
    },
    {
        "py": "if ( weights [ i ] == root and visited [ i + 1 ] == 0 ) : NEW_LINE INDENT print ( notroot , i + 1 ) NEW_LINE visited [ i + 1 ] = 1 NEW_LINE DEDENT",
        "explain": "Check if current node ' s \u2581 weight \u2581 \u2581 is \u2581 same \u2581 as \u2581 root \u2581 node ' s weight and if it is not visited or not"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT weights = [ 1 , 2 , 1 , 2 , 5 ] NEW_LINE N = len ( weights ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "construct_tree ( weights , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "def minCost ( s , k ) : NEW_LINE",
        "explain": "Function to find minimum cost to convert given string into string of K length same substring"
    },
    {
        "py": "n = len ( s ) NEW_LINE",
        "explain": "Stores length of string"
    },
    {
        "py": "ans = 0 NEW_LINE",
        "explain": "Stores the minimum cost"
    },
    {
        "py": "for i in range ( k ) : NEW_LINE",
        "explain": "Traverse left substring of k length"
    },
    {
        "py": "a = [ 0 ] * 26 NEW_LINE for j in range ( i , n , k ) : NEW_LINE INDENT a [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT",
        "explain": "Stores the frequency"
    },
    {
        "py": "min_cost = sys . maxsize - 1 NEW_LINE",
        "explain": "Stores minimum cost for sequence of S [ i ] % k indices"
    },
    {
        "py": "for ch in range ( 26 ) : NEW_LINE INDENT cost = 0 NEW_LINE DEDENT",
        "explain": "Check for optimal character"
    },
    {
        "py": "for tr in range ( 26 ) : NEW_LINE INDENT cost += abs ( ch - tr ) * a [ tr ] NEW_LINE DEDENT",
        "explain": "Find sum of distance ' a ' + ch from character S [ i ] % k indices"
    },
    {
        "py": "min_cost = min ( min_cost , cost ) NEW_LINE",
        "explain": "Choose minimum cost for each index i"
    },
    {
        "py": "ans += min_cost NEW_LINE",
        "explain": "Increment ans"
    },
    {
        "py": "print ( ans ) NEW_LINE",
        "explain": "Print minimum cost to convert string"
    },
    {
        "py": "S = \" abcdefabc \" NEW_LINE K = 3 NEW_LINE",
        "explain": "Given string S"
    },
    {
        "py": "minCost ( S , K ) NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "def minAbsDiff ( N ) : NEW_LINE INDENT if ( N % 4 == 0 or N % 4 == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 NEW_LINE DEDENT",
        "explain": "Function to split the first N natural numbers into two sets having minimum absolute difference of their sums"
    },
    {
        "py": "N = 6 NEW_LINE print ( minAbsDiff ( N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 10000 NEW_LINE",
        "explain": "Python3 program for the above approach"
    },
    {
        "py": "adj = { } NEW_LINE used = [ 0 for i in range ( N ) ] NEW_LINE max_matching = 0 NEW_LINE",
        "explain": "Adjacency list to store edges"
    },
    {
        "py": "def AddEdge ( u , v ) : NEW_LINE INDENT if u not in adj : NEW_LINE INDENT adj [ u ] = [ ] NEW_LINE DEDENT if v not in adj : NEW_LINE INDENT adj [ v ] = [ ] NEW_LINE DEDENT DEDENT",
        "explain": "Add an edge between U and V in tree"
    },
    {
        "py": "adj [ u ] . append ( v ) NEW_LINE",
        "explain": "Edge from u to v"
    },
    {
        "py": "adj [ v ] . append ( u ) NEW_LINE",
        "explain": "Edge from V to U"
    },
    {
        "py": "def Matching_dfs ( u , p ) : NEW_LINE INDENT global max_matching NEW_LINE for i in range ( len ( adj [ u ] ) ) : NEW_LINE DEDENT",
        "explain": "Function that finds the maximum matching of the DFS"
    },
    {
        "py": "if ( adj [ u ] [ i ] != p ) : NEW_LINE INDENT Matching_dfs ( adj [ u ] [ i ] , u ) NEW_LINE DEDENT",
        "explain": "Go further as we are not allowed to go towards its parent"
    },
    {
        "py": "if ( not used [ u ] and not used [ p ] and p != 0 ) : NEW_LINE",
        "explain": "If U and its parent P is not taken then we must take & mark them as taken"
    },
    {
        "py": "max_matching += 1 NEW_LINE used [ u ] = 1 NEW_LINE used [ p ] = 1 NEW_LINE",
        "explain": "Increment size of edge set"
    },
    {
        "py": "def maxMatching ( ) : NEW_LINE",
        "explain": "Function to find the maximum matching in a graph"
    },
    {
        "py": "Matching_dfs ( 1 , 0 ) NEW_LINE",
        "explain": "Taking 1 as a root of the tree"
    },
    {
        "py": "print ( max_matching ) NEW_LINE",
        "explain": "Print maximum Matching"
    },
    {
        "py": "n = 5 NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "AddEdge ( 1 , 2 ) NEW_LINE AddEdge ( 1 , 3 ) NEW_LINE AddEdge ( 3 , 4 ) NEW_LINE AddEdge ( 3 , 5 ) NEW_LINE",
        "explain": "Joining edge between two nodes in tree"
    },
    {
        "py": "maxMatching ( ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "import sys NEW_LINE",
        "explain": "Python3 program to implement the above approach"
    },
    {
        "py": "def getMinCost ( A , B , N ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( N ) : NEW_LINE INDENT mini = min ( mini , min ( A [ i ] , B [ i ] ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Function to calculate and return the minimum cost required to swap two arrays"
    },
    {
        "py": "return mini * ( 2 * N - 1 ) NEW_LINE",
        "explain": "Return the total minimum cost"
    },
    {
        "py": "N = 3 NEW_LINE A = [ 1 , 4 , 2 ] NEW_LINE B = [ 10 , 6 , 12 ] NEW_LINE print ( getMinCost ( A , B , N ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def printVector ( arr ) : NEW_LINE INDENT if ( len ( arr ) != 1 ) : NEW_LINE DEDENT",
        "explain": "Function to print the values stored in vector arr"
    },
    {
        "py": "for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = \" \u2581 \" ) NEW_LINE DEDENT print ( ) NEW_LINE",
        "explain": "Traverse the vector arr"
    },
    {
        "py": "def findWays ( arr , i , n ) : NEW_LINE",
        "explain": "Recursive function to prdifferent ways in which N can be written as a sum of at 2 or more positive integers"
    },
    {
        "py": "if ( n == 0 ) : NEW_LINE INDENT printVector ( arr ) NEW_LINE DEDENT",
        "explain": "If n is zero then prthis ways of breaking numbers"
    },
    {
        "py": "for j in range ( i , n + 1 ) : NEW_LINE",
        "explain": "Start from previous element in the representation till n"
    },
    {
        "py": "arr . append ( j ) NEW_LINE",
        "explain": "Include current element from representation"
    },
    {
        "py": "findWays ( arr , j , n - j ) NEW_LINE",
        "explain": "Call function again with reduced sum"
    },
    {
        "py": "del arr [ - 1 ] NEW_LINE",
        "explain": "Backtrack to remove current element from representation"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "n = 4 NEW_LINE",
        "explain": "Given sum N"
    },
    {
        "py": "arr = [ ] NEW_LINE",
        "explain": "To store the representation of breaking N"
    },
    {
        "py": "findWays ( arr , 1 , n ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def Maximum_subsequence ( A , N ) : NEW_LINE",
        "explain": "Function to count maximum subsequence"
    },
    {
        "py": "frequency = dict ( ) ; NEW_LINE",
        "explain": "Stores the frequency of array elements"
    },
    {
        "py": "max_freq = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "Stores max frequency"
    },
    {
        "py": "if ( frequency [ it ] > max_freq ) : NEW_LINE INDENT max_freq = frequency [ it ] ; NEW_LINE DEDENT",
        "explain": "Update max subsequence"
    },
    {
        "py": "print ( max_freq ) ; NEW_LINE",
        "explain": "Print the count"
    },
    {
        "py": "arr = [ 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 ] ; NEW_LINE Maximum_subsequence ( arr , len ( arr ) ) ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def DivideString ( s , n , k ) : NEW_LINE INDENT c = 0 NEW_LINE no = 1 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE DEDENT",
        "explain": "Function to print the arrangement of characters"
    },
    {
        "py": "fr = [ 0 ] * 26 NEW_LINE ans = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT fr [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE",
        "explain": "Stores frequency of characters"
    },
    {
        "py": "if ( fr [ i ] == k ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT",
        "explain": "Count the character having frequency K"
    },
    {
        "py": "if ( fr [ i ] > k and fr [ i ] != 2 * k ) : NEW_LINE INDENT c1 += 1 NEW_LINE ch = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT if ( fr [ i ] == 2 * k ) : NEW_LINE INDENT c2 += 1 NEW_LINE ch1 = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE ans . append ( \"1\" ) NEW_LINE mp = { } NEW_LINE if ( c % 2 == 0 or c1 > 0 or c2 > 0 ) : NEW_LINE for i in range ( n ) : NEW_LINE",
        "explain": "Count the character having frequency greater than K and not equal to 2 K"
    },
    {
        "py": "if ( fr [ ord ( s [ i ] ) - ord ( ' a ' ) ] == k ) : NEW_LINE INDENT if ( s [ i ] in mp ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE DEDENT else : NEW_LINE INDENT if ( no <= ( c // 2 ) ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE mp [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Case 1"
    },
    {
        "py": "if ( c % 2 == 1 and c1 > 0 ) : NEW_LINE INDENT no = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ch and no <= k ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE DEDENT DEDENT DEDENT",
        "explain": "Case 2"
    },
    {
        "py": "if ( c % 2 == 1 and c1 == 0 ) : NEW_LINE INDENT no = 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ch1 and no <= k ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE no += 1 NEW_LINE DEDENT if ( fr [ s [ i ] - ' a ' ] == k and flag == 0 and ans [ i ] == '1' ) : NEW_LINE INDENT ans [ i ] = '2' NEW_LINE flag = 1 NEW_LINE DEDENT DEDENT DEDENT print ( \" \" . join ( ans ) ) NEW_LINE else : NEW_LINE",
        "explain": "Case 3"
    },
    {
        "py": "print ( \" NO \" ) NEW_LINE",
        "explain": "If all cases fail"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = \" abbbccc \" NEW_LINE N = len ( S ) NEW_LINE K = 1 NEW_LINE DivideString ( S , N , K ) NEW_LINE DEDENT",
        "explain": "Driver Code"
    },
    {
        "py": "def check ( S , prices , type1 , n ) : NEW_LINE",
        "explain": "Function to check if two items can be selected from two different categories without exceeding the total price"
    },
    {
        "py": "for j in range ( 0 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE DEDENT",
        "explain": "Loop to choose two different pairs using two nested loops"
    },
    {
        "py": "if ( ( type1 [ j ] == 0 and type1 [ k ] == 1 ) or ( type1 [ j ] == 1 and type1 [ k ] == 0 ) ) : NEW_LINE INDENT if ( prices [ j ] + prices [ k ] <= S ) : NEW_LINE INDENT return \" Yes \" ; NEW_LINE DEDENT DEDENT return \" No \" ; NEW_LINE",
        "explain": "Condition to check if the price of these two elements is less than S"
    },
    {
        "py": "prices = [ 3 , 8 , 6 , 5 ] ; NEW_LINE type1 = [ 0 , 1 , 1 , 0 ] ; NEW_LINE S = 10 ; NEW_LINE n = 4 ; NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "print ( check ( S , prices , type1 , n ) ) ; NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def getLargestSum ( N ) : NEW_LINE",
        "explain": "Function to return the maximum sum of a + b satisfying the given condition"
    },
    {
        "py": "for i in range ( 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , int ( N ** ( 1 / 2 ) ) + 1 ) : NEW_LINE DEDENT",
        "explain": "Consider all possible pairs and check the sum divides product property"
    },
    {
        "py": "k = N // j ; NEW_LINE a = k * i ; NEW_LINE b = k * j ; NEW_LINE",
        "explain": "To find the largest factor k"
    },
    {
        "py": "if ( a <= N and b <= N and a * b % ( a + b ) == 0 ) : NEW_LINE",
        "explain": "Check if the product is divisible by the sum"
    },
    {
        "py": "max_sum = max ( max_sum , a + b ) ; NEW_LINE",
        "explain": "Storing the maximum sum in the max_sum variable"
    },
    {
        "py": "return max_sum ; NEW_LINE",
        "explain": "Return the max_sum value"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT N = 25 ; NEW_LINE max_sum = getLargestSum ( N ) ; NEW_LINE print ( max_sum ) ; NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def encryptString ( string , n ) : NEW_LINE INDENT i , cnt = 0 , 0 NEW_LINE encryptedStr = \" \" NEW_LINE while i < n : NEW_LINE DEDENT",
        "explain": "Function to return the encrypted string"
    },
    {
        "py": "cnt = i + 1 NEW_LINE",
        "explain": "Number of times the current character will be repeated"
    },
    {
        "py": "while cnt > 0 : NEW_LINE INDENT encryptedStr += string [ i ] NEW_LINE cnt -= 1 NEW_LINE DEDENT i += 1 NEW_LINE return encryptedStr NEW_LINE",
        "explain": "Repeat the current character in the encrypted string"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE INDENT string = \" geeks \" NEW_LINE n = len ( string ) NEW_LINE print ( encryptString ( string , n ) ) NEW_LINE DEDENT",
        "explain": "Driver code"
    },
    {
        "py": "def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE DEDENT",
        "explain": "Function to return required minimum difference"
    },
    {
        "py": "for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT",
        "explain": "finding minimum and maximum values"
    },
    {
        "py": "return max ( 0 , mx - mn - 2 * x ) NEW_LINE",
        "explain": "returning minimum possible difference"
    },
    {
        "py": "n = 3 NEW_LINE x = 3 NEW_LINE A = [ 1 , 3 , 6 ] NEW_LINE",
        "explain": "Driver program"
    },
    {
        "py": "print ( minDiff ( n , x , A ) ) NEW_LINE",
        "explain": "function to return the answer"
    },
    {
        "py": "def swapCount ( s ) : NEW_LINE INDENT chars = s NEW_LINE DEDENT",
        "explain": "Python3 program to count swaps required to balance string"
    },
    {
        "py": "countLeft = 0 NEW_LINE countRight = 0 NEW_LINE",
        "explain": "Stores total number of left and right brackets encountered"
    },
    {
        "py": "swap = 0 NEW_LINE imbalance = 0 ; NEW_LINE for i in range ( len ( chars ) ) : NEW_LINE INDENT if chars [ i ] == ' [ ' : NEW_LINE DEDENT",
        "explain": "Swap stores the number of swaps required imbalance maintains the number of imbalance pair"
    },
    {
        "py": "countLeft += 1 NEW_LINE if imbalance > 0 : NEW_LINE",
        "explain": "Increment count of left bracket"
    },
    {
        "py": "swap += imbalance NEW_LINE",
        "explain": "Swaps count is last swap count + total number imbalanced brackets"
    },
    {
        "py": "imbalance -= 1 NEW_LINE elif chars [ i ] == ' ] ' : NEW_LINE",
        "explain": "Imbalance decremented by 1 as it solved only one imbalance of left and right"
    },
    {
        "py": "countRight += 1 NEW_LINE",
        "explain": "Increment count of right bracket"
    },
    {
        "py": "imbalance = ( countRight - countLeft ) NEW_LINE return swap NEW_LINE",
        "explain": "Imbalance is reset to current difference between left and right brackets"
    },
    {
        "py": "s = \" [ ] ] [ ] [ \" ; NEW_LINE print ( swapCount ( s ) ) NEW_LINE s = \" [ [ ] [ ] ] \" ; NEW_LINE print ( swapCount ( s ) ) NEW_LINE",
        "explain": "Driver code"
    },
    {
        "py": "def longestSubSequence ( A , N ) : NEW_LINE",
        "explain": "Function to find the length of the longest subsequence of pairs whose first element is increasing and second is decreasing"
    },
    {
        "py": "dp = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE",
        "explain": "dp [ i ] : Stores the longest subsequence upto i"
    },
    {
        "py": "dp [ i ] = 1 NEW_LINE for j in range ( i ) : NEW_LINE",
        "explain": "Base case"
    },
    {
        "py": "if ( A [ j ] [ 0 ] < A [ i ] [ 0 ] and A [ j ] [ 1 ] > A [ i ] [ 1 ] ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT",
        "explain": "When the conditions hold"
    },
    {
        "py": "print ( dp [ N - 1 ] ) NEW_LINE",
        "explain": "Finally , prthe required answer"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "A = [ [ 1 , 2 ] , [ 2 , 2 ] , [ 3 , 1 ] ] NEW_LINE N = len ( A ) NEW_LINE",
        "explain": "Given Input"
    },
    {
        "py": "longestSubSequence ( A , N ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findWays ( N , dp ) : NEW_LINE",
        "explain": "Function to calculate the total number of ways to have sum N"
    },
    {
        "py": "if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT",
        "explain": "Base Case"
    },
    {
        "py": "if ( dp [ N ] != - 1 ) : NEW_LINE INDENT return dp [ N ] NEW_LINE DEDENT cnt = 0 NEW_LINE",
        "explain": "Return already stored result"
    },
    {
        "py": "for i in range ( 1 , 7 ) : NEW_LINE INDENT if ( N - i >= 0 ) : NEW_LINE INDENT cnt = ( cnt + findWays ( N - i , dp ) ) NEW_LINE DEDENT DEDENT",
        "explain": "Recur for all 6 states"
    },
    {
        "py": "dp [ N ] = cnt NEW_LINE return dp [ N ] NEW_LINE",
        "explain": "Return the result"
    },
    {
        "py": "if __name__ == \" _ _ main _ _ \" : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 4 NEW_LINE",
        "explain": "Given sum N"
    },
    {
        "py": "dp = [ - 1 ] * ( N + 1 ) NEW_LINE",
        "explain": "Initialize the dp array"
    },
    {
        "py": "print ( findWays ( N , dp ) ) NEW_LINE",
        "explain": "Function Call"
    },
    {
        "py": "def findWays ( N ) : NEW_LINE",
        "explain": "Function to calculate the total number of ways to have sum N"
    },
    {
        "py": "dp = [ 0 ] * ( N + 1 ) ; NEW_LINE dp [ 0 ] = 1 ; NEW_LINE",
        "explain": "Initialize dp array"
    },
    {
        "py": "for i in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] = 0 ; NEW_LINE DEDENT",
        "explain": "Iterate over all the possible intermediate values to reach N"
    },
    {
        "py": "for j in range ( 1 , 7 ) : NEW_LINE INDENT if ( i - j >= 0 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + dp [ i - j ] ; NEW_LINE DEDENT DEDENT",
        "explain": "Calculate the sum for all 6 faces"
    },
    {
        "py": "print ( dp [ N ] ) ; NEW_LINE",
        "explain": "Print total number of ways"
    },
    {
        "py": "if __name__ == ' _ _ main _ _ ' : NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "N = 4 ; NEW_LINE",
        "explain": "Given sum N"
    },
    {
        "py": "findWays ( N ) ; NEW_LINE",
        "explain": "Function call"
    },
    {
        "py": "INF = 1e9 + 9 NEW_LINE",
        "explain": "Python3 implementation to split the string into minimum number of parts such that each part is also present in the another string"
    },
    {
        "py": "class TrieNode ( ) : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . child = [ None ] * 26 NEW_LINE DEDENT DEDENT",
        "explain": "Node of Trie"
    },
    {
        "py": "def insert ( idx , s , root ) : NEW_LINE INDENT temp = root NEW_LINE for i in range ( idx , len ( s ) ) : NEW_LINE DEDENT",
        "explain": "Function to insert a node in the Trie Data Structure"
    },
    {
        "py": "if temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] == None : NEW_LINE",
        "explain": "Inserting every character from idx till end to string into trie"
    },
    {
        "py": "temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] = TrieNode ( ) NEW_LINE temp = temp . child [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE",
        "explain": "If there is no edge corresponding to the ith character , then make a new node"
    },
    {
        "py": "def minCuts ( S1 , S2 ) : NEW_LINE INDENT n1 = len ( S1 ) NEW_LINE n2 = len ( S2 ) NEW_LINE DEDENT",
        "explain": "Function to find the minimum number of parts such that each part is present into another string"
    },
    {
        "py": "root = TrieNode ( ) NEW_LINE for i in range ( n2 ) : NEW_LINE",
        "explain": "Making a new trie"
    },
    {
        "py": "insert ( i , S2 , root ) NEW_LINE",
        "explain": "Inserting every substring of S2 in trie"
    },
    {
        "py": "dp = [ INF ] * ( n1 + 1 ) NEW_LINE",
        "explain": "Creating dp array and init it with infinity"
    },
    {
        "py": "dp [ 0 ] = 0 NEW_LINE for i in range ( n1 ) : NEW_LINE",
        "explain": "Base Case"
    },
    {
        "py": "temp = root NEW_LINE for j in range ( i + 1 , n1 + 1 ) : NEW_LINE INDENT if temp . child [ ord ( S1 [ j - 1 ] ) - ord ( ' a ' ) ] == None : NEW_LINE DEDENT",
        "explain": "Starting the cut from ith character taking temporary node pointer for checking whether the substring [ i , j ) is present in trie of not"
    },
    {
        "py": "break NEW_LINE",
        "explain": "If the jth character is not in trie we 'll break"
    },
    {
        "py": "dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) NEW_LINE",
        "explain": "Updating the the ending of jth character with dp [ i ] + 1"
    },
    {
        "py": "temp = temp . child [ ord ( S1 [ j - 1 ] ) - ord ( ' a ' ) ] NEW_LINE",
        "explain": "Descending the trie pointer"
    },
    {
        "py": "if dp [ n1 ] >= INF : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n1 ] NEW_LINE DEDENT",
        "explain": "Answer not possible"
    },
    {
        "py": "S1 = \" abcdab \" NEW_LINE S2 = \" dabc \" NEW_LINE print ( minCuts ( S1 , S2 ) ) NEW_LINE",
        "explain": "Driver Code"
    },
    {
        "py": "def largestSquare ( matrix , R , C , q_i , q_j , K , Q ) : NEW_LINE INDENT countDP = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE DEDENT",
        "explain": "Function to find the largest square in the matrix such that it contains atmost K 1 's"
    },
    {
        "py": "countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , R ) : NEW_LINE INDENT countDP [ i ] [ 0 ] = ( countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ) NEW_LINE DEDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ 0 ] [ j ] = ( countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ) NEW_LINE DEDENT for i in range ( 1 , R ) : NEW_LINE INDENT for j in range ( 1 , C ) : NEW_LINE INDENT countDP [ i ] [ j ] = ( matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT",
        "explain": "Precomputing the countDP prefix sum of the matrix"
    },
    {
        "py": "for q in range ( 0 , Q ) : NEW_LINE INDENT i = q_i [ q ] NEW_LINE j = q_j [ q ] NEW_LINE DEDENT",
        "explain": "Loop to solve Queries"
    },
    {
        "py": "min_dist = min ( i , j , R - i - 1 , C - j - 1 ) NEW_LINE ans = - 1 NEW_LINE l = 0 NEW_LINE u = min_dist NEW_LINE while ( l <= u ) : NEW_LINE INDENT mid = int ( ( l + u ) / 2 ) NEW_LINE x1 = i - mid NEW_LINE x2 = i + mid NEW_LINE y1 = j - mid NEW_LINE y2 = j + mid NEW_LINE DEDENT",
        "explain": "Calculating the maximum possible distance of the centre from edge"
    },
    {
        "py": "count = countDP [ x2 ] [ y2 ] NEW_LINE if ( x1 > 0 ) : NEW_LINE INDENT count -= countDP [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 > 0 ) : NEW_LINE INDENT count -= countDP [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 > 0 and y1 > 0 ) : NEW_LINE INDENT count += countDP [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT",
        "explain": "Count total number of 1 s in the sub square considered"
    },
    {
        "py": "if ( count <= K ) : NEW_LINE INDENT ans = 2 * mid + 1 NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT u = mid - 1 NEW_LINE DEDENT print ( ans ) NEW_LINE",
        "explain": "If the count is less than or equals to the maximum move to right half"
    },
    {
        "py": "matrix = [ [ 1 , 0 , 1 , 0 , 0 ] , [ 1 , 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 1 , 0 ] ] NEW_LINE K = 9 NEW_LINE Q = 1 NEW_LINE q_i = [ 1 ] NEW_LINE q_j = [ 2 ] NEW_LINE largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) NEW_LINE",
        "explain": "Driver Code"
    }
]